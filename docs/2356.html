<html>
<head>
<title>Extracting an Unsaved Memory-Content by Walking through Windows Heaps, but How?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过遍历Windows堆来提取未保存的内存内容，但是怎么做呢？</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/extracting-an-unsaved-memory-content-by-walking-through-windows-heaps-but-how-6992589d872e?source=collection_archive---------1-----------------------#2022-09-11">https://infosecwriteups.com/extracting-an-unsaved-memory-content-by-walking-through-windows-heaps-but-how-6992589d872e?source=collection_archive---------1-----------------------#2022-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="3a1f" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir">注意事项</strong> : <br/>问候各位读者！在你阅读这篇内容之前，我想提醒你，这是基于我的研究和发现，所以如果你遇到或碰巧看到一个<strong class="jt ir">误导性信息</strong>，我很想听听你的意见，我对任何应该正确陈述的信息都非常开放。</p><p id="b560" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">首先，我想对我的同事和来自FMIPA Padjajaran大学的IFEST CTF委员会表示感谢，感谢他们组织了如此精彩的CTF活动，并给了我和我的团队<a class="ae kp" href="https://petircysec.com/" rel="noopener ugc nofollow" target="_blank"> PETIR </a>一个机会来主持并成为CTF问题解决者的一员。这篇文章是基于我做的一个记忆法医挑战。</p></blockquote><p id="0339" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">你有没有想过我们如何从计算机内存中提取有价值的内容，尤其是在一个已经运行的进程中？内存取证允许你这样做。一些著名的调查记忆的取证工具包括:</p><ul class=""><li id="b99a" class="kt ku iq jt b ju jv jy jz kq kv kr kw ks kx ko ky kz la lb bi translated"><a class="ae kp" href="https://github.com/volatilityfoundation/volatility" rel="noopener ugc nofollow" target="_blank">波动率2 </a> / <a class="ae kp" href="https://github.com/volatilityfoundation/volatility3" rel="noopener ugc nofollow" target="_blank">波动率3 </a></li><li id="eb26" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko ky kz la lb bi translated"><a class="ae kp" href="https://github.com/simsong/bulk_extractor" rel="noopener ugc nofollow" target="_blank">散装提取器</a>(雕刻器)</li><li id="7302" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko ky kz la lb bi translated">还有更多！</li></ul><p id="63b1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如果你不熟悉记忆取证，我会推荐你从<a class="ae kp" href="https://stuxnet999.github.io/volatility/2020/08/18/Basics-of-Memory-Forensics.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir"> stuxnet </strong> </a>博客和一本很棒的书<code class="fe lh li lj lk b"><a class="ae kp" href="https://www.amazon.com/Art-Memory-Forensics-Detecting-Malware/dp/1118825098" rel="noopener ugc nofollow" target="_blank">The Art of Memory Forensics</a></code> <a class="ae kp" href="https://www.amazon.com/Art-Memory-Forensics-Detecting-Malware/dp/1118825098" rel="noopener ugc nofollow" target="_blank"> </a>中阅读它的基本内容。</p><p id="b116" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们通常会遇到这样一种情况，一个挑战被赋予了一个带有通用扩展的内存转储，比如<strong class="jt ir">。vmem </strong>或<strong class="jt ir">。raw，</strong>并识别操作系统崩溃转储或内存转储，一个名为<code class="fe lh li lj lk b">imageinfo</code>或<code class="fe lh li lj lk b">kdbgscan</code>的易失性插件将负责做到这一点。有很多博客讨论每个<code class="fe lh li lj lk b">volatility</code>插件的功能，我想从安德里亚·福尔图娜的博客中推荐它(一部分接一部分)。</p><p id="a13e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><strong class="jt ir"> A .案例场景</strong></p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/48c65fe049a6bf948b74f4758f4a8b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yykIYn-c3FfJpt86A6-thg.png"/></div></div></figure><p id="eedf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">假设一个DFIR的研究人员有一个假设，我们能够解析和提取我们在一个应用程序中输入的内容，而不需要首先检索它的转储文件，所以它应该由我们自己精确定位。为了更简单，研究人员同意定义一个将被使用的范围是一个<strong class="jt ir">笔记应用</strong>。</p><p id="998b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><strong class="jt ir">为了测试假设，研究人员创建了一个任意的</strong> <code class="fe lh li lj lk b"><strong class="jt ir">passwords</strong></code> <strong class="jt ir">，由四个换行符(\n) </strong>分隔，由<strong class="jt ir">个随机的字母数字字符和符号</strong>组成。同样<strong class="jt ir">不可读</strong>但是ASCII约束仍然保持在32和126之间。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lx"><img src="../Images/2ffd77efa3d2f3a34d8e540f5ed6ea0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AzAjz-us7BzZtsfX.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">参考:<a class="ae kp" href="https://id.wikipedia.org/wiki/Berkas:ASCII-Table.svg" rel="noopener ugc nofollow" target="_blank">https://id.wikipedia.org/wiki/Berkas:ASCII-Table.svg</a></figcaption></figure><p id="25bf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">在<a class="ae kp" href="https://thehackersmeetup.medium.com/beginners-guide-to-capture-the-flag-ctf-71a1cbd9d27c" rel="noopener"> CTF </a>中，我们通常使用CTF事件名称的可识别前缀作为起始标志的出现，如<code class="fe lh li lj lk b">COMPFEST{</code>、<code class="fe lh li lj lk b">HackToday{</code>、<code class="fe lh li lj lk b">CSCCTF{</code>，然后是哈希值或<strong class="jt ir">可读的</strong>字母数字字符组合，如<code class="fe lh li lj lk b">CSCCTF{y3Y_i_am_r3ad1ng_th!s_mediUm}</code>。但在这种情况下，它将更ASCII <strong class="jt ir">不可读。</strong>例如，<strong class="jt ir">未保存的</strong>文件可能包含如下格式:</p><pre class="lm ln lo lp gt mc lk md me aw mf bi"><span id="51d6" class="mg mh iq lk b gy mi mj l mk ml">s)(&amp;^a<br/>r#@fdJk<br/>at4$sg<br/>^%$j4r<br/>t%$r3e</span></pre><p id="9042" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">挑战被设计成更难从<a class="ae kp" href="https://www.howtogeek.com/427805/how-to-use-the-strings-command-on-linux/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir">字符串</strong> </a>命令中被猜到。现在你可能会认为这是非常猜测性的，只有通过使用<a class="ae kp" href="https://www.cyberciti.biz/faq/howto-use-grep-command-in-linux-unix/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir"> grep/findstr </strong> </a>命令和<a class="ae kp" href="https://en.wikipedia.org/wiki/Regular_expression" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir">正则表达式</strong> </a> <strong class="jt ir"> </strong>找到密码才能提取出来，但这些很可能是无意的解决方案。我们将更加关注技术方法，准确定位<strong class="jt ir">在内存</strong>中需要提取内容的位置。如果您已经熟悉<code class="fe lh li lj lk b">volatility</code>的基本功能，您可以跳到下一部分。</p><p id="7628" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><strong class="jt ir"> B .背景</strong></p><p id="3594" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">在我们使用上面提到的工具深入研究之前，如果我们有一个关于这些内容如何在内存中分配的理论基础，就能知道如何提取这些内容，那会更好。</p><p id="3c59" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们开始使用<code class="fe lh li lj lk b">volatility</code>插件<code class="fe lh li lj lk b">kdbgscan</code>确定内存转储的操作系统配置文件。</p><pre class="lm ln lo lp gt mc lk md me aw mf bi"><span id="91bd" class="mg mh iq lk b gy mi mj l mk ml">python vol.py -f /home/kali/Desktop/memory_gone.vmem kdbgscan                                                                                                                             </span><span id="4b40" class="mg mh iq lk b gy mm mj l mk ml">Volatility Foundation Volatility Framework 2.6.1</span><span id="e4b8" class="mg mh iq lk b gy mm mj l mk ml">**************************************************<br/>Instantiating KDBG using: /home/kali/Desktop/memory_gone.vmem WinXPSP2x86 (5.1.0 32bit)<br/>Offset (P)                    : 0x29f2120<br/>KDBG owner tag check          : True<br/>Profile suggestion (KDBGHeader): Win7SP1x64<br/>PsActiveProcessHead           : 0x2a2b940<br/>PsLoadedModuleList            : 0x2a49c90<br/>KernelBase                    : 0xfffff8000280f000</span><span id="f52b" class="mg mh iq lk b gy mm mj l mk ml">**************************************************<br/>Instantiating KDBG using: /home/kali/Desktop/memory_gone.vmem WinXPSP2x86 (5.1.0 32bit)<br/>Offset (P)                    : 0x29f2120<br/>KDBG owner tag check          : True<br/>Profile suggestion (KDBGHeader): Win2008R2SP0x64<br/>PsActiveProcessHead           : 0x2a2b940<br/>PsLoadedModuleList            : 0x2a49c90<br/>KernelBase                    : 0xfffff8000280f000</span><span id="ac9a" class="mg mh iq lk b gy mm mj l mk ml">[SNIP]</span><span id="b660" class="mg mh iq lk b gy mm mj l mk ml">**************************************************<br/>Instantiating KDBG using: /home/kali/Desktop/Windows 7 x64-b77cc556.vmem WinXPSP2x86 (5.1.0 32bit)<br/>Offset (P)                    : 0x29f2120<br/>KDBG owner tag check          : True<br/>Profile suggestion (KDBGHeader): Win2008R2SP1x64_24000<br/>PsActiveProcessHead           : 0x2a2b940<br/>PsLoadedModuleList            : 0x2a49c90<br/>KernelBase                    : 0xfffff8000280f000</span></pre><p id="6b5d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">您将从<code class="fe lh li lj lk b">volatility</code>工具中看到许多配置文件建议，这是由于来自KDBG头启发值的误报结果，这是由于<code class="fe lh li lj lk b">kdbgsearch</code>的基于偏移量的遍历搜索的行为。在我的Github文章中，我还附上了来自一个不同的Windows操作系统的"<strong class="jt ir"> magic" </strong> headers值。难怪Win7和Win2008会出现在操作系统配置文件建议中。我们将使用第一个配置文件建议，<strong class="jt ir"> Win7SP1x64。</strong></p><p id="322c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">接下来，我们将列出在当前状态下已经在操作系统内部运行的实时进程。您可以使用以下插件:</p><ol class=""><li id="bfcb" class="kt ku iq jt b ju jv jy jz kq kv kr kw ks kx ko mn kz la lb bi translated"><code class="fe lh li lj lk b">plist</code></li><li id="3f71" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko mn kz la lb bi translated"><code class="fe lh li lj lk b">pstree</code></li><li id="a857" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko mn kz la lb bi translated"><code class="fe lh li lj lk b">psscan</code></li><li id="ba4c" class="kt ku iq jt b ju lc jy ld kq le kr lf ks lg ko mn kz la lb bi translated"><code class="fe lh li lj lk b">psxview</code></li></ol><p id="8c25" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">同样，进一步的解释将在<a class="ae kp" href="https://andreafortuna.org/2017/07/03/volatility-my-own-cheatsheet-part-2-processes-and-dlls/" rel="noopener ugc nofollow" target="_blank">和</a>中讨论。由于我们不处理任何<strong class="jt ir">隐藏的</strong>过程，我们将关注场景中提到的内置笔记应用程序。</p><pre class="lm ln lo lp gt mc lk md me aw mf bi"><span id="0973" class="mg mh iq lk b gy mi mj l mk ml">python vol.py -f /home/kali/Desktop/memory_gone.vmem --profile=Win7SP1x64 pslist<br/>Volatility Foundation Volatility Framework 2.6.1<br/>Offset(V)          Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                          Exit                          <br/>------------------ -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------<br/>0xfffffa8018da5040 System                    4      0     80      567 ------      0 2022-06-26 05:28:51 UTC+0000                                 <br/>0xfffffa8019d1b540 smss.exe                228      4      2       29 ------      0 2022-06-26 05:28:51 UTC+0000                                 <br/>0xfffffa801ab4e060 csrss.exe               308    296      9      503      0      0 2022-06-26 05:29:12 UTC+0000                                 <br/>0xfffffa801ac631c0 csrss.exe               348    340      8      209      1      0 2022-06-26 05:29:13 UTC+0000                                 <br/>0xfffffa801ac4c310 wininit.exe             356    296      3       76      0      0 2022-06-26 05:29:14 UTC+0000                                 <br/>0xfffffa801aca5060 winlogon.exe            384    340      5      134      1      0 2022-06-26 05:29:14 UTC+0000                                 <br/>0xfffffa801abdf060 services.exe            444    356      9      213      0      0 2022-06-26 05:29:16 UTC+0000                                 <br/>0xfffffa801abee060 lsass.exe               460    356      7      754      0      0 2022-06-26 05:29:17 UTC+0000                                 <br/>0xfffffa801ac8a330 lsm.exe                 468    356     10      137      0      0 2022-06-26 05:29:17 UTC+0000                                 <br/>0xfffffa801b00db00 svchost.exe             560    444     10      355      0      0 2022-06-26 05:29:21 UTC+0000                                 <br/>0xfffffa801b056470 svchost.exe             632    444      8      270      0      0 2022-06-26 05:29:22 UTC+0000                                 <br/>0xfffffa801b0ba5a0 sppsvc.exe              788    444      5      151      0      0 2022-06-26 05:29:25 UTC+0000                                 <br/>0xfffffa801a3894a0 svchost.exe             828    444     29      631      0      0 2022-06-26 05:29:27 UTC+0000                                 <br/>0xfffffa801b0cf720 svchost.exe             852    444     55     1312      0      0 2022-06-26 05:29:27 UTC+0000                                 <br/>0xfffffa801b0ecb00 svchost.exe             900    444     22      634      0      0 2022-06-26 05:29:27 UTC+0000                                 <br/>0xfffffa801b119060 audiodg.exe             932    900      5      120      0      0 2022-06-26 05:29:29 UTC+0000                                 <br/>0xfffffa801b172b00 svchost.exe             304    444     34      580      0      0 2022-06-26 05:30:41 UTC+0000                                 <br/>0xfffffa801b17b830 svchost.exe             552    444     25      537      0      0 2022-06-26 05:30:41 UTC+0000                                 <br/>0xfffffa801b2751a0 spoolsv.exe            1152    444     15      285      0      0 2022-06-26 05:30:47 UTC+0000                                 <br/>0xfffffa801b2818b0 svchost.exe            1180    444     19      339      0      0 2022-06-26 05:30:47 UTC+0000                                 <br/>0xfffffa8019a99b00 svchost.exe            1272    444     10      149      0      0 2022-06-26 05:30:48 UTC+0000                                 <br/>0xfffffa801b0f7b00 svchost.exe            1568    444      6       96      0      0 2022-06-26 05:30:53 UTC+0000                                 <br/>0xfffffa801a540060 svchost.exe            1940    444     25      271      0      0 2022-06-26 05:31:49 UTC+0000                                 <br/>0xfffffa8018ef2b00 svchost.exe            1668    444     11      363      0      0 2022-06-26 05:32:02 UTC+0000                                 <br/>0xfffffa8018fd8060 SearchIndexer.          952    444     14      773      0      0 2022-06-26 05:32:20 UTC+0000                                 <br/>0xfffffa801903eb00 taskhost.exe           2412    444     10      260      1      0 2022-06-26 05:32:46 UTC+0000                                 <br/>0xfffffa80190a1b00 dwm.exe                2496    828      3       73      1      0 2022-06-26 05:32:46 UTC+0000                                 <br/>0xfffffa8018fe1240 explorer.exe           2548   2472     24      813      1      0 2022-06-26 05:32:47 UTC+0000                                 <br/>0xfffffa8019115b00 regsvr32.exe           2668   2548      0 --------      1      0 2022-06-26 05:32:50 UTC+0000   2022-06-26 05:32:52 UTC+0000  <br/>0xfffffa801913bb00 mscorsvw.exe           2836    444      5       82      0      1 2022-06-26 05:32:59 UTC+0000                                 <br/>0xfffffa80191bab00 mscorsvw.exe           2872    444      5       75      0      0 2022-06-26 05:33:01 UTC+0000                                 <br/>0xfffffa80191816e0 svchost.exe            2900    444     12      344      0      0 2022-06-26 05:33:02 UTC+0000                                 <br/>0xfffffa801929f060 wmpnetwk.exe           2636    444     10      211      0      0 2022-06-26 05:33:29 UTC+0000                                 <br/>0xfffffa80195989b0 StikyNot.exe           2776   2548     10      173      1      0 2022-06-26 05:34:26 UTC+0000                                 <br/>0xfffffa80192ad060 WmiPrvSE.exe           2108    560      7      120      0      0 2022-06-26 05:34:52 UTC+0000                                 <br/>0xfffffa80191ed060 notepad.exe             588   2548      1       58      1      0 2022-06-26 05:35:06 UTC+0000                                 <br/>0xfffffa80195138e0 CompatTelRunne         1848    444      2       51      0      0 2022-06-26 05:35:45 UTC+0000                                 <br/>0xfffffa8019549b00 conhost.exe             764    308      2       33      0      0 2022-06-26 05:35:45 UTC+0000                                 <br/>0xfffffa8019559600 CompatTelRunne         2600   1848     12      420      0      0 2022-06-26 05:35:45 UTC+0000</span></pre><p id="40b9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们可以看到只使用了2个内置笔记应用程序，一个<strong class="jt ir">记事本</strong>和一个<strong class="jt ir">便笺</strong>，因此我们的探索范围限制字段仅在那里。我们应该注意的另一个基本发现是一个<code class="fe lh li lj lk b">screenshot</code>插件，以查看是否有任何迹象表明，由于操作系统保存了一个基于GDI的伪SS，某个应用程序在可视窗口桌面中弹出。为什么这很重要？这对我们以后找到原始图像转储的<strong class="jt ir">偏移</strong>可能会很方便。</p><pre class="lm ln lo lp gt mc lk md me aw mf bi"><span id="d2b5" class="mg mh iq lk b gy mi mj l mk ml">python vol.py -f /home/kali/Desktop/memory_gone.vmem --profile=Win7SP1x64 screenshot -D /home/kali/Desktop/ss</span><span id="1711" class="mg mh iq lk b gy mm mj l mk ml">Volatility Foundation Volatility Framework 2.6.1<br/>Wrote /home/kali/Desktop/ss/session_0.Service-0x0-3e4$.Default.png<br/>Wrote /home/kali/Desktop/ss/session_0.Service-0x0-3e5$.Default.png<br/>Wrote /home/kali/Desktop/ss/session_0.msswindowstation.mssrestricteddesk.png<br/>Wrote /home/kali/Desktop/ss/session_0.WinSta0.Default.png<br/>Wrote /home/kali/Desktop/ss/session_0.WinSta0.Disconnect.png<br/>Wrote /home/kali/Desktop/ss/session_0.WinSta0.Winlogon.png<br/>Wrote /home/kali/Desktop/ss/session_0.Service-0x0-3e7$.Default.png<br/>Wrote /home/kali/Desktop/ss/session_1.WinSta0.Default.png<br/>Wrote /home/kali/Desktop/ss/session_1.WinSta0.Disconnect.png<br/>Wrote /home/kali/Desktop/ss/session_1.WinSta0.Winlogon.png</span></pre><p id="0e3e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如果我们检查一下WinSta0.Default.png，我们会注意到一点提示。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mo"><img src="../Images/550a4dc7ee8ab337ae8416b8dddf46a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zjnS4pqePT0NCrOwJMobcA.png"/></div></div></figure><p id="3a6f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">上面的一个“飞行”盒子看起来像一张<strong class="jt ir">便利贴</strong>，我们可以通过一个叫做<a class="ae kp" href="https://www.gimp.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir"> GIMP </strong> </a>的工具解析或看到它的颜色。虽然GIMP被称为图像操作工具，但是它的功能也允许它读取和<strong class="jt ir">渲染</strong>某个偏移量的原始数据。这种技术已经在一些CTF中大量使用，比如这里的<a class="ae kp" href="https://developpaper.com/ctf-realizing-windows-memory-forensics-with-volatility-and-gimp/" rel="noopener ugc nofollow" target="_blank">和</a>，你可以自己尝试一下。你能阅读便利贴的内容吗？我会把它作为奖励挑战留给你！</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mp"><img src="../Images/bb8b2b59ef59e1efb6252e0084dc14dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Scj78MOHKhzJxcej_dEWrw.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">参考:<a class="ae kp" href="https://developpaper.com/ctf-realizing-windows-memory-forensics-with-volatility-and-gimp/" rel="noopener ugc nofollow" target="_blank">https://develop paper . com/CTF-realizing-windows-memory-forensics-with-volatile-and-gimp/</a></figcaption></figure><p id="b242" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><strong class="jt ir"> C .潜入回忆</strong></p><p id="a661" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们现在将关注第二个应用程序，<strong class="jt ir">记事本。为了实现我们的目标，我们应该知道用户输入是如何在记事本本身的进程中工作的。你知道吗，每当我们在键盘上键入一些东西时，那些<strong class="jt ir">数据</strong>都存储在我们操作系统中的<strong class="jt ir">分配内存</strong>中，由于数据不是静态的，这意味着即使我写了这个中等的故事，这个故事的长度也是<strong class="jt ir">而不是最初声明的</strong>，所以它发生在“运行时”<strong class="jt ir">。我们可以把它想象成一个字符数组(某种数据缓冲)。那么如何处理动态分配的缓冲区呢？<strong class="jt ir"/><a class="ae kp" href="https://www.geeksforgeeks.org/heap-data-structure/" rel="noopener ugc nofollow" target="_blank"><strong class="jt ir">垛</strong> </a>带头。应用程序也会发生这种情况，它们可能会在堆</strong>上分配一个内存区域<strong class="jt ir">。</strong></strong></p><p id="469e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">那么这个应用程序在这样一个进程中是如何工作的呢？应用程序本身是一个<strong class="jt ir">可执行程序</strong>，它位于某个内存区域内。一个进程拥有<strong class="jt ir">自己的</strong> <a class="ae kp" href="https://docs.microsoft.com/en-us/windows/win32/memory/virtual-address-space" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir">虚拟内存空间</strong> </a>。这就像一个移动应用程序，也是孤立的。在Windows操作系统中，有许多<a class="ae kp" href="https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list" rel="noopener ugc nofollow" target="_blank">Windows API</a>将通过枚举它们来跟踪每一个进程。</p><p id="78dd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如果我们看看下面的图表，</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/389c030bae1d707ff90d14703e2e4dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*kWdlvssvXNriuey5GroUAg.png"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">参考资料:<a class="ae kp" href="https://icegrave0391.github.io/2020/03/09/memfor-7/" rel="noopener ugc nofollow" target="_blank">https://icegrave0391.github.io/2020/03/09/memfor-7/</a></figcaption></figure><p id="64c6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">这就是<strong class="jt ir">进程内存</strong>架构的样子。它有一个动态的<a class="ae kp" href="https://docs.microsoft.com/en-us/troubleshoot/windows-client/deployment/dynamic-link-library" rel="noopener ugc nofollow" target="_blank">dll</a>非常明显，特别是在Windows中，有一些默认的dll，比如<strong class="jt ir">kernel32.dll</strong>等等。每个进程也有一个环境变量像一个<strong class="jt ir">可执行路径</strong>，一些缺省的目录位置和更多的像or环境变量组成的缺省路径。还有PEB (Process Environment Block)，它是Windows中的一种数据结构，包含内存中的位置映射列表。一个<strong class="jt ir">进程堆</strong>是我们要进一步研究的组件，因为它包含了应用程序接收的输入。另一层称为线程堆栈，包含一个函数调用位置。</p><p id="cb50" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们现在的目标是<strong class="jt ir">定位</strong>已经在某个进程的<strong class="jt ir">堆</strong>中键入的输入，在本例中，是<strong class="jt ir">记事本</strong>。虽然有一些来自<code class="fe lh li lj lk b">volatility</code>的叫做<strong class="jt ir">记事本</strong>和<strong class="jt ir">堆</strong>的有用插件，但它仍然不支持我们的OS Profile的版本(仅在WinXP和2003中支持)。</p><pre class="lm ln lo lp gt mc lk md me aw mf bi"><span id="361a" class="mg mh iq lk b gy mi mj l mk ml">#notepad.py </span><span id="4387" class="mg mh iq lk b gy mm mj l mk ml">[SNIP]<br/><br/>class _HEAP(obj.CType):<br/>    """ A Heap on XP and 2003 """<br/>        <br/>    def is_valid(self):<br/>        return obj.CType.is_valid(self) and self.Signature == 0xeeffeeff<br/><br/>    def segments(self):<br/>        """ A list of the _HEAP_SEGMENTs. <br/><br/>        This is an array of pointers so we have to deref<br/>        before returning or the caller will be calling <br/>        is_valid on the pointer and not the object. <br/>        """<br/>        return [seg.dereference() for seg in self.Segments if seg != 0]<br/><br/>class _HEAP_SEGMENT(obj.CType):<br/>    """ A Heap Segment on XP and 2003 """    <br/><br/>    def is_valid(self):<br/>        return obj.CType.is_valid(self) and self.Signature == 0xffeeffee<br/><br/>    def heap_entries(self):<br/>        """Enumerate the heaps in this segment. <br/><br/>        ##FIXME: <br/>        * Raise ValueError if corruptions are detected. <br/>        * Should we start at FirstEntry or Entry?<br/>        """<br/><br/>        next = self.Entry #FirstEntry.dereference()<br/>        last = self.LastValidEntry.dereference()<br/><br/>        chunk_size = self.obj_vm.profile.get_obj_size("_HEAP_ENTRY")<br/><br/>        while (next and <br/>                    next.obj_offset &lt; last.obj_offset):<br/><br/>            yield next<br/><br/>            next = obj.Object("_HEAP_ENTRY", <br/>                    offset = next.obj_offset + next.Size * chunk_size, <br/>                    vm = next.obj_vm)</span><span id="1551" class="mg mh iq lk b gy mm mj l mk ml">[SNIP]</span></pre><p id="c737" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">因此，我们将尝试手动列出记事本本身的<code class="fe lh li lj lk b">heaps</code>内存区域。我们可以通过使用volatility中的<code class="fe lh li lj lk b">VAD</code>插件来实现，比如<code class="fe lh li lj lk b">vadtree</code>、<code class="fe lh li lj lk b">vadwalk</code>、<code class="fe lh li lj lk b">vaddump</code>、<code class="fe lh li lj lk b">vadinfo</code>(参见本<a class="ae kp" href="https://resources.infosecinstitute.com/topic/finding-enumerating-processes-within-memory-part-2/" rel="noopener ugc nofollow" target="_blank">页</a>了解VAD信息)。幸运的是，volatility支持像<code class="fe lh li lj lk b">dot</code>、<code class="fe lh li lj lk b">png</code>、<code class="fe lh li lj lk b">xlsx</code>这样的模块输出，我们将使用其中一个模块来演示WinAPI如何分配内存区域，以及如何定位堆位置及其范围。我将使用<code class="fe lh li lj lk b">vadtree</code>插件和<strong class="jt ir">记事本</strong> (588)的特定PID。</p><pre class="lm ln lo lp gt mc lk md me aw mf bi"><span id="4612" class="mg mh iq lk b gy mi mj l mk ml">python vol.py -f /home/kali/Desktop/memory_gone.vmem --profile=Win7SP1x64 vadtree -p 588 --output-file=/home/kali/Desktop/vadtree.dot --output=dot<br/>Volatility Foundation Volatility Framework 2.6.1<br/>Outputting to: /home/kali/Desktop/vadtree.dot</span><span id="8365" class="mg mh iq lk b gy mm mj l mk ml">#-- convert dot format to PNG<br/>dot vadtree.dot -Tpng &gt; vadtree.png</span></pre><p id="8e77" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">输出将是这样的，</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mr"><img src="../Images/e93e5216d688e972c77cdd8428ce7938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JMTUOkyGnyG_7aRVTEsDVA.png"/></div></div></figure><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ms"><img src="../Images/303e84f73abe526e0cdb8139c50a0951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xX2ocRuipb5sTsucipfFog.png"/></div></div></figure><p id="1181" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">注意有一些颜色像<strong class="jt ir">黄色、白色、灰色和红色</strong>。这非常有趣，因为volatility已经识别了每个存储区域的特征，准确地说是颜色代码<strong class="jt ir"/>，尽管还有一些其他颜色没有显示出来。在它的<a class="ae kp" href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference#vadtree" rel="noopener ugc nofollow" target="_blank">文档</a>中也有解释。</p><p id="234c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><strong class="jt ir"> A)黄色</strong> - &gt;包含一个映射文件</p><p id="38c5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><strong class="jt ir"> B)绿色-&gt;-</strong>包含一个线程堆栈</p><p id="c25e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><strong class="jt ir"> C)红色- &gt; </strong>包含了<strong class="jt ir">进程堆</strong></p><p id="3819" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><strong class="jt ir"> D)灰色</strong> - &gt;包含dll</p><p id="3f66" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们可以得出结论，有6个内存(节点)包含进程堆，我们将进一步研究它们。替代方法是使用volatility的一个<strong class="jt ir"> volshell </strong>插件。</p><pre class="lm ln lo lp gt mc lk md me aw mf bi"><span id="e570" class="mg mh iq lk b gy mi mj l mk ml">python vol.py -f /home/kali/Desktop/memory_gone.vmem --profile=Win7SP1x64 volshell -p 588<br/>Volatility Foundation Volatility Framework 2.6.1<br/>Current context: notepad.exe @ 0xfffffa80191ed060, pid=588, ppid=2548 DTB=0x2bf7f000</span><span id="0294" class="mg mh iq lk b gy mm mj l mk ml">Welcome to volshell! Current memory image is:<br/>file:///home/kali/Desktop/memory_gone.vmem<br/>To get help, type 'hh()'<br/>&gt;&gt;&gt; list_of_process_heaps_address = proc().Peb.ProcessHeaps.dereference() <br/>&gt;&gt;&gt; list_of_process_heaps_address<br/>&lt;Array 4325376,65536,1310720,1572864,30277632,33357824&gt;<br/>&gt;&gt;&gt; for i in [4325376,65536,1310720,1572864,30277632,33357824]:<br/>...     print(hex(i))<br/>... <br/>0x420000<br/>0x10000<br/>0x140000<br/>0x180000<br/>0x1ce0000<br/>0x1fd0000</span></pre><p id="634d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">这些是进程堆的起始地址，与之前我们尝试使用<code class="fe lh li lj lk b">vadtree</code>列出它们时VAD的起始节点相同。现在，对于最后一步，我们将在可能位于这些进程堆地址之一的特定地址中定位<strong class="jt ir">的确切内容</strong>。</p><p id="f793" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">为了找到位于进程堆中的用户输入，我们将处理一个<strong class="jt ir">堆块状态(从_HEAP_ENTRY flags chunk得出)。</strong>目前已知一些标志状态(空闲、忙碌、额外)，但如果有更多，请让我们都知道！</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mt"><img src="../Images/cebe1343cbede53d94f4f17be889a68d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5Gf0MSjFe9hJGmGiyFeNQ.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">参考:<a class="ae kp" href="https://illmatics.com/Understanding_the_LFH_Slides.pdf" rel="noopener ugc nofollow" target="_blank">https://illmatics.com/Understanding_the_LFH_Slides.pdf</a></figcaption></figure><p id="2beb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们需要知道的值得注意的结构变量是:如果<strong class="jt ir"> _HEAP_ENTRY- &gt;标志</strong>中的<strong class="jt ir">HEAP _ ENTRY _ EXTRA _ PRESENT</strong>被设置(标志被设置，值为0x02 ),并且状态名为<strong class="jt ir"> extra </strong>,则<strong class="jt ir">用户输入存在于应用程序</strong>中。</p><p id="8f47" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们将使用<a class="ae kp" href="http://www.windbg.org/" rel="noopener ugc nofollow" target="_blank"> WinDBG </a>来进一步分析堆内存区域。为了让调试器解析内存转储，我们需要首先创建一个有效的<a class="ae kp" href="https://docs.microsoft.com/en-us/windows/client-management/generate-kernel-or-complete-crash-dump" rel="noopener ugc nofollow" target="_blank">操作系统崩溃转储</a>，幸运的是，<code class="fe lh li lj lk b">volatility</code>已经有了名为<code class="fe lh li lj lk b">raw2dmp</code>的插件。我们还使用<strong class="jt ir"> volshell </strong>来支持通过偏移地址转储数据。</p><pre class="lm ln lo lp gt mc lk md me aw mf bi"><span id="6afc" class="mg mh iq lk b gy mi mj l mk ml">python vol.py -f /home/kali/Desktop/memory_gone.vmem --profile=Win7SP1x64 raw2dmp -O /home/kali/Desktop/memdump_ctf/windump.dmp<br/>Volatility Foundation Volatility Framework 2.6.1<br/>Writing data (5.00 MB chunks): |...........................................................................................................................................................................................................................................................................................................................................................................................................................|</span></pre><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mu"><img src="../Images/4de8aad74d998a752df8e45030a53b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X5UJ2zNJ90JVhx57AMOBRQ.png"/></div></div></figure><p id="7275" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们将把DMP文件传递给WinDBG，并注意它将首先检测作为16位进程架构的崩溃转储。这是一个已知的问题，你可以在这里阅读<a class="ae kp" href="https://social.msdn.microsoft.com/Forums/vstudio/en-US/4b306267-1fd2-431a-96c5-83a4f1c6b323/dx-command-of-windbg-is-strange-when-a-dmp-of-windbg-from-volatility-raw2dmp-is-analyzed?forum=wdk" rel="noopener ugc nofollow" target="_blank">。为了将其声明为64位，我们将使用<strong class="jt ir">。effmach </strong>。</a></p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mv"><img src="../Images/3d11d7d771c57b0e3f7eb8a6adf8412e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0p7s355_4xICkR8BENOUXg.png"/></div></div></figure><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/5c49817ca334026e11b2bca9b803cb73.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*RbqUnRWhTWuGiU1AiEqDIw.png"/></div></figure><p id="e3a2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">然后，我们需要将<strong class="jt ir">当前上下文</strong>切换到我们的进程<strong class="jt ir">记事本</strong>。为了找到上下文地址，我们可以使用这个命令或者使用PID指定的<strong class="jt ir"> volshell </strong>，这是之前找到的(0xfffffa80191ed060)。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/6764bc26fd10c69dcae26b1cf1e72a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*bikWldHQZHKQwhKMuGFIHA.png"/></div></figure><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi my"><img src="../Images/515dfe2bc4d057a8e7039ddf88daa7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*IV4FxUemJnPLGxX3lvoBkA.png"/></div></figure><p id="3456" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">现在，我们必须确保之前来自VAD节点的堆内存区域与我们在WinDBG中发送<code class="fe lh li lj lk b">!heap</code>命令后提示的输出相同。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/f367d7e42740ad2377d77a8afbb73906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*5RgCnbBAf5g8uXT3V53_Vw.png"/></div></figure><p id="ec3b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们需要一个一个地检查它们，以便检索我们的内容，正如我们之前已经记下的，<strong class="jt ir">堆块状态</strong>需要包含一个额外的<strong class="jt ir">。</strong></p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi na"><img src="../Images/b96edd79b0d899e7f766b1a5d54a5ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3l4mbKaAX2iOcnaQU4iPA.png"/></div></div></figure><p id="ed40" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我将附上包含<code class="fe lh li lj lk b">extra</code>状态的截取输出，</p><pre class="lm ln lo lp gt mc lk md me aw mf bi"><span id="d0f1" class="mg mh iq lk b gy mi mj l mk ml">[SNIP]</span><span id="b44b" class="mg mh iq lk b gy mm mj l mk ml">000000000044fc90  000000000044fca0  0000000000420000  0000000000420000       250       c30        10  busy <br/>000000000044fee0  000000000044fef0  0000000000420000  0000000000420000        60       250        20  busy extra user_flag <br/>000000000044ff40  000000000044ff50  0000000000420000  0000000000420000       180        60        10  busy <br/>00000000004500c0  00000000004500d0  0000000000420000  0000000000420000       110       180        10  busy</span><span id="1a8e" class="mg mh iq lk b gy mm mj l mk ml">[SNIP]</span><span id="93e3" class="mg mh iq lk b gy mm mj l mk ml">0000000000454a50  0000000000454a60  0000000000420000  0000000000420000        60       3e0        10  busy <br/>0000000000454ab0  0000000000454ac0  0000000000420000  0000000000420000       1b0        60        20  busy extra user_flag <br/>0000000000454c60  0000000000454c70  0000000000420000  0000000000420000        90       1b0        2c  busy extra user_flag <br/>0000000000454cf0  0000000000454d00  0000000000420000  0000000000420000        b0        90        20  busy extra user_flag <br/>0000000000454da0  0000000000454db0  0000000000420000  0000000000420000        40        b0        24  busy extra user_flag <br/>0000000000454de0  0000000000454df0  0000000000420000  0000000000420000        30        40        2c  busy extra user_flag <br/>0000000000454e10  0000000000454e20  0000000000420000  0000000000420000        30        30        2c  busy extra user_flag <br/>0000000000454e40  0000000000454e50  0000000000420000  0000000000420000        30        30        20  busy extra user_flag <br/>0000000000454e70  0000000000454e80  0000000000420000  0000000000420000       570        30         8  busy <br/>00000000004553e0  00000000004553f0  0000000000420000  0000000000420000        b0       570         8  busy</span></pre><p id="9366" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们已经获得了地址，现在我们将从指定的地址转储内容。我将首先演示具有<code class="fe lh li lj lk b">extra</code>的第一个地址，它是从0x44fee0到0x44fef0派生的。请注意，这意味着起点是从0x44fef0到(第一个进程堆地址内的新堆区域—堆区域的前一个起点)，这意味着分配的大小是0x 44 ff 40–0x 44 fef 0 = 80。</p><p id="dfd2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">使用<strong class="jt ir"> volshell </strong>，我们可以像这样转储它，</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/371df3c0f54b9312dc01bdf7c8e012b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*GYbgzYOqYZ7-Uo_KqqhKJA.png"/></div></figure><p id="bb73" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">有一些独特的特征，内存有一个<strong class="jt ir">空字节分隔符</strong>，所以所有这些空字节都可以被忽略，换行符变成了<strong class="jt ir">标准行尾</strong> (\r\n)的格式，所以它被转换为<strong class="jt ir"> %0d%0a </strong>，但是如果在内存中，它就是<strong class="jt ir"> 0d 00 0a 00 </strong>。然而，有时它没有那个“\r”，所以它只是<strong class="jt ir"> 0a 00 </strong>。</p><p id="1521" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">支持线端理论的一些发现依赖于此:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nc"><img src="../Images/cbbd5c67d538bd084af85d9290ddc1a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CfaVO03VThj_DOFsrV0MXQ.png"/></div></div></figure><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nd"><img src="../Images/5426124c6ee214264456129f1b97fc5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dLd9CwwO5bvCVzfb6MCzOQ.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">图片片段摘自<a class="ae kp" href="http://www.maxi-pedia.com/line+termination+line+feed+versus+carriage+return+0d0a" rel="noopener ugc nofollow" target="_blank">http://www . maxi-pedia . com/line+termination+line+feed+versus+carriage+return+0d0a</a></figcaption></figure><p id="d898" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">你现在可以从之前捕捉到的图像中找到答案，那就是记事本的内容！该场景说，这些内容由四个换行符分隔，所以是五个不同的单词。</p><pre class="lm ln lo lp gt mc lk md me aw mf bi"><span id="34fb" class="mg mh iq lk b gy mi mj l mk ml">g0O@<br/>$#,&amp;<br/>%f3st<br/>h4v$@<br/>j$@rt</span></pre><p id="94f6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">最后一步只是将这些单词连接成一个字符串(<strong class="jt ir"> g0O@$#，&amp; %f3sth4v$@j$@rt </strong>)并计算其MD5哈希，结果是856 e 37 da E6 a 6 f 35 deb 2 ee 34912 FD 2476。</p><p id="ed0e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">决赛旗~ &gt;<strong class="jt ir">ifest 22 { 856 e 37 da E6 a 6 f 35 deb 2 ee 34912 FD 2476 }</strong></p><p id="9db5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">您可以随意试验具有<code class="fe lh li lj lk b">extra</code>状态的其他堆区域，但是您需要知道内容应该至少具有4个<strong class="jt ir"> 0d 00 0a 00 </strong>或者具有<strong class="jt ir"> 0a 00 </strong>的组合。你可以自己尝试制作一个具体的场景，但这次要有可读的内容！</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="2e98" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">感谢我为这篇文章引用的所有参考资料！</p><div class="nl nm gp gr nn no"><a href="https://icegrave0391.github.io/2020/03/09/memfor-7/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">进程内存内部| Icegrave</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">本章分析了用于分配不同数据的各种应用程序编程接口(API)</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">icegrave0391.github.io</p></div></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://docs.microsoft.com/en-us/troubleshoot/windows-client/deployment/dynamic-link-library" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">动态链接库(DLL) - Windows客户端</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">本文介绍什么是动态链接库(DLL ),以及使用DLL时可能出现的各种问题。它…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">docs.microsoft.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc lv no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://stackoverflow.com/questions/28483473/windows-heap-chunk-header-parsing-and-size-calculation" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">Windows堆块头解析和大小计算</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">摘要:堆条目现在已经编码了，关键在堆本身。假设我有一个堆在0x00d60000: 0:000&gt;…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">stackoverflow.com</p></div></div><div class="nx l"><div class="od l nz oa ob nx oc lv no"/></div></div></a></div><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="oe of l"/></div></figure><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="oe of l"/></div></figure><div class="nl nm gp gr nn no"><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-heap" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">堆(WinDbg) - Windows驱动程序</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">的！堆扩展显示堆使用信息，控制堆管理器中的断点，检测泄漏的堆…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">docs.microsoft.com</p></div></div><div class="nx l"><div class="og l nz oa ob nx oc lv no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://systemroot.gitee.io/pages/apiexplorer/d5/d8/heapdbg_8c-source.html#l00444" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">heapdbg.c</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">转到该文件的文档。</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">systemroot.gitee.io</p></div></div></div></a></div><p id="2328" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">随时欢迎支持我！</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><a href="https://www.buymeacoffee.com/aseng"><div class="gh gi oh"><img src="../Images/7df76f8286c4b1a103ad4de822e474f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/0*4NT2oqw7i56w1uWO.png"/></div></a></figure><p id="1011" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><a class="ae kp" href="https://trakteer.id/felix-alexander-swfnt/tip?open=true" rel="noopener ugc nofollow" target="_blank">https://trakteer.id/felix-alexander-swfnt/tip?open=true</a></p></div></div>    
</body>
</html>