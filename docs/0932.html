<html>
<head>
<title>Bypass AMSI in PowerShell — A Nice Case Study</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">绕过PowerShell中的AMSI—一个很好的案例研究</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/bypass-amsi-in-powershell-a-nice-case-study-f3c0c7bed24d?source=collection_archive---------2-----------------------#2020-11-05">https://infosecwriteups.com/bypass-amsi-in-powershell-a-nice-case-study-f3c0c7bed24d?source=collection_archive---------2-----------------------#2020-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1a5b6f4600f74c62f01431e3beea09bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_9ct2f-uBwwm57OYNu1ag.png"/></div></div></figure><p id="a282" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在RedTeam的一个项目中，我希望使用BloodHoundAD脚本。BloodHound是一个单页JavaScript web应用程序，构建在Linkurious之上，用electronic编译，带有一个Neo4j数据库，由C#数据收集器提供数据。BloodHound使用图论来揭示活动目录环境中隐藏的、通常是意想不到的关系。攻击者可以使用BloodHound轻松识别高度复杂的攻击路径，否则无法快速识别。防御者可以使用BloodHound识别并消除这些相同的攻击路径。蓝队和红队都可以使用BloodHound轻松地深入了解Active Directory环境中的特权关系。【https://github . com/blood houndad/blood hound】。</p><p id="4d1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我解释一下这个场景…</p><p id="b745" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想用SharpHound。SharpHound是BloodHound Ingestor的C#重写版本。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/f7b7b33a82c97b266864143a0b3debe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhgFFMFko21Cv7Whw59TMA.png"/></div></div></figure><p id="31ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您直接在PowerShell中运行SharpHound.ps1时，最新版本的AMSI会阻止它运行:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1a5b6f4600f74c62f01431e3beea09bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_9ct2f-uBwwm57OYNu1ag.png"/></div></div></figure><p id="b9f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为这个脚本被认为是恶意负载，微软AMSI有它的签名并阻止它运行。</p><p id="a2db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，我将这个脚本分成几部分，并在PowerShell中分别直接运行每个部分。这样做的原因是我想找出恶意有效载荷的哪些部分可以被AMSI准确地检测到。</p><p id="e7ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">OMG！AMSI无法检测此参数的值:<strong class="ka ir"> $EncodedCompressedFile </strong>。这是恶意代码的主要部分。现在，您需要使用脚本的其他部分来在PowerShell中正确执行它。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/358324df3fe4b0cc383623001ef4083b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qis38pMrcotIQERNAa4Aww.png"/></div></div></figure><p id="10e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过base64编码和deflate压缩恶意负载，然后执行它来绕过AMSI。这是概念验证视频。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lc ld l"/></div></figure></div></div>    
</body>
</html>