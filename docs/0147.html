<html>
<head>
<title>How does TLS 1.3 protect against downgrade attacks?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TLS 1.3如何防御降级攻击？</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/how-does-tls-1-3-protect-against-downgrade-attacks-e0e97ccc38d4?source=collection_archive---------0-----------------------#2018-08-15">https://infosecwriteups.com/how-does-tls-1-3-protect-against-downgrade-attacks-e0e97ccc38d4?source=collection_archive---------0-----------------------#2018-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e62f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TLS 1.3标准最终于2018年8月发布。作者试图解决TLS协议旧版本中不幸存在的问题。问题之一是缺乏对降级攻击的保护。</p><h1 id="c41d" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">什么是针对TLS的降级攻击？</h1><p id="e5f7" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">让我们假设TLS客户端和服务器都支持现代TLS协议版本(如TLS 1.2)和具有强加密算法的密码套件。TLS降级攻击的目标是欺骗客户端和服务器使用较旧的协议版本或TLS连接的不安全参数。在一次成功的降级攻击后，对手可能试图利用旧协议版本或弱加密算法中的已知(或未知)缺陷。降级攻击通常要求对手能够拦截和修改网络流量，这通常被称为中间人。这是一种非常强大的对手——普通人似乎不太可能实施这样的攻击。</p><p id="926a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有几个著名的降级攻击的例子，如狮子狗，怪胎和Logjam。</p><p id="e382" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，现代TLS客户端和服务器支持旧的协议版本和弱加密算法，以向后兼容旧的客户端和服务器。可以容易地应用于现代TLS实现的降级攻击的最简单和最可靠的缓解之一就是禁用不安全的协议版本和算法。但是尽管如此，由于兼容性问题，这种简单的缓解可能花费太多。</p><h1 id="d86c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">TLS 1.3提供了什么来防止降级攻击？</h1><p id="62d6" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">下面是TLS 1.3标准如何定义降级保护:</p><blockquote class="lr ls lt"><p id="a13f" class="jq jr lu js b jt ju jv jw jx jy jz ka lv kc kd ke lw kg kh ki lx kk kl km kn im bi translated"><em class="it">双方的加密参数应该相同，并且应该相同，就好像对等体在没有受到攻击的情况下一直在通信一样</em></p></blockquote><p id="96d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说，一个好的降级保护机制确保客户端和服务器总是协商最安全的协议版本和加密参数，即使中间有坏人。</p><p id="f8aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TLS 1.3提供了两种防止降级攻击的措施。首先，它要求客户机和服务器都发送一个完成的消息，该消息包含一个覆盖所有先前握手消息的MAC，因此客户机和服务器都确保协商的参数没有被攻击者中途修改。下面是TLS 1.3标准如何准确定义完成消息的内容:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="1e0d" class="mi kp it me b gy mj mk l ml mm">finished_key =<br/>       HKDF-Expand-Label(BaseKey, "finished", "", Hash.length)<br/><br/>   Structure of this message:<br/><br/>      struct {<br/>          opaque verify_data[Hash.length];<br/>      } Finished;<br/><br/>   The verify_data value is computed as follows:<br/><br/>      verify_data =<br/>          HMAC(finished_key,<br/>               Transcript-Hash(Handshake Context,<br/>                               Certificate*, CertificateVerify*))<br/><br/>      * Only included if present.</span></pre><p id="cedc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mn mo mp me b">Certificate</code>和<code class="fe mn mo mp me b">CertificateVerify</code>消息仅在出现时包含在内。<code class="fe mn mo mp me b">finished_key</code>来源于一个协商好的握手秘密。</p><p id="fc19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，<a class="ae ly" href="https://tools.ietf.org/html/rfc8446#section-4.1.3" rel="noopener ugc nofollow" target="_blank"> TLS 1.3提供了降级保护机制，该机制嵌入在<code class="fe mn mo mp me b">ServerHello</code>消息中的服务器随机随机数</a>中。如果TLS 1.3服务器发现只可能协商旧的协议版本，那么TLS 1.3要求将它们的<code class="fe mn mo mp me b">ServerHello.random</code>字段的最后8个字节设置为预定义的值之一:</p><ul class=""><li id="ace8" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">如果协商TLS 1.2，那么最后8个字节必须是<code class="fe mn mo mp me b">44 4F 57 4E 47 52 44 01</code></li><li id="9318" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">如果协商TLS 1.1或更旧的协议版本，那么最后8个字节必须是<code class="fe mn mo mp me b">44 4F 57 4E 47 52 44 00</code></li></ul><p id="69d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，TLS 1.3要求客户端必须检查接收到的<code class="fe mn mo mp me b">ServerHello.random</code>的最后8个字节是否不等于上面的任何一个值，如果是，则必须终止连接。</p><p id="1d59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顺便说一下，上面字节序列的前7个字节表示“DOWNGRD”。换句话说，TLS 1.3规范要求客户端和服务器的行为如下:</p><ul class=""><li id="93d1" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">我是服务器，支持TLS 1.3。我从一个客户那里得到一个连接，说它只支持TLS 1.2或更低版本。没关系，但我要把消息“DOWNGRD”放到我的<code class="fe mn mo mp me b">ServerHello.random</code>上。这将让客户知道我实际上支持较高的协议版本，但我被要求使用较低的版本。</li><li id="d63b" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">我是客户端，我支持TLS 1.3。在我的<code class="fe mn mo mp me b">ClientHello</code>消息中，我要求服务器使用TLS 1.3。但是突然收到一条ServerHello消息，说服务器只支持TLS 1.2或更低版本。让我检查一下<code class="fe mn mo mp me b">ServerHello.random</code>是否包含“DOWNGRD”消息，如果是，中间有人试图对我们进行降级攻击，我们应该停止讨论。</li></ul><p id="d763" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果中间的攻击者删除了来自<code class="fe mn mo mp me b">ServerHello.random</code>的“DOWNGRD”消息，这不会有多大帮助，因为客户端和服务器在密钥交换过程中使用<code class="fe mn mo mp me b">ServerHello.random</code>。服务器无论如何都将使用原始值，因此在这种情况下握手将会失败。</p><p id="23ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们希望TLS 1.3协议的所有实现都不会忘记实现那些针对降级攻击的措施。</p><p id="087f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">附:这是给你的一个小作业。<code class="fe mn mo mp me b">ServerHello.random</code>包含32个字节。对于TLS 1.3连接，偶然随机选取“DOWNGRD + 00/01”的概率是多少？我们应该担心吗？</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="bcf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lu">原载于2018年8月15日</em><a class="ae ly" href="https://blog.gypsyengineer.com/en/security/how-does-tls-1-3-protect-against-downgrade-attacks.html" rel="noopener ugc nofollow" target="_blank"><em class="lu">【blog.gypsyengineer.com】</em></a><em class="lu">。</em></p><figure class="lz ma mb mc gt nm gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/caa48e0fecee77811531f187da560523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*UlrWHC-Ee5rFoZbS5fcLlw.png"/></div></figure></div></div>    
</body>
</html>