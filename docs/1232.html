<html>
<head>
<title>JavaScript prototype pollution: practice of finding and exploitation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript原型污染:发现和利用的实践</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2?source=collection_archive---------0-----------------------#2021-04-15">https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2?source=collection_archive---------0-----------------------#2021-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="2c5f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你关注参与bug bounty计划的研究人员的报告，你可能知道JavaScript原型污染漏洞的类别。如果您第一次没有看到这个短语，那么我建议您填补这个空白，因为这个漏洞可能会导致服务器和客户端完全受损。您使用或开发的产品中至少有一个运行在JavaScript上:web应用程序的客户端部分、桌面(电子)、服务器(节点)或移动应用程序。</p><p id="ad9d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这篇文章将帮助你深入原型污染的话题。在<strong class="jw ir">和</strong>章节中，什么是原型污染？您将了解JavaScript对象和原型是如何工作的，以及它们的具体功能是如何导致漏洞的。在<strong class="jw ir">客户端原型污染</strong>和<strong class="jw ir">服务器端原型污染</strong>小节中，您将了解如何在现实情况中搜索和利用该漏洞。最后，您将了解如何保护您的应用程序，以及为什么最常见的保护方法很容易被绕过。</p><p id="dd2d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在继续下一节之前，我建议您打开开发人员工具，亲自尝试一下本文中给出的示例，以便获得一些实践经验和对材料的更深入理解。</p><h1 id="260f" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">JavaScript特性</h1><p id="95de" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">原型污染漏洞是JavaScript语言独有的。因此，在处理漏洞本身之前，我们需要了解导致漏洞的JavaScript特性。</p><h2 id="2821" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">目标</h2><p id="21b0" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">JavaScript中对象是如何存在的？打开<a class="ae mh" href="https://developers.google.com/web/tools/chrome-devtools/open" rel="noopener ugc nofollow" target="_blank">开发者工具</a>并创建一个包含两个属性的简单对象。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="d73e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以通过两种主要方式访问对象的属性。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="fcd9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们试图访问一个不存在的属性会发生什么？</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="77aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们得到了值<code class="fe mp mq mr ms b">undefined</code>，这意味着属性丢失了。到目前为止一切顺利。</p><p id="1c12" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在JavaScript中，函数可以像普通变量一样处理(更多信息请参考<a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function" rel="noopener ugc nofollow" target="_blank">一级函数</a>文章)，所以对象方法被定义为属性，事实上也确实如此。将<code class="fe mp mq mr ms b">foo()</code>方法添加到<code class="fe mp mq mr ms b">o</code>对象中并调用它。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="99ed" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">姑且称之为<code class="fe mp mq mr ms b">toString()</code>法。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="03fd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">突然，<code class="fe mp mq mr ms b">toString()</code>方法被执行，即使<code class="fe mp mq mr ms b">o</code>对象没有<code class="fe mp mq mr ms b">toString()</code>方法！我们可以使用<code class="fe mp mq mr ms b">Object.getOwnPropertyNames()</code>功能对此进行检查。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b17b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事实上，只有三个属性:<code class="fe mp mq mr ms b">name</code>、<code class="fe mp mq mr ms b">surname</code>和<code class="fe mp mq mr ms b">foo</code>。<code class="fe mp mq mr ms b">toString()</code>方法从何而来？</p><h2 id="e940" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">对象原型</h2><p id="24e7" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">就实体数量而言，JavaScript是最少的。几乎任何实体都是包含数组、函数甚至类定义的对象！我们会在课堂上更详细地讲到这里。</p><p id="9bc5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在JavaScript中，没有大多数程序员共同理解的类。如果您以前没有遇到过JavaScript中的类，但是有使用其他语言中的类的经验，那么我建议的第一件事是忘记您所知道的关于类的一切。</p><p id="d1b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，假设你有两个实体:一个<a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#data_and_structure_types" rel="noopener ugc nofollow" target="_blank">对象</a>和一个<a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#data_and_structure_types" rel="noopener ugc nofollow" target="_blank">原语</a>(数字、字符串、<code class="fe mp mq mr ms b">null</code>等)。).如何使用它们来实现继承这样一个方便的类特性呢？您可以选择每个对象将拥有的特殊属性。它将包含对父级的引用。我们姑且称这个属性为<code class="fe mp mq mr ms b">[[Prototype]]</code>。好吧，如果我们不想从父类继承所有的属性和方法呢？让我们从父类中选择一个特殊的属性，将从该属性中继承属性和方法，并将其命名为<code class="fe mp mq mr ms b">prototype</code>！</p><p id="88a7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有几种方法<a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank">可以找出一个物体</a>的原型，例如，通过使用<code class="fe mp mq mr ms b">Object.getPrototypeOf()</code>方法。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="8d78" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们只返回了<code class="fe mp mq mr ms b"><a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener ugc nofollow" target="_blank">Object.prototype</a></code>，它是JavaScript中几乎所有对象的原型。确定这是一个<code class="fe mp mq mr ms b">Object.prototype</code>非常简单。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="8890" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当你通过<code class="fe mp mq mr ms b">o.name</code>或<code class="fe mp mq mr ms b">o['name']</code>访问一个对象属性时，实际上执行以下操作:</p><ol class=""><li id="cd11" class="mt mu iq jw b jx jy kb kc kf mv kj mw kn mx kr my mz na nb bi translated">JavaScript引擎在<code class="fe mp mq mr ms b">o</code>对象中搜索<code class="fe mp mq mr ms b">name</code>属性。</li><li id="f4a4" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr my mz na nb bi translated">如果属性存在，则返回该属性。否则，获取<code class="fe mp mq mr ms b">o</code>对象的原型，并在其中搜索属性！</li></ol><p id="7e6f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以结果是，<code class="fe mp mq mr ms b">toString()</code>方法实际上是在<code class="fe mp mq mr ms b">Object.prototype</code>中定义的，但是因为在创建一个对象时，它的原型被隐式地赋给了<code class="fe mp mq mr ms b">Object.prototype</code>，所以我们几乎可以为任何事情调用<code class="fe mp mq mr ms b">toString()</code>方法。</p><p id="8e60" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">反过来，父节点也可以有原型，父节点的父节点，以此类推。从一个对象到<code class="fe mp mq mr ms b">null</code>的原型序列被称为原型链或<a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="noopener ugc nofollow" target="_blank">原型链</a>。在这方面，一个小备注:当访问一个属性时，在整个原型链中搜索该属性。</p><p id="aa54" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以对象<code class="fe mp mq mr ms b">o</code>为例，原型链比较短，只有一个原型。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="9e42" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于<code class="fe mp mq mr ms b">window</code>对象就不能这么说了。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b7ff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">顺便说一下，根据上下文的不同，JavaScript中的“原型”一词至少可以指三种不同的东西:</p><ul class=""><li id="0cc3" class="mt mu iq jw b jx jy kb kc kf mv kj mw kn mx kr nh mz na nb bi translated">内部属性<code class="fe mp mq mr ms b">[[Prototype]]</code>。它被称为internal，因为它位于JavaScript引擎的“内部”，我们只能通过特殊函数<code class="fe mp mq mr ms b">__proto__</code>、<code class="fe mp mq mr ms b">Object.getPrototypeOf()</code>和其他函数来访问它。</li><li id="1ed5" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated">prototype属性:Object.prototype、Function.prototype等。</li><li id="9b64" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated"><code class="fe mp mq mr ms b">__proto__</code>属性。这是一种罕见且不太正确的用法，因为从技术上讲<code class="fe mp mq mr ms b">__proto__</code>是一个getter / setter，它只获取对对象原型的引用并返回它。</li></ul><h1 id="b5a8" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">什么是原型污染？</h1><p id="551a" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">术语原型污染是指<a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#fundamental_objects" rel="noopener ugc nofollow" target="_blank">基本对象</a>的<code class="fe mp mq mr ms b">prototype</code>属性发生变化的情况。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="17e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">执行这段代码后，几乎任何对象都将拥有一个值为<code class="fe mp mq mr ms b">42</code>的<code class="fe mp mq mr ms b">age</code>属性。例外情况有两种:</p><ul class=""><li id="2e13" class="mt mu iq jw b jx jy kb kc kf mv kj mw kn mx kr nh mz na nb bi translated">如果在对象上定义了<code class="fe mp mq mr ms b">age</code>属性，它将覆盖原型的相同属性。</li><li id="e406" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated">如果对象不是从<code class="fe mp mq mr ms b">Object.prototype</code>继承的。</li></ul><p id="c0e1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">原型污染在代码中可以是什么样子？考虑程序<code class="fe mp mq mr ms b">pp.js</code>。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="73c5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果攻击者控制了参数<code class="fe mp mq mr ms b">a</code>和<code class="fe mp mq mr ms b">v</code>，他们可以将a设置为<code class="fe mp mq mr ms b">'__proto__ '</code>，将<code class="fe mp mq mr ms b">v</code>设置为任意字符串值，从而将<code class="fe mp mq mr ms b">test</code>属性添加到<code class="fe mp mq mr ms b">Object.prototype</code>。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="adf5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">恭喜你，我们刚刚发现原型污染！"但是有哪个头脑正常的人会使用这样的结构呢？"—你可能会问。的确，这种例子在现实生活中很少出现。然而，在某些情况下，有一些看似无害的构造允许我们添加或更改<code class="fe mp mq mr ms b">Object.prototype</code>的属性。具体的例子将在下面的章节中讨论。</p><h1 id="6c40" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">客户端原型污染</h1><p id="b7b7" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">2020年中期开始积极探索客户端原型污染。目前，当有效载荷在请求参数中(在<code class="fe mp mq mr ms b">?</code>之后)或在片段中(在<code class="fe mp mq mr ms b">#</code>之后)时，向量被很好地研究。此漏洞通常会升级为反射XSS。</p><p id="e9cc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">很有可能有效负载不仅可以在请求参数或片段中传递，还可以保存在服务器上。因此，有效负载将在每次访问某个页面的每个用户都起作用，不管他是否访问了恶意链接。</p><h2 id="aecc" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">寻找原型污染</h2><p id="b1bf" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">让我们试着在一个脆弱的地点找到污染的原型。最简单的方法是为谷歌Chrome安装<a class="ae mh" href="https://github.com/msrkp/PPScan" rel="noopener ugc nofollow" target="_blank"> PPScan </a>扩展并访问易受攻击的页面。</p><p id="7737" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以看到分机上的计数器现在等于2。这意味着其中一个有效载荷工作良好。如果我们单击扩展图标，我们将会看到有效负载证明存在漏洞。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/04b8e386cd97e4f4b244011b25689e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WL-A40G-CT3p4UHpV0RmEg.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated"><em class="nt"> PPScan扩展正在运行</em></figcaption></figure><p id="351c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们用手试试其中的一个有效负载:点击链接<code class="fe mp mq mr ms b">https://ctf.nikitastupin.com/pp/known.html?__proto__[polluted]=test</code>，打开开发者工具并检查结果。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="62d1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">太好了，有效载荷起作用了！不幸的是，客户机原型污染本身并不构成严重的危险。您最多可以用它来创建一个客户端DoS，这可以通过更新页面来处理。</p><h1 id="4c4a" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">影响和小工具</h1><p id="741f" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">在客户端，升级到XSS是最有趣的。可用于将原型污染升级到其他漏洞的JavaScript代码称为gadget。一般来说，我们要么有一个众所周知的小工具，要么我们必须自己寻找小工具。搜索新的小玩意要花很多时间。</p><h2 id="fe12" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">使用现有小工具</h2><p id="537d" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">首先，检查一下<a class="ae mh" href="https://github.com/BlackFan/client-side-prototype-pollution" rel="noopener ugc nofollow" target="_blank">black fan/client-side-prototype-pollution</a>资源库或<a class="ae mh" href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution" rel="noopener ugc nofollow" target="_blank">跨站脚本(XSS)备忘单</a>中现有的小工具是有意义的。</p><p id="ccdb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">至少有两种方法可以检查已知的小工具:</p><ul class=""><li id="73ad" class="mt mu iq jw b jx jy kb kc kf mv kj mw kn mx kr nh mz na nb bi translated">使用<a class="ae mh" href="https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg?hl=en" rel="noopener ugc nofollow" target="_blank"> Wappalyzer </a>插件。</li><li id="001d" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated">使用脚本<a class="ae mh" href="https://gist.github.com/nikitastupin/b3b64a9f8c0eb74ce37626860193eaec" rel="noopener ugc nofollow" target="_blank"> fingerprint.js </a>。</li></ul><p id="799e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们使用第二种方法，但首先我们要了解它是如何工作的。通常，小工具将在全局上下文中定义特定的变量，通过这些变量的存在，您可以确定小工具的存在。例如，如果您使用Twitter广告，您可能会使用Twitter通用网站标签，该标签将定义<code class="fe mp mq mr ms b">twq</code>变量。<a class="ae mh" href="https://gist.github.com/nikitastupin/b3b64a9f8c0eb74ce37626860193eaec" rel="noopener ugc nofollow" target="_blank"> fingerprint.js </a>主要检查全局上下文中的特定变量。我从<a class="ae mh" href="https://github.com/BlackFan/client-side-prototype-pollution" rel="noopener ugc nofollow" target="_blank">black fan/client-side-prototype-pollution</a>借用了小工具和它们对应的变量。</p><p id="c785" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">复制脚本并在易受攻击的页面的上下文中执行。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/51658c4151333fa15c60b6f98acc17a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KehnmLwY_M-e5wQWOB1r-g.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated"><a class="ae mh" href="https://gist.github.com/nikitastupin/b3b64a9f8c0eb74ce37626860193eaec" rel="noopener ugc nofollow" target="_blank"><em class="nt">fingerprint . js</em></a><em class="nt">显示页面有Twitter通用网站标签小工具</em></figcaption></figure><p id="c9b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">看起来该页面有一个Twitter通用网站标签小工具。我们在<a class="ae mh" href="https://github.com/BlackFan/client-side-prototype-pollution" rel="noopener ugc nofollow" target="_blank">black fan/client-side-prototype-pollution</a>中找到了这个小工具的描述，最重要的是，我们对带有现成有效载荷的<a class="ae mh" href="https://github.com/BlackFan/client-side-prototype-pollution/blob/004bf5353f6f30b720f3d68c5aca5191531f35d6/gadgets/twitter-uwt.md#poc" rel="noopener ugc nofollow" target="_blank"> PoC </a>部分感兴趣。在易受攻击的站点<code class="fe mp mq mr ms b"><a class="ae mh" href="https://ctf.nikitastupin.com/pp/known.html?__proto__[hif][]=javascript:alert(document.domain)." rel="noopener ugc nofollow" target="_blank">https://ctf.nikitastupin.com/pp/known.html?__proto__[hif][]=javascript:alert(document.domain)</a></code> <a class="ae mh" href="https://ctf.nikitastupin.com/pp/known.html?__proto__[hif][]=javascript:alert(document.domain)." rel="noopener ugc nofollow" target="_blank">上测试有效载荷。</a></p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/4ecf3db9496aabfbad862134180f7f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I2JZsKFqLnuWZzA4gIgfJw.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated"><em class="nt">在一个知名小工具的帮助下，原型污染成功运行</em></figcaption></figure><p id="045c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">几秒钟后，梦寐以求的<code class="fe mp mq mr ms b">alert ()</code>出现了，太棒了！</p><h2 id="137e" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">寻找新的小工具</h2><p id="e744" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">没有小工具的时候我们该怎么办？我们去<code class="fe mp mq mr ms b">https://ctf.nikitastupin.com/pp/unknown.html</code>看看，确保它容易受到原型污染<code class="fe mp mq mr ms b"><a class="ae mh" href="https://ctf.nikitastupin.com/pp/unknown.html?__proto__[polluted]=31337." rel="noopener ugc nofollow" target="_blank">https://ctf.nikitastupin.com/pp/unknown.html?__proto__[polluted]=31337</a></code> <a class="ae mh" href="https://ctf.nikitastupin.com/pp/unknown.html?__proto__[polluted]=31337." rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6787" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不过，这一次<a class="ae mh" href="https://gist.github.com/nikitastupin/b3b64a9f8c0eb74ce37626860193eaec" rel="noopener ugc nofollow" target="_blank"> fingerprint.js </a>没有找到小工具。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/b661667ec46e2265b5da963ec4b1bc8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LXXV214WiBwBHfGoy29gXQ.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated"><a class="ae mh" href="https://gist.github.com/nikitastupin/b3b64a9f8c0eb74ce37626860193eaec" rel="noopener ugc nofollow" target="_blank"><em class="nt">fingerprint . js</em></a><em class="nt">没找到那个小玩意</em></figcaption></figure><p id="541f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽管Wappalyzer报告了jQuery的存在，但这是一个误报，因为在站点<code class="fe mp mq mr ms b"><a class="ae mh" href="https://ctf.nikitastupin.com/pp/unknown.html." rel="noopener ugc nofollow" target="_blank">https://ctf.nikitastupin.com/pp/unknown.html</a></code> <a class="ae mh" href="https://ctf.nikitastupin.com/pp/unknown.html." rel="noopener ugc nofollow" target="_blank">上使用了jquery-deparam库。</a></p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/1d1a7a9f9725a8a8217a4dcc081cb670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Q5ZCvyYT4PU2-noLYJ_FA.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated"><em class="nt">来自Wappalyzer插件的误报响应</em></figcaption></figure><p id="03d4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有几种方法可以找到新的小工具:</p><ol class=""><li id="0139" class="mt mu iq jw b jx jy kb kc kf mv kj mw kn mx kr my mz na nb bi translated"><a class="ae mh" href="https://github.com/filedescriptor/untrusted-types/tree/old" rel="noopener ugc nofollow" target="_blank">文件描述符/不可信类型</a>。在撰写本文时，该插件有两个版本:<code class="fe mp mq mr ms b">main</code>和<code class="fe mp mq mr ms b">old</code>。我们将使用<code class="fe mp mq mr ms b">old</code>，因为它比<code class="fe mp mq mr ms b">main</code>简单。这个插件最初是为DOM XSS搜索开发的，细节可以在视频<a class="ae mh" href="https://youtu.be/CNNCCgDkt5k" rel="noopener ugc nofollow" target="_blank">中找到。</a></li><li id="9d7d" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr my mz na nb bi translated"><a class="ae mh" href="https://github.com/securitum/research/tree/master/r2020_prototype-pollution" rel="noopener ugc nofollow" target="_blank"> pollute.js </a>。这个工具是如何工作的，以及它允许你发现哪些漏洞，可以在文章<a class="ae mh" href="https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/" rel="noopener ugc nofollow" target="_blank">原型污染——绕过客户端HTML杀毒软件</a>中读到。</li><li id="e35e" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr my mz na nb bi translated">使用调试器，用手搜索。</li></ol><p id="ff46" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们使用第一种方法。安装插件，打开控制台，进入<code class="fe mp mq mr ms b">https://ctf.nikitastupin.com/pp/unknown.html</code>。总的来说，<a class="ae mh" href="https://github.com/filedescriptor/untrusted-types/tree/old" rel="noopener ugc nofollow" target="_blank">file descriptor/untrusted-types</a>扩展只是记录所有可能导致DOM XSS的API调用。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/8dae27a35e55b9aaac5b83d94da0a74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AYAQ-1iXiNuRH0_PTiw6ew.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated"><em class="nt">我们使用</em><a class="ae mh" href="https://github.com/filedescriptor/untrusted-types/tree/old" rel="noopener ugc nofollow" target="_blank"><em class="nt">file descriptor/untrusted-types</em></a><em class="nt">插件来搜索新的小工具</em></figcaption></figure><p id="eb0a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们的情况下，只有两种情况。现在，我们需要手动检查每种情况，看看我们是否可以使用原型污染来改变任何变量，以实现XSS。</p><p id="f399" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第一个是带有<code class="fe mp mq mr ms b">this</code>参数的<code class="fe mp mq mr ms b">eval</code>，我们跳过了它。在第二种情况下，我们看到某个HTML元素的<code class="fe mp mq mr ms b">src</code>属性被赋予了值<code class="fe mp mq mr ms b">https://ctf.nikitastupin.com/pp/hello.js</code>。转到堆栈跟踪，转到<code class="fe mp mq mr ms b">loadContent @ unknown.html:17</code>，我们会看到下面的代码。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="7ad0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这段代码加载了<code class="fe mp mq mr ms b">s</code>脚本。脚本源由<code class="fe mp mq mr ms b">scriptSource</code>变量设置。<code class="fe mp mq mr ms b">scriptSource</code>变量依次采用已经存在的<code class="fe mp mq mr ms b">window.scriptSource</code>值，或默认值<code class="fe mp mq mr ms b">"https://ctf.nikitastupin.com/pp/hello.js"</code>。</p><p id="330a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是我们的小玩意所在的地方。有了原型污染，我们可以在<code class="fe mp mq mr ms b">Object.prototype</code>上定义一个任意的属性，它当然是一个<code class="fe mp mq mr ms b">window</code>原型。我们尝试添加值<code class="fe mp mq mr ms b">Object.prototype.scriptSource = </code>，为此，转到<code class="fe mp mq mr ms b"><a class="ae mh" href="https://ctf.nikitastupin.com/pp/unknown.html?__proto__[scriptSource]=https://ctf.nikitastupin.com/pp/alert.js." rel="noopener ugc nofollow" target="_blank">https://ctf.nikitastupin.com/pp/unknown.html?__proto__[scriptSource]=https://ctf.nikitastupin.com/pp/alert.js</a></code> <a class="ae mh" href="https://ctf.nikitastupin.com/pp/unknown.html?__proto__[scriptSource]=https://ctf.nikitastupin.com/pp/alert.js." rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/df7ccb53e02a16823a05b4613fb1047f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRk2_xmLq9Yo4rm-p6hp5Q.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated"><em class="nt">使用新装置成功运行原型污染</em></figcaption></figure><p id="2898" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是我们的<code class="fe mp mq mr ms b">alert()</code>！我们刚刚为一个特定的站点找到了一个新的小工具。</p><p id="93fe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可能会说这是一个人为的例子，你不会在现实世界中找到它。然而，在实践中，这种情况会发生，因为构造<code class="fe mp mq mr ms b">var v = v || "default"</code>在JavaScript中很常见。例如，用于<a class="ae mh" href="https://github.com/leizongmin/js-xss/" rel="noopener ugc nofollow" target="_blank"> leizongmin/js-xss </a>库的小工具，在文章<a class="ae mh" href="https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/" rel="noopener ugc nofollow" target="_blank">原型污染-绕过客户端HTML清理器</a>的“xss”部分中有所描述，就使用了这种结构。</p><h2 id="bfa5" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">边缘情况</h2><p id="42cb" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">除了通常的向量<code class="fe mp mq mr ms b">__proto__[polluted]=1337</code>和<code class="fe mp mq mr ms b">__proto__.polluted=31337</code>之外，有一次我碰到了一个奇怪的案例。那是在一个大网站上。不幸的是，该报告尚未披露，所以没有名字。我的私人搜索插件prototype pollution报告了一个漏洞，但是不可能使用法线向量来重现它。我坐下来想弄清楚发生了什么事。漏洞已经被修复，但我们有一个副本。</p><p id="f405" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">导航至<code class="fe mp mq mr ms b">https://ctf.nikitastupin.com/pp/bypass.html?__proto__[polluted]=1337&amp;__proto__.polluted=31337</code>。打开开发者工具，检查漏洞是否起作用。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="bcf5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">看起来这个漏洞没有起作用，但是让我们更深入地研究一下源代码。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="363a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">已经熟悉的函数<code class="fe mp mq mr ms b">deparam</code>用参数<code class="fe mp mq mr ms b">location.search</code>调用。让我们看看函数定义。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="7dac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们立即明白我们正在处理的是精简的代码，因此会更加困难。接下来，我们注意到熟悉的线条<code class="fe mp mq mr ms b">"__proto__"</code>、<code class="fe mp mq mr ms b">"constructor"</code>和<code class="fe mp mq mr ms b">"prototype"</code>。最有可能的是，这是一个参数黑名单，这意味着开发人员已经尝试修复该漏洞。但是为什么插件会发现漏洞呢？我们进一步了解。</p><p id="0908" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">进一步理解静力学中的精简源代码是极其困难的，所以我们在<code class="fe mp mq mr ms b">h = h[a] = u &lt; p ? h[a] || (l[u + 1] &amp;&amp; isNaN(l[u + 1]) ? {} : []) : o</code>行放了一个断点。在如下所示的行上设置断点。为什么会在上面？事实是，插件注意到它的原型污染，这就是为什么从它开始似乎是最合乎逻辑的。重新加载页面并进入调试器。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nu"><img src="../Images/c5204dbb19a174a872058bfefa4deecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yyVp86iz8OoyLinsxG8j4w.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated"><em class="nt">使用调试器寻找修复旁路</em></figcaption></figure><p id="2429" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们看到一个可能导致漏洞的构造:<code class="fe mp mq mr ms b">h = {}; a = "__PROTO__"; h = h[a] = ...</code>。为什么漏洞不起作用？事实是<code class="fe mp mq mr ms b">__PROTO__</code>和<code class="fe mp mq mr ms b">__proto__</code>是不同的标识符。下一个想法是弄清楚黑名单是如何应用的，并试图找到一个变通办法。在使用调试器几个小时后，我理解了函数的内部逻辑:<code class="fe mp mq mr ms b">toUpperCase()</code>应用于黑名单中的单词，并试图绕过这个操作，但尝试都不成功。</p><p id="8f83" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我决定从大处着眼来处理我还没见过的代码。在所有有助于爬行的东西中，只剩下一行了。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="ddce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">乍一看，这个字符串处理数组(例如，<code class="fe mp mq mr ms b">a[0]=31&amp;a[1]=337</code>被解析为<code class="fe mp mq mr ms b">a = [31, 337]</code>)。如果您仔细观察，那么普通对象(例如，<code class="fe mp mq mr ms b">b=42</code>)也由该行处理。尽管这个代码没有直接导致原型污染，但是没有使用黑名单，说明这是一个规避的希望！</p><p id="56e0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我记得有一个<a class="ae mh" href="https://github.com/richardgirges/express-fileupload/issues/239" rel="noopener ugc nofollow" target="_blank">案例</a>，原型污染以类似的方式被修复(黑名单<code class="fe mp mq mr ms b">__proto__</code>、<code class="fe mp mq mr ms b">constructor</code>、<code class="fe mp mq mr ms b">prototype</code>)，另一个研究人员绕过了这个，能够改变<code class="fe mp mq mr ms b">toString</code>类型的属性，最终DoS。我的第一个想法是将<code class="fe mp mq mr ms b">includes()</code>方法改为返回<code class="fe mp mq mr ms b">false</code>。但是后来我意识到我只能添加一个字符串，当<code class="fe mp mq mr ms b">includes</code>是一个字符串并且我们对它进行了一个调用<code class="fe mp mq mr ms b">()</code>时，一个异常发生了(<code class="fe mp mq mr ms b">includes is not a function</code>)并且脚本不再工作。</p><p id="eb2a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">之后，我想起JavaScript中的数组是普通对象，因此数组元素可以通过方括号访问。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4134" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">顺着这个思路，我得到了一个思路，你可以先把<code class="fe mp mq mr ms b">__proto__</code>放在一个数组元素里，然后通过索引访问这个元素，从而绕过黑名单。</p><p id="b4e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在第<code class="fe mp mq mr ms b">aaa.utils.isArray(i[a]) ...</code>行设置断点。尝试有效载荷<code class="fe mp mq mr ms b">https://ctf.nikitastupin.com/pp/bypass.html?v=1337</code>，进入调试器，点击“单步执行下一个函数调用”。结果，<code class="fe mp mq mr ms b">i[a] = o</code>被执行，我们检查<code class="fe mp mq mr ms b">i</code>的值。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4ba9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果指定<code class="fe mp mq mr ms b">__proto__</code>而不是<code class="fe mp mq mr ms b">v</code>会怎么样？尝试有效载荷<code class="fe mp mq mr ms b">https://ctf.nikitastupin.com/pp/bypass.html?__proto__=1337</code>，此时<code class="fe mp mq mr ms b">i[a] = [i[a], o]</code>被执行，我们检查<code class="fe mp mq mr ms b">i</code>的值。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="297c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">哇哦。结果是一个非常花哨的对象，但最重要的是解析下面的参数时会用到这个对象！你可能会问，这对我们有什么帮助？答案就在一步之遥。</p><p id="a558" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">移除先前的断点，并在潜在易受攻击的构造上的第<code class="fe mp mq mr ms b">h = h[a]</code>行添加一个断点。我们还将向有效载荷添加另一个参数<code class="fe mp mq mr ms b">https://ctf.nikitastupin.com/pp/bypass.html?__proto__=1337&amp;o[k]=leet</code>。我们进入调试器并检查<code class="fe mp mq mr ms b">h[0]</code>的值。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="e938" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">突然，我们可以访问<code class="fe mp mq mr ms b">Object.prototype</code>！要理解为什么会发生这种情况，让我们记住(JavaScript中的数组元素可以通过使用方括号来访问，索引可以是字符串，(2)如果在对象上没有找到属性，则在原型链中继续搜索。所以结果是，当我们执行<code class="fe mp mq mr ms b">h["0"]</code>时，对象<code class="fe mp mq mr ms b">h</code>上不存在的属性<code class="fe mp mq mr ms b">"0"</code>取自原型<code class="fe mp mq mr ms b">h.__proto__</code>，其值为<code class="fe mp mq mr ms b">Object.prototype</code>。</p><p id="4b61" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以如果我们把<code class="fe mp mq mr ms b">o</code>改成<code class="fe mp mq mr ms b">0</code>，那么我们可以给<code class="fe mp mq mr ms b">Object.prototype</code>加一个属性？禁用断点，尝试<code class="fe mp mq mr ms b">https://ctf.nikitastupin.com/pp/bypass.html?__proto__=1337&amp;0[k]=leet</code>并检查结果。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="5791" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我想你自己已经想明白了。</p><h1 id="3794" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">服务器端原型污染</h1><p id="eff4" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">这一切都始于<a class="ae mh" href="https://youtu.be/LUsiFV3dsK8" rel="noopener ugc nofollow" target="_blank">Olivier Arteau——NodeJS应用中的原型污染攻击</a>、<a class="ae mh" href="https://github.com/HoLyVieR/prototype-pollution-nsec18" rel="noopener ugc nofollow" target="_blank">原型污染nsec18 </a>。Oliver在<a class="ae mh" href="https://hackerone.com/holyvier?filter=type%3Apublic&amp;type=user" rel="noopener ugc nofollow" target="_blank">几个npm包</a>中发现了原型污染漏洞，其中包括一个最受欢迎的<a class="ae mh" href="https://www.npmjs.com/package/lodash" rel="noopener ugc nofollow" target="_blank"> lodash </a>包(<a class="ae mh" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-3721" rel="noopener ugc nofollow" target="_blank">CVE-2018–3721</a>)。lodash包用于JavaScript生态系统的许多应用程序和包中。特别是，它被用在流行的<a class="ae mh" href="https://github.com/TryGhost/Ghost" rel="noopener ugc nofollow" target="_blank"> Ghost </a> CMS中，由于这个原因，CMS容易受到远程代码执行的攻击，利用这个漏洞不需要认证。</p><h2 id="7368" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">寻找原型污染</h2><p id="5128" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">如果没有源代码，这类漏洞很难检测和利用。例外情况是当你有一个CVE和一个现成的有效载荷。但是假设我们有源代码。代码中有哪些地方需要注意？这种漏洞在哪里最常见？</p><p id="31d0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">哪些语言结构容易出现漏洞？</p><p id="26bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最常见的是，原型污染出现在以下结构/操作中:</p><ul class=""><li id="d67e" class="mt mu iq jw b jx jy kb kc kf mv kj mw kn mx kr nh mz na nb bi translated">对象的递归合并(例如，<a class="ae mh" href="https://github.com/jonschlinkert/merge-deep" rel="noopener ugc nofollow" target="_blank"> jonschlinkert/merge-deep </a></li><li id="9c03" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated">克隆对象(例如，<a class="ae mh" href="https://github.com/jonschlinkert/clone-deep" rel="noopener ugc nofollow" target="_blank"> jonschlinkert/clone-deep </a>)</li><li id="24aa" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated">将GET参数转换为JavaScript对象(例如，<a class="ae mh" href="https://github.com/AceMetrix/jquery-deparam" rel="noopener ugc nofollow" target="_blank"> AceMetrix/jquery-deparam </a>)</li><li id="d146" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated">将<code class="fe mp mq mr ms b">.toml</code>或<code class="fe mp mq mr ms b">.ini</code>配置文件转换为JavaScript对象(例如，<a class="ae mh" href="https://github.com/npm/ini" rel="noopener ugc nofollow" target="_blank"> npm/ini </a>)</li></ul><p id="fa1b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以追踪一种模式:那些将复杂数据结构(例如，<code class="fe mp mq mr ms b">.toml</code>)作为输入并将其转换为JavaScript对象的操作是易受攻击的。</p><p id="0195" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">动态分析</strong></p><p id="b4a5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们从动态开始，因为它更容易理解和应用。该算法非常简单，并且已经在<a class="ae mh" href="https://github.com/HoLyVieR/prototype-pollution-nsec18/tree/master/find-vuln" rel="noopener ugc nofollow" target="_blank"> find-vuln </a>中实现:</p><ol class=""><li id="335d" class="mt mu iq jw b jx jy kb kc kf mv kj mw kn mx kr my mz na nb bi translated">下载npm包。</li><li id="2a35" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr my mz na nb bi translated">调用包中的每个函数，用一个pagelode作为参数。</li><li id="1ff8" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr my mz na nb bi translated">检查漏洞是否起作用。</li></ol><p id="6fb1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae mh" href="https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/find-vuln/find-vuln.js" rel="noopener ugc nofollow" target="_blank"> find-vuln.js </a>唯一的缺点是它不检查<code class="fe mp mq mr ms b">constructor.prototype</code>，因此错过了一些漏洞，但这个缺口很容易修复。</p><p id="e043" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用类似的算法，我发现了<a class="ae mh" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-28449" rel="noopener ugc nofollow" target="_blank"> CVE-2020-28449 </a>、<a class="ae mh" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-28450" rel="noopener ugc nofollow" target="_blank"> CVE-2020-28450 </a>、<a class="ae mh" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-28460" rel="noopener ugc nofollow" target="_blank">CVE-2020–28460</a>以及<a class="ae mh" href="https://github.com/jonschlinkert/merge-deep" rel="noopener ugc nofollow" target="_blank"> merge-deep </a>包中的一个漏洞。我通过Snyk 报告了这两个漏洞。有了第一个，一切都很顺利，但是有了第二个，一个搞笑的情况就出来了。发送报告后，维护者很长时间没有取得联系，结果GitHub安全实验室发现了同样的漏洞，设法更早地联系到维护者并进行注册(<a class="ae mh" href="https://securitylab.github.com/advisories/GHSL-2020-160-merge-deep" rel="noopener ugc nofollow" target="_blank">GHSL-2020–160</a>)。</p><p id="6e8e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一般来说，即使现在对find-vuln.js 做一些小的改动，你也能发现npm包中的漏洞。</p><p id="f008" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">静态分析</strong></p><p id="4600" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用简单的grep很难发现这种类型的漏洞，但是使用<a class="ae mh" href="https://securitylab.github.com/tools/codeql" rel="noopener ugc nofollow" target="_blank"> CodeQL </a>可以非常成功地进行搜索。现有的<a class="ae mh" href="https://github.com/github/codeql/tree/main/javascript/ql/src/Security/CWE-915" rel="noopener ugc nofollow" target="_blank"> CodeQL查询</a>实际上发现了真实包中的原型污染，尽管目前并没有覆盖该漏洞的所有变体。</p><h2 id="55bd" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">影响</h2><p id="4784" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">假设我们发现了一个易受原型污染的库。这个漏洞能对系统造成多大的破坏？</p><p id="c56a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在NodeJS环境中，这几乎总是有保证的DoS，因为您可以覆盖一个基本函数(例如，<code class="fe mp mq mr ms b">Object.prototype.toString()</code>)，并且对该函数的所有调用都将返回一个异常。让我们看看流行的<a class="ae mh" href="https://github.com/expressjs/express" rel="noopener ugc nofollow" target="_blank"> expressjs/express </a>服务器的例子。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="d0ed" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">安装依赖项并启动服务器。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4e73" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在终端的另一个选项卡中，我们发送有效载荷。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b94c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如你所看到的，在发送有效载荷之后，服务器失去了处理甚至简单的GET请求的能力，因为express内部使用了<code class="fe mp mq mr ms b">Object.keys()</code>，我们成功地将它从一个函数变成了一个数字。</p><p id="2c56" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在web应用程序中，您通常可以加速远程代码执行。通常，这是通过模板引擎完成的。操作的细节可以在下面的文章中找到。</p><ul class=""><li id="ee96" class="mt mu iq jw b jx jy kb kc kf mv kj mw kn mx kr nh mz na nb bi translated"><a class="ae mh" href="https://blog.p6.is/AST-Injection/" rel="noopener ugc nofollow" target="_blank"> AST注入，原型污染RCE </a></li><li id="c8b0" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated"><a class="ae mh" href="https://blog.p6.is/Real-World-JS-1/" rel="noopener ugc nofollow" target="_blank">现实世界JS — 1 </a></li><li id="4d51" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated"><a class="ae mh" href="https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf" rel="noopener ugc nofollow" target="_blank">NodeJS应用中的原型污染攻击</a></li></ul><h1 id="2fee" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">减轻</h1><p id="2a37" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">有不同的方法来修复这个漏洞，让我们从最流行的选项开始。</p><h2 id="e073" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">现场黑名单</h2><p id="5768" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">大多数情况下，开发人员只是将<code class="fe mp mq mr ms b">__proto__</code>添加到黑名单中，并不复制该字段。即使有经验的开发人员也会这样做(例如<a class="ae mh" href="https://github.com/npm/ini/commit/56d2805e07ccd94e2ba0984ac9240ff02d44b6f1" rel="noopener ugc nofollow" target="_blank"> npm/ini案例</a>)。</p><p id="ea98" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过使用<code class="fe mp mq mr ms b">constructor.prototype</code>而不是<code class="fe mp mq mr ms b">__proto__</code>很容易绕过这个修复。</p><p id="4c5d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一方面，这种方法易于实现并且通常足以修复漏洞，另一方面，它没有消除问题，因为仍然存在改变Object.prototype和其他原型的可能性。</p><h2 id="5045" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated"><code class="fe mp mq mr ms b">Object.create(null)</code></h2><p id="a6a4" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">您可以使用没有原型的对象，然后修改原型将是不可能的。</p><p id="3166" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">缺点是这个对象会进一步破坏某些功能。例如，有人可能想在这个对象上调用<code class="fe mp mq mr ms b">toString()</code>并得到<code class="fe mp mq mr ms b">o.toString is not a function</code>的响应。</p><h2 id="2d26" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated"><code class="fe mp mq mr ms b">Object.freeze()</code></h2><p id="104e" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">另一个选项是使用<code class="fe mp mq mr ms b"><a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noopener ugc nofollow" target="_blank">Object.freeze()</a></code>功能冻结<code class="fe mp mq mr ms b">Object.prototype</code>。之后，对象。原型无法修改。</p><p id="6e85" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，有一些陷阱:</p><ul class=""><li id="860c" class="mt mu iq jw b jx jy kb kc kf mv kj mw kn mx kr nh mz na nb bi translated">修改<code class="fe mp mq mr ms b">Object.prototype</code>的依赖关系可能会中断。</li><li id="11eb" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated">一般来说，你需要冻结<code class="fe mp mq mr ms b">Array.prototype</code>和其他物体。</li></ul><h2 id="61ad" class="lv kt iq bd ku lw lx dn ky ly lz dp lc kf ma mb lg kj mc md lk kn me mf lo mg bi translated">JSON模式</h2><p id="1889" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">您可以根据预定义的<a class="ae mh" href="https://json-schema.org" rel="noopener ugc nofollow" target="_blank"> JSON模式</a>验证输入数据，并丢弃所有其他参数。例如，您可以使用带有<code class="fe mp mq mr ms b">additionalProperties = false</code>参数的<a class="ae mh" href="https://github.com/ajv-validator/ajv" rel="noopener ugc nofollow" target="_blank"> avj </a>库来实现这一点。</p><h1 id="298a" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h1><p id="faef" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">JavaScript原型污染是一个极其危险的漏洞，需要从寻找新载体的角度和寻找新工具(利用)的角度进行更多的研究。在客户端，当有效载荷保存在服务器上时，向量根本没有开发，因此有进一步研究的空间。</p><p id="ed62" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，JavaScript还有许多其他有趣的功能可以用于新的漏洞，例如<a class="ae mh" href="https://youtu.be/oGeEoaplMWA" rel="noopener ugc nofollow" target="_blank"> DEF CON安全模式——潇峰——发现隐藏属性来攻击Node js生态系统</a>。毫无疑问，JavaScript的其他微妙之处会给应用程序的安全性带来同样严重或更严重的后果。</p><h1 id="7e55" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">感谢</h1><p id="c32c" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">首先感谢<a class="ae mh" href="https://twitter.com/_holyvier_" rel="noopener ugc nofollow" target="_blank">奥利维耶</a>、<a class="ae mh" href="https://twitter.com/SecurityMB" rel="noopener ugc nofollow" target="_blank">米查兹·本特考斯基</a>、<a class="ae mh" href="https://twitter.com/Black2Fan" rel="noopener ugc nofollow" target="_blank">谢尔盖·博布罗夫</a>、<a class="ae mh" href="https://twitter.com/S1r1u5_" rel="noopener ugc nofollow" target="_blank"> s1r1us </a>、<a class="ae mh" href="https://twitter.com/po6ix" rel="noopener ugc nofollow" target="_blank"> po6ix </a>、<a class="ae mh" href="https://twitter.com/wcbowling" rel="noopener ugc nofollow" target="_blank">威廉·鲍林</a>关于原型污染话题的文章、报道和节目，分享给大家。没有他们，这项研究很难开始:)</p><p id="55d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">谢尔盖·博布罗夫和<a class="ae mh" href="https://twitter.com/0ang3el" rel="noopener ugc nofollow" target="_blank">米哈伊尔·叶戈罗夫</a>合作寻找漏洞。</p><p id="43aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">感谢<a class="ae mh" href="https://www.facebook.com/alyona.mv" rel="noopener ugc nofollow" target="_blank">阿廖娜·马南尼科娃</a>、阿纳托利·卡秋申、<a class="ae mh" href="https://habr.com/ru/users/AlexanderBarabanov/" rel="noopener ugc nofollow" target="_blank">亚历山大·巴拉巴诺夫</a>、<a class="ae mh" href="https://twitter.com/makrushind" rel="noopener ugc nofollow" target="_blank">丹尼斯·马克鲁申</a>和<a class="ae mh" href="https://twitter.com/Zherya" rel="noopener ugc nofollow" target="_blank">德米特里·热雷格里亚</a>对本文的校对、反馈和其他帮助。</p><h1 id="cc2c" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">参考</h1><ul class=""><li id="2dbe" class="mt mu iq jw b jx lq kb lr kf nv kj nw kn nx kr nh mz na nb bi translated"><a class="ae mh" href="https://github.com/BlackFan/client-side-prototype-pollution" rel="noopener ugc nofollow" target="_blank">black fan/客户端原型污染</a> / <a class="ae mh" href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution" rel="noopener ugc nofollow" target="_blank">跨站脚本(XSS)备忘单</a></li><li id="99d2" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated"><a class="ae mh" href="https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/" rel="noopener ugc nofollow" target="_blank">原型污染——绕过客户端HTML杀毒程序</a></li><li id="f355" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated"><a class="ae mh" href="https://github.com/msrkp/PPScan" rel="noopener ugc nofollow" target="_blank"> PPScan </a></li><li id="93f6" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated"><a class="ae mh" href="https://blog.p6.is/AST-Injection/" rel="noopener ugc nofollow" target="_blank"> AST注入，原型污染RCE </a></li><li id="74cb" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated"><a class="ae mh" href="https://blog.p6.is/Real-World-JS-1/" rel="noopener ugc nofollow" target="_blank">现实世界JS — 1 </a></li><li id="04b1" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated"><a class="ae mh" href="https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf" rel="noopener ugc nofollow" target="_blank">原型污染攻击在NodeJS中的应用</a></li><li id="9109" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated"><a class="ae mh" href="https://blog.s1r1us.ninja/research/PP" rel="noopener ugc nofollow" target="_blank">“一个让互联网无污染的故事”——在野外开发客户端原型污染</a></li></ul><p id="335a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">示例:</p><ul class=""><li id="66e5" class="mt mu iq jw b jx jy kb kc kf mv kj mw kn mx kr nh mz na nb bi translated"><a class="ae mh" href="https://hackerone.com/reports/986386" rel="noopener ugc nofollow" target="_blank">通过Wistia嵌入式代码在www.hackerone.com上反射XSS</a></li><li id="135c" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated"><a class="ae mh" href="https://bugcrowd.com/disclosures/57b28008-4653-4dec-88c3-4d38e40023ff/toolbox-teslamotors-com-html-injection-via-prototype-pollution-potential-xss" rel="noopener ugc nofollow" target="_blank">【toolbox.teslamotors.com】HTML通过原型注入污染/潜在XSS </a></li><li id="bf6a" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated"><a class="ae mh" href="https://mksben.l0.cm/2020/10/discord-desktop-rce.html" rel="noopener ugc nofollow" target="_blank">不和谐桌面app RCE </a></li></ul><p id="1469" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">示例(节点):</p><ul class=""><li id="e708" class="mt mu iq jw b jx jy kb kc kf mv kj mw kn mx kr nh mz na nb bi translated"><a class="ae mh" href="https://hackerone.com/reports/852613" rel="noopener ugc nofollow" target="_blank">通过最新的Kibana 7.6.2在云上远程执行代码</a></li><li id="702c" class="mt mu iq jw b jx nc kb nd kf ne kj nf kn ng kr nh mz na nb bi translated"><a class="ae mh" href="https://hackerone.com/reports/861744" rel="noopener ugc nofollow" target="_blank">即将推出的Kibana 7.7.0中的远程代码执行</a></li></ul><p id="a6bc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">杂项:</p><ul class=""><li id="0307" class="mt mu iq jw b jx jy kb kc kf mv kj mw kn mx kr nh mz na nb bi translated"><a class="ae mh" href="https://youtu.be/oGeEoaplMWA" rel="noopener ugc nofollow" target="_blank"> DEF CON安全模式——潇峰——发现隐藏属性攻击节点js生态系统</a></li></ul></div></div>    
</body>
</html>