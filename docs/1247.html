<html>
<head>
<title>EXPLOITING FORMAT STRING VULNERABILITY</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用格式字符串漏洞</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/exploiting-format-string-vulnerability-97e3d588da1b?source=collection_archive---------0-----------------------#2021-04-18">https://infosecwriteups.com/exploiting-format-string-vulnerability-97e3d588da1b?source=collection_archive---------0-----------------------#2021-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e9a59e073e9bbab5a79c81bb3ee4c678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WYYDAw9E3OXYxC8solmGXw.png"/></div></div></figure><h1 id="07da" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是格式字符串漏洞？</h1><p id="2f06" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当输入字符串数据由易受攻击的函数处理时，就会发生格式字符串攻击，因此攻击者可以借助格式字符串函数/printf()系列函数传递格式以利用堆栈值</p><p id="1e0c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通过格式字符串漏洞，攻击者可以执行代码、读取堆栈值或在应用程序中导致分段错误</p><h1 id="1567" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">PRINTF()系列中的常见格式</h1><ol class=""><li id="f862" class="lz ma iq ky b kz la ld le lh mb ll mc lp md lt me mf mg mh bi translated">%c —格式化单个字符</li><li id="3f6a" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">% d-将整数格式化为十进制值</li><li id="d43e" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">% f-格式以十进制值浮动</li><li id="0943" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">%p —格式化指向地址位置的指针</li><li id="11e0" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">%s —格式化字符串</li><li id="ca4d" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">%x —格式化十六进制值</li><li id="0bbf" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">%n —写入的字节数</li></ol><h1 id="b250" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">格式化SRING的易受攻击的函数</h1><ol class=""><li id="29ac" class="lz ma iq ky b kz la ld le lh mb ll mc lp md lt me mf mg mh bi translated">printf()</li><li id="2356" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">fprintf()</li><li id="8b6b" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">sprintf()</li><li id="b808" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">vprintf()</li><li id="a4d7" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">snprintf()</li><li id="cf96" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">vsnprintf()</li><li id="bdf7" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">vfprintf()</li><li id="ad90" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">vfprintf()</li></ol><h1 id="9e5e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">为什么会出现格式字符串漏洞</h1><p id="dd5f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当我们传递带有格式字符串的输入时，printf()调用它来显示输出</p><p id="cf25" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，如果输入具有与格式相关的有效数据，它将被正确打印</p><p id="408a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果数据具有与printf()无关的格式值，就可能被利用</p><p id="39c9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">示例:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="c860" class="mw jz iq ms b gy mx my l mz na">1. If printf(data) is used, I can pass "junkdata %d %p %lp %x" to exploit the function<br/>           <br/>2. If printf("%s %p %p",data), here data gets filled by %s and the remaining formats can get exploited into stack</span></pre><p id="acc9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当格式字符串没有相应的变量来调用数据时，它将开始从堆栈中弹出随机值，而不管它们的位置/地址</p><h1 id="c64c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">剥削</h1><h1 id="dcab" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">示例1</h1><p id="7fd0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们考虑一个简单的程序来测试这个漏洞</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/e9ab84374706b97f024621ef352b8af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JY-EbKgKY7I1UM1H.png"/></div></div></figure><p id="ba4e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">用GCC编译这个二进制文件(没有标志)</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/68b331052e27756730b29d79c74f628a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mMqwN3xUXUxiuEQD.png"/></div></div></figure><p id="bbcb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当我们传递一个普通的字符串数据时，它成功地打印出来</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/c83ffed5e11bdd0cdcee16c60c20dc65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RhKliXxw6p6XVhgH.png"/></div></div></figure><p id="5eb9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果我们越过缓冲区，它就会崩溃</p><p id="9dda" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是如果我们传递带格式值的字符串，它会给我们随机的堆栈值</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/9213267b432562f05266fb6f407aae08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fot1EGyfxsaBr9qa.png"/></div></div></figure><p id="82e2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们传递“%p”来获取指针格式的地址值</p><p id="4660" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们在格式值前面传递一些数据</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/915b258d217a797b54c7df2ed28e7fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2JyRSUfu04mKA1Jg.png"/></div></div></figure><p id="d240" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们可以从第6个位置的堆栈值中看到我们的输入</p><p id="7e61" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">像这样传递字符串输入可以帮助我们定位数据的位置，从而有助于利用数据</p><p id="faf3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在我们已经追踪到了我们的输入在堆栈中存储的位置</p><p id="7d35" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当我们从它没有的地址调用不同的格式时，应用程序有可能崩溃</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/7d7fb3b877cdc0536fe9970a1b58d430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QZLNCowj-SKe6YdL.png"/></div></div></figure><p id="c05b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们已经通过AAAABBBB传递了我们的输入</p><p id="10ce" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">答— -&gt; 0x41</p><p id="ccc1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">b—--&gt; 0x 42</p><p id="6212" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">由于我们运行在64位，我们可以在每个地址存储多达8个字节</p><p id="2b6b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们已经找到了存储输入的位置&amp;我们把它看作堆栈中的指针地址</p><p id="8ee7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当我们试图用“%s”格式调用该位置时，“分段错误”发生了</p><p id="096d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因为地址0x42424242414141中没有任何字符串，或者超出了应用程序的内存范围</p><p id="9bfa" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">所以错误发生时，请确定您试图调用的格式的地址和类型</p><p id="3f0f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您要调用的地址中应该有一个值，它可以支持您需要的格式类型</p><h1 id="3bdb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">示例2</h1><p id="68aa" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们尝试获取一些应用程序中没有使用的数据</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/fdf139456dce7812afebd9d1a4cd065a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jAae-Vn8xUZDMTyR.png"/></div></div></figure><p id="a724" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里我们使用一个全局变量“data ”,其中包含一些字符串</p><p id="1b0b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们打印了变量的地址</p><p id="c7ae" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们用32位的GCC编译程序</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/d252c9ef8ce5e19374059e8e0b71abda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*geJyO_9N8Fw7LCJB.png"/></div></div></figure><p id="9269" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通过用输入测试该应用程序(模糊化过程)</p><p id="597e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你可以看到我们的输入从内存输出的第11个位置打印出来</p><p id="187b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您可以“直接”引用格式字符串漏洞中的位置，以便从堆栈中调用所需位置的值</p><p id="1e2f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要从第11个位置打印堆栈值，您可以使用“%11$p”来表示堆栈的第11个位置</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/6c52c935dca8d7e2fa9abe0c34e25d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aMWW930Wx-cBPGjg.png"/></div></div></figure><p id="84d0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们传递“数据”的地址作为我们的第二个输入，以便它存储在第一个输入旁边的堆栈中</p><p id="9b9c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果是“小端”,则以相反的顺序传递地址</p><h2 id="4129" class="mw jz iq bd ka nk nl dn ke nm nn dp ki lh no np km ll nq nr kq lp ns nt ku nu bi translated">注意</h2><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="ba96" class="mw jz iq ms b gy mx my l mz na">Always remember to fill with 8 bytes / 4 bytes (64bit/32bit) or else the address / expected value may get broken</span></pre><p id="aa12" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在我们的第二个数据在第12位</p><p id="05c5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们知道其中有一些字符串数据，但不知道是什么</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/c086c5b6db298459536ef30ab8067786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sQihW2f7KBUfK2y-.png"/></div></div></figure><p id="fe43" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">所以我们传递“%s”格式从堆栈内存中读取字符串</p><p id="2f7b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通过超过第12位的“%s”</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/b1b95e5b63f9f3e7e4d8279ad6fda492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jVPfdfAYtXFbIFvx.png"/></div></div></figure><p id="1b3e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们用“%s”制作我们的有效负载</p><p id="02d1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">用“%s”传递我们的有效负载使我们以字符串形式查看第12位的数据</p><p id="e349" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们还可以通过进一步访问堆栈来利用此漏洞</p><h1 id="ddf6" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">缓解措施</h1><ol class=""><li id="64d7" class="lz ma iq ky b kz la ld le lh mb ll mc lp md lt me mf mg mh bi translated">使用对应于指定变量的格式字符串</li><li id="77e5" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">使用“%s”作为格式字符串可以将整个输入作为单个字符串</li><li id="fe00" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">使用参数调用值和函数</li><li id="0450" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">可以使用像“格式_高”这样的防御策略</li></ol><h2 id="239c" class="mw jz iq bd ka nk nl dn ke nm nn dp ki lh no np km ll nq nr kq lp ns nt ku nu bi translated">GitHub Repo中提供了漏洞利用示例</h2><h2 id="f1f0" class="mw jz iq bd ka nk nl dn ke nm nn dp ki lh no np km ll nq nr kq lp ns nt ku nu bi translated"><a class="ae nx" href="https://github.com/AidenPearce369/ExploitDev" rel="noopener ugc nofollow" target="_blank">aiden peace 369</a></h2></div></div>    
</body>
</html>