<html>
<head>
<title>NodeJS Application Pentest Tips - Improper URI Handling in Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS应用程序测试提示-在Express中不正确的URI处理</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/nodejs-application-pentest-tips-improper-uri-handling-in-express-390b3a07cb3e?source=collection_archive---------0-----------------------#2018-05-20">https://infosecwriteups.com/nodejs-application-pentest-tips-improper-uri-handling-in-express-390b3a07cb3e?source=collection_archive---------0-----------------------#2018-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8495" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Web应用程序渗透测试方法有许多共同的概念/测试。然而，每种语言和基础设施都有自己特定的漏洞类别和测试方式。表明一些:</p><ol class=""><li id="dbae" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">代码注入</li><li id="adec" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">对象反序列化</li><li id="e608" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">竞态条件</li><li id="cc4b" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">正则表达式DOS</li></ol><p id="a8e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在不久的将来，我会发表以上类别的新故事。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/33222678d2d9e4f82e05387e4631f037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eA8vLLZekLqccIul5c2o6A.jpeg"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">NodeJS</figcaption></figure><p id="c24e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谈到NodeJS，一种源自JavaScript的服务器端编程语言，渗透测试人员必须考虑一些至关重要的测试。我在谷歌上搜索了一些关于NodeJS应用程序安全性的信息，看看到底发生了什么，我得到的最多的是关于<a class="ae lp" href="https://www.google.com/search?q=nodejs+eval+vulnearbility&amp;oq=nodejs+eval+vulnearbility" rel="noopener ugc nofollow" target="_blank"> eval()函数</a>导致<a class="ae lp" href="https://www.google.com/search?q=code+injection&amp;oq=code+injection" rel="noopener ugc nofollow" target="_blank">代码注入</a>的提示，解释了漏洞和利用方式。我决定在一些故事中掩盖其他缺陷和攻击。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="3279" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">与其他Web服务器相比，Express</h1><p id="f476" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">Express与Apache等其他web服务器相比，有几个不同之处，尽管攻击概念仍然保持不变。作为一个例子，在Apache web服务器中，pentesters通常通过诸如<a class="ae lp" href="https://sourceforge.net/projects/dirb/" rel="noopener ugc nofollow" target="_blank"> dirb </a>这样的脚本进行文件/目录暴力攻击。然而，在Express中的站点，由于<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/routes" rel="noopener ugc nofollow" target="_blank">路由和控制</a>的默认行为，需要更智能的暴力，例如，在端点上执行<a class="ae lp" href="https://github.com/xmendez/wfuzz" rel="noopener ugc nofollow" target="_blank"> wfuzz </a>以达到未经授权的API访问。我将在后面的故事中讨论这个话题。</p><p id="f0c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在另一个例子中，就cookie处理而言，在Apache和PHP集成的应用程序中，完全由程序员来处理。根据默认行为和常见的替换代码样式，客户端可以更改cookie的值。然而，在Express应用程序中，cookie模块使cookie防篡改。</p><pre class="la lb lc ld gt na nb nc nd aw ne bi"><span id="391c" class="nf ly iq nb b gy ng nh l ni nj">ssl_vpn.use(session({<br/>    secret: 'h3r3 1s My s4cR3T K4y',<br/>    name: 'app.cookie',<br/>    resave: false,<br/>    saveUninitialized: true,<br/>}))</span></pre><p id="646e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客户端cookie:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nk"><img src="../Images/7864e7ea0e7001fdf3486ac31cbc5779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ll0vfHJCm8TlWqAzlS1g5w.png"/></div></div></figure></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="88a6" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">一个缺陷—身份验证和会话处理</h1><p id="0c4c" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated"><a class="ae lp" href="https://www.owasp.org/index.php/Top_10-2017_A2-Broken_Authentication" rel="noopener ugc nofollow" target="_blank">破解认证</a>类别的漏洞因情况而异。它们没有像SQL注入那样的常规模式。我想指出一个我在NodeJS语言的断认证中看到的案例。最近，我谷歌了一个使用session的小应用程序，看看程序员是如何处理授权的，我得到了<a class="ae lp" href="https://gist.github.com/smebberson/1581536" rel="noopener ugc nofollow" target="_blank">这个代码</a>。正如在代码中看到的，有一个中间件函数处理授权:</p><pre class="la lb lc ld gt na nb nc nd aw ne bi"><span id="5c2d" class="nf ly iq nb b gy ng nh l ni nj">function checkAuth (req, res, next) {<br/> console.log('checkAuth ' + req.url);</span><span id="507e" class="nf ly iq nb b gy nl nh l ni nj">// don't serve /secure to those not logged in<br/> // you should add to this list, for each and every secure url<br/> if (req.url === '/secure' &amp;&amp; (!req.session || !req.session.authenticated)) {<br/>  res.render('unauthorised', { status: 403 });<br/>  return;<br/> }</span><span id="fd33" class="nf ly iq nb b gy nl nh l ni nj">next();<br/>}</span></pre><p id="7360" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序有一个名为<code class="fe nm nn no nb b">secure</code>的端点，需要验证会话才能看到。这是一个阻止未授权用户访问的挑战，程序员解决了这个问题。<code class="fe nm nn no nb b">/secure?bypass</code>的漏洞很明显，很容易被砖头认证。攻击媒介:</p><pre class="la lb lc ld gt na nb nc nd aw ne bi"><span id="4a56" class="nf ly iq nb b gy ng nh l ni nj">curl <a class="ae lp" href="http://localhost:8999/secure?bypass" rel="noopener ugc nofollow" target="_blank">http://localhost:8999/secure?bypass</a></span></pre><p id="4c29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其他攻击和缺陷可能正在发生，我不会在这个故事中涵盖更多的例子。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="2b1c" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">这种情况下的缓解</h1><p id="099c" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">程序员一直试图用一种非常简单的方式来处理认证问题，以节省性能，但他失去了安全性的权衡。有几种方法可以解决这个问题，我的解决方案是编写一个回调函数来检查会话，在需要身份验证的部分的开始调用它(也可以使用中间位置)。</p><pre class="la lb lc ld gt na nb nc nd aw ne bi"><span id="4721" class="nf ly iq nb b gy ng nh l ni nj">function check_auth(req, res, callback) {<br/>    if (!req.session || !req.session.authenticated) {<br/>        res.redirect('/login');<br/>        return;<br/>    }<br/>    callback(req, res)<br/>}</span></pre><p id="1acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用法:</p><pre class="la lb lc ld gt na nb nc nd aw ne bi"><span id="f320" class="nf ly iq nb b gy ng nh l ni nj">app.get('/', function (req, res) {<br/>    redirect_if_auth(req, res, function (req, res) {<br/>        res.render('index', {Vars});<br/>    })<br/>})</span></pre></div></div>    
</body>
</html>