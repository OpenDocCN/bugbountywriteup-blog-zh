<html>
<head>
<title>How to understand and develop a Nmap of your Own — Part 1 — CyberForged</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何理解和开发自己的Nmap第1部分——网络锻造</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/how-to-understand-and-develop-a-nmap-of-your-own-part-1-cyberforged-ee92dd4bb901?source=collection_archive---------2-----------------------#2021-02-08">https://infosecwriteups.com/how-to-understand-and-develop-a-nmap-of-your-own-part-1-cyberforged-ee92dd4bb901?source=collection_archive---------2-----------------------#2021-02-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d185d8d0e8046259527fd9aa90278cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMWSnqXLKnhSgQwHWbtpJQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">让我们开发Nmap吧！</figcaption></figure><p id="1bb0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如我们在上一集所看到的，Nmap是识别服务器上开放的服务的一把瑞士军刀。</p><p id="b752" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这一系列文章中，我们不打算谈论同样的事情，但我们将看到Nmap最实用和技术性的部分:我们将看到它是如何工作的，以及我们如何用Java(一种通用的跨平台语言)开发它的操作。通过这种方式，我们将能够在将它与其他应用程序集成时复制它的行为，并且我们将能够清楚简明地理解它的行为和流程。</p><p id="4019" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将把我们自己的Nmap的开发分为4个阶段:这篇文章本身就是一个意图声明，因为我们将为我们接下来要做的事情打下基础。在第二部分中，我们将只编写其功能的一小部分(最基本的，TCP端口检测)，然后我们将开发一个扩展来覆盖更多类型的服务(UDP)，在最后一部分中，我们将研究如何使用该工具运行自动化脚本。</p><p id="9e4e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">需要注意的是，我们将使用Kali作为我们的操作系统，它默认安装了nmap。如果您不使用Kali，您可以通过在终端中运行这些行来安装Nmap(您需要root权限)</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="4b83" class="lj lk iq lf b gy ll lm l ln lo">//Update the list of packages available <br/>sudo apt-get update </span><span id="4360" class="lj lk iq lf b gy lp lm l ln lo">//Install nmap <br/>sudo apt-get install nmap </span><span id="5a22" class="lj lk iq lf b gy lp lm l ln lo">//Verify the installation <br/>nmap --version</span></pre><p id="ff60" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们去吧！</p><h1 id="5088" class="lq lk iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Nmap在现实中是什么样子的？</h1><p id="9282" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">我认为，在我们进入如何开发我们自己的Nmap以及它如何工作之前，我们应该看看Nmap在现实中是什么样子的。</p><p id="b529" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要运行Nmap(如果不使用Kali就安装一次)，我们所要做的就是使用它的名称，在这种情况下，我们可以看到我们安装了哪个版本:</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/cc7e98bd76f7d10bc853585a82de5d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Wabs3MoeQ2x-yCZB.png"/></div></div></figure><p id="b00c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了测试我们运行它后会得到什么样的结果，我们可以使用Nmap组织提供的URL:scanme.nmap.org</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/ea4492f457a78816a2299282398bc68a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/0*0z2Kuzs0qegLfpYd.png"/></div></figure><p id="818e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里值得注意的是，我们使用了两个标志:</p><ul class=""><li id="ed6b" class="mu mv iq ke b kf kg kj kk kn mw kr mx kv my kz mz na nb nc bi translated">-sC:它运行默认脚本，以便对服务器上公开的服务执行完整的检测。</li><li id="3b1f" class="mu mv iq ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">-sS:使用一种特定类型的扫描，称为TCP连接，这是最简单的一种。</li></ul><p id="13b2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们看到scanme.nmap.org的端口22、80、9929和31337是开放的。这些端口对应于SSH、Web服务器、Nping和Elite服务，它们在服务器上处于活动状态并进行监听。</p><h1 id="c594" class="lq lk iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">发现开放端口</h1><p id="a02e" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">既然我们已经看到了Nmap在现实中的样子，我们必须开始理解它是如何发挥其魔力的。首先，我们必须列出我们感兴趣的特性:</p><ul class=""><li id="8b5a" class="mu mv iq ke b kf kg kj kk kn mw kr mx kv my kz mz na nb nc bi translated">服务器上开放端口的列表</li><li id="0f03" class="mu mv iq ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">检测这些端口上的服务(识别)</li><li id="8238" class="mu mv iq ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">运行自动化安全脚本</li></ul><p id="89ff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于第一个任务，有很多技巧。事实上，在网上<a class="ae ni" href="http://phrack.org/issues/51/11.html#article" rel="noopener ugc nofollow" target="_blank">http://phrack.org/issues/51/11.html#article</a>我们可以看到Nmap使用的技术。其中，主要的有:</p><ul class=""><li id="6203" class="mu mv iq ke b kf kg kj kk kn mw kr mx kv my kz mz na nb nc bi translated">TCP connect()扫描:这是所有扫描中最简单的。它只是尝试使用TCP三次握手连接到一个端口，如果连接成功，就意味着该端口是开放的。这就是我们将在这一系列文章中使用的。</li><li id="5c99" class="mu mv iq ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">TCP SYN扫描:也叫“半开”。TCP握手的第一部分被使用(发送一个SYN包),如果端口应答，这意味着端口是开放的。</li><li id="521d" class="mu mv iq ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">TCP FIN扫描:有时防火墙会阻止SYN数据包，因此无法通过之前的扫描进行检测。TCP FIN扫描发送一个FIN数据包，如果端口实际上是打开的，则等待RST数据包。</li><li id="d54d" class="mu mv iq ke b kf nd kj ne kn nf kr ng kv nh kz mz na nb nc bi translated">UDP ICMP端口不可达扫描:在这种情况下，我们可以使用这种类型的扫描来检测UDP上的开放端口，而不是TCP。这种扫描利用了这样一个事实，即如果UDP端口被关闭，当UDP数据包被发送到它时，它将“正常地”用ICMP_PORT_UNREACH数据包作出响应。在这种情况下，我们将检测关闭的端口，因此，我们将知道哪些是开放的。</li></ul><p id="38e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还有更多类型的扫描，但这些是我们目前最感兴趣的。</p><p id="48b4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于第二项任务，即检测那些开放端口上的服务，我们必须做一些实地工作，看看通过这些端口侦听的每个程序回答什么类型的数据。当我们开始开发这个部分时，我们将不得不构建一个服务和它们对探测包的相应回复的字典，以便自动识别它们。</p><p id="ffc8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于最后一个，自动化脚本的执行，我们将利用bash脚本，并且从我们闪亮的新Nmap中，我们将运行它们以便自动化测试，例如检测那些端口上暴露的服务中的漏洞。</p><p id="4fac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">准备好了吗？在下一篇文章中，我们将设计第一个任务，并开始编码我们全新的Nmap！</p><p id="6fd3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你现在有什么意见吗？留在评论框吧！</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="c3e8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="nq">原载于2021年2月8日</em><a class="ae ni" href="https://cyberforged.com/how-to-understand-develop-nmap-part-1/" rel="noopener ugc nofollow" target="_blank"><em class="nq">【https://cyberforged.com】</em></a><em class="nq">。</em></p></div></div>    
</body>
</html>