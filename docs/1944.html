<html>
<head>
<title>Return-Oriented Programming on RISC-V — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RISC-V上面向返回的程序设计——第一部分</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/return-oriented-programming-on-risc-v-part-1-dd9817b52d2b?source=collection_archive---------1-----------------------#2022-03-14">https://infosecwriteups.com/return-oriented-programming-on-risc-v-part-1-dd9817b52d2b?source=collection_archive---------1-----------------------#2022-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8c8a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理论视角</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/be00af455120e86ee10f7b717d2ce24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BU9tlYBRU5kNdmWx"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">杰里米·贝赞格在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="09a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如今，将计算任务从CPU卸载到硬件专用单元是一种普遍趋势，与通用处理器相比，硬件专用单元在执行时间和性能功耗比方面提供了更好的性能。这种方法包括在硅片上设计新的硬件组件，在人工智能推理、图形加速等任务中胜过CPU。这些专用组件与通用处理器放在同一个芯片上，这样就产生了片上系统(SoC)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/63d4b73cc16b9dd7a71706582e264997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*2ldBoM6HJstBAg-pLtGBjg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">SoC —高级概述</figcaption></figure><p id="d89b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在最重要的芯片生产商中观察到这种趋势，如<a class="ae kv" href="https://www.xilinx.com/products/silicon-devices/soc.html" rel="noopener ugc nofollow" target="_blank"> Xilinx </a>、<a class="ae kv" href="https://www.intel.com/content/www/us/en/support/articles/000056878/intel-nuc/intel-nuc-laptop-kits.html" rel="noopener ugc nofollow" target="_blank">英特尔</a>、<a class="ae kv" href="https://www.nvidia.com/en-us/autonomous-machines/embedded-systems/" rel="noopener ugc nofollow" target="_blank">英伟达</a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/Apple_M1" rel="noopener ugc nofollow" target="_blank">苹果</a>。</p><p id="cad7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">纵观SoC世界，我认为ARM是用于在SoC内部实现CPU的最广泛的CPU架构。</p><p id="d0b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">跳过ARM(一种基于许可的架构)的优缺点，我的注意力被RISC-V(一种新的有前途的开源CPU架构)吸引住了，它最初是由伯克利大学开发的。</p><p id="5fb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将把对RISC-V的深入分析留给另一篇文章，现在我将把重点放在我对它的安全担忧上。</p><p id="bf93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上一个时期，有几个针对CPU架构的漏洞。也许呼声最高的是《幽灵党》和《毁灭》<a class="ae kv" href="https://meltdownattack.com/meltdown.pdf" rel="noopener ugc nofollow" target="_blank">和《毁灭》</a>,紧随其后的还有更多。这些类型的攻击利用现代处理器上的侧通道，不需要任何软件漏洞，并且独立于操作系统，揭示了在考虑安全性的情况下设计的指令集架构(ISA)的重要性。</p><p id="c888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我看到了像RISC-V这样的开源CPU架构的许多优势，它允许包括安全研究人员和公司在内的许多贡献者进行快速更新。</p><h1 id="7f54" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">为什么我选择了面向回报的编程</h1><p id="080b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">大学毕业后，我决定在一个硕士项目中学习网络安全。有许多有趣的话题，其中包括面向返回的编程(ROP ),这是一个非常聪明的利用，被证明在许多CPU架构上是有效的，包括x86–64、ARM和SPARC。软件中实现了针对ROP的保护机制，包括地址空间布局随机化(ASLR)和堆栈加那利。</p><p id="1a3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我研究这个漏洞的时候，我没有发现任何关于RISC-V上ROP的东西，所以我决定解决这个问题，这个问题在我的论文中已经结束了。</p><p id="e922" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将介绍如何使用ROP开发RISC-V CPU。</p><h1 id="1b3b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">ROP简介</h1><p id="da0c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">面向返回的编程是一种代码重用技术，它允许攻击者绕过所有现代CPU架构和操作系统提供的<a class="ae kv" href="https://en.wikipedia.org/wiki/W%5EX" rel="noopener ugc nofollow" target="_blank">写异或执行</a>保护机制。</p><p id="2788" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ROP源自<a class="ae kv" href="https://seclists.org/bugtraq/1997/Aug/63" rel="noopener ugc nofollow" target="_blank">回入libc </a>攻击。</p><p id="0e9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与return-into-libc类似，ROP不会在受害者的内存空间中注入新代码。相反，它使用来自被利用的应用程序加载的模块的代码。另一方面，ROP不像return-into-libc那样使用库中的整个函数。它依赖于有效指令的短序列，称为<em class="mq">小工具</em>。</p><p id="6281" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个小工具都执行简短的计算，如加法或逻辑运算。获得强大ROP攻击的关键是将执行某项任务所需的所有小工具链接在一起。通过使用这种方法，ROP获得了比return into-libc更大的灵活性。而且，有可能获得一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Turing_completeness" rel="noopener ugc nofollow" target="_blank">图灵全集</a>的小工具。</p><p id="af3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得攻击者拥有与编程语言相同的工具，一切都基于应用程序内存空间中已经存在的合法代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/6c5913ecc864e583714e31f7bcdb0cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*geVf_r1dXTQEinvb2vkc8g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">ROP攻击的演变</figcaption></figure><h1 id="55ee" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">ROP配方</h1><p id="4f92" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">成功的ROP攻击需要以下要素:</p><ul class=""><li id="ea5a" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">缓冲区溢出易受攻击的应用程序</li><li id="7b8f" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">可靠的小工具链接机制</li><li id="6807" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">一大套小工具</li></ul><h1 id="c7af" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">缓冲区溢出易受攻击的应用程序</h1><p id="8fdc" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们需要一个易受缓冲区溢出攻击的应用程序来覆盖良性函数的返回地址。通过这种方式，我们可以改变小工具的执行流程。</p><h1 id="f78a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">可靠的小工具链接机制</h1><p id="6088" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一切都是关于分支和跳跃。我们想执行一些指令，跳转到另一个有用的指令序列(gadget)。小工具之间的链接必须是自动化的，由CPU实现，因为我们不控制内存中的代码，我们只控制堆栈。</p><h1 id="d7ec" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">一大套小工具</h1><p id="c75c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们希望尽可能强大。通过明智地选择小工具的结构和链接机制，我们可以从最流行的库中获得大量可用的小工具，这给了我们与编程语言相同的能力。</p><h1 id="b8b8" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">ROP概述</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/eafb8c31729826a2487c362460169cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlpUd8v1yHN644XTQnEGfQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">ROP概述</figcaption></figure><p id="8b3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj nk b">benign_function()</code>易受缓冲区溢出的攻击。通过提供一个精心制作的有效载荷，攻击者可以用第一个小工具G1的地址替换原来的返回地址。</p><p id="ed4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有效载荷通常包含两种类型的数据:</p><ul class=""><li id="7d63" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">执行恶意任务所需的所有小工具的地址</li><li id="f070" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">小工具需要加载到寄存器中的值</li></ul><p id="8d72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在代码执行被重定向到libc之后，G1被执行，然后是G2和G3。请注意，libc中没有恶意代码。G1、G2和G3本身没有恶意，但是指令的执行顺序(指令3 →指令8)和这些指令使用的值(来自堆栈，由攻击者控制)会导致恶意行为。</p><h1 id="0ea3" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">基本ROP示例</h1><p id="040a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在让我们来看看x86–64上的一个基本ROP攻击。我们从这个架构开始，因为它提供了一个简单易懂的例子。我将使用一个32位CPU的例子，但是它对64位CPU的工作方式是一样的。正如您将看到的，小工具链接机制是特定于每个CPU架构的，因为它依赖于执行堆栈操作的指令。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/573489ee3f0562dd87e005df77839ed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*SDr6ne_w23ju7riKbYkeaQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">x86–64上的ROP</figcaption></figure><p id="7a3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子摘自Shacham的《骨骼上无辜肉体的几何形状:不带函数调用的return-into-libc(在x86上)》。当<em class="mq">良性函数()</em>被调用时，返回地址保存在堆栈上，并且<em class="mq"> esp </em>寄存器指向该堆栈位置。如果攻击者覆盖了返回地址和随后的位置，程序执行将转移到<code class="fe nh ni nj nk b"><em class="mq">pop %edx</em></code> gadget。</p><p id="2e9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它是这样工作的:</p><ol class=""><li id="cbdc" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr nm my mz na bi translated">当<code class="fe nh ni nj nk b"><em class="mq">benign_function()</em></code>返回时，调用<code class="fe nh ni nj nk b"><em class="mq">ret</em></code>指令，执行跳转到<code class="fe nh ni nj nk b"><em class="mq">esp</em></code>指向的地址，在我们的例子中是<code class="fe nh ni nj nk b"><em class="mq">pop %edx</em></code>的地址，并且<code class="fe nh ni nj nk b"><em class="mq">esp</em></code>的值增加32位(上图中的点1)</li><li id="50dd" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr nm my mz na bi translated">现在<code class="fe nh ni nj nk b"><em class="mq">esp</em></code>指向<code class="fe nh ni nj nk b"><em class="mq">0xdeadbeef</em></code>位置。<code class="fe nh ni nj nk b"><em class="mq">pop %edx</em></code>用<code class="fe nh ni nj nk b"><em class="mq">esp</em></code>指向的值(0xdeadbeef -上图中的点2)加载<code class="fe nh ni nj nk b"><em class="mq">edx</em></code>寄存器，并将<code class="fe nh ni nj nk b"><em class="mq">esp</em></code>递增32位</li><li id="915b" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr nm my mz na bi translated">现在<code class="fe nh ni nj nk b"><em class="mq">esp</em></code>指向下一个小工具的地址**(上图中的点3)。<code class="fe nh ni nj nk b"><em class="mq">pop %edx</em></code>之后的<code class="fe nh ni nj nk b"><em class="mq">ret</em></code>使程序执行跳转到另一个小工具，即<code class="fe nh ni nj nk b"><em class="mq">esp</em></code>指向的新值，并将<code class="fe nh ni nj nk b"><em class="mq">esp</em></code>值递增32位</li></ol><p id="01f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种方式，这些小工具在x86–64 CPU架构上被链接在一起，从而导致非常强大的攻击。</p><h1 id="2382" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">RISC-V上的ROP</h1><h1 id="ce3f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">指令组</h1><p id="c93f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">RISC-V是基于加载存储原理的RISC(精简指令集计算机)。这意味着唯一可以访问片外存储器的指令是加载和存储指令。所有指令都有固定的宽度，必须自然对齐。此外，RISC-V不像x86–64或ARM那样有堆栈操作指令。正如我们之前看到的，x86–64有POP和RET指令，它们更新堆栈指针的值，以指向堆栈上的下一个值。另一方面，RISC-V使用一系列的<code class="fe nh ni nj nk b"><em class="mq">lw</em></code>(加载字)和<code class="fe nh ni nj nk b"><em class="mq">addi</em></code>(立即添加)指令从堆栈加载一个值，并更新堆栈指针。另外，RISC-V没有专门的返回指令。<code class="fe nh ni nj nk b"><em class="mq">ret</em></code>是一条伪指令，扩展为<code class="fe nh ni nj nk b"><em class="mq">jalr zero, 0(ra)</em></code> <em class="mq">、</em>，将程序计数器设置为<code class="fe nh ni nj nk b"><em class="mq">ra + 0</em></code>，并将之前程序计数器的值加4保存到寄存器<code class="fe nh ni nj nk b"><em class="mq">zero</em></code>、，寄存器<code class="fe nh ni nj nk b"><em class="mq">zero</em></code>、硬连线为零。这意味着在返回之前，返回值必须从堆栈复制到<code class="fe nh ni nj nk b"><em class="mq">ra</em></code>中。</p><h1 id="1aa2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">寄存器和调用约定</h1><p id="099d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">RV32I(基本整数指令集，32位)有32个通用寄存器。登记册组织的一些重要方面是:</p><ul class=""><li id="10ba" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated"><code class="fe nh ni nj nk b">x0/zero</code>硬连线为零</li><li id="9d35" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><code class="fe nh ni nj nk b">x1/ra</code>保存函数的返回地址</li><li id="77a3" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><code class="fe nh ni nj nk b">x2/sp</code>保存堆栈指针</li><li id="8383" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><code class="fe nh ni nj nk b">x10-x17/a0-a7</code>保存函数的参数</li><li id="d912" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><code class="fe nh ni nj nk b">x8-9, x18-27/s0-s11</code>(保存的寄存器)跨函数调用保存它们的值；任何使用保存的寄存器的函数都必须在返回之前恢复其原始值</li></ul><h1 id="e2ed" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">分步解决</h1><p id="0bb9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如您所见，在x86–64上，ROP攻击非常简单。您可以使用弹出指令从堆栈中检索值，并且可以使用<code class="fe nh ni nj nk b">RET</code>跳转到下一个小工具。所有这些都没有考虑堆栈指针更新。在RISC-V上，任务更复杂。我们必须使用load指令+一个内存地址来检索数据(从堆栈或内存中)。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="3428" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要获得强大的ROP攻击，您需要一个可靠的小工具链接方法。对于x86–64，这个目标是通过<code class="fe nh ni nj nk b">RET</code>指令来实现的，该指令使用下一个小工具的地址更新程序计数器寄存器，并进一步移动堆栈指针。考虑到这一点，人们可以将任何函数尾声作为一个小工具使用。这种方法也可以用在RISC-V上，但是它有一些缺点。</p><pre class="kg kh ki kj gt nu nk nv nw aw nx bi"><span id="0cab" class="ny lu iq nk b gy nz oa l ob oc">sw    a5, 1518 (a4)<br/>ld    ra, 8(sp)<br/>addi  sp, sp,16<br/>ret</span></pre><p id="9c03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们有一个在内存中存储值的小工具。第一行存储该值，第二行用堆栈中的返回地址加载<code class="fe nh ni nj nk b"><em class="mq">ra</em></code>寄存器，第三行更新堆栈指针并执行<code class="fe nh ni nj nk b"><em class="mq">ret</em></code>。很简单，但是我们来看另一个例子。</p><pre class="kg kh ki kj gt nu nk nv nw aw nx bi"><span id="b1e3" class="ny lu iq nk b gy nz oa l ob oc">li    a0, 0<br/>ld    ra, 40(sp)<br/>ld    s0, 32(sp)<br/>ld    s1, 24(sp)<br/>ld    s2, 16(sp)<br/>ld    s3, 8(sp)<br/>addi  sp, sp, 48<br/>ret</span></pre><p id="03e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，<code class="fe nh ni nj nk b"><em class="mq">a0</em></code>被加载零，<code class="fe nh ni nj nk b"><em class="mq">ra</em></code>被加载返回地址，<code class="fe nh ni nj nk b">s0 → s3</code>被加载它们来自堆栈的先前值，因为调用约定规定保存的寄存器必须在函数调用中保留它们的值。如果使用这个小工具，攻击者必须在堆栈上提供伪值，以加载到保存的寄存器中，这意味着更大的有效负载。这种类型的函数后记在<em class="mq"> libc中很常见。</em></p><p id="5584" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我想出了另一个主意。我观察到在<em class="mq"> libc中有很多<em class="mq">跳转到保存的寄存器</em>指令的序列。</em>所以，我把小工具分为两类:功能小工具和链接小工具。</p><h1 id="96a1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">功能小工具</h1><p id="de30" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">功能小工具是那些执行对攻击有用的操作并在<code class="fe nh ni nj nk b"><em class="mq">jalr s0→s11</em></code> <em class="mq">结束的小工具。</em>因此，与下一个小工具的链接由保存的寄存器完成。</p><p id="7982" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是一些功能小工具的例子。</p><pre class="kg kh ki kj gt nu nk nv nw aw nx bi"><span id="67b8" class="ny lu iq nk b gy nz oa l ob oc">// Load from memory to register<br/>ld    a0, 0(s0)<br/>jalr  s1</span><span id="722f" class="ny lu iq nk b gy od oa l ob oc">// Load a constant to a register<br/>li    a2, 0<br/>jalr  s3</span><span id="afd8" class="ny lu iq nk b gy od oa l ob oc">// Calling the execve system call<br/>li    a7, 221<br/>ecall</span></pre><h1 id="97c2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">链接小工具(充电器)</h1><p id="247a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这是一个特殊的小工具，用于将所有其他小工具链接在一起。它是第一个执行的小工具，通常在攻击开始时调用。它用将要在攻击中使用的所有功能小工具的地址加载保存的寄存器，从这里开始是<em class="mq">充电器</em>名称。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/dceb35c559b05c4dd534250562e0ac5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*M1eUNBs4ZLJsceAuR8E7bg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">充电器小工具</figcaption></figure><p id="a38c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上图中，我们有一个充电器小工具的例子。</p><ul class=""><li id="a20e" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">第一条指令(绿色)用第一个功能小工具的地址加载<code class="fe nh ni nj nk b"><em class="mq">ra</em></code>寄存器。</li><li id="78cc" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">接下来的七条指令(蓝色)用所有将在攻击中使用的功能小工具的地址加载保存的寄存器<code class="fe nh ni nj nk b"><em class="mq">s0→s6</em></code>。</li><li id="2965" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">黄色指令更新堆栈指针。</li><li id="0c2f" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">最后，orange指令执行<code class="fe nh ni nj nk b"><em class="mq">ret</em></code>，它将跳转到<code class="fe nh ni nj nk b"><em class="mq">ra</em></code>(第一个功能小工具)中加载的地址。</li></ul><h1 id="8289" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">理论攻击</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/a1f29cbf01e8c9e7ba7a9747f18cb2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5HLvMWOV0pReIgTk7skdUA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">RISC-V攻击的理论ROP</figcaption></figure><p id="e0fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们有一个在RISC-V架构上运行的理论上的面向返回的编程攻击。</p><ul class=""><li id="871f" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated"><code class="fe nh ni nj nk b"><em class="mq">benign_function()</em></code>(及以下所有位置)* *的堆栈空间被攻击者溢出，合法返回地址被充电器小工具的地址(恶意返回地址)改变。</li><li id="7289" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">在返回之前，<code class="fe nh ni nj nk b"><em class="mq">benign_function()</em></code>通过向前移动<code class="fe nh ni nj nk b"><em class="mq">sp</em></code>来释放堆栈空间(到下一个空闲位置)。</li><li id="1563" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">当<code class="fe nh ni nj nk b"><em class="mq">benign_function()</em></code>返回时，程序执行跳转到充电器小工具(<code class="fe nh ni nj nk b">ld ra, 72(sp)</code>，....)，它用第一个功能小工具的地址加载<code class="fe nh ni nj nk b"><em class="mq">ra</em></code>寄存器。之后，保存的寄存器<code class="fe nh ni nj nk b">s0 → s6</code>被加载攻击者提供的来自堆栈的值。</li><li id="2668" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">最后，充电器小工具更新<code class="fe nh ni nj nk b"><em class="mq">sp</em></code>(另一个对攻击者有用的值可以跟随在堆栈上)并执行<code class="fe nh ni nj nk b"><em class="mq">ret</em></code> <em class="mq">。</em></li><li id="a8da" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">此时，执行将跳转到第一个功能小工具，该功能小工具将使用在<code class="fe nh ni nj nk b"><em class="mq">s0</em></code> ( <code class="fe nh ni nj nk b">ld a0, 0(s0)</code>)中存储的地址找到的值加载<code class="fe nh ni nj nk b"><em class="mq">a0</em></code>，并将跳转到另一个功能小工具<code class="fe nh ni nj nk b"><em class="mq">s1</em></code> ( <code class="fe nh ni nj nk b">jalr s1</code>)中存储的地址。</li></ul><p id="473f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RISC-V上面向返回编程的完整功能示例将在以后的文章中介绍。</p><h1 id="cfa1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">这种方法的优点和缺点</h1><p id="3b59" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这种方法的主要优点是减少了攻击中使用的有效载荷。如果使用基于函数后记的方法，攻击者必须提供伪值来加载在函数返回之前恢复的保存的寄存器。这可能导致大的有效载荷，在某些情况下可能是无效的。另一方面，我没有在libc中找到一个图灵全套小工具，它降低了攻击者的能力。</p><h1 id="9f99" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">安全问题</h1><p id="1fb9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">既然我们知道RISC-V架构可以使用面向返回的编程技术来开发，我们可以问:RISC-V是不安全的吗？不会。ROP攻击利用函数返回机制和函数调用约定，它们本身并无恶意。此外，我们需要一个易受攻击的应用程序，它允许攻击者从函数中窃取返回地址。此外，还有许多阻止ROP攻击的保护机制，我们将在下一节中看到。从这个角度来看，我认为RISC-V比封闭的CPU架构有显著的优势，因为每个处理器制造商可以选择集成哪种保护机制。</p><h1 id="d5bd" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">保护机制</h1><p id="e742" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们能做什么来防止ROP攻击？有许多解决这个问题的方法。大部分都是软硬件协同的结合。</p><ul class=""><li id="0b14" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated"><em class="mq">地址空间布局随机化</em>:这是一种软件计算机安全技术，在内存中随机化进程、堆栈、堆和库的地址。每次在执行中启动一个进程，它将被放置在内存中的一个随机地址。使用我们的攻击示例，这意味着攻击者不知道小工具(libc)的地址。点击这里了解更多关于这个<a class="ae kv" href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" rel="noopener ugc nofollow" target="_blank">的信息。</a></li><li id="a56c" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><em class="mq"> G-Free: </em>这是一个基于编译器的解决方案，消除了二进制可执行文件中所有未对齐的自由分支指令。更多细节<a class="ae kv" href="https://dl.acm.org/doi/10.1145/1920261.1920269" rel="noopener ugc nofollow" target="_blank">这里</a>。</li><li id="9d9a" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><a class="ae kv" href="https://dl.acm.org/doi/10.1145/1966913.1966920" rel="noopener ugc nofollow" target="_blank"> <em class="mq"> ROPdefender </em> </a></li><li id="6497" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><a class="ae kv" href="https://www.ieee.hr/_download/repository/Ivan_Fratric.pdf" rel="noopener ugc nofollow" target="_blank">T13】ROP guardT15】</a></li><li id="7f3e" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><a class="ae kv" href="https://www.ndss-symposium.org/ndss2014/programme/ropecker-generic-and-practical-approach-defending-against-rop-attacks/" rel="noopener ugc nofollow" target="_blank"><em class="mq"/></a></li><li id="ceff" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><em class="mq">堆栈加那利:</em>该技术用于检测堆栈缓冲区溢出，并防止跳转到ROP小工具。它的工作原理是将一个随机整数值(canary)放在堆栈上，就在返回地址之前。在执行返回指令之前检查canary值，以确保返回地址没有被修改(如果返回地址被覆盖，canary值也会被更改)。更多详情<a class="ae kv" href="https://en.wikipedia.org/wiki/Stack_buffer_overflow" rel="noopener ugc nofollow" target="_blank">此处</a>。</li><li id="7531" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><em class="mq">拉链栈</em>:这是一种新颖的技术(2019)，通过使用加密的链式结构来保护返回地址。它能够保护堆栈中的所有返回地址，并确保函数以正确的顺序返回。作者在RISC-V CPU上实现了这个解决方案，并修改了RISC-V指令集。这里强调了开源CPU架构的优势。更多细节<a class="ae kv" href="https://arxiv.org/abs/1902.00888" rel="noopener ugc nofollow" target="_blank">这里</a>。</li><li id="4d96" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><a class="ae kv" href="https://ieeexplore.ieee.org/document/8714980" rel="noopener ugc nofollow" target="_blank"> <em class="mq"> FIXER </em> </a>:另一种新技术(2019)，通过强制控制流完整性来提供针对ROP的保护机制。此外，还在RISC-V CPU上实现并测试了它。</li></ul><h1 id="fe0f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">进一步阅读</h1><p id="07a8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果你喜欢这个主题，并想深入研究，我在这里留下了进一步的阅读清单。我很快会带着一篇关于RISC-V上ROP的实践文章回来。</p><p id="5211" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有两篇独立的研究论文论述了这一主题:</p><ul class=""><li id="8ed3" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated"><a class="ae kv" href="https://dl.acm.org/doi/10.1145/3320269.3384738" rel="noopener ugc nofollow" target="_blank">RISC-V上面向返回的编程</a></li><li id="f179" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><a class="ae kv" href="https://arxiv.org/abs/2007.14995" rel="noopener ugc nofollow" target="_blank">RISC-V中面向返回的编程</a></li></ul><p id="59c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两篇论文都发表于2020年，我相信你会在那里发现有趣的东西。我独立完成了我的研究，并为ACM CCSW 2020发表了一篇摘要。</p><p id="364f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于一般ROP，我建议:</p><ul class=""><li id="06d8" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated"><a class="ae kv" href="https://insecure.org/sploits/linux.libc.return.lpr.sploit.html" rel="noopener ugc nofollow" target="_blank">返回libc </a></li><li id="6a83" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><a class="ae kv" href="https://hovav.net/ucsd/dist/geometry.pdf" rel="noopener ugc nofollow" target="_blank">骨头上无肉的几何图形:不带函数调用的Return-intolibc(在x86上)</a></li><li id="86f6" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><a class="ae kv" href="https://cseweb.ucsd.edu/~savage/papers/CCS08GoodInstructions.pdf" rel="noopener ugc nofollow" target="_blank">当好指令变坏时:将面向返回的编程推广到RISC </a></li><li id="074e" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><a class="ae kv" href="https://hovav.net/ucsd/dist/noret-ccs.pdf" rel="noopener ugc nofollow" target="_blank">无返回的面向返回的编程</a></li><li id="2cd8" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><a class="ae kv" href="https://static.googleusercontent.com/media/www.zynamics.com/en//downloads/kornau-tim--diplomarbeit--rop.pdf" rel="noopener ugc nofollow" target="_blank">面向ARM架构的返回编程</a></li><li id="f959" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated"><a class="ae kv" href="https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/carlini" rel="noopener ugc nofollow" target="_blank"> ROP依然危险:突破现代防御</a></li></ul><pre class="kg kh ki kj gt nu nk nv nw aw nx bi"><span id="7577" class="ny lu iq nk b gy nz oa l ob oc">📩 Please feel free to share this article with colleagues and friends who will find it valuable.</span></pre><p id="7d1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mq">原载于2022年2月17日https://www.bogdandeac.com</em><em class="mq"/><a class="ae kv" href="https://www.bogdandeac.com" rel="noopener ugc nofollow" target="_blank"><em class="mq">。</em></a></p></div></div>    
</body>
</html>