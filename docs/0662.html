<html>
<head>
<title>Fuzzing FastCGI With AFL-Fuzz</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用AFL-Fuzz使FastCGI起毛</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/fuzzing-fastcgi-an-odyssey-4ffc1c72a732?source=collection_archive---------0-----------------------#2020-07-01">https://infosecwriteups.com/fuzzing-fastcgi-an-odyssey-4ffc1c72a732?source=collection_archive---------0-----------------------#2020-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8245" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我和AFL-fuzzing在FastCGI的冒险故事。如果您对模糊FastCGI二进制文件感兴趣，请不要犹豫。</p><h1 id="d706" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">FastCGI是什么？</h1><p id="edd0" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">FastCGI是一个<strong class="js iu">二进制协议</strong>。在大多数情况下，用户与web服务器(如nginx或lighttpd)交互，web服务器又通过命名管道或TCP连接与FastCGI通信。FastCGI然后执行代码。</p><h1 id="6e4d" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">为什么是FastCGI？</h1><p id="7666" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我可以访问用C/C++编写的使用FastCGI的二进制文件。事实上，FastCGI几乎用于每一个嵌入式设备。最流行的版本是OpenMarket的FCGI 2.4.0，也就是<strong class="js iu"> 17岁。</strong></p><p id="4df4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也没有关于fuzzing FastCGI的文档或研究(除了这篇)。</p><h1 id="2cc3" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">FastCGI请求</h1><p id="57ba" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">根据<a class="ae ls" href="https://tools.ietf.org/html/rfc3875" rel="noopener ugc nofollow" target="_blank"> RFC 3875 </a>，FCGX_Request主要由两部分组成:</p><ul class=""><li id="622e" class="lt lu it js b jt ju jx jy kb lv kf lw kj lx kn ly lz ma mb bi translated">envp:envp充满了元变量，有些是用户控制的，有些不是。web服务器可能会也可能不会对这些元变量进行URL编码</li><li id="dc3d" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">参数:100%由用户控制且未修改</li></ul><p id="ea0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你不能只向FastCGI发送HTTP请求，它是一个二进制协议。FastCGI请求的hexdump如下所示:</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mh"><img src="../Images/a52292aa92041354fd4cca99a43b5281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kwydx2w6zg62McOjn4ysJQ.jpeg"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Top = envp。Bottom =参数</figcaption></figure><p id="8324" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的请求是在研究过程中通过复制命名管道并使用socat拦截使用以下命令的请求而捕获的:</p><blockquote class="mx my mz"><p id="258d" class="jq jr ko js b jt ju jv jw jx jy jz ka na kc kd ke nb kg kh ki nc kk kl km kn im bi translated">socat-t100-v-x UNIX-LISTEN:fcgi _ sock，mode=777，reuseaddr，fork UNIX-CONNECT:fcgi_sock2，raw</p></blockquote><h1 id="ee3f" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">问题#1:插座</h1><p id="42c5" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">FastCGI通过TCP套接字或命名管道接受输入。AFL-Fuzz通过STDIN或fuzzed进程使用的文件发送输入。</p><p id="13cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最快的方法是修改我们正在模糊化的二进制文件，将第一个参数作为一个文件，读取文件内容，并将内容发送到它的套接字端口。我们需要在FCGX_Accept_r运行之前分叉这个进程，因为它阻塞了。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nd"><img src="../Images/3cea475b0e6bc8567be22c1223f79290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uF9hbg7dKWPTfvc1pEpn3g.jpeg"/></div></div></figure><p id="7258" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这不是一个完美的实现。它速度慢，容易出故障，并且会产生很大的性能瓶颈。</p><p id="888f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">FastCGI在我们虚拟机上的执行速度是0.011秒。</p><p id="04ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们最初假设执行速度为90–100/秒。</p><p id="eb78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而在QEMU模式下，结果大约是7-20次/秒。</p><p id="0bbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您看到的崩溃是误报，是由于位翻转协议而发生的，这在正常情况下是攻击者无法控制的。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ne"><img src="../Images/45e2e63788c08d5fd13cc71de6280d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCzf6z4a7HS4Oi7B8HirFw.png"/></div></div></figure><h1 id="0823" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">问题#2:编译</h1><p id="7afe" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">QEMU模式烂透了。为什么我们还停留在QEMU模式？</p><p id="8e5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嵌入式设备上的二进制文件通常用不同于普通Ubuntu VM的运行时编译。大多数嵌入式设备使用musl而不是glibc(都实现了libc)。</p><p id="1c76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主要的区别是musl二进制文件占用更少的空间，并且考虑到了安全性。</p><p id="300a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哦，还有<strong class="js iu"> </strong> <a class="ae ls" href="https://github.com/google/sanitizers/issues/1080" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> musl不支持ASAN </strong> </a> <strong class="js iu"> </strong>这就给检测内存问题造成了障碍。</p><p id="f932" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">afl-g++和musl-g++有一些标志不兼容的问题。每个二进制文件都是不同的，所以您必须自己进行故障排除来检测您自己的二进制文件。</p><p id="1f42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们用AFL检测了我们的二进制文件，我们的性能速度是70–90/秒！比以前好多了，但离完美还差得远。</p><h1 id="daee" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">问题#3:标准输入</h1><p id="5f99" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我习惯于看到1-5K exec/second的afl-fuzz截图。以我现在的速度，要找到任何漏洞都要花很长时间。下一步很明显:<strong class="js iu">修改fcgi库以接受标准输入。</strong></p><blockquote class="mx my mz"><p id="12cd" class="jq jr ko js b jt ju jv jw jx jy jz ka na kc kd ke nb kg kh ki nc kk kl km kn im bi translated">*在此插入黑客魔法*</p></blockquote><p id="5a6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">噗！FastCGI可以通过标准输入读取请求，而不是套接字或TCP连接。这是新实施的概念证明:</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nf"><img src="../Images/12a0f7008d56814fa32272c5a3e9e21b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8TMCl2JLhBzZXD0CFLudg.png"/></div></div></figure><p id="5e26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">AFL-Fuzz的执行速度现在是每核500–1.5K exec/秒。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi ng"><img src="../Images/4175418d79bad6ada3490f99a894fa00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVJkRUKq4rKwGrjDVRKnDQ.png"/></div></div></figure><h1 id="cdce" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">决赛成绩</h1><p id="5dbe" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">AFL-Fuzz使用30个内核，在5天内运行了23亿次执行。我们有31起本地独有的车祸！</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi nh"><img src="../Images/8ecc402cd07ced03551507a40684cbac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*STZn2uVSZsmc2aZIcjvdVw.png"/></div></div></figure><p id="c332" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显示的平均执行速度是由于二进制文件尝试磁盘I/O操作，这导致了性能瓶颈。</p><p id="3bc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有瓶颈，你应该至少达到1K exec/core/second。</p><h1 id="1af0" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">FastCGI模糊保护:</h1><p id="839c" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated"><strong class="js iu">创建字典:</strong> FastCGI极其挑剔。如果你需要帮助理解协议，afl-analyze是一个很好的工具，可以给你一个直观的视图。</p><p id="1221" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">尽量减少你的语料库:</strong>语料库越小越好。通过<a class="ae ls" href="https://github.com/wuyunfeng/Python-FastCGI-Client" rel="noopener ugc nofollow" target="_blank">创建自己的请求</a>并保存到netcat，我可以将我的语料库从1200字节减少到400字节。</p><p id="9e56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用AFLSmart: </strong>我无法配置一个正常工作的桃核，但最终最重要的是使用<a class="ae ls" href="https://github.com/aflsmart/aflsmart" rel="noopener ugc nofollow" target="_blank"> AFLSmart </a>进行结构感知模糊化。</p><p id="5fa7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将让您只模糊FastCGI请求的特定部分，比如特定的元变量或主体。</p><p id="7083" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">接受标准输入:</strong>接受标准输入是游戏规则的改变者，也是模糊FastCGI二进制文件的唯一可行的方法。我已经在Github 上发布了修改fcgi库<a class="ae ls" href="https://github.com/omaidf/FastCGIFuzzing" rel="noopener ugc nofollow" target="_blank">的diff。</a></p></div></div>    
</body>
</html>