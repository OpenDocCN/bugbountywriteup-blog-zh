<html>
<head>
<title>Learning More About YAML Deserialization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解有关YAML反序列化的更多信息</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/learning-more-about-yaml-deserialization-9c08093b4a3d?source=collection_archive---------2-----------------------#2022-06-12">https://infosecwriteups.com/learning-more-about-yaml-deserialization-9c08093b4a3d?source=collection_archive---------2-----------------------#2022-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0874db036c7d8ece91bc81d7728f270d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qiKO_Eao27BOQL6_"/></div></div></figure><p id="297b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">简介</strong></p><p id="9181" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于Java、Python和Ruby等编程语言，反序列化攻击非常普遍。当数据流在没有首先执行任何检查的情况下被直接反序列化时，这些缺陷就会显现出来，并可能导致远程代码的执行。</p><p id="9813" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇博文中，我们将学习另一种反序列化技术，但是是在YAML的环境中。</p><p id="e891" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在深入了解YAML反序列化的基础知识之前，让我们先了解一下序列化和反序列化。</p><p id="e6b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">连载:</strong></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi kz"><img src="../Images/4b8e136e88aa6a80e86647df8c5f870c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FNlAaj0gJXJP29uy"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated"><a class="ae li" href="https://portswigger.net/web-security/deserialization" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="9a58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们假设你正在玩一个网络游戏。你所拥有的角色会有很多属性。比如用户名、头像、衣服、等级、武器等。你认为这些属性是如何在服务器上传递/交流甚至存储的？</p><p id="7f64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">答案是序列化。</p><p id="a81d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">什么是序列化？将对象转换成字节流或平面结构称为序列化。</p><p id="485f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个“字节流”也被称为对象的扁平版本。现在这可以通过网络发送，甚至可以保存在磁盘、文件和数据库中。</p><p id="de66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">序列化的反义词是反序列化。反序列化是指将这些字节流转换回对象形式。</p><p id="680c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是这怎么会导致漏洞呢？当web服务器接受一个序列化的值而不验证它，然后反序列化它时，问题就出现了。如果用户控制序列化的值，他可以篡改它，当反序列化时，会导致意想不到的结果。</p><p id="51c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">什么是YAML？</p><p id="b1e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">YAML代表另一种标记语言。维基百科将YAML定义为“一种人类可读的数据序列化语言”。它通常用于配置文件和存储或传输数据的应用程序中。它使用Python风格的缩进来表示嵌套，还使用了更多</p><p id="af96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一种压缩格式，使用[]表示列表，使用{}表示地图。</p><p id="2bec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与编程语言不同，它没有合适的格式，这也是它与其他语言的区别。</p><p id="7e4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">让我们考虑一个例子:</strong></p><p id="3635" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">未序列化数据:</strong></p><blockquote class="lj lk ll"><p id="f83c" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi">{</p><p id="e82c" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">姓名':'马尼什'，</p><p id="8771" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">'年龄':12，</p><p id="e1f9" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">技能':['编程'，'软技能']</p><p id="5d77" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi">}</p></blockquote><p id="a336" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">序列化后，这将变成:</p><p id="3e97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">名称:马尼什</p><p id="30fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">年龄:12岁</p><p id="e23e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">技能:</p><p id="1b00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">-编程</p><p id="7f3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">-软技能</p><p id="4c37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">这是一个怎样的漏洞？</strong></p><p id="84c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它不是。但是如果我们序列化一个对象，最终会发生什么，不是简单地反序列化它，而是执行它。</p><p id="96b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最常用的库是:PyYAML和ruamel.yaml，如果使用不安全的方法对它们进行序列化和反序列化，这两个库都容易受到YAML反序列化攻击。</p><p id="a7c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">PyYAML、ruamel.yaml中用于序列化和反序列化的方法是相同的。</p><p id="cb68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，用于序列化的方法有:</p><p id="f38f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">dump()，dump_all()，safe_dump()，safe_dump_all()。</p><p id="1a1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">若要序列化{ 'name': 'Manish '，' age': 12，' skills': ['programming '，' soft skills'] }</p><p id="647b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用于序列化对象的方法有:</p><p id="05ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">load()、load_all()、full_load()、full_load_all()、safe_load()和safe_load_all()。</p><p id="188f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">创建有效载荷</strong></p><p id="33ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在这里用来创建有效负载的方法是使用__reduce__()方法。即使服务器使用PyYAML或ruamel.yaml，这也是可行的。</p><p id="e9a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意:假设受支持的系统托管在基于Unix的操作系统上。</p><blockquote class="lj lk ll"><p id="991b" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">导入yaml</p><p id="69c7" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">导入子流程</p><p id="5597" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">类负载(对象):</p><p id="9431" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">def __reduce__(自己):</p><p id="9fd5" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">返回(子流程。Popen，(' ls '，))</p><p id="6f13" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">deserialized _ data = YAML . dump(Payload())</p><p id="197b" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">打印(反序列化_数据)</p></blockquote><p id="6311" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">序列化的输出将是:</p><blockquote class="lj lk ll"><p id="8a8c" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">！python/对象/应用:子流程。波本</p><p id="cad9" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">- ls</p></blockquote><p id="7f38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们先了解一下有效载荷:</p><p id="4166" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如前所述，我们已经使用__reduce__()方法创建了有效负载。我们使用了子流程模块，它提供了生成新流程的函数。使用的方法是Popen，使用的参数是<strong class="kd iu"> ls。</strong>Popen用于在新进程中执行新命令，<strong class="kd iu"> ls </strong>用于打印当前工作目录下的文件。</p><p id="2bcd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当这个有效负载进入web应用程序的易受YAML反序列化攻击的易受攻击字段时，它不仅会反序列化有效负载，还会执行它。</p><p id="3ba4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看备份的代码会是什么样子:</p><p id="347b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">deserialized _ data = YAML . load(data)</strong></p><p id="c023" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，该命令成功执行，并输出当前工作目录的内容。</p><h1 id="1e1f" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">补救</h1><p id="0c50" class="pw-post-body-paragraph kb kc it kd b ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky im bi translated">此漏洞被分配了CVE CVE-2017–18342，并已在PyYAML 5.1版中修补。</p><p id="fe1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可能正在使用的PyYAML版本高于5.1(当前版本是6.0)</p><p id="13c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是有没有办法完全绕过这个漏洞呢？嗯，这取决于你用的是哪个版本。也有不安全的方法，但是必须满足一定的条件才能执行。</p><p id="d634" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意:如果您希望尝试这样做，您可以切换到PyYAML版本&lt; 5.1.</p><p id="f4dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">The load () method will throw an error if you try to use the load() method with the above payload. But if you added “<strong class="kd iu"> Loader=Loader </strong>，或者将该行设置为<strong class="kd iu">deserialized _ data = unsafe _ load(data，Loader=Loader)，</strong>它将结束执行它。</p><p id="532f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，如果您使用的是PyYAML的更新版本，这就不适合您了，但是这里的问题是，一旦下载了py YAML，没有多少人愿意更新他们的库。</p><p id="cad1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结论</p><p id="092f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">反序列化漏洞会产生广泛的影响，包括执行远程代码或提升权限。因此，在反序列化任何数据之前，对任何数据输入进行清理和检查是绝对必要的。</p></div></div>    
</body>
</html>