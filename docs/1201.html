<html>
<head>
<title>[Research] Authenticated RCE found in HorizontCMS — Part 1 (Malicious Plugins)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[研究]在HorizontCMS中发现的认证RCE—第1部分(恶意插件)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/bughunt-authenticated-rce-found-in-horizontcms-part-1-malicious-plugins-72846f4ab6fe?source=collection_archive---------2-----------------------#2021-03-31">https://infosecwriteups.com/bughunt-authenticated-rce-found-in-horizontcms-part-1-malicious-plugins-72846f4ab6fe?source=collection_archive---------2-----------------------#2021-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/26225a12ed369afd9f808c82988959f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2U_j5IyL_0n0hIFXw2znw.png"/></div></div></figure><h1 id="2c38" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="4427" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">几周前，我和我的好友<a class="ae lx" href="https://ctrsec.io/" rel="noopener ugc nofollow" target="_blank"> Chi Tran </a>合作，在一个开源的CMS应用程序<a class="ae lx" href="https://github.com/ttimot24/HorizontCMS" rel="noopener ugc nofollow" target="_blank"> HorizontCMS </a>上寻找一些bug。此应用程序由<a class="ae lx" href="https://github.com/ttimot24" rel="noopener ugc nofollow" target="_blank"> @ttimot24 </a>创建。感谢您对我们的错误报告做出快速回应，并允许我们写一篇关于它们的博文！</p><p id="df8e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">首先，我们在测试环境中安装了HorizontCMS，并让它监听本地主机(127.0.0.1)。然后，我们将Firefox配置为允许本地主机代理。(如果您还不知道，请在Firefox上进行以下配置，以便它可以代理本地主机web应用程序。)</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9ccccc99589ef23417539f6f718b81f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YX1_HflFwtcCx0OnBohGA.png"/></div></div></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="3c66" class="kb kc it bd kd ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky bi translated">初始挖掘</h1><p id="7efe" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">接下来，我们知道最近为HorizontCMS发现的一个CVE是关于一个任意PHP文件上传漏洞:<a class="ae lx" href="https://packetstormsecurity.com/files/160046/HorizontCMS-1.0.0-beta-Shell-Upload.html" rel="noopener ugc nofollow" target="_blank">CVE-2020–27387</a>。因此，我们最初的方法是看看我们是否可以绕过作者已经解决的任何文件类型限制。这一次，通过限制文件扩展名，如<code class="fe mt mu mv mw b">.php</code>、<code class="fe mt mu mv mw b">.php5</code>、<code class="fe mt mu mv mw b">.php7</code>、<code class="fe mt mu mv mw b">.phtml</code>、<code class="fe mt mu mv mw b">.inc</code>等，问题得到了适当的缓解。</p><h2 id="452d" class="mx kc it bd kd my mz dn kh na nb dp kl lk nc nd kp lo ne nf kt ls ng nh kx ni bi translated">绕过补丁…？</h2><p id="27a9" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">但是，我们通过使用“<code class="fe mt mu mv mw b">/</code>”(例如<code class="fe mt mu mv mw b">test.php/</code>)上传PHP文件发现了一个文件类型旁路。</p><ol class=""><li id="0290" class="nj nk it lb b lc ly lg lz lk nl lo nm ls nn lw no np nq nr bi translated">将<code class="fe mt mu mv mw b">test.php</code>文件上传到“文件管理器”</li></ol><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/bf00342fd953cf0a98280cc95d27d771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WGYLig-QWwxlN9Ebr5T9dg.png"/></div></div></figure><p id="27a5" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">2.文件被上传；然而，它被重新命名为一些胡言乱语</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/e55aa3f6357dffa61b70a3b671120f30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJlMUyrxuiPzN_9SCsTuKQ.png"/></div></div></figure><p id="37a1" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">3.将文件名从胡言乱语重命名为<code class="fe mt mu mv mw b">test.php/</code> →点击“重命名”我们可以看到文件名现在改为<code class="fe mt mu mv mw b">test.php</code></p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/6eee39b59c03444ed0dae149681634bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ey5WYobOfpH5ddnzBpEt2g.png"/></div></div></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/975e8b45cfd177d85d25928a5ec55616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y26Q-l5YtrAIX_rFF2RvDw.png"/></div></div></figure><blockquote class="nw nx ny"><p id="a097" class="kz la nz lb b lc ly le lf lg lz li lj oa ma lm ln ob mb lq lr oc mc lu lv lw im bi translated">注意:如果你只是试图将文件名重新命名为test.php或test.php5，它不会起作用，因为作者应用了<strong class="lb iu"> validationRegex() </strong>函数来修复原来的CVE(<a class="ae lx" href="https://packetstormsecurity.com/files/160046/HorizontCMS-1.0.0-beta-Shell-Upload.html" rel="noopener ugc nofollow" target="_blank">CVE-2020–27387</a>)</p></blockquote><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/6b26b8baa88b81fa602f40a93009c39f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*jdYEu42Mim8nK0tJqMj3ug.png"/></div></figure><h2 id="d768" class="mx kc it bd kd my mz dn kh na nb dp kl lk nc nd kp lo ne nf kt ls ng nh kx ni bi translated">简单的CVE？？？</h2><p id="46db" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">不幸的是，这并不容易…当我们试图通过浏览器访问上传的<code class="fe mt mu mv mw b">test.php</code>文件时，我们遇到了以下404错误页面。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/436e3bc3f228c3978d4f766e8c10ef1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pU4qcPh0IPxWDRj_-75C9g.png"/></div></div></figure><p id="dbe8" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">所以，我们想进入下一个有趣的功能:<strong class="lb iu">插件</strong>。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/4e30500e1c3a7fa384aa0e35ee3c3d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oa-Gzi6-F8dYS5Qq2gp-Xw.png"/></div></div></figure><blockquote class="nw nx ny"><p id="ae60" class="kz la nz lb b lc ly le lf lg lz li lj oa ma lm ln ob mb lq lr oc mc lu lv lw im bi translated">注意:后来，我们终于找到了另一种方法来绕过PHP文件类型的限制，上传恶意文件，以获得RCE。请查看在horizont CMS-Part 2(PHP文件类型旁路)  <em class="it">中找到的<a class="ae lx" href="https://bigb0ss.medium.com/bughunt-authenticated-rce-found-in-horizontcms-part-2-php-filetype-bypass-4580176223eb" rel="noopener">Part 2—<strong class="lb iu">【BugHunt】认证的RCE😀</strong></a></em></p></blockquote></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="a2f0" class="kb kc it bd kd ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky bi translated">恶意插件RCE</h1><p id="965f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">许多应用程序使用插件来引入新的特性和附加功能；因此，可能值得检查你是否可以上传任何恶意插件，以潜在地获得RCE。根据我的经验，上传一个新插件，一个应用程序可能需要特定的文件格式，HorizontCMS也是如此。但幸运的是，作者有一个wiki页面，详细解释了如何开发一个插件，并且有一个示例插件！😎</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/6594321e5cfa1a6d88ced6b727e70793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YVqIi2K2IJZbLG1WbP6CZQ.png"/></div></div><figcaption class="oh oi gj gh gi oj ok bd b be z dk translated">维基—<a class="ae lx" href="https://github.com/ttimot24/HorizontCMS/wiki/Plugins" rel="noopener ugc nofollow" target="_blank">https://github.com/ttimot24/HorizontCMS/wiki/Plugins</a></figcaption></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/2a9e76314db4757cf6db7efcd6a493fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tyMiyeLuJ0OuQC6GWj4obA.png"/></div></div><figcaption class="oh oi gj gh gi oj ok bd b be z dk translated">示例插件—<a class="ae lx" href="https://github.com/ttimot24/GoogleMaps" rel="noopener ugc nofollow" target="_blank">https://github.com/ttimot24/GoogleMaps</a></figcaption></figure><p id="b46b" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我们对这个插件文件是如何开发、上传和部署到应用程序上的做了一些全面的评估。我们在插件文件中发现了一些易受攻击的代码，我们可以在其中引入恶意的PHP代码来导致RCE。</p><h2 id="821f" class="mx kc it bd kd my mz dn kh na nb dp kl lk nc nd kp lo ne nf kt ls ng nh kx ni bi translated">寻找漏洞</h2><p id="224f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">首先，我们压缩了作者提供的示例GoogleMaps插件，并上传了它(上传时，它会在应用程序中自动解压缩。)</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/8062c7d6e1be0b40dd9527b460fafaa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XcbjpTzO1P6fuF0SVh6BEg.png"/></div></div></figure><p id="8bb5" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">然后，有一个选项来“安装”和“激活”应用程序的插件。一旦完成，插件被激活，并在菜单栏下创建“谷歌地图”。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/8161d63d0f1d6058ecca104b50611a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWO19UQuf5g2RIMk9YSA_Q.png"/></div></div></figure><p id="264c" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我们观察到谷歌地图插件中有一个“<code class="fe mt mu mv mw b">Add location</code>”功能。当我们添加一个任意的位置并保存它时，它以一个成功的消息“<code class="fe mt mu mv mw b">Location added succesfully!</code>”响应</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/ddf6d8d02776b768f0f41a0dacad4ea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXbH1h1eFyiwqX-YpVZoeg.png"/></div></div></figure><p id="d12a" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">因此，我们很好奇应用程序是如何处理这个过程的，尤其是在什么情况下，它会用成功消息进行响应。</p><p id="36f7" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我们在插件源文件中搜索响应，发现下面的PHP脚本(<code class="fe mt mu mv mw b">GoogleMaps/resources/lang/en/messages.php</code>)对我们来说非常明显。The电码基本上是在做:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/8080fd05316f7a46415161ea510fbf9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BrngHjIY4_b1G28e9zg5mA.png"/></div></div><figcaption class="oh oi gj gh gi oj ok bd b be z dk translated">message.php</figcaption></figure><ul class=""><li id="fbfe" class="nj nk it lb b lc ly lg lz lk nl lo nm ls nn lw oq np nq nr bi translated">当成功添加位置时</li><li id="ad73" class="nj nk it lb b lc or lg os lk ot lo ou ls ov lw oq np nq nr bi translated">打印出"<code class="fe mt mu mv mw b">Location added succesfully!</code>"</li></ul><p id="adaf" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我们在这里嗅到了一些潜在的任意代码执行:]</p><h2 id="2083" class="mx kc it bd kd my mz dn kh na nb dp kl lk nc nd kp lo ne nf kt ls ng nh kx ni bi translated">有效负载准备</h2><p id="a576" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">那么，如果我们修改这段代码(在我们控制的插件文件中)来添加一个名为<code class="fe mt mu mv mw b">$shell</code>的PHP反向shell变量，并且这个变量将在成功添加位置时被调用，会怎么样呢？听起来很有希望:]</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ow"><img src="../Images/de2710b3c6bf5a8a56d8155f0c715843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbgTYy0UlzIw_x24mEjfEg.png"/></div></div><figcaption class="oh oi gj gh gi oj ok bd b be z dk translated">改良message.php</figcaption></figure><h2 id="37a8" class="mx kc it bd kd my mz dn kh na nb dp kl lk nc nd kp lo ne nf kt ls ng nh kx ni bi translated">RCE</h2><p id="44e9" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们重新压缩了修改后的GoogleMaps插件，并再次上传。当我们这次添加位置时，我们成功地执行了反向shell，并在系统上获得了RCE！</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ox"><img src="../Images/d5a232f3d5f98a1d3bcd805918fc2bcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dL0hOmOD5PRYKjWvfCytSA.png"/></div></div></figure><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/ca235cb1f91ce5f641d6eb37c3624a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*7qjmqBQweTLIf76yP5T-lw.png"/></div></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="53b8" class="kb kc it bd kd ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky bi translated">结论</h1><p id="eab5" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在识别和验证问题后，我们向应用程序所有者披露了此问题。此外，请查看第2部分中我们如何绕过PHP文件类型限制上传任意文件以获得RCE :]</p><ul class=""><li id="4f52" class="nj nk it lb b lc ly lg lz lk nl lo nm ls nn lw oq np nq nr bi translated"><a class="ae lx" href="https://bigb0ss.medium.com/bughunt-authenticated-rce-found-in-horizontcms-part-2-php-filetype-bypass-4580176223eb" rel="noopener"><strong class="lb iu">【BugHunt】在HorizontCMS —第2部分(PHP文件类型绕过)</strong> </a>中发现经过身份验证的RCE</li></ul></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="97e6" class="mx kc it bd kd my mz dn kh na nb dp kl lk nc nd kp lo ne nf kt ls ng nh kx ni bi translated">披露时间表</h2><ul class=""><li id="0839" class="nj nk it lb b lc ld lg lh lk oz lo pa ls pb lw oq np nq nr bi translated">2011年3月15日—向HorizontCMS报告错误</li><li id="ea02" class="nj nk it lb b lc or lg os lk ot lo ou ls ov lw oq np nq nr bi translated">2011年3月16日— HorizontCMS承认该问题</li><li id="5c9c" class="nj nk it lb b lc or lg os lk ot lo ou ls ov lw oq np nq nr bi translated">2011年3月16日——CVE提出请求(MITRE)</li></ul></div></div>    
</body>
</html>