<html>
<head>
<title>CVE-2020-1925: Requests to arbitrary URLs in Apache Olingo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CVE-2020-1925:对Apache Olingo中任意URL的请求</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/cve-2020-1925-requests-to-arbitrary-urls-in-apache-olingo-c66958682835?source=collection_archive---------0-----------------------#2020-01-26">https://infosecwriteups.com/cve-2020-1925-requests-to-arbitrary-urls-in-apache-olingo-c66958682835?source=collection_archive---------0-----------------------#2020-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1cb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不久前，我写了一篇关于不安全的反序列化和我在Apache Olingo中发现的DoS漏洞的文章。这篇文章描述了图书馆的另一个问题。这一次，它是Olingo客户端中的一个小缺陷，可能允许向任意URL发送一些HTTP请求。该问题已在4.7.1版中修复。</p><p id="71fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你不知道，Apache Olingo是一个实现开放数据协议(OData)的Java库。该协议允许以一种简单的方式创建和使用可查询和可互操作的RESTful APIs。</p><p id="8585" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">最初发表于</em><a class="ae kp" href="https://blog.gypsyengineer.com/en/security/cve-2020-1925-ssrf-in-apache-olingo.html" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://blog.gypsyengineer.com</em></a></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/55d6924332bafb57096076ad13859f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nVY4oo_lJ0xvZAGz.jpg"/></div></div></figure><h1 id="f2c5" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">问题</h1><p id="98c3" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">OData协议在HTTP上运行。Apache Olingo提供了一个OData客户端。特别是，这个库有一个<code class="fe mf mg mh mi b">AsyncRequestWrapperImpl</code>类，可以向OData服务器发送请求，然后处理响应。当客户机请求OData服务器创建新记录时，服务器可能无法立即创建。在这种情况下，服务器可能会回复202状态代码，并在URL中包含<code class="fe mf mg mh mi b">Location</code>标头。该类保存此URL以备将来使用:</p><pre class="kr ks kt ku gt mj mi mk ml aw mm bi"><span id="47a0" class="mn ld it mi b gy mo mp l mq mr">private void retrieveMonitorDetails(final HttpResponse res) {<br/>  Header[] headers = res.getHeaders(HttpHeader.LOCATION);<br/>  if (ArrayUtils.isNotEmpty(headers)) {<br/>    this.location = URI.create(headers[0].getValue());<br/>...</span></pre><p id="5cb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，该类可以向URL发送一个GET请求来检查记录是否准备好了:</p><pre class="kr ks kt ku gt mj mi mk ml aw mm bi"><span id="b26e" class="mn ld it mi b gy mo mp l mq mr">public boolean isDone() {<br/>   if (response == null) {<br/>     // check to the monitor URL<br/>     final HttpResponse res = checkMonitor(location);<br/> ...<br/> public R getODataResponse() {<br/>   HttpResponse res = null;<br/>   for (int i = 0; response == null &amp;&amp; i &lt; MAX_RETRY; i++) {<br/>     res = checkMonitor(location);<br/> ...<br/> protected final HttpResponse checkMonitor(final URI location) {<br/>   if (location == null) {<br/>     throw new AsyncRequestException(<br/>         "Invalid async request response. Missing monitor URL");<br/>   }<br/>   final HttpUriRequest monitor = odataClient.getConfiguration()<br/>       .getHttpUriRequestFactory().create(HttpMethod.GET, location);</span></pre><p id="6d44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者，它甚至可以发送删除请求:</p><pre class="kr ks kt ku gt mj mi mk ml aw mm bi"><span id="b255" class="mn ld it mi b gy mo mp l mq mr">public ODataDeleteResponse delete() {<br/>   final ODataDeleteRequest deleteRequest = odataClient.getCUDRequestFactory()<br/>       .getDeleteRequest(location);<br/>   return deleteRequest.execute();<br/> }<br/> ...<br/> public AsyncResponseWrapper asyncDelete() {<br/>   return odataClient.getAsyncRequestFactory().getAsyncRequestWrapper(<br/>       odataClient.getCUDRequestFactory().getDeleteRequest(location)).execute();<br/>  }</span></pre><p id="4dd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是这个类不检查来自<code class="fe mf mg mh mi b">Location</code>头的URL是否属于服务器。因此，服务器可以欺骗客户端向任意URL发送请求。例如，URL可以指向客户端可访问但服务器不可访问的私有资源。</p><p id="83ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mf mg mh mi b">AsyncBatchRequestWrapperImpl</code>级也有同样的问题。</p><p id="15bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该问题是在代码审查期间发现的。</p><h1 id="4911" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">解决方案</h1><p id="294c" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">该问题已通过添加检查来确保来自<code class="fe mf mg mh mi b">Location</code>标题的URL属于服务器而得到修复。现在在<code class="fe mf mg mh mi b">checkLocation()</code>方法中执行检查，该方法验证方案、域名和端口是否与服务器的URL匹配:</p><pre class="kr ks kt ku gt mj mi mk ml aw mm bi"><span id="f1bc" class="mn ld it mi b gy mo mp l mq mr">private URI checkLocation(URI uri) {<br/>   if (!this.uri.getScheme().equals(uri.getScheme())) {<br/>     throw new AsyncRequestException("Unexpected scheme in the Location header");<br/>   }<br/>   if (!this.uri.getHost().equals(uri.getHost())) {<br/>     throw new AsyncRequestException("Unexpected host name in the Location header");<br/>   }<br/>   if (this.uri.getPort() != uri.getPort()) {<br/>     throw new AsyncRequestException("Unexpected port in the Location header");<br/>   }<br/>   return uri;<br/> }</span></pre><h1 id="6d97" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">我的应用程序容易受到攻击吗？</h1><p id="565a" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">这个问题的答案很大程度上取决于特定应用程序如何使用Apache Olingo。</p><p id="0296" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，如果应用程序不使用<code class="fe mf mg mh mi b">AsyncRequestWrapperImpl</code>或<code class="fe mf mg mh mi b">AsyncBatchRequestWrapperImpl</code>类，那么它不会受到影响。</p><p id="cd4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果应用程序使用这些类，那么以下问题可能有助于理解攻击者如何利用这些类中的问题:</p><ol class=""><li id="a794" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated">应用程序可以连接到不受信任的服务器吗？</li><li id="f682" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">有什么方法可以欺骗应用程序向不受信任的服务器发送请求吗？</li><li id="df6d" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">攻击者有办法修改客户端和服务器之间的数据吗？</li></ol><p id="fe0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果至少有一个问题的答案是肯定的，而不是否定的，那么这个应用程序很可能会受到影响。</p><h1 id="3df5" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="cf68" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">这个问题看起来并不严重，因为对手可能很难利用它。尽管如此，为了安全起见，最好还是将Apache Olingo更新到4.7.1。</p><h1 id="ea68" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">参考</h1><ul class=""><li id="5e67" class="ms mt it js b jt ma jx mb kb ng kf nh kj ni kn nj my mz na bi translated"><a class="ae kp" href="https://nvd.nist.gov/vuln/detail/CVE-2020-1925" rel="noopener ugc nofollow" target="_blank">CVE——2020年至1925年</a></li><li id="da88" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn nj my mz na bi translated"><a class="ae kp" href="https://github.com/apache/olingo-odata4/pull/63" rel="noopener ugc nofollow" target="_blank">补丁</a></li><li id="0d99" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn nj my mz na bi translated"><a class="ae kp" href="https://mail-archives.apache.org/mod_mbox/olingo-user/202001.mbox/%3CCAGSZ4d6HwpF2woOrZJg_d0SkHytXJaCtAWXa3ZtBn33WG0YFvw%40mail.gmail.com%3E" rel="noopener ugc nofollow" target="_blank">阿帕奇安全顾问</a></li><li id="5fab" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn nj my mz na bi translated"><a class="ae kp" href="https://olingo.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇奥林戈</a></li></ul></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="4a37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">最初发表于</em><a class="ae kp" href="https://blog.gypsyengineer.com/en/security/cve-2020-1925-ssrf-in-apache-olingo.html" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://blog.gypsyengineer.com</em></a></p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="5110" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">关注</em> <a class="ae kp" href="https://medium.com/bugbountywriteup" rel="noopener"> <em class="ko"> Infosec报道</em> </a> <em class="ko">获取更多此类精彩报道。</em></p><div class="nr ns gp gr nt nu"><a href="https://medium.com/bugbountywriteup" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">信息安全报道</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">收集了世界上最好的黑客的文章，主题从bug奖金和CTF到vulnhub…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="oe l of og oh od oi la nu"/></div></div></a></div></div></div>    
</body>
</html>