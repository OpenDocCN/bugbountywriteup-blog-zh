<html>
<head>
<title>SAT-Solver, Optimization, and Belief Propagation Attacks on SHA-256</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对SHA-256的SAT求解器、优化和信念传播攻击</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/sat-solver-optimization-and-belief-propagation-attacks-on-sha-256-33c0233440e9?source=collection_archive---------0-----------------------#2020-11-27">https://infosecwriteups.com/sat-solver-optimization-and-belief-propagation-attacks-on-sha-256-33c0233440e9?source=collection_archive---------0-----------------------#2020-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="031a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">四轮SHA-256散列函数产生17，806个未知位和26，383个逻辑关系。我们可以在一秒钟内解决这个问题。</h2></div><p id="7adf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你跟踪比特币使用的臭名昭著的SHA-256哈希函数的64轮中的4轮中的所有比特及其逻辑关系，这将是它的样子。一个有17806个节点，26383条边的图。我们可以在不到一秒的时间内解决它。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/a55739dfce11675030dce48e3d5d2081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IZklimRpYcwi4IQ7"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">4轮SHA-256位关系[图片由作者提供]</figcaption></figure><h1 id="eec1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">描述</h1><p id="26a6" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在本帖中，我们将尝试反转单向加密哈希函数，特别关注<a class="ae mo" href="https://en.bitcoinwiki.org/wiki/SHA-256" rel="noopener ugc nofollow" target="_blank"> SHA-256 </a>。散列函数<code class="fe mp mq mr ms b">f</code>可以被认为是对比特<code class="fe mp mq mr ms b">X</code>的运算，以产生输出比特<code class="fe mp mq mr ms b">Y</code> : <code class="fe mp mq mr ms b">f(X) = Y</code>。给定<code class="fe mp mq mr ms b">Y</code>和<code class="fe mp mq mr ms b">f</code>如何工作的知识，我们想要找到一些比特<code class="fe mp mq mr ms b">X'</code>比如<code class="fe mp mq mr ms b">f(X') = Y</code>。这通常被称为<a class="ae mo" href="https://en.wikipedia.org/wiki/Preimage_attack" rel="noopener ugc nofollow" target="_blank">原像攻击</a>。注意<code class="fe mp mq mr ms b">X</code>不一定需要等于<code class="fe mp mq mr ms b">X'</code>。</p><p id="a265" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一次成功的原像攻击对基本上整个互联网、金融界和主要政府的国防都有严重的影响。哈希函数用于各种领域:从比特币挖掘和交易，到HTTPS加密，再到在服务器数据库中存储用户密码。</p><p id="188e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我花了很长时间(太长了！)试图用各种方法解决这个“不可能”的问题，详述如下。作为一个<strong class="kh ir">免责声明</strong>:我没有声称这些方法中的任何一个破坏了完整的64轮SHA-256散列函数的安全性。大概还是不可行(证明我错了！).这里有些方法最多能解16轮，有些方法连1轮都解不了。但主要的一点是分享想法，并激发你在这些想法的基础上继续努力。</p><p id="406b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个项目对应的Python和C++代码可以在<a class="ae mo" href="https://github.com/trevphil/preimage-attacks" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。这篇文章最初发表在trevphil.com。</p><h1 id="dc8a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">散列函数的符号表示</h1><p id="4501" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">为了解决这个问题，我们需要做的第一件事是找出哈希函数<code class="fe mp mq mr ms b">f</code>如何对输入位<code class="fe mp mq mr ms b">X</code>进行操作，以产生输出位<code class="fe mp mq mr ms b">Y</code>，而不对<code class="fe mp mq mr ms b">X</code>做任何假设。为此，我编写了一些哈希函数，包括SHA-256和一些简单的“测试”函数，它们对符号位向量进行操作。这种符号表示允许我们跟踪哈希函数中所有计算的输入和输出位之间的关系，例如，如果<code class="fe mp mq mr ms b">C = A &amp; B</code>，我们跟踪位<code class="fe mp mq mr ms b">C</code>是<code class="fe mp mq mr ms b">A</code>和<code class="fe mp mq mr ms b">B</code>的“与”结果的关系。最终，在所有的计算之后，我们将得到函数<code class="fe mp mq mr ms b">f(X) = Y</code>中<code class="fe mp mq mr ms b">Y</code>的每一位和<code class="fe mp mq mr ms b">X</code>的每一位之间的关系。</p><p id="84a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个过程中可以做一些简化。例如，假设位<code class="fe mp mq mr ms b">A</code>是来自未知输入<code class="fe mp mq mr ms b">X</code>的位，位<code class="fe mp mq mr ms b">B</code>是哈希算法中等于0的<em class="mt">常数</em>。那么我们知道<code class="fe mp mq mr ms b">C = A &amp; 0 = 0</code>所以<code class="fe mp mq mr ms b">C = 0</code>不管<code class="fe mp mq mr ms b">A</code>的值是多少。下面列出了对单个位的操作的一些简化:</p><ul class=""><li id="e89b" class="mu mv iq kh b ki kj kl km ko mw ks mx kw my la mz na nb nc bi translated"><code class="fe mp mq mr ms b">B = A &amp; 1 = A</code></li><li id="30ae" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><code class="fe mp mq mr ms b">B = A | 0 = A</code></li><li id="b14a" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><code class="fe mp mq mr ms b">B = A | 1 = 1</code></li><li id="6a2f" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><code class="fe mp mq mr ms b">B = A ^ 1 = ~A</code></li><li id="176d" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><code class="fe mp mq mr ms b">B = A ^ 0 = A</code></li><li id="1f0e" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><code class="fe mp mq mr ms b">B = A ^ A = 0</code></li><li id="f4ea" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><code class="fe mp mq mr ms b">B = A &amp; A = A | A = A</code></li></ul><p id="8aa2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些简化有助于减少散列函数的符号表示的大小，因为输出位<code class="fe mp mq mr ms b">B</code>有时是常数或等于未知输入<code class="fe mp mq mr ms b">A</code>。当这种情况发生时，我们不需要引入新的未知变量。</p><p id="fd32" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，通过将所有运算(XOR、OR、add)减少到仅使用AND和NOT逻辑门，可以使问题更容易处理。我把NOT gates称为INV(为逆):<code class="fe mp mq mr ms b">B = ~A</code>。让我们看一个使用AND和INV门重写XOR的例子:<code class="fe mp mq mr ms b">C = A ^ B</code>等价于</p><pre class="lc ld le lf gt ni ms nj nk aw nl bi"><span id="fb87" class="nm ls iq ms b gy nn no l np nq">X = ~(A &amp; B)<br/>Y = ~(A &amp; X)<br/>Z = ~(B &amp; X)<br/>C = ~(Y &amp; Z)</span></pre><p id="0c95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<em class="mt">确实</em>引入了中间变量，但关键的是，AND和INV运算可以<strong class="kh ir">线性化</strong>，也可以在连续域中表示，这在数学上很重要。通常在离散域中，我们会将每一位视为取值为0或1的二进制“<a class="ae mo" href="https://en.wikipedia.org/wiki/Random_variable" rel="noopener ugc nofollow" target="_blank">随机变量</a>”。</p><p id="2f90" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">AND运算可以用乘法:<code class="fe mp mq mr ms b">C = A &amp; B = A * B</code>表示，INV运算用减法:<code class="fe mp mq mr ms b">B = ~A = 1 - A</code>表示。为了线性化AND运算，我们可以使用下面的方法:</p><pre class="lc ld le lf gt ni ms nj nk aw nl bi"><span id="72df" class="nm ls iq ms b gy nn no l np nq">C = A &amp; B = A * B<br/>Equivalent to:<br/>C &lt;= A<br/>C &lt;= B<br/>C &gt;= A + B - 1</span></pre><p id="0aa2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，在INV操作期间没有信息丢失(我们总是可以从INV的输出中恢复输入)，但是在输出为0期间和输出为0时有<em class="mt">信息丢失。当输出为1时，我们知道两个输入都必须为1。但是当输出为0时，有三种可能的输入:<code class="fe mp mq mr ms b">0 = 0 &amp; 0 = 0 &amp; 1 = 1 &amp; 0</code>。<strong class="kh ir">因此，反转散列函数的所有复杂性都来自输出为0的与门</strong>。</em></p><h1 id="b98f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">例子</h1><p id="e0fd" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">这是一个相对简单的(与SHA-256相比)“哈希函数”，我创建了一个测试函数。如果我们可以使用输出位<code class="fe mp mq mr ms b">Y</code>(显示为绿色)的观测值来预测输入位<code class="fe mp mq mr ms b">X</code>(显示为黑色)，那么我们就在正确的轨道上。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nr"><img src="../Images/c321974f3b8882960e2ddf5bc3a01701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DW0ReX-PSmR1EFpG"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">作者图片</figcaption></figure><p id="1a4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哈希函数本身看起来像这样:</p><pre class="lc ld le lf gt ni ms nj nk aw nl bi"><span id="c99c" class="nm ls iq ms b gy nn no l np nq">def hash(hash_input, difficulty):<br/>  n = len(hash_input)<br/>  n4 = n // 4</span><span id="925f" class="nm ls iq ms b gy ns no l np nq">  np.random.seed(1)<br/>  A = int.from_bytes(np.random.bytes(n // 8), 'big')<br/>  B = int.from_bytes(np.random.bytes(n // 8), 'big')<br/>  C = int.from_bytes(np.random.bytes(n // 8), 'big')<br/>  D = int.from_bytes(np.random.bytes(n // 8), 'big')</span><span id="8b18" class="nm ls iq ms b gy ns no l np nq">  mask = SymBitVec((1 &lt;&lt; n4) - 1, size=n)<br/>  h = hash_input<br/>  for _ in range(difficulty):<br/>    a = ((h &gt;&gt; (n4 * 0)) &amp; mask) ^ A<br/>    b = ((h &gt;&gt; (n4 * 1)) &amp; mask) ^ B<br/>    c = ((h &gt;&gt; (n4 * 2)) &amp; mask) ^ C<br/>    d = ((h &gt;&gt; (n4 * 3)) &amp; mask) ^ D<br/>    a = (a | b)<br/>    b = (b &amp; c)<br/>    c = (c ^ d)<br/>    h = a | (b &lt;&lt; (n4 * 1)) | (c &lt;&lt; (n4 * 2)) | (d &lt;&lt; (n4 * 3))<br/>  return h</span></pre><p id="ddc2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不平凡，但仍然足够简单，求解器可以快速评估。我们一开始就可以做的一件事是“<strong class="kh ir">预解</strong>”技术。假设我们观察到一个散列位<code class="fe mp mq mr ms b">A = 1</code>，我们知道它通过INV: <code class="fe mp mq mr ms b">A = ~B</code>与图中的“父”位相关。我们可以自动赋值<code class="fe mp mq mr ms b">B = 0</code>。类似地，对于具有值1的与门输出的位，图中的父位可以被赋予值1。在将这些位值“反向传播”到双亲之后，我们可以再次“正向传播”，因为我们可能已经找到了逻辑门的输入值，而这些逻辑门的输入先前是未知的。可以重复向后/向前传递，直到没有发现新的比特值。这已经可以在哈希计算中解决数量惊人的位数。</p><h1 id="7814" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">解决方法</h1><p id="ca60" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在预求解操作之后，位关系的有向图可能仍然具有许多未知位。我们可以用暴力来解决这个问题，但是还有其他更快更有效的方法。使用截至2020年11月的最新和最棒的解决方法，从我认为最有效到最无效列出了解决方法。在第17轮SHA-256上，即使是最好的方法似乎也失败了(下面讨论)。</p><ol class=""><li id="6f97" class="mu mv iq kh b ki kj kl km ko mw ks mx kw my la nt na nb nc bi translated"><a class="ae mo" href="https://www.msoos.org/cryptominisat5/" rel="noopener ugc nofollow" target="_blank"> CryptoMiniSat </a></li><li id="ca16" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la nt na nb nc bi translated"><a class="ae mo" href="http://minisat.se/" rel="noopener ugc nofollow" target="_blank">迷你卫星</a></li><li id="2aed" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la nt na nb nc bi translated">古罗比MILP </li><li id="e028" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la nt na nb nc bi translated"><a class="ae mo" href="https://developers.google.com/optimization/mip/mip" rel="noopener ugc nofollow" target="_blank">谷歌</a> <code class="fe mp mq mr ms b"><a class="ae mo" href="https://developers.google.com/optimization/mip/mip" rel="noopener ugc nofollow" target="_blank">ortools</a></code> <a class="ae mo" href="https://developers.google.com/optimization/mip/mip" rel="noopener ugc nofollow" target="_blank"> MILP </a></li><li id="4474" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la nt na nb nc bi translated"><a class="ae mo" href="https://developers.google.com/optimization/cp" rel="noopener ugc nofollow" target="_blank">谷歌</a> <code class="fe mp mq mr ms b"><a class="ae mo" href="https://developers.google.com/optimization/cp" rel="noopener ugc nofollow" target="_blank">ortools</a></code> <a class="ae mo" href="https://developers.google.com/optimization/cp" rel="noopener ugc nofollow" target="_blank">约束编程</a></li><li id="b4e6" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la nt na nb nc bi translated"><a class="ae mo" href="https://www.ibm.com/analytics/cplex-cp-optimizer" rel="noopener ugc nofollow" target="_blank">复杂约束编程</a></li><li id="7b66" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la nt na nb nc bi translated"><a class="ae mo" href="https://www.ibm.com/support/knowledgecenter/SSSA5P_12.7.1/ilog.odms.cplex.help/CPLEX/UsrMan/topics/discr_optim/mip/01_mip_title_synopsis.html" rel="noopener ugc nofollow" target="_blank">复杂MILP </a></li><li id="cd01" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la nt na nb nc bi translated">传统优化</li><li id="ae22" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la nt na nb nc bi translated"><a class="ae mo" href="https://arxiv.org/pdf/1909.08605" rel="noopener ugc nofollow" target="_blank">带刻度的非凸面</a></li><li id="5553" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la nt na nb nc bi translated">愚蠢的信念传播</li><li id="3454" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la nt na nb nc bi translated">神经网络</li></ol><p id="7da1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些策略可以分为几个大类，我将很快讨论。</p><p id="18e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，这是一个问题大小(未知变量数量)与选定数量的求解器运行时间的对数图，以及对该对数数据的线性回归。问题的大小对应于SHA-256回合1、4、8、12和16。这些解算器是在我的弱双核16 GB MacBook Air上运行的，没有一个被允许运行超过24小时。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nu"><img src="../Images/a139a5e51b7704fc61119928d16b909e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EoJQZPcViiBY-2Ej"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">作者图片</figcaption></figure><p id="21fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为观察SHA-256算法的复杂度如何随着回合数的增加而增加是很有趣的。在第17回合发生了一些事情，导致了复杂性的激增。我的最佳猜测是，计算中“相距很远”的位之间的与门是问题所在。如果您为哈希计算期间创建的每个位分配一个单调递增的索引，并查看输入到与门的位的索引之间的最大距离，则最大间隔约为126，000位，最多16轮。在17轮时，差距增加到197，000位。对于SAT求解器，这可能意味着它不会检测到无效的变量赋值，直到值已经传播了很长一段距离。对于完整的64轮SHA-256，最大差距是386，767。</p><p id="319c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面，我们可以看到，随着循环次数的增加，位关系图中INV和and门的数量呈(近似)线性增长。先验因子对应于散列输入位，因此它们自然保持不变。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nv"><img src="../Images/3116bfb78631695664c33a41dd51fa6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZMzqth0jGkuMo10j"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">作者图片</figcaption></figure><h1 id="a82f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">SAT求解器</h1><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/82b6f707bf50f1f38ae7bc351b0bb0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*US1ZttDbKEAnvsfk63qCTg.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片修改自<a class="ae mo" href="https://commons.wikimedia.org/wiki/File:Tree-depth.svg" rel="noopener ugc nofollow" target="_blank">维基共享</a></figcaption></figure><p id="b0e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可满足性(SAT)求解器对布尔逻辑关系进行操作，以找到自由布尔变量的满意赋值。我会把像MiniSat、CryptoMiniSat、<code class="fe mp mq mr ms b">ortools</code>约束编程和Cplex约束编程这样的解算器归入这一类。这些类型的求解器通常通过将固定值分配给自由变量来工作，直到出现逻辑冲突，然后回溯直到冲突被解决，并在冲突区域尝试新的变量分配。尽管这是一个粗略的简化。人们想出了很多方法来加速这个过程，启发法来选择变量赋值的顺序，从冲突中学习等等。<a class="ae mo" href="https://www.msoos.org/minisat-faq/" rel="noopener ugc nofollow" target="_blank">这里</a>是一个很好的入门网站，<a class="ae mo" href="https://www.youtube.com/watch?v=d76e4hV1iJY&amp;ab_channel=ClojureTV" rel="noopener ugc nofollow" target="_blank">这个家伙</a>做了一个很好的演讲。</p><p id="e281" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">据我所知，这是迄今为止前像攻击最好的方法之一。许多解算器都是用C或C++实现的，所以它们运行速度极快，并且用启发式算法进行了大量优化。人们已经尝试使用SAT解算器来破解加密哈希函数，但是你最终会碰到可行问题大小的极限。为了使用MiniSat或CryptoMiniSat，我将位关系转换为<a class="ae mo" href="https://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html" rel="noopener ugc nofollow" target="_blank"> DIMACS合取范式</a> (CNF)。我甚至没有利用CryptoMiniSat对XOR门的优化处理，因为所有东西都简化为AND和INV门。</p><h1 id="7404" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">MILP</h1><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/6fa8db0c6177625979753bf96afb7a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*94NVGyrgXhGIti7B7onRaA.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片来自<a class="ae mo" href="https://commons.wikimedia.org/wiki/File:Branch-and-bound-polytopes.png" rel="noopener ugc nofollow" target="_blank">维基共享资源</a></figcaption></figure><p id="aea6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">混合整数线性规划(MILP)是一种优化形式，其中优化变量可以是整数值，而不是通常的实数值。古罗比·MILP、克莱斯·MILP和<code class="fe mp mq mr ms b">ortools</code> MILP就属于这一类。老实说，支撑MILP解算器的理论相当复杂(或者我应该说...<a class="ae mo" href="https://en.wikipedia.org/wiki/Simplex" rel="noopener ugc nofollow" target="_blank">单工</a>)。然而，如果你想阅读更多，谷歌术语像“线性编程松弛”，“分支和界限”，或“切割平面。”一个很好的起点是Gurobi对MIP的介绍。</p><p id="f610" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像Gurobi、Cplex和<a class="ae mo" href="https://www.coin-or.org/" rel="noopener ugc nofollow" target="_blank"> coin-or </a>这样的主要玩家的解算器工作得很好(很像SAT解算器)，直到17轮SHA-256。INV逻辑门编码为求解器的等式约束(<code class="fe mp mq mr ms b">B = 1 — A</code>)，and门编码为前面描述的3个不等式约束。优化目标是任意的，但是我通常最大化未知位值的总和。</p><h1 id="abae" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">传统优化</h1><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/60a6d2d272d55d646a507b3651dce07d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/0*reO9iy74Q215ey0P.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片来自<a class="ae mo" href="https://commons.wikimedia.org/wiki/File:Gradient_descent_method.png" rel="noopener ugc nofollow" target="_blank">维基共享资源</a></figcaption></figure><p id="23b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与混合整数优化相反，我还尝试了使用实值优化变量的普通优化。具有N个元素的向量<code class="fe mp mq mr ms b">x</code>被优化，其表示哈希计算中每个比特的值。为了转换为布尔值，如果<code class="fe mp mq mr ms b">x[i] &gt; 0.5</code>，我将位<em class="mt"> i </em>设置为1，否则为0。在优化中，位反转被表示为等式约束，<code class="fe mp mq mr ms b">Ax = b</code>，and门由3个不等式表示(如前所述)，给出不等式约束<code class="fe mp mq mr ms b">Cx &lt;= d</code>。还可以将<code class="fe mp mq mr ms b">x</code>的上下限添加到不等式约束中，从而加强<code class="fe mp mq mr ms b">0 &lt;= x &lt;= 1</code>。</p><p id="4556" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于位反转约束的例子，我们说<code class="fe mp mq mr ms b">bit_1 = ~bit_0 = 1 - bit_0</code>。然后我们会在<code class="fe mp mq mr ms b">A</code>中有一个类似于<code class="fe mp mq mr ms b">[1 1 0 ... 0]</code>的行，并且在<code class="fe mp mq mr ms b">b</code>向量中相应的元素会是<code class="fe mp mq mr ms b">1</code>。然后<code class="fe mp mq mr ms b">Ax = b</code>给出<code class="fe mp mq mr ms b">bit_0 + bit_1 = 1</code>。</p><p id="b333" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了观察到的散列输出位被初始化为它们的观察值之外，<code class="fe mp mq mr ms b">x</code>的初始猜测被初始化为<code class="fe mp mq mr ms b">0.5</code>。我没有将观察到的位添加到等式约束中，因为<a class="ae mo" href="https://docs.scipy.org/doc/scipy/reference/optimize.minimize-slsqp.html" rel="noopener ugc nofollow" target="_blank"> SLSQP </a>抱怨系统是超定的。</p><p id="51b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果问题变得相当复杂，这种方法的表现就会很差。通过舍入实数来近似布尔值并不能很好地转化为有效的解决方案。</p><h1 id="98c0" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated"><strong class="ak">稳健估计和分级非凸性</strong></h1><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/79aad34f217bd6151f21965e3e2f6bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*d6w3P2YJgNRtMIc2QSKfUw.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片来自<a class="ae mo" href="https://arxiv.org/pdf/1909.08605.pdf" rel="noopener ugc nofollow" target="_blank"> H. Yang、P. Antonante、V. Tzoumas和L. Carlone </a></figcaption></figure><p id="fab7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经在基于图形的SLAM上做了相当多的工作，并且有了一个想法，从健壮的估计技术到解决原像问题。这种东西叫做“分级非凸性”(GNC)，在<a class="ae mo" href="https://arxiv.org/abs/1909.08605" rel="noopener ugc nofollow" target="_blank">这篇</a>论文中介绍过。</p><p id="5f42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在GraphSLAM中，很多研究都致力于剔除错误添加到图表中的异常值。当图形被优化时，某些技术如<a class="ae mo" href="http://www2.informatik.uni-freiburg.de/~stachnis/pdf/agarwal13icra.pdf" rel="noopener ugc nofollow" target="_blank">动态协方差缩放</a> (DCS)可以帮助图形优化忽略影响目标函数的异常值。GNC实现了类似的结果，但其工作原理是将非凸优化问题转化为凸优化问题，然后用每次迭代后都会改变的超参数逐渐降低凸性。我的想法是将同样的事情应用于原像问题。对于每个与门，我们可以添加“冲突的”约束，这些约束对与门变量做出不同的假设(想想:<code class="fe mp mq mr ms b">0&amp;0</code>、<code class="fe mp mq mr ms b">0&amp;1</code>、<code class="fe mp mq mr ms b">1&amp;0</code>、<code class="fe mp mq mr ms b">1&amp;1</code>)，其中一些假设是不正确的。随着优化的进行，稳健估计技术将拒绝坏的约束并保留好的约束。</p><p id="0dac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，就像以前一样，这对于中等复杂的问题来说也不是很有效。然而，如果这项技术可以扩展到MIP优化，也许我们会看到非常不同的结果。</p><h1 id="94c0" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">信念传播</h1><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/6b285e5f5cfe08a8a35a3f25066392ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/0*CilB_gUpBkmpt_g-.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片来自<a class="ae mo" href="https://commons.wikimedia.org/wiki/File:Factor_Graph_representation.png" rel="noopener ugc nofollow" target="_blank">维基共享资源</a></figcaption></figure><p id="2e3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">置信传播(BP)是一种迭代的“消息传递”算法，其中消息在因子图中的因子和随机变量(RVs)之间传递。当没有消息变化超过某个小值ε时，我们说算法已经<em class="mt">收敛</em>。</p><p id="f6d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦消息收敛，我们可以使用它们在因子图上执行查询，例如回答问题“如果我知道所有的散列位，输入消息位0是1的概率是多少？”</p><p id="3f88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“消息”到底是什么？老实说，这很难解释。有点数学化，理论化，不直观。我会推荐<a class="ae mo" href="http://nghiaho.com/?page_id=1366" rel="noopener ugc nofollow" target="_blank">这篇文章</a>去了解它。</p><p id="25a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因子图是一个二分图，其中图的一边以RVs(位)作为节点，另一边以所有“因子”作为节点(and、INV逻辑门)。每个因子代表一个条件概率分布，并且具有一个“查询”RV(逻辑门的输出)以及一个“相关性”RV列表(逻辑门的输入)。</p><p id="df15" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比如让<code class="fe mp mq mr ms b">C = A &amp; B</code>。那么一个因子<code class="fe mp mq mr ms b">f</code>可以代表<code class="fe mp mq mr ms b">P(C | A, B)</code>，即观察到<code class="fe mp mq mr ms b">C = 0</code>或<code class="fe mp mq mr ms b">C = 1</code>的概率，假设我们知道<code class="fe mp mq mr ms b">A</code>和<code class="fe mp mq mr ms b">B</code>的值。</p><p id="67b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个因素都有一个表，该表包含查询位的<a class="ae mo" href="https://en.wikipedia.org/wiki/Conditional_probability_distribution" rel="noopener ugc nofollow" target="_blank">条件概率分布</a> (CPD)，给出了所有可能的依赖值。该表在消息传递算法中使用。如果一个因子中有n个依赖项，那么表的大小就是2^N，因此您可以看到将每个因子的大小保持在较低水平是多么有益。我们的因子<code class="fe mp mq mr ms b">f</code>会有一个表，如:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/7406719c25f6320a819fb5addaf8d92c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*svBJKiui-Ve8IZ1RxJh4Kg.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">C = A &amp; B的CPD表[图片由作者提供]</figcaption></figure><p id="764a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">注意</strong>:不需要计算<code class="fe mp mq mr ms b">P(C = 0 | A, B)</code>，因为它可以由<code class="fe mp mq mr ms b">1.0 - P(C = 1 | A, B)</code>导出。</p><p id="6572" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经用C++实现了信念传播算法，因为用Python处理大规模问题会很慢。然而，我发现这种方法在实践中表现不佳。树结构上的信念传播将总是收敛，但是对于循环因子图没有收敛保证(所谓的“多圈信念传播”)。</p><p id="7031" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于循环消息传递，最终经常发生的是消息值的分歧，我们会遇到数字上溢/下溢错误。一个可能的解决方案是和积算法的对数版本，我<em class="mt">尝试过</em>来实现，但是放弃了(见<a class="ae mo" href="https://www.researchgate.net/publication/3924103_Efficient_implementations_of_the_sum-product_algorithm_for_decoding_LDPC_codes" rel="noopener ugc nofollow" target="_blank">这里</a>，这里<a class="ae mo" href="https://www2.cs.duke.edu/research/AI/papers/Felzenszwalb06.pdf" rel="noopener ugc nofollow" target="_blank">这里</a>)。</p><h1 id="287a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">神经网络</h1><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d5e76f5ddde82c35a0285949c495f423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*trRgJLAKrgkx8EE7M6qZ9Q.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片来自<a class="ae mo" href="https://commons.wikimedia.org/wiki/File:NeuralNetwork.png" rel="noopener ugc nofollow" target="_blank">维基共享资源</a></figcaption></figure><p id="0c6a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的想法是，在已知散列输出<code class="fe mp mq mr ms b">Y</code>和散列函数<code class="fe mp mq mr ms b">f</code>的情况下，可以训练神经网络来预测有效的散列输入<code class="fe mp mq mr ms b">X</code>。换句话说，神经网络应该通过观察随机输入和输出的许多实例来学习反函数<code class="fe mp mq mr ms b">g</code>，其中<code class="fe mp mq mr ms b">f(g(Y)) = Y</code>。为此，我(痛苦地)修改了符号位向量原语，以支持<a class="ae mo" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>张量，并100%支持反向传播。</p><p id="9cf0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我实现的神经网络架构需要投入更多的工作和思考。到目前为止，他们的表现一点也不好。我一直在努力加强位之间的“硬”关系，例如网络试图在哈希计算中学习所有位的有效分配，但同时需要知道，如果两位通过INV操作相关，那么<code class="fe mp mq mr ms b">B = 1 - A</code>。基于图形的神经网络是一种可能的方法，但我最近看到了这个<a class="ae mo" href="https://www.youtube.com/watch?v=EqvzIGY_bI4&amp;ab_channel=MicrosoftResearch" rel="noopener ugc nofollow" target="_blank">演讲</a>和相应的<a class="ae mo" href="https://github.com/dselsam/neurosat/tree/master/python" rel="noopener ugc nofollow" target="_blank">代码</a>用于一个叫做“NeuroSAT”的网络，这非常有趣，也许很有前途。</p><p id="ebf5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，通过散列函数的反向传播(更一般地说，在一个大问题上训练网络)非常慢。我相信这是哈希函数创建的复杂的<a class="ae mo" href="https://pytorch.org/docs/stable/autograd.html" rel="noopener ugc nofollow" target="_blank">亲笔签名</a>图的结果，因为所有的切片和单个张量元素(位)的移动。</p><h1 id="192e" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">参考资料和资源</h1><p id="db31" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我希望你在这里学到了一些东西，或者这篇文章激发了我还没有想到的创造性解决方案的想法。您可以随时尝试联系我(trevphil3 -at- gmail -dot- com ),我会尽力回复。我花了一年多的时间在业余时间研究这个问题，我对此充满热情！除了本文正文中的链接，这里还有一些更有帮助的链接和论文:</p><ul class=""><li id="5b26" class="mu mv iq kh b ki kj kl km ko mw ks mx kw my la mz na nb nc bi translated"><a class="ae mo" href="https://www.duo.uio.no/bitstream/handle/10852/34912/thesis-output.pdf?sequence=1&amp;isAllowed=y" rel="noopener ugc nofollow" target="_blank">基于SAT的SHA-1原像攻击，Vegard Nossum硕士论文</a></li><li id="74ee" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><a class="ae mo" href="http://jheusser.github.io/2013/02/03/satcoin.html" rel="noopener ugc nofollow" target="_blank">解释使用比特币的SAT求解器</a></li><li id="6235" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><a class="ae mo" href="https://www.microsoft.com/en-us/research/publication/applications-of-sat-solvers-to-cryptanalysis-of-hash-functions/" rel="noopener ugc nofollow" target="_blank">用于密码分析的SAT解算器</a></li><li id="c2c7" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><a class="ae mo" href="http://blog.sophisticatedways.net/2018/11/visualising-sha-1.html" rel="noopener ugc nofollow" target="_blank">可视化加密哈希函数</a></li><li id="9795" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><a class="ae mo" href="https://github.com/narkkil/md5" rel="noopener ugc nofollow" target="_blank"> md5实现</a></li><li id="7efd" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><a class="ae mo" href="http://www.sfu.ca/~gwa5/pdf/2009_01.pdf" rel="noopener ugc nofollow" target="_blank">利用计算成本高昂的黑盒函数解决高维设计问题的建模和优化策略调查</a></li><li id="f823" class="mu mv iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><a class="ae mo" href="https://eprint.iacr.org/2020/371.pdf" rel="noopener ugc nofollow" target="_blank">对Keccak的单一跟踪攻击</a></li></ul></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="8de0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mt">最初发表于</em><a class="ae mo" href="https://trevphil.com/posts/preimage-attacks" rel="noopener ugc nofollow" target="_blank"><em class="mt">trevphil.com</em></a></p></div></div>    
</body>
</html>