<html>
<head>
<title>Heap exploitation #1 — Tcache attack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆利用#1 — Tcache攻击</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/heap-exploitation-journey-1-tcache-attack-5b38fb0c19b0?source=collection_archive---------0-----------------------#2021-10-01">https://infosecwriteups.com/heap-exploitation-journey-1-tcache-attack-5b38fb0c19b0?source=collection_archive---------0-----------------------#2021-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0797" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗨伙计们。距离我上次玩CTFs已经半年了。现在我回来学习堆利用。我会写这样的博客，介绍这些技术和展示它们的挑战。</p><p id="2f9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这第一集中，我们将探索tcache链表中指针的中毒，以分配一个任意的块(从我们想要的任何地址开始的块)。</p><p id="6737" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了说明这个概念，我将带你经历在<strong class="jp ir"> DEFCON19资格赛回合</strong>中的挑战<strong class="jp ir"> babyheap </strong>。挑战链接可以在<a class="ae kl" href="https://github.com/guyinatuxedo/nightmare/tree/master/modules/29-tcache/dcquals19_babyheap" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">这里找到</strong> </a>。</p><blockquote class="km kn ko"><p id="dab2" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/guyinatuxedo/nightmare/tree/master/modules/29-tcache/dcquals19_babyheap" rel="noopener ugc nofollow" target="_blank">https://github . com/guyinatuxedo/nightmare/tree/master/modules/29-tcache/DC quals 19 _ baby heap</a></p></blockquote><h1 id="4d6f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">侦察</h1><p id="ca6a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">像往常一样，我总是做的第一步是<em class="kp">检查sec </em>并在<em class="kp"> ghidra </em>中反编译二进制文件。</p><p id="68a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到所有保护都已启用:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/09bcc25bdff81cef17db24254fc137d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oN5Dmf8XqCUNMbej4gG9gQ.png"/></div></div></figure><p id="083f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也来了解一下libc的版本:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mi"><img src="../Images/5ec07d36faa9c2b758f961cbfbbc7c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OIdWUpJBpwrtvV0eMeMCxw.png"/></div></div></figure><p id="a8a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">启动ghidra，我们可以看到处理主菜单的功能:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mj"><img src="../Images/e5865b48f0bcc12c597f02750ef9fcee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0vFvTGsNV7BOZV3lPC1t7g.png"/></div></div></figure><p id="2f4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没什么有趣的。让我们来看看<strong class="jp ir">使</strong>功能:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mj"><img src="../Images/7fc55277cc6611ec1707db05457b6acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvojg1Xk1jwKoCx4TX-_1w.png"/></div></div></figure><p id="0812" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从“index_in_array”变量可以看出，我们最多只允许分配10个块。此外，这个变量表示给当前块的索引。</p><p id="4daf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只能分配0xf8区块和0x178区块。然后，使用全局变量，分配的块指针和它们相应的<em class="kp">输入大小(不是分配的块的大小，如果检查块头的话是0x 100)</em>被存储在内存中:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mk"><img src="../Images/3d148dcdbd8f1ab208955adb029b6b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtIKYsZYSyv0B1RyLuKXVA.png"/></div></div></figure><p id="9bae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，在上面的<em class="kp">第一个while循环</em>中，它是:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ml"><img src="../Images/53af5d51530dac498829a72b9435372a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iel145jHFu5VaIiuOz3_Ig.png"/></div></div></figure><p id="0cbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为plVar1是指针，+2作为指针数学执行，这意味着它将plVar1保存的地址增加16(由于是64位二进制，所以1地址是8字节)。</p><p id="76e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码还表明，给当前块的<em class="kp">索引依赖于“size_addr”中的第一个非空大小。</em></p><p id="d519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mm"><img src="../Images/acdedfac30f464e47911b8fa845eb388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0V6efX0n8PqaUzGgSC4eiA.png"/></div></div></figure><p id="14b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，它将用户数据读入分配的块，直到遇到空字节或换行符。因为计数器变量“uVar3”在读取后递增，这允许我们以“输入大小+ 1”字节进行扫描。于是我们这里就有了<strong class="jp ir"> <em class="kp">单字节溢出</em> </strong>。</p><p id="e8dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们来看看<strong class="jp ir">销毁</strong>功能:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mm"><img src="../Images/941933371ba4f9508285ddd7f1291ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XKtlojmSngX9DW-S3rhZTg.png"/></div></div></figure><p id="d3e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它首先检查指向已分配块的指针是否已经为空，以避免双重释放。然后，它将指针、大小和内容设置为空并释放内存。所以我们没什么可以利用的。</p><p id="ba28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，<strong class="jp ir">显示</strong>功能:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mm"><img src="../Images/4df928457d0fcb9ae60affb7da9493dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x1h5rHg8R6CuLAEFVKyMWw.png"/></div></div></figure><p id="251d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，<strong class="jp ir"><em class="kp"/></strong>或许可以让我们打印出用户以外的数据？除此之外，这里没什么特别的。</p><p id="c5b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在既然libc版本≥ 2.26(见上)，就有了<strong class="jp ir"> <em class="kp"> tcache </em> </strong>，分别是:</p><blockquote class="km kn ko"><p id="107b" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">每个线程都有一个每线程缓存(称为tcache ),其中包含一个小的块集合，可以在不锁定arena的情况下访问这些块。这些块被存储为<strong class="jp ir">一个单链表</strong>的数组，类似于fastbins，但是链接指向有效负载(用户区域)而不是块头。<strong class="jp ir">每个bin包含一个大小的块</strong>，所以数组由块大小索引(间接)。与fastbins不同，tcache在每个bin  (tcache_count)中被限制允许多少块。如果对于给定的请求大小，tcache bin为空，则不使用下一个更大的块(可能会导致内部碎片)，而是使用正常的malloc例程，即锁定线程的arena并从那里开始工作。<br/><a class="ae kl" href="https://sourceware.org/glibc/wiki/MallocInternals#Thread_Local_Cache_.28tcache.29" rel="noopener ugc nofollow" target="_blank">https://sourceware . org/glibc/wiki/malloc internals # Thread _ Local _ Cache _ . 28 tcache . 29</a></p></blockquote><p id="565a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当分配块时，堆管理器执行以下策略<strong class="jp ir">，按顺序</strong>:</p><blockquote class="km kn ko"><p id="3a88" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated"><strong class="jp ir">试试<em class="iq"> fastbin/smallbin </em>回收策略</strong></p><p id="4c8e" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">-如果对应的<em class="iq">快速库</em>存在，尝试从那里找到一个块(并且也有机会用来自快速库的条目预填充<em class="iq"> tcache </em>)。</p><p id="09ad" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">-否则，如果相应的<em class="iq">小容器</em>存在，从那里分配(随着我们的进行，机会主义地预填充<em class="iq"> tcache </em>)。</p><p id="b6fc" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated"><strong class="jp ir">解决所有延期释放</strong></p><p id="349c" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">-否则“真正释放”快速箱中的条目，并将它们的合并块移动到<em class="iq">未排序的</em>箱。</p><p id="f49b" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">-检查<em class="iq">未分类</em>箱中的每个条目。如果合适，就停。否则，将未排序的条目放到相应的小/大bin中(可能会将小条目提升到<em class="iq"> tcache </em>中)<br/><a class="ae kl" href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/" rel="noopener ugc nofollow" target="_blank">https://azeria-labs . com/heap-exploitation-part-2-glibc-heap-free-bins/</a></p></blockquote><p id="a604" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们释放数据块时，它执行以下策略<strong class="jp ir">，按顺序</strong>:</p><blockquote class="km kn ko"><p id="bfa6" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">4.如果大块可以放进一个<em class="iq">t缓存</em>箱，把它存放在那里。</p><p id="fed1" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">5.如果块设置了<em class="iq"> M </em>位，通过<em class="iq"> munmap </em>将其返回给操作系统。</p><p id="8f02" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">6.否则，我们获得竞技场堆锁，然后:</p><p id="8669" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">-如果大块适合一个fastbin，就把它放在相应的fastbin上，我们就完成了。</p><p id="6e67" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">-如果块大于64KB，立即合并fastbins，并将合并后的块放在未排序的bin上。</p><p id="50d6" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">-将该块与小、大和未排序的容器中的相邻自由块前后合并。</p><p id="7269" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">-如果产生的块位于堆的顶部，则将其合并到堆的顶部，而不是将其存储在bin中。</p><p id="f4de" class="jn jo kp jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated">-否则将其存放在<em class="iq">未分类的箱子</em>中。(<em class="iq"> Malloc </em>稍后会将条目从未排序的箱子中放入小箱子或大箱子中)。</p></blockquote><p id="fa35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们的块将会在tcache中结束。现在每个tcache bin最多可以容纳7个相同大小的块<strong class="jp ir">。我们最多可以释放/分配10个块，那么最后3个空闲块去哪了？</strong></p><p id="6f97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kp">如最后一点所述，它进入未分拣的箱子。有趣的是，如果一个被释放的块是unsorted_bin </em>  <em class="kp">中唯一的块，那么它将</em> <strong class="jp ir"> <em class="kp">保存一个指向arena </em> </strong> <em class="kp">的指针。但是在我们的简单程序中，只有一个竞技场——主竞技场。所以我们得到一个</em> <strong class="jp ir"> <em class="kp">指针指向libc中的某个固定偏移量。</em></strong><em class="kp">(</em><a class="ae kl" href="https://drive.google.com/file/d/1eJskblBnGMOM-lKyDKcqVFh8EQG1GB48/view" rel="noopener ugc nofollow" target="_blank"><em class="kp">https://drive . Google . com/file/d/1 ejskblbngmom-lkydkcqvfh 8 eqg1 GB 48/view</em></a><em class="kp">)</em></p><p id="9dfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查看这在gdb中是什么样子，分配8个≤ 0xf8字节的块，释放它们，再次分配8个≤ 0xf8字节的块，内容为“AAAAAAAA ”,然后显示第8个块的内容。然后，我们只需获取输出的最后8个字节:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mn"><img src="../Images/2771359a4395269984e04bf3df8a6217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgNp930_67zDwvTn2DRYkA.png"/></div></div></figure><p id="8e75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后用vmmap找到libc基址，从中减去“0x00007ffff7fedca0”得到偏移量:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mo"><img src="../Images/d8b870925438385c47ca421280d2d55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1die2RxoP4qlTQs6ReaLEA.png"/></div></div></figure><p id="e82a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们能够泄漏libc，这给了我们一个提示，也许我们应该尝试调用一个execve小工具？</p><h1 id="4b36" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">剥削</h1><p id="262f" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">到目前为止，我们已经:</p><ul class=""><li id="b360" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated">一个字节溢出到下一个块的大小。</li><li id="528a" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">libc泄密。</li></ul><p id="42fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，tcache bins是链表，所以如果我们可以修改指向下一个空闲块的指针(tcache中的一个空闲块),那么我们应该能够分配一个任意的块？</p><p id="508c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们把它修改到哪里呢？在二进制文件中，我们没有任何有用的函数可以重定向。但是，我们可以修改它，在“<strong class="jp ir"> __malloc_hook </strong>”处分配一个块，这是一个自定义函数，在调用“malloc”时会自动调用。然后我们用one_gadget填充“_malloc_hook”，这样当我们分配一个新的块时，我们将弹出一个shell！！！</p><p id="050c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘣！！！我觉得这是个好计划。现在我们只需要找出一种方法来修改tcache中空闲块的指针。</p><p id="6fc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回想一下在前面的侦察部分，我们有一个一字节溢出到下一个块的大小。让我们假设<strong class="jp ir">下一个块被分配</strong>。因此，如果我们<em class="kp">将其大小</em> e修改为0x181，然后<em class="kp">释放</em>它，它将<em class="kp">在0x180字节的tcache bin </em>中结束，而不是在0xf8字节的tcache bin中结束。然后，如果我们分配另一个&gt; 0xf8字节的块，由于程序的算法，我们将尝试分配一个0x178的块。所以我们得到了相同的块，但这次我们被允许将≥ 0xf9字节填充到它的0xf8字节存储区中！！</p><p id="8980" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘣！！！我们在修改后的块中进行任意写入。如果那个块被释放，并且在tcache bin中，那么我们可以重写它的指针，指向“<strong class="jp ir"> __malloc_hook </strong>”。之后，我们继续在tcache bin中分配块，直到我们到达“__malloc_hook”，然后我们将我们的地址填入one_gadget。最后我们再分配一个chunk来触发“__malloc_hook”，弹出一个shell！！！！！！！</p><p id="56ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要记住的一件重要事情是，我们必须小心表示块的输入索引:在<strong class="jp ir"> make </strong>函数中，算法遍历全局变量(包含指向块的指针),直到遇到空指针，然后将该索引分配给当前块。此外，因为<strong class="jp ir"> <em class="kp"> tcache是LIFO，我们以与释放它们的顺序相反的顺序取回数据块</em> </strong>。</p><p id="a1f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一件需要记住的重要事情是，我们不能在输入中提供空字节，因为make函数只能读取到遇到' \0 '或' \n '为止。</p><h1 id="78c5" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">总结我们的攻击计划</h1><ol class=""><li id="4a50" class="mp mq iq jp b jq lr ju ls jy nd kc ne kg nf kk ng mv mw mx bi translated">分配10块0xf8字节。释放前8个。用内容“A”* 8重新分配8个块。</li><li id="263a" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk ng mv mw mx bi translated">显示第8块的内容。解压缩最后8个字节，从偏移量中减去，并设置libc基址。</li><li id="d2e3" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk ng mv mw mx bi translated">以这样的方式释放0xf8块，当我们<strong class="jp ir"> <em class="kp">重新分配它们时，我们按此顺序得到块</em> </strong>:前面的块防止向后合并，其大小将被覆盖的块，将执行大小覆盖的块，其指针将被覆盖到“__malloc_hook”的块，最后的块防止向前合并。</li><li id="b13a" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk ng mv mw mx bi translated">按照上面的顺序重新分配块，第三个块应该有内容“A”* 0x F8+chr(0x 81)。</li><li id="4a76" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk ng mv mw mx bi translated">释放第二个块，它将在0x180字节的bin中结束，因为它的大小被第三个块的内容覆盖。</li><li id="b5c4" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk ng mv mw mx bi translated">释放第4个块，它将在0xf8字节的bin中结束。</li><li id="8627" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk ng mv mw mx bi translated">分配一个0x178字节的块，我们将得到旧的第二个块。用“__malloc_hook”的“A”* 0x F8+“B”* 8+地址填充。现在，第四个块的指针被设置为“__malloc_hook”。</li><li id="72a5" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk ng mv mw mx bi translated">分配一个0xf8字节的块，我们将得到第4个块。</li><li id="9685" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk ng mv mw mx bi translated">分配另一个0xf8字节的块，我们将得到“__malloc_hook”。填入one_gadget的地址。</li><li id="9203" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk ng mv mw mx bi translated">分配另一个块来触发“__malloc_hook”，从而触发one_gadget。</li><li id="fde5" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk ng mv mw mx bi translated">享受你的贝壳吧！！:)</li></ol><p id="f9df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我的漏洞利用python代码的链接:<a class="ae kl" href="https://github.com/wechicken456/nightmare_solutions/blob/main/dcquals19_babyheap/my_exploit.py" rel="noopener ugc nofollow" target="_blank">https://github . com/we chicken 456/nightman _ solutions/blob/main/dcquals 19 _ baby heap/my _ exploit . py</a></p><p id="71d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哇哦，那很有趣。像一个字节溢出这样的小错误会造成如此灾难性的后果。</p><p id="7224" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有任何问题，请随时评论或dm我的不和谐！</p><p id="dbc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不和谐:tuz#9881</p><p id="7435" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">github:【https://github.com/wechicken456 T2】</p><p id="7283" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝你生日快乐！直到下一次..</p></div></div>    
</body>
</html>