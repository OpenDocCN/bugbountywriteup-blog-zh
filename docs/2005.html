<html>
<head>
<title>The toddler’s introduction to Heap Exploitation, FastBin Dup to Stack (Part 4.1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学走路的孩子对堆利用的介绍，FastBin Dup to Stack(第4.1部分)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-to-stack-part-4-1-425592a2870b?source=collection_archive---------5-----------------------#2022-04-11">https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-to-stack-part-4-1-425592a2870b?source=collection_archive---------5-----------------------#2022-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章是与x64 Linux二进制开发技术相关的系列文章的一部分。在我以前的帖子中，我从探索简单的堆栈损坏错误及其缓解技术开始，逐渐发展到更复杂的主题。在上一篇文章中，我深入研究了使用先前已经释放的内存的概念，在堆内存利用的上下文中，这种错误被称为<strong class="jp ir">释放后使用</strong> (UAF)。</p><p id="ff8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续这个思路，在这篇文章中，我将讨论一种称为<em class="kl"> fastbin dup to stack、<a class="ae km" href="https://github.com/shellphish/how2heap" rel="noopener ugc nofollow" target="_blank">https://github.com/shellphish/how2heap</a>repo中引用的</em>的堆利用技术。也就是说，从我们停止的地方开始，这里是我以前文章的链接:</p><ul class=""><li id="8067" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated"><a class="ae km" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8" rel="noopener">堆利用入门(第1部分)</a></li><li id="8ccd" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><a class="ae km" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-2-d1f325b74286" rel="noopener">堆利用入门(第二部分)</a></li><li id="b7d3" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><a class="ae km" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-overflows-part-3-d3d1aa042d1e" rel="noopener">堆利用入门——溢出(第3部分)</a></li><li id="dc1a" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><a class="ae km" href="https://valsamaras.medium.com/use-after-free-13544be5a921" rel="noopener">堆利用的幼儿入门——免费后使用&amp;双免费(第四部分)</a></li></ul><h2 id="b385" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">FastBin双自由堆栈</h2><p id="1923" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">这种攻击利用双重释放漏洞来迫使<code class="fe lz ma mb mc b"><strong class="jp ir">calloc</strong></code>返回一个指向受控位置(在这种情况下是堆栈)的假块。我将使用对<strong class="jp ir"> how2heap的</strong>示例稍加修改的版本，可以在这里找到:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/f38c39b1ac2db4ba927ac7c86daf2456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tTb-rD-V6AYYYCtMeep-FQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><strong class="bd ld">图1:</strong><a class="ae km" href="https://github.com/shellphish/how2heap/blob/master/glibc_2.23/fastbin_dup_into_stack.c" rel="noopener ugc nofollow" target="_blank">https://github . com/shellphish/how 2 heap/blob/master/glibc _ 2.23/fastbin _ dup _ into _ stack . c</a></figcaption></figure><p id="3676" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将在本例中使用的代码如下所示:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f79a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一步一步地看看这段代码在做什么:</p><ul class=""><li id="ed49" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">因为我们想要描述一种fastbin利用技术，并且当请求内存分配时，分配器首先使用tcache，所以代码在第12行到第19行通过分配七个相同大小的块来“打包”tcache。这将强制分配器使用fastbins列表:</li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/c2dddcd61403875d12182b29880f91df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*lrkk5Nl73L_89uNH-CAwAA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><strong class="bd ld">图2: </strong>打包tcache列表</figcaption></figure><ul class=""><li id="fe0f" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">然后，它创建三个新的分配，将它们分配给<code class="fe lz ma mb mc b">a, b, c</code>变量，并为<code class="fe lz ma mb mc b">a</code>调用两次free函数(double free ):</li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mw"><img src="../Images/4b7bf5abeaee142e0b26ce59a6aef301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SxtU-qxXVJFsrLpMB7IRQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><strong class="bd ld">图3: </strong>双击<code class="fe lz ma mb mc b">a</code>指针</figcaption></figure><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mx"><img src="../Images/a383f7f4ff368c3f093f87c35ad8784a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3qxjGpMol-fAfoFw3pNPQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><strong class="bd ld">图4: </strong>广发双免视图</figcaption></figure><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi my"><img src="../Images/5f7a218dc196a97b788459b9b19d0161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5nuwrceg6n46I2hWHUXJA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><strong class="bd ld">图5: </strong>在fastbins列表中，第一个和最后一个块指向同一个地址。</figcaption></figure><ul class=""><li id="0f85" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">对<strong class="jp ir"> calloc </strong>的<strong class="jp ir"> </strong>接下来的两个调用将从fastbins列表中返回块，但是由于双重空闲，fastbins中仍将有一个条目指向已分配的块:</li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mz"><img src="../Images/c83412bbbaba52beabd4b1995f9a01a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DaVZ9Ad2eIoYMoR-0lNcyg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><strong class="bd ld">图6: </strong>对calloc的下两个呼叫</figcaption></figure><p id="244a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了验证上述内容，将程序加载到gdb中，并跟踪对calloc的两次调用所返回的地址:</p><p id="1e9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">先是</strong> <code class="fe lz ma mb mc b"><strong class="jp ir">calloc(1,8)</strong></code> <strong class="jp ir"> → </strong> <code class="fe lz ma mb mc b"><strong class="jp ir">0x0000555555559790</strong></code></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi na"><img src="../Images/5b7148602ea666927fbebd13ed975121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*nQUU3sZbWWjANle5XQmvkw.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><strong class="bd ld">图7: </strong>块地址返回到$rax</figcaption></figure><p id="581e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二个</strong> <code class="fe lz ma mb mc b"><strong class="jp ir">calloc(1,8)</strong></code> <strong class="jp ir"> → </strong> <code class="fe lz ma mb mc b"><strong class="jp ir">0x00005555555597b0</strong></code></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/b7853ea050b54f5385de1033fb11ad01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*6E0PlRkAQAociwUPb47k1A.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><strong class="bd ld">图8: </strong>块地址返回到$rax</figcaption></figure><p id="d2f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">fastbins中的一个条目仍然指向分配的块<code class="fe lz ma mb mc b"><strong class="jp ir">(0x0000555555559790)</strong></code>:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/51106200a8776a8a07480e614315518c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*IET1HoE2FUDPFK-AfHOtEg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><strong class="bd ld">图9: </strong>在fastbin列表中仍然有一个条目指向一个分配的块</figcaption></figure><ul class=""><li id="ecfb" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">在第61行中，程序模拟了攻击者控制<code class="fe lz ma mb mc b">d</code>指针的情况，该指针(到目前为止)指向一个正在使用且空闲(同时)的块:</li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nd"><img src="../Images/da2d40603d8a5f6e452cdc2082267533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JFO8WqZI8GsLI1hYcKEhQg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><strong class="bd ld">图10: </strong> d指向stack_var的地址，而fastbin中有一个条目指向同一个内存地址</figcaption></figure><ul class=""><li id="1b27" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">在<code class="fe lz ma mb mc b">d</code>被分配到<code class="fe lz ma mb mc b"><strong class="jp ir">stack_var</strong></code> <strong class="jp ir"> </strong>的地址后，一个伪链接将被添加到fastbins列表中，该列表现在将包含两个块(d指向的块和伪块):</li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ne"><img src="../Images/a3cf1542de2c4b2555b95e75df66d8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nAoyAuNMwc1cA7R5Z57pQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><strong class="bd ld">图11:</strong>fastbin列表包含一个指向堆栈的节点</figcaption></figure><p id="10fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于第一次拟合，下一次分配将在0x555555559790分配区块:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/31494884459ebc3fa71136d47bad77ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*nQfb2nGj9l0A7OCJ7SbZFg.png"/></div></figure><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ng"><img src="../Images/034101ef2feddab97388c562fbcfd2b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnqyA0McFKPTF-X1TTsUxw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><strong class="bd ld">图12: </strong>对malloc的调用从fastbins中删除了head块</figcaption></figure><p id="0dae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对类似大小的malloc的后续调用将返回0x 7 ffffff e2f 0处的假块，如编译和运行程序后所示:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nh"><img src="../Images/ddffc86e8c6ae648c8418dc071841e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Q7uASCSRlMKWMx762sTqg.png"/></div></div></figure><p id="2aa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终样本已推送至此:<a class="ae km" href="https://github.com/shellphish/how2heap/blob/master/glibc_2.31/fastbin_dup.c" rel="noopener ugc nofollow" target="_blank">https://github . com/shellphish/how 2 heap/blob/master/glibc _ 2.31/fastbin _ dup . c</a></p></div></div>    
</body>
</html>