<html>
<head>
<title>Detect Dangerous Spring Service Exporters With CodeQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CodeQL检测危险的Spring服务导出程序</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/detect-dangerous-spring-service-exporters-with-codeql-c3c800b7b2de?source=collection_archive---------1-----------------------#2021-03-25">https://infosecwriteups.com/detect-dangerous-spring-service-exporters-with-codeql-c3c800b7b2de?source=collection_archive---------1-----------------------#2021-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0167" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何确定CVE-2016-1000027不影响你的申请</h2></div><p id="5952" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇博文中，我将讨论用CodeQL查询检测不安全的Spring Exporters。首先，我将描述收到CVE-2016-1000027的问题。接下来，我将展示易受攻击的代码是什么样的，以及如何在应用程序中缓解这个问题。然后，我将描述CodeQL查询是如何工作的。此外，我将展示查询中发现的几个漏洞。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/8f5d192311b1895644c1c4f7f64781af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0Gl9LFtWrO4ef97p"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">照片由<a class="ae lu" href="https://unsplash.com/@asthetik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·肯尼利</a>在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7f18" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是春季出口商？</h1><p id="7a86" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">Spring框架提供了将服务bean导出为端点的类。服务导出器从传入的请求中读取数据，然后将数据传递给底层bean。数据可以包含序列化的对象。</p><p id="d54d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，<code class="fe mz na nb nc b">HttpInvokerServiceExporter</code>和<code class="fe mz na nb nc b">SimpleHttpInvokerServiceExporter</code>类将指定的服务bean导出为HTTP端点。这些导出器扩展了使用默认Java反序列化机制来解析传入请求中的数据的<code class="fe mz na nb nc b">RemoteInvocationSerializingExporter</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="778c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是CVE-2016-1000027？</h1><p id="288e" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">默认的Java反序列化机制可以通过<code class="fe mz na nb nc b">ObjectInputStream</code>类获得。这种机制很容易受到攻击。如果攻击者可以让应用程序反序列化恶意数据，在最坏的情况下，可能会导致任意代码执行。</p><p id="ecbc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Spring的<code class="fe mz na nb nc b">RemoteInvocationSerializingExporter</code>使用默认的Java反序列化机制来解析数据。因此，扩展它的所有类都容易受到反序列化攻击。弹簧框架至少包含延伸出<code class="fe mz na nb nc b">RemoteInvocationSerializingExporter</code>的<code class="fe mz na nb nc b">HttpInvokerServiceExporter</code>和<code class="fe mz na nb nc b">SimpleHttpInvokerServiceExporter</code>。这些导出器使用不安全的Java反序列化机制解析来自HTTP主体的数据。</p><p id="15de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae lu" href="https://www.tenable.com/security/research/tra-2016-20" rel="noopener ugc nofollow" target="_blank">该问题被Tenable </a>发现并报告。问题收到<a class="ae lu" href="https://nvd.nist.gov/vuln/detail/CVE-2016-1000027" rel="noopener ugc nofollow" target="_blank"> CVE-2016-1000027 </a>。Spring团队对此做出了回应，摒弃了易受攻击的类，并在文档中添加了一条注释，警告用户关于<a class="ae lu" href="https://github.com/spring-projects/spring-framework/issues/24434" rel="noopener ugc nofollow" target="_blank">问题</a>。他们建议避免使用危险的服务出口商。</p><p id="4115" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">老实说，如果不破坏使用易受攻击的服务导出器的应用程序，似乎不可能解决这个问题。对此类问题的通常解决方法是在反序列化之前检查序列化的对象是否是允许的类的实例。这可以通过覆盖<code class="fe mz na nb nc b">ObjectInputStream.resolveClass()</code>方法或使用Apache Commons IO中的<code class="fe mz na nb nc b">ValidatingObjectInputStream</code>来完成。这里的关键是默认的允许类列表。如果默认列表是限制性的，该修复可能会破坏应用程序。如果列表是许可的，那么应用程序在默认情况下仍然容易受到攻击，用户需要明确指定允许的安全类来消除漏洞。Spring团队决定不提供在易受攻击的导出器中配置允许反序列化的类的方法。</p><p id="964e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CVE-2016-1000027在NVD发布后，安全扫描器开始针对使用Spring框架的应用程序报告此问题。由于Spring框架最近非常流行，许多用户都收到了这样的警告。许多用户的问题是他们不知道如何处理这些提醒。这个问题不能仅仅通过更新应用程序中的Spring Framework版本来解决，因为Spring Framework没有解决这个问题的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0c82" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">易受攻击的代码示例</h1><p id="7cdf" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">使用一个不安全的服务导出器很容易使应用程序变得易受攻击。以下示例显示了基于<code class="fe mz na nb nc b">HttpInvokerServiceExporter</code>的易受攻击的HTTP端点:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f142" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个例子展示了如何在Spring框架的XML配置中定义相同的端点:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="98e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于演示目的，我还为CVE-2016-1000027 编写了一个简单的<a class="ae lu" href="https://github.com/artem-smotrakov/cve-2016-1000027-poc" rel="noopener ugc nofollow" target="_blank"> PoC。这是一个简单的Spring应用程序，它使用了一个易受攻击的服务导出器。该存储库包含一个针对易受攻击端点的演示漏洞利用。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d4c4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何减轻CVE-2016-1000027</h1><p id="fb22" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">最好的方法是停止使用<code class="fe mz na nb nc b">HttpInvokerServiceExporter</code>和<code class="fe mz na nb nc b">SimpleHttpInvokerServiceExporter</code>或者任何其他基于<code class="fe mz na nb nc b">RemoteInvocationSerializingExporter</code>的出口商。相反，可以使用API端点的其他消息格式之一。比如JSON。确保底层反序列化机制配置正确，这样反序列化攻击就不可能发生。</p><p id="6169" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果易受攻击的出口商不能被替换，考虑使用在<a class="ae lu" href="https://openjdk.java.net/jeps/290" rel="noopener ugc nofollow" target="_blank"> JEP 290 </a>中引入的全局反序列化过滤器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="85f1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用于检测不安全Spring导出器的CodeQL查询</h1><p id="f61e" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated"><a class="ae lu" href="https://securitylab.github.com/tools/codeql" rel="noopener ugc nofollow" target="_blank"> CodeQL </a>是一个代码分析引擎。它允许您为代码编写查询来检测各种问题，包括安全问题。让我们看看它如何帮助我们检测不安全的Spring服务出口商。</p><p id="03d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上面的代码片段所示，不安全的服务导出器可以用两种方式定义:</p><ul class=""><li id="a39e" class="nf ng it kk b kl km ko kp kr nh kv ni kz nj ld nk nl nm nn bi translated">Spring配置类中创建bean的方法</li><li id="d08e" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">XML配置中的bean</li></ul><p id="34f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CodeQL可以涵盖这两种方式。这正是我们所需要的。</p><p id="e625" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Spring配置类中，我们需要寻找以下方法:</p><ul class=""><li id="9068" class="nf ng it kk b kl km ko kp kr nh kv ni kz nj ld nk nl nm nn bi translated">该类应该有一个使其成为配置的注释。例如，<code class="fe mz na nb nc b">@Configuration</code>标注。</li><li id="fca6" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">该方法应该返回一个扩展<code class="fe mz na nb nc b">RemoteInvocationSerializingExporter</code>的类的实例。</li><li id="57ae" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">该方法应该有<code class="fe mz na nb nc b">@Bean</code>注释。</li></ul><p id="4b8d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的CodeQL查询实现了这些想法:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b784" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在XML配置中，我们只需要寻找使用扩展了<code class="fe mz na nb nc b">class</code>属性中的<code class="fe mz na nb nc b">RemoteInvocationSerializingExporter</code>的类的<code class="fe mz na nb nc b">&lt;bean&gt;</code>元素。以下简单的CodeQL查询实现了这一点:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9e0f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果安全扫描器针对您的应用程序报告CVE-2016-1000027，您可以使用上面的CodeQL查询来检查应用程序是否真的易受攻击。<a class="ae lu" href="https://github.com/github/codeql/pull/5260" rel="noopener ugc nofollow" target="_blank">这些查询也被添加到CodeQL实验查询包</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2f81" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="afea" class="nf ng it kk b kl mu ko mv kr nt kv nu kz nv ld nk nl nm nn bi translated"><a class="ae lu" href="https://docs.spring.io/spring-framework/docs/2.0.x/reference/remoting.html" rel="noopener ugc nofollow" target="_blank">使用Spring的远程和web服务</a></li><li id="9377" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><a class="ae lu" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/rmi/RemoteInvocationSerializingExporter.html" rel="noopener ugc nofollow" target="_blank"> Spring文档—remote invocationserializingexporter</a></li><li id="d983" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><a class="ae lu" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/remoting/httpinvoker/HttpInvokerServiceExporter.html" rel="noopener ugc nofollow" target="_blank"> Spring文档— HttpInvokerServiceExporter </a></li><li id="0363" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><a class="ae lu" href="https://codeql.github.com/docs/" rel="noopener ugc nofollow" target="_blank"> CodeQL文档</a></li></ul></div></div>    
</body>
</html>