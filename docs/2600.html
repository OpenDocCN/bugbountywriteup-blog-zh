<html>
<head>
<title>Anti-Reversing Techniques (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">防逆转技术(二)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/anti-reversing-techniques-part-2-bd5e0d3cd7aa?source=collection_archive---------6-----------------------#2022-12-05">https://infosecwriteups.com/anti-reversing-techniques-part-2-bd5e0d3cd7aa?source=collection_archive---------6-----------------------#2022-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="49f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一部分中，我们讨论了恶意软件作者用来保护他们的应用程序免受逆向工程的一些常用技术。在第二部分中，我们将会看到更多用于检测和防止逆向工程的方法和技术。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h2 id="5e04" class="ks kt iq bd ku kv kw dn kx ky kz dp la jy lb lc ld kc le lf lg kg lh li lj lk bi translated">调试器检测:</h2><h2 id="c996" class="ks kt iq bd ku kv kw dn kx ky kz dp la jy lb lc ld kc le lf lg kg lh li lj lk bi translated"><strong class="ak">代码执行计时技术:</strong></h2><p id="4253" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">当使用调试器分析可执行文件时，有时我们使用单步执行来遍历一些汇编指令，执行的时间会比正常执行长得多，让我们以这段代码为例:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/8477f578bc9dcf46503f85ec4e83ecc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_BerRnHGK0aDIEmshO_Rw.png"/></div></div></figure><p id="6bbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在代码的开头，我们有一个对“<strong class="jp ir"> GetTickCount </strong>”函数的调用，该函数返回自系统启动以来经过的毫秒数。根据我在机器上的测量，执行“<strong class="jp ir"> ShellExecuteW </strong>”函数之前的代码需要30到47毫秒。之后我们再次调用"<strong class="jp ir"> GetTickCount </strong>"函数来获取时间，然后获取两个调用值之间的差值，如果超过70毫秒则退出进程，否则打印消息。</p><p id="b2ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有其他Windows APIs可用于获取时间，例如:</p><ul class=""><li id="3dd7" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">GetLocalTime()。</li><li id="9688" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">GetSystemTime()。</li><li id="26f6" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">QueryPerformanceCounter()。</li></ul></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h2 id="de20" class="ks kt iq bd ku kv kw dn kx ky kz dp la jy lb lc ld kc le lf lg kg lh li lj lk bi translated">软件断点:</h2><p id="4adf" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">软件断点是一种常见的反调试技术，被恶意行为者用来增加对他们的恶意软件进行逆向工程的难度。这种技术包括在程序的特定位置插入特定的代码指令，称为断点。当程序执行时，断点会导致程序停止运行，使得调试器很难分析程序的行为。</p><p id="9e30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用汇编语言实现断点的一种方法是使用<code class="fe mq mr ms mt b">int 3</code>指令。这个指令是一个软件中断，它导致程序停止运行，并将控制权转移给调试器。下面是一个如何在C++中使用<code class="fe mq mr ms mt b">int 3</code>指令的例子:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mu"><img src="../Images/7d7481f321671853b4017c3ce72952e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4aPI2iUfY0_vwF2QIU3HQQ.png"/></div></div></figure></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h2 id="c0e6" class="ks kt iq bd ku kv kw dn kx ky kz dp la jy lb lc ld kc le lf lg kg lh li lj lk bi translated">硬件断点:</h2><p id="ce96" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">硬件断点是一种反调试技术，它使用CPU的专用硬件功能来检测和防止程序调试。这项技术包括在特定的内存地址或寄存器上设置断点，然后指示CPU在程序访问或修改指定的地址或寄存器时触发中断。</p><p id="771f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是如何检查是否设置了硬件断点的示例:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mv"><img src="../Images/544c1348366474f89db3bdbba3a895b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33-0FT_UQJioXxAhpt-hSQ.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">"检查硬件断点"</figcaption></figure><p id="d40f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何调试寄存器中的非零值都可能表示该进程正在设置了硬件断点的调试器下运行。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h2 id="13b2" class="ks kt iq bd ku kv kw dn kx ky kz dp la jy lb lc ld kc le lf lg kg lh li lj lk bi translated">自调试:</h2><p id="3fd1" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">是恶意软件作者使用的一种技术，用于防止调试器附加到进程或检查进程是否在调试器下。它包括使用调试器来调试程序本身，以便检测和防止其他调试器附加到程序上。</p><p id="abd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个实例示例，它创建流程的第二个实例，并创建一个名为“debugger_present”的命名事件。进程的第二个实例将尝试将调试器附加到父进程，如果失败，它将设置事件，该事件将向父进程指示另一个调试器已附加到它:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi na"><img src="../Images/0a14db33c35bf1f07d4d08a79b88e2c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRfVZblYjdb6NmGfE-Dlsw.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">父进程</figcaption></figure><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi na"><img src="../Images/c6383d83f73082e22b33747ccc44326a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHLIusquuURd7Ufcbv5FbA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">子进程</figcaption></figure></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h2 id="b4d2" class="ks kt iq bd ku kv kw dn kx ky kz dp la jy lb lc ld kc le lf lg kg lh li lj lk bi translated">UnhandledExceptionFilter()</h2><p id="a99c" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">如果程序遇到任何已注册的异常处理程序都无法处理的异常，则kernel32！将调用UnhandledExceptionFilter()函数。可以使用<strong class="jp ir"> kernel32注册一个定制的未处理异常过滤器！SetUnhandledExceptionFilter()。</strong>但是，如果正在调试程序，则不会调用自定义过滤器，而是将异常传递给调试器。因此，如果将控制传递给未处理的异常筛选器，则可以推断程序没有在调试器下运行:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nb"><img src="../Images/ff9fbb053f24100d1af7458a615504b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YxOKJZ6RhYxNSafOBkZeYg.png"/></div></div></figure></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="5394" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢你花时间阅读这篇文章，直到下次。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h2 id="fa8b" class="ks kt iq bd ku kv kw dn kx ky kz dp la jy lb lc ld kc le lf lg kg lh li lj lk bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae nc" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4个线程、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>