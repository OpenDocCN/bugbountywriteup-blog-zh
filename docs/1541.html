<html>
<head>
<title>Kubernetes Container Escape With HostPath Mounts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有主机路径挂载的Kubernetes容器转义</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/kubernetes-container-escape-with-hostpath-mounts-d1b86bd2fa3?source=collection_archive---------3-----------------------#2021-08-23">https://infosecwriteups.com/kubernetes-container-escape-with-hostpath-mounts-d1b86bd2fa3?source=collection_archive---------3-----------------------#2021-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1e2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您使用Kubernetes，将主机文件系统作为一个卷安装到容器中应该会让您夜不能寐。我来解释一下原因。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ba0437eaeb82aaf69781b28520ea0025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34_SfcEcC9guWzfQkEtbpQ.png"/></div></div></figure><h2 id="8966" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">什么是“卷”？</h2><p id="0be0" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">因为容器应该是短暂的和无状态的，所以它们需要某种方法在容器之外保存数据。在某些情况下，他们甚至需要<strong class="jp ir">持久的</strong>数据存储，即使在容器重启后也能被访问。</p><p id="46e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有许多不同的卷类型，例如awsElasticBlockStore卷类型。此外部卷类型将EBS卷装入您的容器。如果您的容器重新启动，新的容器将挂载EBS卷来备份从以前的容器保存的数据。</p><p id="d468" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是也有可能使用本地存储来实现持久性。这意味着使用Kubernetes worker节点的主机文件系统。使用这个本地<strong class="jp ir">主机路径</strong>卷类型引入了一些有趣的安全隐患。Kubernetes文档甚至提出了这样的警告:</p><blockquote class="lv lw lx"><p id="2b01" class="jn jo ly jp b jq jr js jt ju jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj kk ij bi translated"><strong class="jp ir">警告:</strong></p><p id="66f3" class="jn jo ly jp b jq jr js jt ju jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj kk ij bi translated">主机路径卷存在许多安全风险，最佳做法是尽可能避免使用主机路径。当必须使用HostPath卷时，它的范围应该仅限于所需的文件或目录，并且以只读方式装载。</p></blockquote><p id="151f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有兴趣深入了解容器挂载是如何工作的，我建议您研究一下linux名称空间原语，特别是挂载名称空间。但是这对于理解这篇博文的其余部分是不必要的。</p><h2 id="38d8" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">如何创建卷？</h2><p id="86bd" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">可以在pod的Kubernetes yaml清单中声明卷。您可以指定<code class="fe mc md me mf b">.spec.volumes</code>和<code class="fe mc md me mf b">.spec.containers[*].volumeMounts</code>来指定它是哪种类型的卷，以及在容器中的什么位置安装它。</p><p id="e30c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个pod的例子，它创建了一个容器，将主机的根目录挂载到容器内部的<code class="fe mc md me mf b">/host</code>。</p><pre class="km kn ko kp gt mg mf mh mi aw mj bi"><span id="7d76" class="kx ky iq mf b gy mk ml l mm mn"><strong class="mf ir">apiVersion</strong>: v1<br/><strong class="mf ir">kind</strong>: Pod<br/><strong class="mf ir">metadata</strong>:<br/>  <strong class="mf ir">name</strong>: test-pd<br/><strong class="mf ir">spec</strong>:<br/>  <strong class="mf ir">containers</strong>:  <br/>  - <strong class="mf ir">image</strong>: alpine<br/>    <strong class="mf ir">name</strong>: test-container<br/>    <strong class="mf ir">command</strong>: ["tail"]<br/>    <strong class="mf ir">args</strong>: <!-- -->["-f", "/dev/null"]<!-- --> <br/>    <strong class="mf ir">volumeMounts</strong>:<br/>    - <strong class="mf ir">mountPath</strong>: /host<br/>      <strong class="mf ir">name</strong>: test-volume<br/>  <strong class="mf ir">volumes</strong>:<br/>  - <strong class="mf ir">name</strong>: test-volume<br/>    <strong class="mf ir">hostPath</strong>:<br/>      <em class="ly"># directory location on host</em><br/>      <strong class="mf ir">path</strong>: /<br/>      <em class="ly"># this field is optional</em><br/>      <strong class="mf ir">type</strong>: Directory</span></pre><p id="e5a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们运行这个pod并在其中执行一个shell，我们可以看到我们可以访问主机的根文件系统。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mo"><img src="../Images/6894564ae79eeba40fed5450da6f4e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4hcbG3pgjSKHYja8z6BYQQ.gif"/></div></div></figure><p id="1b36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此……任何能够创建不受限制地访问主机路径卷的pod的人都可以轻松提升他们的权限。</p><h2 id="d13a" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">这怎么能被利用…真的吗？</h2><p id="28a8" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">希望没有人真的将根文件系统直接挂载到他们的容器中。一个更现实的例子是作用于特定目录的HostPath卷。例如，让我们修改原始示例:</p><pre class="km kn ko kp gt mg mf mh mi aw mj bi"><span id="f3e4" class="kx ky iq mf b gy mk ml l mm mn"><strong class="mf ir">apiVersion</strong>: v1<br/><strong class="mf ir">kind</strong>: Pod<br/><strong class="mf ir">metadata</strong>:<br/>  <strong class="mf ir">name</strong>: test-pd<br/><strong class="mf ir">spec</strong>:<br/>  <strong class="mf ir">containers</strong>:  <br/>  - <strong class="mf ir">image</strong>: alpine<br/>    <strong class="mf ir">name</strong>: test-container<br/>    <strong class="mf ir">command</strong>: ["tail"]<br/>    <strong class="mf ir">args</strong>: <!-- -->["-f", "/dev/null"]<!-- --> <br/>    <strong class="mf ir">volumeMounts</strong>:<br/>    - <strong class="mf ir">mountPath</strong>: /var/log/host<br/>      <strong class="mf ir">name</strong>: test-volume<br/>  <strong class="mf ir">volumes</strong>:<br/>  - <strong class="mf ir">name</strong>: test-volume<br/>    <strong class="mf ir">hostPath</strong>:<br/>      <em class="ly"># directory location on host</em><br/>      <strong class="mf ir">path</strong>: /var/log<br/>      <em class="ly"># this field is optional</em><br/>      <strong class="mf ir">type</strong>: Directory</span></pre><p id="6135" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从安全的角度来看，这个例子仍然有缺陷，但是我已经看到它在专业领域的合理使用。</p><p id="4fcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不管出于什么原因，这个pod可以访问主机的<code class="fe mc md me mf b">/var/log</code>目录。一旦我们考虑Kubernetes日志记录实际上是如何工作的，这就特别有趣了。运行<code class="fe mc md me mf b">kubectl logs test-pd </code>时，kubelet返回/var/log/pods/&lt;path _ to _ 0 . log&gt;的内容。但是从主机的角度来看，pod的0.log文件是一个符号链接。由于我们挂载了/var/log并拥有写访问权限，因此我们可以将日志文件symlink覆盖到任意文件。让我们用/etc/shadow的符号链接替换这个test-pd的日志文件符号链接。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mo"><img src="../Images/c2848cb9459917dc0c76be44a9dfcecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ozq55jouQq1VgCF0DsEbug.gif"/></div></div></figure><p id="7c1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们可以读取/etc/shadow的内容。完整的内容无法打印，因为它们不是预期的日志格式，但这可以通过使用<code class="fe mc md me mf b">kubectl logs &lt;pod&gt; --tail=&lt;line number&gt;</code>查看完整的内容来解决。</p><h2 id="e038" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">缓解措施</h2><p id="33c2" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">有几种方法可以防止与主机路径卷相关的潜在错误配置。</p><ol class=""><li id="f235" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated"><strong class="jp ir">将主机路径卷的范围限定到特定目录。</strong></li></ol><p id="d847" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保指定一个必要的<code class="fe mc md me mf b">spec.volumes.hostpath.path</code>目录。否则，请避免一起使用主机路径。</p><p id="3095" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">确保主机路径卷是只读的。</strong></p><p id="6f53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">装载卷时，您可以将其设置为只读模式。</p><pre class="km kn ko kp gt mg mf mh mi aw mj bi"><span id="e1f1" class="kx ky iq mf b gy mk ml l mm mn"><strong class="mf ir">volumeMounts</strong>:<br/>    - <strong class="mf ir">mountPath</strong>: /var/log/host<br/>      <strong class="mf ir">name</strong>: test-volume<br/>      <strong class="mf ir">readOnly</strong>: true</span></pre><p id="3bdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">***奖励点:使用容器优化操作系统，如Google的容器优化操作系统或AWS的Bottlerocket，它们默认包含只读根文件系统。</p><p id="6f5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir">通过准入控制器限制对主机路径卷的访问。</strong></p><p id="7d74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着PodSecurityPolicies现在被弃用，并且目前没有确定的标准，我建议使用<a class="ae my" href="https://github.com/open-policy-agent/gatekeeper" rel="noopener ugc nofollow" target="_blank">开放策略代理网关守卫</a>或<a class="ae my" href="https://kyverno.io/" rel="noopener ugc nofollow" target="_blank"> Kyverno </a>来定义关于HostPath卷的策略。</p><p id="4b5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个完全拒绝HostPath的Kyverno集群策略。</p><div class="mz na gp gr nb nc"><a href="https://kyverno.io/policies/pod-security/baseline/disallow-host-path/disallow-host-path/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">不允许主机路径</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">⭐️如果你喜欢Kyverno，在GitHub上给它一颗星吧！⭐️ Kyverno吊舱安全政策类别最低版本主题…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">kyverno.io</p></div></div></div></a></div><h2 id="fe63" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">额外资源</h2><p id="badd" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">有一篇很棒的Aquasec博客文章深入探讨了利用日志主机路径错误配置的问题。</p><div class="mz na gp gr nb nc"><a href="https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">Kubernetes吊舱逃生使用日志安装</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">Kubernetes有许多活动部件，有时以某种方式组合它们会产生意想不到的安全缺陷。在…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">blog.aquasec.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq kv nc"/></div></div></a></div><p id="9a0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">BishopFox很好地描述了更多的主机路径利用。</p><div class="mz na gp gr nb nc"><a href="https://github.com/BishopFox/badPods/tree/main/manifests/hostpath" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">主BishopFox/badPods的bad pods/manifest/host path</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">在这种情况下，即使您无权访问主机的进程或网络名称空间，如果管理员没有…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="nr l nn no np nl nq kv nc"/></div></div></a></div></div></div>    
</body>
</html>