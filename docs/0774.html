<html>
<head>
<title>Vault 101 : Samsung CTF App Reverse Engineering Challenge Write-up</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跳马101:三星CTF应用逆向工程挑战赛报道</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/vault-101-samsung-ctf-android-reverse-engineering-challenge-write-up-d5a2b16a9212?source=collection_archive---------2-----------------------#2020-08-18">https://infosecwriteups.com/vault-101-samsung-ctf-android-reverse-engineering-challenge-write-up-d5a2b16a9212?source=collection_archive---------2-----------------------#2020-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0a0e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">报道三星SCTF的Android逆向工程挑战赛:使用基于逆向工程的纯静态分析的Vault 101。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1d8f4bcb2f0f3b9eb38b6388c186806a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jTnNS1bEaBb735VPTtRVzg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kr"><img src="../Images/34ee65cdbdb687ff2fda5d171cc77968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iY2f9GUbHfT5FlAVKVwvqA.png"/></div></div></figure><h1 id="9429" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">背景</h1><p id="d39d" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">不要浪费你太多的时间，奔向<em class="mg">好东西，</em>这里有一些基本信息。关于三星的虚拟CTF事件“<strong class="lm ir">黑客的游乐场2020 </strong>”。</p><blockquote class="mh mi mj"><p id="33d0" class="lk ll mg lm b ln mk jr lp lq ml ju ls mm mn lv lw mo mp lz ma mq mr md me mf ij bi translated">挑战:<strong class="lm ir">找到密码。</strong></p><p id="8521" class="lk ll mg lm b ln mk jr lp lq ml ju ls mm mn lv lw mo mp lz ma mq mr md me mf ij bi translated">给定的文件:<strong class="lm ir">vault 101–1.1-release . apk</strong></p><p id="6821" class="lk ll mg lm b ln mk jr lp lq ml ju ls mm mn lv lw mo mp lz ma mq mr md me mf ij bi translated">混淆级别= <strong class="lm ir">高</strong></p><p id="2b5d" class="lk ll mg lm b ln mk jr lp lq ml ju ls mm mn lv lw mo mp lz ma mq mr md me mf ij bi translated">求解数= 15</p></blockquote><p id="b27d" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">好消息来了。</p><h1 id="ffb3" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">应用分析</h1><p id="9aea" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">在挑战中，我们得到一个apk文件，你可以从<a class="ae ms" href="https://github.com/FrigidSec/CTFWriteups/blob/master/SCTF/Vault101/_docs/challengeApp/Vault101-1.1-release.apk" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</p><p id="9f74" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">作为静态分析过程的第一步，我们将使用JADX反编译应用程序。你可以通过你电脑上的工具或者使用任何可用的<a class="ae ms" href="http://www.javadecompilers.com/apk" rel="noopener ugc nofollow" target="_blank">基于网络的服务</a>来完成这项工作。</p><p id="dc15" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">得到应用程序的反编译版本后，让我们开始吧。</p><h2 id="2356" class="mt kt iq bd ku mu mv dn ky mw mx dp lc lt my mz le lx na nb lg mb nc nd li ne bi translated">查找主类</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/84edca6a7746cbfbb657fbb97e13a6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7fvlSP4UZuqxMLbY5R5fw.png"/></div></div></figure><p id="ac56" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">当应用程序被反编译时，您通常会看到类似这样的内容，因此我们将遵循主活动最常见的位置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/ec0521292db9ed18a123ba5451f5af63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U8DSB5xQ2fN1ed6DwLY2DQ.png"/></div></div></figure><p id="feb8" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">我们这里有一些有希望的东西。让我们打开MainActivity.java检查一下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9c1f" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">在上面的代码中我们可以看到，代码的这个突出部分负责显示好的或坏的消息:</p><blockquote class="mh mi mj"><p id="5a7e" class="lk ll mg lm b ln mk jr lp lq ml ju ls mm mn lv lw mo mp lz ma mq mr md me mf ij bi translated">boolean a2 =<strong class="lm ir"><em class="iq">this</em>. s . a(<em class="iq">this</em>. p . gettext()。toString())；</strong></p><p id="5590" class="lk ll mg lm b ln mk jr lp lq ml ju ls mm mn lv lw mo mp lz ma mq mr md me mf ij bi translated">吐司toast =新吐司(<em class="iq">这个</em>)；</p><p id="ddce" class="lk ll mg lm b ln mk jr lp lq ml ju ls mm mn lv lw mo mp lz ma mq mr md me mf ij bi translated">toast . set view(getLayoutInflater()。膨胀(<strong class="lm ir"> a2？r . layout . toast _ success _ layout:r . layout . toast _ fail _ layout</strong>，(view group)findViewById(r . id . custom _ toast _ container))；</p></blockquote><p id="54a1" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">所以现在我们知道，我们需要从“s.a()”函数中获得“true”布尔值来获得好的toast。</p><p id="af28" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">还要注意,“s.a”实际上是“public volatile b.c.a.b ”,因此我们需要导航到该类，该类将在各自的文件夹中提供，所以让我们转到那里:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/0e6a81a21e56531f97021a4605bbf59e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mj_tzvvuNfsBymQ_mquesA.png"/></div></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3343" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">让我们一起来看看a.java:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="614d" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">现在这个类被高度混淆了，我们只看到它向<code class="fe nk nl nm nn b"><strong class="lm ir">c.java</strong>'s<strong class="lm ir"> d()</strong> function</code>发送了一些乱码数据</p><p id="ddfe" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">以类似的方式跟踪所有的类，我们得到以下信息</p><blockquote class="mh mi mj"><p id="470d" class="lk ll mg lm b ln mk jr lp lq ml ju ls mm mn lv lw mo mp lz ma mq mr md me mf ij bi translated"><code class="fe nk nl nm nn b">1. c.java is performing some kind of string manipulation</code></p><p id="d7a5" class="lk ll mg lm b ln mk jr lp lq ml ju ls mm mn lv lw mo mp lz ma mq mr md me mf ij bi translated"><code class="fe nk nl nm nn b">2. a.java is sending encoded function names to call and getting result from c.java</code></p><p id="2e7c" class="lk ll mg lm b ln mk jr lp lq ml ju ls mm mn lv lw mo mp lz ma mq mr md me mf ij bi translated"><code class="fe nk nl nm nn b">3. we need to reconstruct function names by reversing the gibberish names via c.d()</code></p></blockquote><h1 id="bb6b" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">了解加密和反混淆</h1><p id="173f" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">让我们看看c.java</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c55a" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">我们不需要反转它，因为这是用于规范化函数调用的函数。</p><p id="5512" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">检查一下，我在java程序中实现了相同的功能:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="427e" class="mt kt iq nn b gy ns nt l nu nv">public static int <em class="mg">INTGET</em>=1;<br/><br/>public static char a(char c, int i) {<br/>    return (char) (c &amp; ((1 &lt;&lt; i) ^ 65535));<br/>}<br/>public static char b(char c, int i) {<br/>    return (char) (c | (1 &lt;&lt; i));<br/>}<br/>public static char c(char c, int i) {<br/>    return (char) ((c &amp; (1 &lt;&lt; i)) &gt;&gt; i);<br/>}<br/>public static String d(CharSequence charSequence, int i) {<br/>    StringBuilder sb = new StringBuilder();<br/>    if (i == 0) {<br/>        return sb.toString();<br/>    }<br/>    for (int i2 = 0; i2 &lt; charSequence.length(); i2++) {<br/>        char charAt = charSequence.charAt(i2);<br/>        char c = (char) (i &gt;&gt; (i2 % 4));<br/>        int i3 = i2 % 3;<br/>        if (i3 == 0) {<br/>            for (int i4 = 0; i4 &lt; 8; i4 += 2) {<br/>                char c2 = (char) (<em class="mg">c</em>(charAt, i4) ^ <em class="mg">c</em>(c, i4));<br/>                if (c2 == 0) {<br/>                    charAt = <em class="mg">a</em>(charAt, i4);<br/>                } else if (c2 == 1) {<br/>                    charAt = <em class="mg">b</em>(charAt, i4);<br/>                }<br/>            }<br/>        } else if (i3 == 1) {<br/>            for (int i5 = 1; i5 &lt; 8; i5 += 2) {<br/>                char c3 = (char) (<em class="mg">c</em>(charAt, i5) ^ <em class="mg">c</em>(c, i5));<br/>                if (c3 == 0) {<br/>                    charAt = <em class="mg">a</em>(charAt, i5);<br/>                } else if (c3 == 1) {<br/>                    charAt = <em class="mg">b</em>(charAt, i5);<br/>                }<br/>            }<br/>        } else if (i3 == 2) {<br/>            for (int i6 = 0; i6 &lt; 8; i6++) {<br/>                char c4 = (char) (<em class="mg">c</em>(charAt, i6) ^ <em class="mg">c</em>(c, i6));<br/>                if (c4 == 0) {<br/>                    charAt = <em class="mg">a</em>(charAt, i6);<br/>                } else if (c4 == 1) {<br/>                    charAt = <em class="mg">b</em>(charAt, i6);<br/>                }<br/>            }<br/>        }<br/>        sb.append((char) (charAt ^ <em class="mg">INTGET</em>));<br/>    }<br/>    return sb.toString();<br/>}</span></pre><p id="d804" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">现在，如果我们将参数传递给函数，我们会看到它们被转换成android关键字。</p><p id="dee0" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">例如:</p><p id="ac98" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">这是在a.java:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/9855a91b27da9b9ae1a51eba41e38f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IIEMu7mucwsq-JK3lc0oOQ.png"/></div></div></figure><p id="711d" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">我们将把d()的参数传递给我们的程序:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/d6358d0a36aee9f531c626fab74ebf72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ZzEJo_zu3FsCVknM0bV7g.png"/></div></div></figure><p id="65f8" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">我们得到以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/4c614e4f4f19aaae1be00f8ab3c7de2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*3CIpQpwIqUynZIy0BperaA.png"/></div></figure><p id="9081" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">看到了吗？在对所有的d()调用执行了此操作并清理了一些代码之后，我们得到了类似于:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/8649860645927394d2f368da76725c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nSGSypvlqBcD368bUOK5dA.png"/></div></div></figure><p id="041b" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">看到了吗？整个crypt实现。</p><p id="d3e2" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">因此从这里我们得到以下信息:</p><blockquote class="mh mi mj"><p id="05e5" class="lk ll mg lm b ln mk jr lp lq ml ju ls mm mn lv lw mo mp lz ma mq mr md me mf ij bi translated"><code class="fe nk nl nm nn b">1. All the actual function calls are encoded in some custom encoding and can be reversed by implementing the same function in java</code></p><p id="dd02" class="lk ll mg lm b ln mk jr lp lq ml ju ls mm mn lv lw mo mp lz ma mq mr md me mf ij bi translated"><code class="fe nk nl nm nn b">2. Class 'a' is handling Encryption for the application</code></p><p id="3297" class="lk ll mg lm b ln mk jr lp lq ml ju ls mm mn lv lw mo mp lz ma mq mr md me mf ij bi translated"><code class="fe nk nl nm nn b">3. Encryption used is AES with Cipher Block Chaining (CBC) and PKCS5Padding : this can be implemented in java also, we just need the key.</code></p></blockquote><h1 id="2ede" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">获取标志</h1><p id="c1c2" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">在清除上述所有代码并重新研究应用程序后，我们得到以下信息:</p><ol class=""><li id="5e4c" class="oa ob iq lm b ln mk lq ml lt oc lx od mb oe mf of og oh oi bi translated">用户输入一些字符串= <strong class="lm ir"> ustr </strong></li><li id="2b71" class="oa ob iq lm b ln oj lq ok lt ol lx om mb on mf of og oh oi bi translated">应用程序使用AES和一个base64硬编码密钥对字符串进行加密= <strong class="lm ir"> AES.e(ustr) </strong></li><li id="aebf" class="oa ob iq lm b ln oj lq ok lt ol lx om mb on mf of og oh oi bi translated">应用程序对base64 =<strong class="lm ir">b64 . e(AES . e(USTR))</strong>中的密文进行编码</li><li id="e2f2" class="oa ob iq lm b ln oj lq ok lt ol lx om mb on mf of og oh oi bi translated">然后将其与硬编码的字符串(<strong class="lm ir"> HcS </strong>)进行比较，并返回布尔值</li></ol><p id="c80f" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">这意味着HcS也是使用名称流加密的，我们可以反转它</p><p id="11aa" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">我们需要找到<strong class="lm ir"> B64.d(AES.d(HcS)) = Flag </strong></p><p id="95b1" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">为此，我用java重新构建了加密算法和所有参数。</p><p id="41f4" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">他们将<strong class="lm ir">键存储在资源中的arrays.xml </strong>中，并将<strong class="lm ir"> HcS存储在资源中的strings.xml </strong>中</p><p id="8074" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">这里需要注意的一点是，密钥也编码在我们之前找到的自定义算法中。但是因为我们已经重建了它，我们可以再次使用它来完成这一部分。在应用程序中，密钥通过</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="ccf9" class="mt kt iq nn b gy ns nt l nu nv">a.<strong class="nn ir">class.getDeclaredFields()</strong>[0].set(null,DECODEDKEY);</span></pre><h2 id="ed26" class="mt kt iq bd ku mu mv dn ky mw mx dp lc lt my mz le lx na nb lg mb nc nd li ne bi translated">要破解的最终代码</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9cb9" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">我还删除了a.java的加密部分，因为我们不需要它。</p><p id="acdd" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">运行上面的代码后，我们得到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/9ca1c7a98c426b7481448672992f06fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*rBKoDYMQQZt2BJrr5m70AA.png"/></div></figure><p id="85c1" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">这是我们的旗帜:</p><p id="c79f" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated"><strong class="lm ir">SCTF { 53 cur 17y _ 7 HR 0 u 6h _ 085 cur 17y _ 15 _ N07 _ 3n 0 u 6h }</strong></p><h1 id="5a5e" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">结论</h1><p id="fe76" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">这是一个有趣的挑战，找出使用的编码和代码的重建花费了90%的时间。</p><p id="7c3d" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">自己试试，你会喜欢的！</p><p id="7518" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">如果你有足够的兴趣，<a class="ae ms" href="https://saket-upadhyay.github.io/2020/08/18/sstf-vault-wtireup.html" rel="noopener ugc nofollow" target="_blank">这里是这个解决方案的详细和更长的版本</a>，深入解释了这个方法。:)</p><p id="5805" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">下次再见，直到保持足够的咖啡因！</p></div><div class="ab cl op oq hu or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ij ik il im in"><p id="e969" class="pw-post-body-paragraph lk ll iq lm b ln mk jr lp lq ml ju ls lt mn lv lw lx mp lz ma mb mr md me mf ij bi translated">资源:</p><div class="ow ox gp gr oy oz"><a href="https://saket-upadhyay.github.io/2020/08/18/sstf-vault-wtireup.html" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd ir gy z fp pe fr fs pf fu fw ip bi translated">三星CTF应用程序反向工程。详细记录</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">三星CTF“黑客乐园2020”逆向工程挑战赛综述积分:500解答:15我拿了…</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">saket-upadhyay.github.io</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn kp oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://www.tutorialspoint.com/java/lang/class_getdeclaredfields.htm" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd ir gy z fp pe fr fs pf fu fw ip bi translated">Java . lang . class . getdeclaredfields()方法</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">Java . lang . class . getdeclaredfields()方法返回一个Field对象数组，包括public、protected、default…</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">www.tutorialspoint.com</p></div></div><div class="pi l"><div class="po l pk pl pm pi pn kp oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://mkyong.com/java/java-aes-encryption-and-decryption/" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd ir gy z fp pe fr fs pf fu fw ip bi translated">Java AES加密和解密-Mkyong.com</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">高级加密标准(AES，Rijndael)是分组密码加密和解密算法，最常用的…</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">mkyong.com</p></div></div><div class="pi l"><div class="pp l pk pl pm pi pn kp oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://developer.android.com/reference/android/os/Parcel.html" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd ir gy z fp pe fr fs pf fu fw ip bi translated">包裹|安卓开发者</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">AccessibilityServiceMagnificationController . OnMagnificationChangedListener</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">developer.android.com</p></div></div><div class="pi l"><div class="pq l pk pl pm pi pn kp oz"/></div></div></a></div></div></div>    
</body>
</html>