<html>
<head>
<title>Norec Attack: Stripping BLE encryption from Nordic’s Library (CVE-2020–15509)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Norec攻击:从Nordic的库中剥离BLE加密(CVE-2020–15509)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/norec-attack-stripping-ble-encryption-from-nordics-library-cve-2020-15509-9798ab893b95?source=collection_archive---------1-----------------------#2020-07-03">https://infosecwriteups.com/norec-attack-stripping-ble-encryption-from-nordics-library-cve-2020-15509-9798ab893b95?source=collection_archive---------1-----------------------#2020-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/797c4896674bdfb0c82d641f2bf1f056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EqgIPnmpfMYI0vBH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">塞巴斯蒂安·肖尔兹(努基)在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f509" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文讨论了我在一个几乎每个android应用程序都基于的库中发现的一个漏洞，并结合了一个导致该漏洞形成的android bug。</p><h1 id="d68a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">蓝牙低能耗:结合</h1><p id="01db" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如今，许多应用程序希望对其流量进行加密，以保护传输数据的机密性。因此，在蓝牙低能量标准中，必须在加密之前进行一个称为绑定过程。当两个设备被绑定时，这意味着它们已经交换了LTK密钥，因此通信被加密。通信的安全性将在另一篇文章中分析，但是让我们假设BLE提供的保护是好的。此外，请记住，绑定不是必需的，必须由两个配对器件中的一个启动。</p><h1 id="54be" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Android API作为中央设备绑定:困惑</h1><p id="fb49" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Android开发人员可以使用createBond()函数来绑定BLE设备。理想情况下，如果创建了绑定，该函数应该返回true。不幸的是，在Android API中有一个混乱(我已经报告过)，当双方都存储了密钥，并且在未来的绑定事件中使用这些密钥时，即使绑定发生了并且流量被加密，该函数也会返回false。</p><h1 id="83c6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">站在脆弱巨人的肩膀上</h1><p id="13e9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Nordic Semiconductors创建了少数几个易于使用的Android库，帮助开发人员轻松处理蓝牙低能耗连接。我在这个库中发现了一个漏洞，在这个漏洞中，对手可以剥离BLE加密，但是由于处理不当，用户认为流量是加密的。</p><p id="57ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Nordic的两个半导体库受到影响:</p><ul class=""><li id="0411" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">【https://github.com/NordicSemiconductor/Android-BLE-Library T4】</li><li id="580b" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><a class="ae kc" href="https://github.com/NordicSemiconductor/Android-DFU-Library" rel="noopener ugc nofollow" target="_blank">https://github.com/NordicSemiconductor/Android-DFU-Library</a></li></ul><p id="1bd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开发人员使用安卓BLE库来处理BLE连接。<br/>Android-DFU库被开发者用来无线升级他们的BLE固件。</p><p id="df17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我只测试了几个随机的BLE应用程序，它们确实使用了BLE债券，并且利用了北欧图书馆的债券功能。我检查过的应用程序如下:</p><ul class=""><li id="6c26" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">卡琳(一款价值约200美元的智能自行车锁的应用)——com . linka . Lock app . AOS</li><li id="cd45" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">智能锁—services . singularity . smart Lock</li><li id="3e26" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">一把价值60美元的智能锁</li><li id="cf30" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">米洛克斯ble</li><li id="1fb0" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">nRF连接(北欧的产品)</li><li id="161a" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">Mi Home — com.xiaomi.smarthome</li></ul><p id="9f80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个不依赖nordic库的应用程序是phantom lock，然而Phantom Lock(com . plantraco . coolapps . Phantom Lock)创建了一个绑定，而没有检查绑定过程的结果。</p><p id="3e00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">nordic的两个图书馆的漏洞是一样的。所以我们将只检查两个库中的一个:Android-DFU-Library</p><p id="ca34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该漏洞可在no.nordicsemi.android.dfu/BaseDfuImpl类中找到</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="87ad" class="nb lc iq mx b gy nc nd l ne nf">/**<br/>	 * Creates bond to the device. Works on all APIs since 18th (Android 4.3).<br/>	 *<br/>	 * @return true if it's already bonded or the bonding has started<br/>	 */<br/>	@SuppressWarnings("UnusedReturnValue")<br/>	boolean createBond() {<br/>		final BluetoothDevice device = mGatt.getDevice();<br/>		if (device.getBondState() == BluetoothDevice.BOND_BONDED)<br/>			return true;<br/><br/>		boolean result;<br/>		mRequestCompleted = false;<br/><br/>		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Starting pairing...");<br/>		if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {<br/>			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.getDevice().createBond()");<br/>			result = device.createBond();<br/>		} else {<br/>			result = createBondApi18(device);<br/>		}<br/><br/>		// We have to wait until device is bounded<br/>		try {<br/>			synchronized (mLock) {<br/>				while (!mRequestCompleted &amp;&amp; !mAborted)<br/>					mLock.wait();<br/>			}<br/>		} catch (final InterruptedException e) {<br/>			loge("Sleeping interrupted", e);<br/>		}<br/>		return result;<br/>	}</span></pre><p id="d23c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">nordic的函数createBond被开发者调用来保护移动设备和外围设备(例如，可以是心率监测设备)之间的通信。</p><p id="a352" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开发人员调用getBondState()来获取当前的绑定状态，而不是启动并强制启动加密过程。人们可能会认为这是正确的做法，因为在android文档中，乍一看，一切都很好:</p><div class="ng nh gp gr ni nj"><a href="https://developer.android.com/reference/android/bluetooth/BluetoothDevice#getBondState%28%29" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">蓝牙设备|安卓开发者</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">AccessibilityServiceMagnificationController . OnMagnificationChangedListener</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">developer.android.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jw nj"/></div></div></a></div><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/81900d3f375de3bb167a78a8dbd8d635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjutaTmdQ2zFw4l5WRRfdQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">类BluetoothDevice，方法getBondState()，最新Android API</figcaption></figure><p id="d31b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过检查这种方法，我们没有发现任何可能出错的地方。该函数返回远程设备的绑定状态，可以是BOND_NONE、BOND_BONDING或BOND_BONDED。</p><p id="a502" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现这具有误导性，因为它误导了开发人员，让他们误以为getBondState()将返回刚刚发生的绑定状态。然而事实并非如此。让我们检查BOND_BONDED状态:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/592cc6d83432438978552c5fe0fd394b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SOgKe2CBUTlhbG2jshqag.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://developer.android.com/reference/android/bluetooth/BluetoothDevice#BOND_BONDED" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/reference/Android/蓝牙/蓝牙设备#BOND_BONDED </a></figcaption></figure><p id="da42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果密钥存储在设备上，getBondState()将返回状态(常量)BOND_BONDED。这并不一定意味着该设备当前与配对的设备绑定。这意味着通信可以是明文。请记住，即使移动设备根本没有与任何设备配对，也可能会返回此状态(BOND_BONDED)。这是因为状态BOND_BONDED只是一个指示，表明所检查的蓝牙设备已经在android系统上存储了密钥，并且可以使用。</p><p id="149a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开发人员显然被android的文档误导了，认为getStateBond()方法将返回当前的绑定状态，因此如果状态为BOND_BONDED，则返回true。这可以解释为:如果密钥存在于设备上，则返回true(加密开启),尽管绑定可能已经失败。</p><h1 id="c073" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">袭击</h1><p id="0f4b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">攻击的媒介有很多。最明显的一种是攻击外围设备，以消除可用于按键的插槽。每个物联网设备上的大多数BLE芯片组都具有有限的内存大小，因此旧密钥(不同设备的)会被新密钥替换。通过伪装BDADDR，然后绑定几百次到目标外设，可以驱逐所有以前的密钥。这样，所有以前的LTK密钥都会被逐出，转储密钥会存储在设备上。最后，这将帮助我们实现我们的目标，因为库中的bug不会默认创建绑定，并且用户会被通知连接是安全的(我们不需要做任何进一步的步骤，流量将在没有任何进一步操作的情况下被加密)。</p><p id="7e44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种攻击手段是在两个配对设备配对之前劫持通信。在连接请求时，对手可以劫持连接，并作为外围设备做出响应，指示外围设备的存储器中没有存储密钥。这不是一个很难实现的攻击，因为连接请求是在广告信道上发起的，并且这些信道是静态的(没有FHSS)。</p><h1 id="0119" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">困惑= Bug =漏洞</h1><p id="e93b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">下面我给出了一些我对每个设备状态的发现，android的本地createBond()方法的结果，以及预期的结果。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a204b4242e78b0225c035323a313c4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*nwdRsLqq67ngPIfPjBOdgw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">粘合FSM工作台</figcaption></figure><p id="a0ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在最后一行中所观察到的，当密钥同时存在于两个设备上时，createBond()起初似乎有问题并返回false。这使得开发人员开发健壮的包装器变得更加困难，并且经常会导致开发人员产生bug，例如nordic的库的bug，不幸的是，这是一个安全bug。</p><p id="b7ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，即使createBond()返回false，通信仍然是加密的，并且发生了绑定。这是因为该调用是异步的，并且在蓝牙服务中发现，如果当前状态不是BOND_NONE，则返回false。这很令人困惑。</p><p id="4acc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我和nordic的PSIRT团队有过一次交流:</p><blockquote class="ob oc od"><p id="49cc" class="kd ke oe kf b kg kh ki kj kk kl km kn of kp kq kr og kt ku kv oh kx ky kz la ij bi translated"><em class="iq">…我们的团队确认了一个问题，尽管Android显示绑定状态为“已绑定”,但仍能连接到一个已擦除绑定信息的设备。<br/>不过，问题似乎出现在安卓方面。每当绑定信息出现在客户端(Android)时，Android上的方法createBond()都会返回false，当它出现在外围设备端时也是如此。因此，这两种情况(双方的有效债券和客户端的债券信息，因此未加密的链接)是不可区分的。……<br/>[</em>与北欧的PSIRT团队<em class="iq"> ] </em>沟通的一部分</p></blockquote><p id="7b88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">nordic告诉我的有一部分是真的。当客户机有密钥而PE没有时，它是安全的，应该返回false，因为返回true将是一个主要的安全问题。这是因为如果外设没有密钥，用户应该得到警告(否则攻击可能已经发生)。如果可以强制执行重新配对，这是可以避免的，但android不支持这种中级操作。答案是部分正确的，因为正如我之前提到的，android确实提供了一个令人困惑的返回输出。</p><h1 id="e4fc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第一个不安全补丁</h1><blockquote class="ob oc od"><p id="3264" class="kd ke oe kf b kg kh ki kj kk kl km kn of kp kq kr og kt ku kv oh kx ky kz la ij bi translated">…为了检查设备是否配对(这不是100%可靠)，我们确实要检查CCCD在重新连接后是否仍然启用。这是假设CCCD状态是为绑定的设备保留的，这通常是真的，并且可以在远程设备上伪装成该设备(相同的地址，默认启用CCCD)。<br/>因此，在Android上，如果不使用第三方加密机制从使用GATT的设备中获取这些信息，似乎无法检查您是否真正绑定。<br/>在调用createBond()之前不检查焊接状态会导致错误，即使器件焊接正确。<br/>我们建议您就此问题联系谷歌……<br/>【与Nordic的PSIRT团队沟通的一部分】</p></blockquote><p id="f546" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们已经用远离安全解决方案的解决方案修补了库。</p><p id="6762" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们的改变显示如下(他们只改变了安卓-BLE-库，因为安卓-DFU-库还没有打补丁)。</p><p id="c99b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">易受攻击的函数createBond()的修补版本:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1d3c" class="nb lc iq mx b gy nc nd l ne nf">private boolean internalCreateBond() {<br/>    final BluetoothDevice device = bluetoothDevice;<br/>    if (device == null)<br/>        return false;<br/><br/>    log(Log.VERBOSE, "Starting bonding...");<br/><br/>    // Warning: The check below only ensures that the bond information is present on the<br/>    //          Android side, not on both. If the bond information has been remove from the<br/>    //          peripheral side, the code below will notify bonding as success, but in fact the<br/>    //          link will not be encrypted! Currently there is no way to ensure that the link<br/>    //          is secure.<br/>    //          Android, despite reporting bond state as BONDED, creates an unencrypted link<br/>    //          and does not report this as a problem. Calling createBond() on a valid,<br/>    //          encrypted link, to ensure that the link is encrypted, returns false (error).<br/>    //          The same result is returned if only the Android side has bond information,<br/>    //          making both cases indistinguishable.<br/>    //<br/>    // Solution: To make sure that sensitive data are sent only on encrypted link make sure<br/>    //           the characteristic/descriptor is protected and reading/writing to it will<br/>    //           initiate bonding request.<br/>    if (device.getBondState() == BluetoothDevice.BOND_BONDED) {<br/>        log(Log.WARN, "Bond information present on client, skipping bonding");<br/>        request.notifySuccess(device);<br/>        nextRequest(true);<br/>        return true;<br/>    }<br/><br/>    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {<br/>        log(Log.DEBUG, "device.createBond()");<br/>        return device.createBond();<br/>    } else {<br/>        /*<br/>         * There is a createBond() method in BluetoothDevice class but for now it's hidden.<br/>         * We will call it using reflections. It has been revealed in KitKat (Api19).<br/>         */<br/>        try {<br/>            final Method createBond = device.getClass().getMethod("createBond");<br/>            log(Log.DEBUG, "device.createBond() (hidden)");<br/>            //noinspection ConstantConditions<br/>            return (Boolean) createBond.invoke(device);<br/>        } catch (final Exception e) {<br/>            Log.w(TAG, "An exception occurred while creating bond", e);<br/>        }<br/>    }<br/>    return false;<br/>}</span></pre><p id="7380" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我觉得他们的解决方案有点幼稚。它不能解决问题，并假设外围设备具有客户端特征配置描述符(这也可能是伪造的)。这是疯狂和不安全的。</p><h1 id="b72b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">攻击缓解和推荐的补丁</h1><p id="af0f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我已经建议了一种缓解技术，这种技术很容易实现，并且在google修复他们的框架之前可以保证应用程序的安全。我建议的缓解措施是，每当用户希望进行加密通信时，调用android的本机createBond()，然后检查结果。然后，检查当前的焊接状态。</p><p id="e8fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果结果为假，并且绑定状态为BOND_BONDED，则只需移除密钥并重试。</p><p id="7b8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果失败并且绑定状态是BOND_NONE，那么它只是失败了，现在您可以终止连接以保护用户的隐私。</p><p id="479a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了理解如何解决这个问题，让我们检查一下下面的召回表:</p><p id="1709" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在清除键之前</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/673127a960a3bd8dd7d4868d8a87a5f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*0dmCaCFf4dl89s1ZG_ComQ.png"/></div></figure><p id="043c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">擦除该键后</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/cfa28b85e8ad300dd5e939b59ea61225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*7qSkOFytbrvT2dobm0aGvg.png"/></div></figure><p id="ce48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开发人员必须注意的两个拐角情况是第二排情况和第四排情况。这是createBond()失败的两种情况。我们不知道密钥是否存在于另一边的事实，以及android中存在令人困惑的方法的事实，使我们无法区分那两种情况。但是，我们可以删除该键，这将把手机的状态转移到第一排和第三排的情况。这改变了我们的状态，createBond将在两种情况下返回true。这样，我们的通信是安全的，解决方案也很棒！</p><h1 id="8407" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">攻击限制</h1><p id="28b5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当中心希望连接到认证的特征时，攻击是有限的，因此必须进行绑定。在这种情况下，createBond无关紧要，绑定将正常发生，没有任何问题。</p><h1 id="b7b3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">协调漏洞披露时间表</h1><ul class=""><li id="6cb5" class="me mf iq kf b kg lz kk ma ko oj ks ok kw ol la mj mk ml mm bi translated">2020年6月23日:发现漏洞</li><li id="de6c" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">2020年6月24日:向Nordic的PSIRT发送漏洞报告</li><li id="3285" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">01/07/2020: Nordic的第一个补丁(仅在Android-BLE-图书馆上)</li><li id="0b7f" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">2020年2月7日:Nordic确认了安全漏洞</li><li id="ad1a" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">2020年2月7日:Nordic收到关于不安全补丁的通知</li><li id="a34e" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">2020年7月2日:CVE的请求</li><li id="976f" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">2020年7月2日:CVE被接收(CVE-2020-15509)</li><li id="cad4" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">2020年7月3日发布</li></ul><h1 id="2761" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">履行</h1><p id="4ab5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">攻击是用一个自定义工具实现的，我将在以后的文章中讨论。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/3154de12c2546e92f10829c53a821e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kPKj6zLCZkY81tTa.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">原型——Mark I——定制BLE评估套件，首开先河。</figcaption></figure><p id="df77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个产品的原型，我将在接下来的几个月推出。</p><p id="e810" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Java SDK尚未发布。</p><p id="f4ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用定制SDK和定制硬件的攻击只用了不到5行代码就完成了。整个程序不到100行代码。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="6b96" class="nb lc iq mx b gy nc nd l ne nf">private static void startNoricAttack(CEController ce) throws Exception<br/>	{<br/>		for(int i=0; i&lt;100; i++)<br/>		{<br/>                        selectRandomMac();</span><span id="c52d" class="nb lc iq mx b gy on nd l ne nf">			ce.connect(target, ConnectionTypesCommon.AddressType.RANDOM_STATIC_ADDR);<br/>			ce.bondNow(true);<br/>			try {Thread.sleep(100);}catch(InterruptedException iex) {}<br/>			ce.disconnect(19);<br/>			int peer_id = getPeerId();<br/>			ce.deletePeerBond(peer_id);<br/>		}<br/>	}</span></pre><p id="16b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更新:我创建了这个工具的一个精简版本，叫做BLE:bit。它是开源和开放硬件的。可以在这里找到:<strong class="kf ir"> blebit.io </strong></p></div></div>    
</body>
</html>