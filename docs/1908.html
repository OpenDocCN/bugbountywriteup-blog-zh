<html>
<head>
<title>SQLi: Next Level</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQLi:下一级</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/sqli-next-level-5b1145b83c79?source=collection_archive---------1-----------------------#2022-02-22">https://infosecwriteups.com/sqli-next-level-5b1145b83c79?source=collection_archive---------1-----------------------#2022-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="67c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使SQLMap' <code class="fe kl km kn ko b">--eval</code>也帮不上忙:)</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/fb643ecc9d349ef0155466c11ad60d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQndtRJ9XAkRWTSxGKiBYg.png"/></div></div></figure><p id="a64a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一些SQL注入，利用它们并不像你在道德黑客课程中看到的那样简单。比如当易受攻击的参数的值是base64编码时。在这种情况下你会怎么做？</p><p id="4e06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，你可能会使用<code class="fe kl km kn ko b">sqlmap</code>的<code class="fe kl km kn ko b">--base64</code>国旗。<br/>或者对于更复杂的场景，你可能想耍酷，使用<code class="fe kl km kn ko b">sqlmap</code>的脚本引擎，向<code class="fe kl km kn ko b">--eval</code>旗帜寻求帮助。</p><p id="a8f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果连强大的<code class="fe kl km kn ko b">--eval</code>功能都帮不上忙呢？那就是你需要提升知识的时候了。⏫</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="9228" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第一部分:易受攻击的功能</strong></p><p id="1093" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一次测试中，我测试了一个用于发送官方邮件和文件的应用程序。<br/>在收件箱部分，有过滤邮件的功能。通过使用下拉菜单，你可以告诉应用程序显示哪些邮件:<br/>未读邮件<br/>高优先级邮件<br/>带附件的邮件<br/>等。</p><p id="6772" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦选择了任何一个选项，就会发送一个POST请求。<br/>POST主体很奇怪，它是一个JSON，其中一个参数包含XML数据，一个XML标记的属性是易受攻击的SQL查询的输入。<br/>简化后的帖子正文:</p><pre class="kq kr ks kt gt li ko lj lk aw ll bi"><span id="5ca1" class="lm ln iq ko b gy lo lp l lq lr">{<br/>    "param1": "&lt;Search Filter='<strong class="ko ir">GIBBERISH HERE</strong>' Order='DESC' Sort='priority'/&gt;",<br/>    "param2": "something..",<br/>    ...<br/>}</span></pre><p id="cfee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ls">方法论</em> : <br/>我们这里有什么？SQL查询的输入</p><p id="bd61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以控制查询的哪些部分？<br/> 1。<br/>凡(过滤)2。排序依据(排序，顺序)</p><p id="a515" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查询结构可以是怎样的？</p><pre class="kq kr ks kt gt li ko lj lk aw ll bi"><span id="b98d" class="lm ln iq ko b gy lo lp l lq lr">SELECT <br/>  * <br/>FROM <br/>  letters <br/>WHERE <br/>  userid = 12345 <br/>  AND <strong class="ko ir">injection</strong> <br/>ORDER BY <br/>  <strong class="ko ir">injection</strong> <strong class="ko ir">injection</strong></span></pre><p id="fdbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它脆弱吗？<br/>由于查询中有几个注入点，一个简单的方法是确认注入是注释查询的一部分。</p><p id="f2e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:我们不能在WHERE部分注入，因为<code class="fe kl km kn ko b">Filter</code>参数的值是加密值的base64编码(最好说是混淆的)。这是本文的要点，我将向您展示我如何绕过实现的安全机制。😉</p><p id="7481" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始注射:</p><pre class="kq kr ks kt gt li ko lj lk aw ll bi"><span id="e271" class="lm ln iq ko b gy lo lp l lq lr">{<br/>    "param1": "&lt;Search Filter='GIBBERISH HERE' Order='DESC<strong class="ko ir">*/</strong>' Sort='priority<strong class="ko ir">/*</strong>'/&gt;",<br/>    "param2": "something..",<br/>    ...<br/>}</span></pre><p id="8857" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种注入影响后端查询的方式:</p><pre class="kq kr ks kt gt li ko lj lk aw ll bi"><span id="e89b" class="lm ln iq ko b gy lo lp l lq lr">SELECT <br/>  * <br/>FROM <br/>  letters <br/>WHERE <br/>  userid = 12345 <br/>  AND injection <br/>ORDER BY <br/>  injection<strong class="ko ir">/*</strong> <em class="ls">injection</em><strong class="ko ir">*/ &lt;-- (commented part)</strong></span></pre><p id="014f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">响应服务器返回的数据与之前相同，但是使用了不同的<em class="ls">排序</em>，这意味着注入成功了！</p><p id="c957" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好，<code class="fe kl km kn ko b">sqlmap</code>时间？<br/>我用了<code class="fe kl km kn ko b">sqlmap</code>但是无法确认漏洞。所以我开始再次手动测试，但仍然没有机会。</p><p id="fa61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那现在怎么办？放弃？不，那对我来说是禁止的。⛔</p><p id="95e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我决定处理参数<code class="fe kl km kn ko b">Filter</code>的乱码值，并破解加密。反正那样更酷，不是吗？😌但是有可能解密服务器端加密的字符串吗？</p><p id="3419" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> PRO TIP </strong> <br/>每当您在对服务器的请求中看到一个加密的值，但您在服务器的先前响应中找不到该值，这意味着该值很可能在客户端得到了加密。因此，深入研究JS文件并破解代码💣<br/>备注:使用<code class="fe kl km kn ko b">Logger++</code>的<code class="fe kl km kn ko b">Grep Values</code>标签，不勾选<code class="fe kl km kn ko b">Search Requests</code>。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="19e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二部分:逆向工程js代码<br/> </strong>我在服务器之前的响应中搜索了加密值，没有找到该值的任何实例，所以我可以非常肯定加密发生在客户端的JS代码中。<br/>好了，如何找到负责加密查询的js代码？<br/>第一条线索可以是请求本身:</p><pre class="kq kr ks kt gt li ko lj lk aw ll bi"><span id="d1a9" class="lm ln iq ko b gy lo lp l lq lr">{<br/>    "param1": "&lt;Search <strong class="ko ir">Filter</strong>='GIBBERISH HERE' Order='DESC' Sort='priority'/&gt;",<br/>    "param2": "something..",<br/>    ...<br/>}</span></pre><p id="0804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我搜索了包含乱码数据的参数名，并找到了构建XML数据的代码。<br/>不错，一个很好的起点。现在是分析代码的时候了。<br/>如何？使用有史以来最好的js调试工具:<strong class="jp ir"> chrome devtools </strong>😏</p><p id="4011" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">亲提示<br/> </strong>完整阅读本文档:<br/><a class="ae lt" href="https://developer.chrome.com/docs/devtools/javascript/" rel="noopener ugc nofollow" target="_blank">https://developer.chrome.com/docs/devtools/javascript/</a></p><p id="04d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">长话短说，通过使用<code class="fe kl km kn ko b">devtools</code>和设置一些断点，我发现了模糊值背后的工作流程:</p><p id="4462" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1。</strong>根据用户选择的下拉选项，将选择一个SQL查询:</p><pre class="kq kr ks kt gt li ko lj lk aw ll bi"><span id="e9d0" class="lm ln iq ko b gy lo lp l lq lr">function SelectFilter(selectedFilter) {<br/>    switch (selectedFilter) {<br/>        case "unread messages":<br/>            filter = "mailType = 1"<br/>            break;</span><span id="89e9" class="lm ln iq ko b gy lu lp l lq lr">        case "high priority":<br/>            filter = "mailType = 1"<br/>            break;</span><span id="91f1" class="lm ln iq ko b gy lu lp l lq lr">        case "having attachment":<br/>            filter = "mailType = 1"<br/>            break;<br/>    }<br/>    return filter;<br/>}</span></pre><p id="1f85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。</strong>然后对查询进行加密:</p><pre class="kq kr ks kt gt li ko lj lk aw ll bi"><span id="07a8" class="lm ln iq ko b gy lo lp l lq lr">function encrypt(Filter){<br/>    // grep session token<br/>    <br/>    // mix the query with session token<br/>    <br/>    // base64 encode the result of previous step</span><span id="de2c" class="lm ln iq ko b gy lu lp l lq lr">    // obfouscate the result of previous step<br/>    <br/>    // base64 encode again</span><span id="7e7f" class="lm ln iq ko b gy lu lp l lq lr">    return Filter;<br/>}</span></pre><p id="3b88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3。之后，js查询构建XML数据。最后，将XML放入JSON并发送请求</strong></p><p id="d85a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我非常确定，如果我找到一种方法，像js代码那样加密我的SQL负载，并将其发送到服务器，那么在后端代码中将会有一个注入。为什么？<br/>很简单，<br/>因为当开发人员如此努力地隐藏正在传输的查询并在客户端完成所有这些工作时，他认为他的屏障是不可穿透的，并且……服务器端没有保护😏</p><p id="1e2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在我们知道了工作流程。如何使用这些知识来注入我们自己的查询？写一个脚本来做同样的加密？？不，比那简单多了…</p><p id="33f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe kl km kn ko b">devtools</code> … <br/>在加密函数的第一行放置一个断点，<br/>将函数的参数值更改为您自己的查询，<br/>点击恢复按钮，让代码完成它的工作，但是以恶意的方式😉<br/> <em class="ls">我告诉过你要看</em> <code class="fe kl km kn ko b"><em class="ls">devtools</em></code> <em class="ls">文档，不是吗？</em>:)</p><p id="2abf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用了一个简单的基于布尔的注入来确认漏洞。之后，使用字符串连接技术，我发现后端DBMS是<code class="fe kl km kn ko b">SQL Server</code>。<br/>你可以在portswigger的<code class="fe kl km kn ko b">SQL Injection cheat sheet</code>:<br/><a class="ae lt" href="https://portswigger.net/web-security/sql-injection/cheat-sheet" rel="noopener ugc nofollow" target="_blank">https://portswigger . net/we b-security/SQL-injection/cheat-sheet</a>的开头找到这个技巧</p><p id="8d69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在执行了几个查询之后，我意识到注入是基于布尔的。</p><p id="c9b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还记得易受攻击的查询的工作是返回收到的邮件数据，对吗？<br/>那么如果它返回数据，为什么注入是盲目的？<br/>阅读本文，学习如何将盲注转为联注:✌️<br/><a class="ae lt" href="https://medium.com/@Rend_/healing-blind-injections-df30b9e0e06f" rel="noopener">https://medium . com/@ rend _/healing-blind-injections-df 30 b 9 e 0e 06 f</a></p><p id="efdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，在这个阶段我需要使用<code class="fe kl km kn ko b">SQLMap</code>来实现自动化。<br/>但是当易受攻击的参数被如此硬混淆时，如何使用<code class="fe kl km kn ko b">SQLMap</code>？</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="8294" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第三部分:自动化，艰难之路<br/> </strong> <em class="ls">在这一部分，我想向你展示如何正确地使用工具</em><strong class="jp ir"><em class="ls">im</em></strong><em class="ls"/>😊</p><p id="6a99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我快进一下故事… 2X</p><p id="e780" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我需要使用<code class="fe kl km kn ko b">SQLMap</code>进行自动化… <br/>但是输入变得模糊… <br/>使用<code class="fe kl km kn ko b">--eval</code>标志并编写一个脚本来进行模糊… <br/>什么语言<code class="fe kl km kn ko b">--eval</code>接受…？<br/> python… <br/>我应该自己写完整个python脚本吗…？<br/>不是当你已经有代码的时候… <br/>但是它在JS中… <br/>找到一种方法将JS转换成Python… <br/> google it… <br/>哦，有一个叫做<code class="fe kl km kn ko b">js2py</code>的Python模块做了确切的工作… <br/>酷，现在我有了一个混淆有效负载的脚本… <br/>我应该在终端中编写整个脚本作为<code class="fe kl km kn ko b">--eval</code>的输入吗…？<br/>不，保存为<code class="fe kl km kn ko b">.py</code>文件导入:<code class="fe kl km kn ko b">--eval="import mycode;..."</code> <br/>如何将脚本的输出插入请求体…？⛔BLOCKED⛔:我无法让它工作…？为什么…？<br/><code class="fe kl km kn ko b">eval</code>标志不像支持<code class="fe kl km kn ko b">form-based</code>数据那样支持<code class="fe kl km kn ko b">JSON</code>数据… <br/>如果我能够动态地使用<code class="fe kl km kn ko b">burp</code>修改请求会怎样…？<br/>要做到这一点，我需要用burp执行Python代码… <br/>有办法吗…？<br/>谷歌这个也是… <br/>不错，有个扩展叫<code class="fe kl km kn ko b">python scripter</code>那个… <br/> ✅PASSED✅ <br/>怎么用…？<br/>实现了burp针对python的API的一部分… (API本身是针对JAVA的)<br/>哪里可以找到API文档…？<br/>此处:burp suite-&gt;extender tab-&gt;API tab<br/>使用API的函数，添加修改请求正文所需的代码… <br/>通过您的脚本进入<code class="fe kl km kn ko b">python scripter</code> <br/>不起作用…😕<br/>它不识别<code class="fe kl km kn ko b">js2py</code>模块… <br/>试着修一下… <br/> ⛔BLOCKED⛔ <br/>怎么修…？你的代码在burp中不能工作，但在你的终端中可以工作，不是吗？<br/>使用<code class="fe kl km kn ko b">os.popen()</code>从您的终端运行它😉<br/> ✅PASSED✅ <br/>酷，一切正常。现在如何将<code class="fe kl km kn ko b">SQLMap</code>带到剧中…？<br/>先说说<code class="fe kl km kn ko b">SQLMapp</code>是怎么工作的…？它发送一个查询，并根据注入的有效负载分析响应(你还期望别的吗？😐)<br/>它不关心查询在哪里或如何被注入… <br/>它只是分析响应… <br/>所以… <br/>我删除了整个POST主体并在那里放了一个<code class="fe kl km kn ko b">*</code>这样，我的脚本收到的请求只包含了<code class="fe kl km kn ko b">SQLMap</code>的有效载荷… <br/>我获取有效载荷，修改它，然后我把它放在服务器期望的适当主体中… <br/>我的意思是， 我把它放在XML中，把XML放在JSON中… <br/>发送请求，接收它的响应，把响应交给<code class="fe kl km kn ko b">SQLMap</code>并让它做它的工作，分析响应… <br/> ✨DONE✨ <br/> <code class="fe kl km kn ko b">SQLMap</code>确认了基于布尔的注入…</p><p id="3d61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">布尔基？我更喜欢基于工会的:😏<br/><a class="ae lt" href="https://medium.com/@Rend_/healing-blind-injections-df30b9e0e06f" rel="noopener">https://medium . com/@ Rend _/healing-blind-injections-df 30 b 9 e 0e 06 f</a></p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="a313" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">有帮助吗？</strong> <br/>我不要求你给我买杯咖啡，<br/>教我点什么… <br/>不和:<code class="fe kl km kn ko b"><strong class="jp ir">REDN#9702</strong></code></p></div></div>    
</body>
</html>