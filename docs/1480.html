<html>
<head>
<title>Pre-Account Takeover by Reversing a Weak Email Verification Token Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过逆转脆弱的电子邮件验证令牌算法预先接管帐户</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/pre-account-takeover-by-reversing-a-weak-email-verification-token-algorithm-ff0617b2365a?source=collection_archive---------0-----------------------#2021-07-22">https://infosecwriteups.com/pre-account-takeover-by-reversing-a-weak-email-verification-token-algorithm-ff0617b2365a?source=collection_archive---------0-----------------------#2021-07-22</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><p id="0e13" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我欺骗他人的电子邮件，以便在他们首次注册之前预先窃取用户帐户。我是这样做的。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/f69e7174c51f8e38bf260ae0bf16f632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AVbmNs8QMPZM6ncO"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">马库斯·温克勒在<a class="ae lf" href="https://unsplash.com/s/photos/padlock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d668" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我在入侵bug bounty程序时经常测试的一件事是应用程序如何生成令牌。令牌用于密码重置、电子邮件地址验证、一键式登录等。</p><p id="dc8e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在入侵一个私人程序时，我发现一个应用程序生成电子邮件验证令牌的算法很弱。这就是我处理这个问题的方式，也是我如何找到一种方法来生成有效的令牌来验证任何电子邮件地址的所有权，甚至是那些我实际上无法访问的电子邮件地址。这使我能够用我选择的密码在任何电子邮件地址上预先注册帐户，这导致当真正的所有者最终注册时帐户被接管。</p><h1 id="93c0" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">令牌生成算法分析</h1><p id="14ee" class="pw-post-body-paragraph jr js iu jt b ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko in bi translated">在攻击任何有bug bounty范围的web应用程序时，我首先测试的是帐户创建和身份验证功能。这一次，我发现每次我创建一个新的用户帐户，应用程序不让我做任何事情，直到我验证了我的电子邮件地址的所有权。目标应用程序会通过电子邮件给我发送一个验证链接，并提示我检查我的收件箱，这就是我所能做到的</p><p id="1aa2" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">通过强迫我验证我的电子邮件地址，应用程序所有者可以防止预帐户接管。</p><h1 id="80bf" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">账户前接管</h1><p id="8271" class="pw-post-body-paragraph jr js iu jt b ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko in bi translated">现代web应用程序通常有多种登录用户帐户的方式。这些可以包括:</p><ul class=""><li id="7142" class="mj mk iu jt b ju jv jy jz kc ml kg mm kk mn ko mo mp mq mr bi translated">用户名和密码</li><li id="2680" class="mj mk iu jt b ju ms jy mt kc mu kg mv kk mw ko mo mp mq mr bi translated">电子邮件地址和密码</li><li id="8170" class="mj mk iu jt b ju ms jy mt kc mu kg mv kk mw ko mo mp mq mr bi translated">Oauth，例如“用脸书登录”或“用Twitter登录”</li><li id="16c1" class="mj mk iu jt b ju ms jy mt kc mu kg mv kk mw ko mo mp mq mr bi translated">来自任何SAML兼容身份提供商(IdP)的SAML单点登录</li><li id="bd1b" class="mj mk iu jt b ju ms jy mt kc mu kg mv kk mw ko mo mp mq mr bi translated">使用令牌化“神奇”链接的无密码</li></ul><p id="ed7f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">预帐户接管是指攻击者使用一种登录方法创建一个用户帐户，然后受害者使用另一种登录方法创建另一个帐户。然后，应用程序根据匹配的电子邮件地址将两个帐户链接在一起。如果电子邮件地址未经验证，或者验证被绕过，这可能会导致帐户创建前或创建后被接管。</p><p id="8767" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">攻击发生的过程如下:</p><ol class=""><li id="469c" class="mj mk iu jt b ju jv jy jz kc ml kg mm kk mn ko mx mp mq mr bi translated">攻击者使用他们不拥有的电子邮件地址在web应用程序上创建一个用户帐户。</li><li id="92f8" class="mj mk iu jt b ju ms jy mt kc mu kg mv kk mw ko mx mp mq mr bi translated">应用程序不验证他们是电子邮件地址的所有者</li><li id="0777" class="mj mk iu jt b ju ms jy mt kc mu kg mv kk mw ko mx mp mq mr bi translated">该帐户会休眠一段时间</li><li id="6a55" class="mj mk iu jt b ju ms jy mt kc mu kg mv kk mw ko mx mp mq mr bi translated">该电子邮件地址的真正所有者选择“登录脸书”,脸书向用户提供经过验证的电子邮件地址。</li><li id="bf9e" class="mj mk iu jt b ju ms jy mt kc mu kg mv kk mw ko mx mp mq mr bi translated">脸书的电子邮件地址与攻击者注册的电子邮件地址相匹配，这两个帐户被关联起来。</li><li id="5173" class="mj mk iu jt b ju ms jy mt kc mu kg mv kk mw ko mx mp mq mr bi translated">现在，攻击者可以用他们提供的电子邮件地址和密码登录受害者的帐户，他们可以看到受害者每次用脸书登录时在他们帐户内做的一切。</li></ol><h1 id="9204" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">电子邮件验证令牌识别</h1><p id="c3c2" class="pw-post-body-paragraph jr js iu jt b ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko in bi translated">在检查我的收件箱时，我发现了“确认你的账户”的邮件，并把链接复制到了我最喜欢的文本编辑器中。我总是保存所有通过电子邮件发给我的一次性链接，以及帐户名、电子邮件地址、注册时间等等，以防在测试时出现任何模式。</p><p id="54c2" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">该链接的格式为https://craighays.com/verify/?P1=randomString &amp; P2 =随机字符串&amp; P3 =静态文本&amp; P4 =静态文本(不含空格)。</p><p id="4037" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在为不同的账户生成了几封验证邮件后，我发现P3和P4总是一样的。然而，P1和P2总是在每次发送电子邮件时改变。在删除或更改P1或P2后打开链接会导致一条错误消息，并且电子邮件地址未得到验证。因此，P1和P2的组合一起形成了两部分的电子邮件地址所有权验证令牌。</p><h1 id="d965" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">深入挖掘</h1><p id="618e" class="pw-post-body-paragraph jr js iu jt b ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko in bi translated">既然我已经确定了用于确认电子邮件地址的由两部分组成的令牌，我就更深入地研究这两个参数。</p><p id="10c5" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">P1和P2都是base64编码的字符串。发现这一点的一个简单方法是当一个随机出现的字符串以单个=或双==结尾时。这些= chars用作填充符，以确保预编码字符串符合最小位长度。但情况并不总是这样，因为长度完美的字符串不需要填充。如果有疑问，总是通过不同的解码器传递随机字符串，看看是否有什么有趣的东西出来。</p><p id="8b5d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在解码了来自不同链接的多个P1和P2参数后，我可以看到P1总是有4个静态字符后跟12个数字字符的格式，如TEXT000123456789，P2总是有9个数字字符的格式，如123456789。通过查看我的解码P1和P2字符串列表，我可以看到这些数字正在增加，从一个电子邮件验证链接到另一个链接都在大幅增加。P1和P2除了都上涨之外，没有任何关联。</p><p id="ee38" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">起初，我试图根据HTTP响应中的时间戳猜测带编号的字符串，但是毫无结果。相反，我的想法是定义一个电子邮件地址的有效令牌的上限和下限。在一个小范围内，甚至一个9或12位数字都可能被暴力破解来创建一个有效的令牌。</p><h1 id="ba05" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">上限和下限</h1><p id="ad00" class="pw-post-body-paragraph jr js iu jt b ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko in bi translated">从数学角度来看这个问题，我需要猜两个9位数。十二位数总是以000开头，所以实际上是9位数。一个9位数有1，000，000，000种可能的组合。因为我有两个，所以每个电子邮件验证令牌有1，000，000，000 * 1，000，000，000种可能的组合。相当安全。</p><p id="558b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个应用程序的问题是，在生成的每个令牌中，P1和P2的数字大于之前的P1和P2，但小于之后的P1和P2。如果我能创建一个我看得见的令牌，然后创建一个我看不见的令牌，再创建第三个我看得见的令牌，我就能大大缩小可能数字的范围。我可以创建9位数的上限和下限，这比1，000，000，000个可能的组合范围要小得多。</p><p id="697c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我的令牌攻击的步骤如下所示:</p><ol class=""><li id="0619" class="mj mk iu jt b ju jv jy jz kc ml kg mm kk mn ko mx mp mq mr bi translated">用我自己的电子邮件地址创建一个帐户</li><li id="7c38" class="mj mk iu jt b ju ms jy mt kc mu kg mv kk mw ko mx mp mq mr bi translated">使用我不拥有但想要验证的电子邮件地址创建一个帐户</li><li id="1f14" class="mj mk iu jt b ju ms jy mt kc mu kg mv kk mw ko mx mp mq mr bi translated">用我自己的电子邮件地址创建一个帐户</li></ol><h1 id="b876" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">将此付诸实践</h1><p id="62f5" class="pw-post-body-paragraph jr js iu jt b ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko in bi translated">为了证明我可以验证任何电子邮件地址，我决定在目标公司域中验证我自己的名字，例如craighays@targetcompany.com</p><p id="29e1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我打开了三个浏览器配置文件，并在所有三个浏览器上将帐户创建过程进行到最后一页。尽可能快地，(在一个接一个地释放请求之前，使用burp intruder来控制请求)我在所有三个浏览器上提交了“创建帐户”表单，craighays@targetcompany.com在中间。这给我发了两封电子邮件，每封都有电子邮件验证链接。中间那封邮件发给了一个我无法访问的地址。</p><p id="4271" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">从两个验证链接中提取P1和P2参数，我的上限和下限如下所示:</p><p id="a036" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">下部1: 000148309914 <br/>上部1: 000148309953</p><p id="7fb8" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">下部2: 187633910 <br/>上部2: 187634120</p><p id="bd2a" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">P1射程:39 <br/> P2射程:210</p><p id="df8d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">可能的组合:8190。比1，000，000，000*1，000，000，000 = 1.0e18好多了</p><p id="fd00" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">然后我用python运行了以下逻辑:</p><pre class="kq kr ks kt gu my mz na nb aw nc bi"><span id="83c8" class="nd lh iu mz b gz ne nf l ng nh">for P1 in range (LowerP1..UpperP1):<br/>  for P2 in range (LowerP2..UpperP2): <br/>    P1 = "TEXT000" + string(P1) <br/>    P1 = base64encode(P1) <br/>    P2 = base64encode(P2) <br/>    url = buildURL(P1, P2) <br/>    getUrl(url)</span><span id="5c13" class="nd lh iu mz b gz ni nf l ng nh"># Note, this is pseudo code - it won't actually run but it summaries # the script logic into a readable form</span></pre><p id="b72b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">作为buildURL()的一部分，我添加了P3和P4以及URL的其余部分。然后，我简单地发送了一个HTTP GET请求，包含上限和下限之间的所有8，190个可能的2部分令牌，直到我的电子邮件地址得到验证。</p><h1 id="ef55" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结果</h1><p id="a6ba" class="pw-post-body-paragraph jr js iu jt b ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko in bi translated">有了这个，我能够验证craighays@targetcompany.com，证明我的验证旁路工作。由于web应用程序的核心功能已经将电子邮件和密码创建的帐户与脸书创建的具有匹配电子邮件的帐户关联起来，所以我不需要进一步证明这一点。对这种行为的简单解释是我的臭虫奖励报告所需要的。</p><p id="6ab3" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">作为一个副产品，它不仅验证了我创建的帐户，还验证了我测试时在我的上限和下限范围内的公众成员创建的其他几个电子邮件地址…哎呀。</p><h1 id="aed9" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">影响</h1><p id="9a70" class="pw-post-body-paragraph jr js iu jt b ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko in bi translated">我可以绕过账户验证的要求，不用绑定到真实的电子邮件地址就可以使用这个应用程序。我还能够对任何尚未注册的电子邮件地址进行预账户接管，这是毫无防备的受害者第一次登录脸书、推特或其他任何网站。</p><h1 id="6fe8" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">建议的补救措施</h1><p id="a9a6" class="pw-post-body-paragraph jr js iu jt b ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko in bi translated">解决这个问题的最好方法是用一个非常长的随机字符串替换P1和P2，从令牌生成算法中删除序列号。奇怪的是，密码重置方法已经做到了这一点，但出于某种原因，开发人员重新发明了验证电子邮件地址的令牌过程。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="9b7e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">与我私人电子邮件列表中的其他人一起关注我的最新文章、视频、想法等。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="be27" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="nq">原载于2021年7月22日</em><a class="ae lf" href="https://craighays.com/pre-account-takeover-by-reversing-a-weak-email-verification-token-algorithm/" rel="noopener ugc nofollow" target="_blank"><em class="nq">【https://craighays.com】</em></a><em class="nq">。</em></p></div></div>    
</body>
</html>