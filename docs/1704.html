<html>
<head>
<title>CTF Write-Up: Hell Yeah!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CTF报道:地狱耶！</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/ctf-creation-hell-yeah-6d774aecad8f?source=collection_archive---------2-----------------------#2021-12-08">https://infosecwriteups.com/ctf-creation-hell-yeah-6d774aecad8f?source=collection_archive---------2-----------------------#2021-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><ul class=""><li id="d549" class="jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">ctf-mystiko.com有CTF挑战赛。</li><li id="c462" class="jn jo iq jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">挑战名称:地狱耶！</li><li id="1afc" class="jn jo iq jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">类别:逆向工程</li><li id="860c" class="jn jo iq jp b jq kf js kg ju kh jw ki jy kj ka kb kc kd ke bi translated">语言:C++</li></ul><p id="eeb8" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi">— — — — —</p><p id="baef" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">这个例子展示了一种防止CTF玩家通过使用“strings”命令将旗帜隐藏在二进制文件中的方法。我发现strings不能打印短于(至少)三个字符的字符串。因此，在这种情况下，标志被逐行打印到标准输出，而没有存储在变量中。</p><ul class=""><li id="0b0b" class="jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">源代码:</li></ul><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">hellyeah.cpp的源代码</figcaption></figure><p id="92e1" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">为了解决这一挑战，我们需要打破“while”循环，这个循环永远运行下去。以便能够前进到创建旗帜的地方。</p><p id="0730" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">用nop替换所有的跳转可以很容易地做到这一点(不需要太多的思考)。使用x64调试器(在这种情况下是x32，32位版本，因为x64抱怨错误的体系结构)，来替换我们所做的指令:右键单击instruction&gt; assemble &gt; add nops</p><p id="339c" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">当程序加载到调试器中时，我们可以暂停程序，单步执行指令，当我们到达jmp时，不是单步执行，而是首先用nop替换它。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lk"><img src="../Images/2f8516fcdbb9cbcd43cbf6b8598ab268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dOrp49HXhFv4FQ3XicqBuw.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">跳跃已经被nop取代</figcaption></figure><p id="8ff5" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">在某一点上，我们将修补返回到while循环开始处的跳转，因此我们可以进一步查看逐行打印的标志。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/6f305af557a2b85efffec7ff3e7a7c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*bYkU4rx3vGTNZdpijqS1wQ.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">旗帜是逐行打印的</figcaption></figure><p id="a476" class="pw-post-body-paragraph kk kl iq jp b jq jr km kn js jt ko kp ju kq kr ks jw kt ku kv jy kw kx ky ka ij bi translated">一般来说，在反转程序时，用nop替换jmp来访问程序中不符合正常逻辑的部分是很有趣的，但是这可能会导致意外的行为，并且可能需要大量的反复试验。</p></div></div>    
</body>
</html>