<html>
<head>
<title>Breaking Down : SHA-512 Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解:SHA-512算法</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/breaking-down-sha-512-algorithm-1fdb9cc9413a?source=collection_archive---------0-----------------------#2019-11-19">https://infosecwriteups.com/breaking-down-sha-512-algorithm-1fdb9cc9413a?source=collection_archive---------0-----------------------#2019-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/11e141dcb20f836852de0111ecfcc68d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TVR5cOPbCVUIGwJQepRGg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">SHA-512算法</figcaption></figure><div class=""/><div class=""><h2 id="cf57" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">看看引擎盖下面，了解它是如何工作的？</h2></div><p id="e76d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在过去的几周里，我一直在撰写“<em class="lq">分解</em>”系列文章，其中我详细解释了哈希算法，以便任何阅读它的人都能理解创建哈希输出所发生的每一点操作。</p><blockquote class="lr ls lt"><p id="e879" class="ku kv lq kw b kx ky kg kz la lb kj lc lu le lf lg lv li lj lk lw lm ln lo lp ij bi translated"><strong class="kw jg">分解:系列</strong></p><p id="3ee2" class="ku kv lq kw b kx ky kg kz la lb kj lc lu le lf lg lv li lj lk lw lm ln lo lp ij bi translated"><a class="ae lx" href="https://medium.com/bugbountywriteup/breaking-down-md5-algorithm-92803c485d25" rel="noopener"> 1。分解:MD5算法</a></p><p id="bcf6" class="ku kv lq kw b kx ky kg kz la lb kj lc lu le lf lg lv li lj lk lw lm ln lo lp ij bi translated"><a class="ae lx" href="https://medium.com/bugbountywriteup/breaking-down-sha-1-algorithm-c152ed353de2" rel="noopener"> 2。分解:SHA-1算法</a></p></blockquote><p id="ca4e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是这个系列的第三部分，在这里我试图解释SHA-512算法，以及为什么它仍然无法破解，而SHA-1和MD5已经被破解。</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/28bc47d5ae60030f66217981d26698d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*PSMjToG-xUgqVMkPYRY91A.png"/></div></figure><h1 id="1587" class="md me jf bd mf mg mh mi mj mk ml mm mn kl mo km mp ko mq kp mr kr ms ks mt mu bi translated">我们开始吧！</h1><p id="808a" class="pw-post-body-paragraph ku kv jf kw b kx mv kg kz la mw kj lc ld mx lf lg lh my lj lk ll mz ln lo lp ij bi translated">所以，我将一步一步地分解算法的整个工作过程。SHA-512的整体功能与SHA-256非常相似(很可能是我的下一篇文章)，所以如果你已经了解它，理解SHA-512算法将非常简单。</p><h2 id="caef" class="na me jf bd mf nb nc dn mj nd ne dp mn ld nf ng mp lh nh ni mr ll nj nk mt nl bi translated">1.追加:填充位</h2><p id="7c6a" class="pw-post-body-paragraph ku kv jf kw b kx mv kg kz la mw kj lc ld mx lf lg lh my lj lk ll mz ln lo lp ij bi translated">第一步是执行填充函数，在该函数中，我们将一定数量的位附加到明文消息中以增加其长度，该长度应该正好比1024的整数倍少128位。</p><p id="2e93" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">当我们在消息末尾添加这些位时，我们从“1”开始，然后继续添加“0 ”,直到到达需要在填充下添加的最后一位，并在此之后保留128位。</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/6d32d9b6a3673a6f7551d089561cb6e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_T_NEGsK4V47kA4gigBTg.png"/></div></div></figure><h2 id="bdbb" class="na me jf bd mf nb nc dn mj nd ne dp mn ld nf ng mp lh nh ni mr ll nj nk mt nl bi translated">2.追加:长度位</h2><p id="ec96" class="pw-post-body-paragraph ku kv jf kw b kx mv kg kz la mw kj lc ld mx lf lg lh my lj lk ll mz ln lo lp ij bi translated">现在，我们将剩余的128位添加到整个块中，使其正好是1024的倍数，这样整个事情就可以分解为“n”个1024消息块，我们将对其进行操作。计算其余128位的方法是用2⁶⁴.计算模</p><p id="ca1e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">完成后，我们将它附加到填充位和原始消息，使块的总长度为“n x 1024”。</p><h2 id="fb7a" class="na me jf bd mf nb nc dn mj nd ne dp mn ld nf ng mp lh nh ni mr ll nj nk mt nl bi translated">3.初始化缓冲区</h2><p id="4a44" class="pw-post-body-paragraph ku kv jf kw b kx mv kg kz la mw kj lc ld mx lf lg lh my lj lk ll mz ln lo lp ij bi translated">现在，我们有了需要散列的“n x 1024”长度的位消息，让我们把注意力集中在散列函数本身的各个部分。为了进行所需的散列和计算，我们需要初始化一些默认值。</p><pre class="lz ma mb mc gt nn no np nq aw nr bi"><span id="cd48" class="na me jf no b gy ns nt l nu nv">a = 0x6a09e667f3bcc908<br/>b = 0xbb67ae8584caa73b<br/>c = 0x3c6ef372fe94f82b<br/>d = 0xa54ff53a5f1d36f1<br/>e = 0x510e527fade682d1<br/>f = 0x9b05688c2b3e6c1f<br/>g = 0x1f83d9abfb41bd6b<br/>h = 0x5be0cd19137e2179</span></pre><p id="f775" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这些是我们需要的缓冲区的值，我们还需要初始化其他的默认值。这些是我们将要用到的“k”变量的值。</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/1a36ef3448338f93b80c4b910a61c6e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUsOwPu-kjEHC1MPwWOrrA.png"/></div></div></figure><p id="9dc2" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在我们将要探讨的下一步中，您将会清楚地了解创建这些值的原因。</p><h2 id="37ba" class="na me jf bd mf nb nc dn mj nd ne dp mn ld nf ng mp lh nh ni mr ll nj nk mt nl bi translated">4.压缩功能</h2><p id="a36e" class="pw-post-body-paragraph ku kv jf kw b kx mv kg kz la mw kj lc ld mx lf lg lh my lj lk ll mz ln lo lp ij bi translated">现在，我们需要对散列函数有一个更广泛的了解，以便我们能够理解正在发生的事情。首先，我们取1024比特的消息，并将完整的消息分成‘n’比特。</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/ed6d9bdc7513ddaeb9e7853be5ffbbee.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*SluIOftlhfGaLAHsPvrjkg.png"/></div></figure><p id="e266" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">看一下上面的图像，你会知道我们将进行80轮运算，输入W将从1024位得到，这1024位被进一步分成16个部分。从0到15的W值是明文中的消息，但是从16到79的W值是根据前面的16个块计算的，我们有下面提到的公式。</p><pre class="lz ma mb mc gt nn no np nq aw nr bi"><span id="1428" class="na me jf no b gy ns nt l nu nv"><strong class="no jg">W(t) = σ¹(Wᵗ⁻²) + Wᵗ⁻⁷ + </strong><strong class="no jg">σ⁰(Wᵗ⁻¹⁵) + Wᵗ⁻¹⁶</strong><br/>where,<br/> <strong class="no jg">σ⁰(x)</strong>    = ROTR¹(x) ϕ ROTR⁸(x) ϕ SHR⁷(x)<br/> <strong class="no jg">σ¹(x)</strong>    = ROTR¹⁹(x) ϕ ROTR⁶¹(x) ϕ SHR⁶(x)<br/> <strong class="no jg">ROTRⁿ(x)</strong> = Circular right rotation of 'x' by 'n' bits<br/> <strong class="no jg">SHRⁿ(x)</strong>  = Circular right shift of 'x' by 'n' bits<br/> <strong class="no jg">ϕ</strong>        = addition modulo 2⁶⁴</span></pre><p id="d63e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在我们知道了获取0到79的W值的方法，并且已经有了从0到79的所有轮次的K值，我们可以继续下去，看看我们在哪里以及如何为散列计算输入这些值。</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/dfe9e66a76ea823c2a03bbda12094a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*Cn0aZUO1Ixy96h1Gc-lgTw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">“圆”的描绘</figcaption></figure><p id="deb9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在上图中，我们可以确切地看到每一轮发生了什么，现在我们已经有了每个函数的值和公式，我们可以执行整个哈希过程。</p><pre class="lz ma mb mc gt nn no np nq aw nr bi"><span id="515b" class="na me jf no b gy ns nt l nu nv">Ch(E, F, G) = (E AND F) XOR ((NOT E) AND G)<br/>Ma(A, B, C) = (A AND B) XOR (A AND C) XOR (B AND C)<br/>    ∑(A)    = (A &gt;&gt;&gt; 2) XOR (A &gt;&gt;&gt; 13) XOR (A &gt;&gt;&gt; 22)<br/>    ∑(E)    = (E &gt;&gt;&gt; 6) XOR (E &gt;&gt;&gt; 11) XOR (E &gt;&gt;&gt; 25)<br/>     +      = addition modulo 2⁶⁴</span></pre><p id="5760" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这些功能在80轮中的每一轮都要重复执行n次。</p><h2 id="82f5" class="na me jf bd mf nb nc dn mj nd ne dp mn ld nf ng mp lh nh ni mr ll nj nk mt nl bi translated">5.输出</h2><p id="0c45" class="pw-post-body-paragraph ku kv jf kw b kx mv kg kz la mw kj lc ld mx lf lg lh my lj lk ll mz ln lo lp ij bi translated">每一轮的输出充当下一轮的输入，并且该过程继续进行，直到消息的最后一位通过一轮，并且来自最后消息的最后块的输出是散列码。输出的长度为512位。</p><h1 id="e5bf" class="md me jf bd mf mg mh mi mj mk ml mm mn kl mo km mp ko mq kp mr kr ms ks mt mu bi translated">结论</h1><p id="cec9" class="pw-post-body-paragraph ku kv jf kw b kx mv kg kz la mw kj lc ld mx lf lg lh my lj lk ll mz ln lo lp ij bi translated">在MD5和SHA-1等哈希算法被破解之后，SHA-512哈希算法是目前最好、最安全的哈希算法之一。由于其复杂的性质，它没有被很好地接受，SHA-256是一个通用标准，但行业正在缓慢地向这种散列算法发展。</p><p id="e057" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们看看SHA-512散列算法的整个工作过程，并以简洁的方式了解它是如何工作的。</p><blockquote class="lr ls lt"><p id="c998" class="ku kv lq kw b kx ky kg kz la lb kj lc lu le lf lg lv li lj lk lw lm ln lo lp ij bi translated">需要被散列的消息，我们首先附加几个比特到它，使它正好比1024的倍数少128比特。在我们用2⁶⁴.计算原始消息的模之后，添加剩余的128位一旦我们这样做了，我们就把它们分成n个1024比特的块。在此之后，我们将1024位块一个接一个地传递到压缩函数中，即80轮运算的集合。这里我们进一步将它们分成16部分，每部分64位。64位的这16个部分在每轮运算中以顺序方式充当输入，并且使用前16个部分计算16到79的W。我们已经有了每一轮的默认值“K”。现在，我们开始一轮又一轮的操作，每一轮都需要反复执行。一轮的输出被作为下一轮的输入，并且该过程继续重复，直到最后一个消息块的第80轮发生。最后一个消息块最后一轮后得到的输出就是整个消息的哈希码。</p></blockquote><p id="6703" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这就是发生在SHA-512算法中的整个运算的简短版本。</p><p id="9aaf" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果你喜欢，请鼓掌&amp;让我们合作吧。获取、设置、破解！</p><p id="5d6f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">网站</strong>:<a class="ae lx" href="https://www.aditya12anand.com/" rel="noopener ugc nofollow" target="_blank">aditya12anand.com</a>|<strong class="kw jg">捐款</strong>:<a class="ae lx" href="https://paypal.me/aditya12anand" rel="noopener ugc nofollow" target="_blank">paypal.me/aditya12anand</a><br/><strong class="kw jg">电报</strong>:<a class="ae lx" href="https://t.me/aditya12anand" rel="noopener ugc nofollow" target="_blank">https://t.me/aditya12anand</a><br/><strong class="kw jg">推特</strong>:<a class="ae lx" href="https://twitter.com/aditya12anand?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">twitter.com/aditya12anand</a><br/><strong class="kw jg">LinkedIn</strong>:<a class="ae lx" href="https://www.linkedin.com/in/aditya12anand/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/aditya12anand/</a><br/><strong class="kw jg">电子邮件</strong>:aditya12anand@protonmail.com</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="95fe" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="lq">关注</em> <a class="ae lx" href="https://medium.com/bugbountywriteup" rel="noopener"> <em class="lq"> Infosec报道</em> </a> <em class="lq">获取更多此类精彩报道。</em></p><div class="ip iq gp gr ir og"><a href="https://medium.com/bugbountywriteup" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jg gy z fp ol fr fs om fu fw je bi translated">信息安全报道</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">收集了世界上最好的黑客的文章，主题从bug奖金和CTF到vulnhub…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ix og"/></div></div></a></div></div></div>    
</body>
</html>