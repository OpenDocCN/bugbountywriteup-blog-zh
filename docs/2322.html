<html>
<head>
<title>Double free() attacks in ARM (Part one)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ARM中的双自由()攻击(上)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/double-free-attacks-in-arm-part-one-4519eee6770a?source=collection_archive---------1-----------------------#2022-08-28">https://infosecwriteups.com/double-free-attacks-in-arm-part-one-4519eee6770a?source=collection_archive---------1-----------------------#2022-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7e59" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">介绍</h2></div><p id="faf3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们继续我们在ARM中的堆利用系列。如果你是这方面的新手，请查看下面的文章来掌握一些基本知识。</p><p id="ebe5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://medium.com/@ad2001/list/arm-exploitation-b558826b8c7e?source=my_lists---------1-------b558826b8c7e---------------------" rel="noopener">https://medium . com/@ ad 2001/list/arm-exploitation-b 558826 b 8 c 7e？source = my _ lists-1-b 558826 b8 c7e-</a></p><p id="a093" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将深入研究<strong class="kh ir">双自由</strong>bug。那么什么是双免bug呢？</p><p id="b12d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以基本上这是一个漏洞，当一个变量被<strong class="kh ir">释放两次</strong>时就会出现。当我们多次尝试释放()一个资源时，就会破坏堆分配器的数据结构。</p><p id="ce94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更多详情，你可以查看下面的链接。</p><div class="lc ld gp gr le lf"><a href="https://cwe.mitre.org/data/definitions/415.html" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">CWE - CWE-415:双倍免费(4.8英镑)</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">常见弱点枚举(CWE)是软件弱点的列表。</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">cwe.mitre.org</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt lu lf"/></div></div></a></div><h2 id="f8d1" class="lv lw iq bd lx ly lz dn ma mb mc dp md ko me mf mg ks mh mi mj kw mk ml mm mn bi translated">双重免费介绍()</h2><p id="e401" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">让我们来看一个例子。</p><blockquote class="mt mu mv"><p id="3616" class="kf kg mw kh b ki kj jr kk kl km ju kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated"># include<stdio.h><br/># include&lt;malloc . h&gt;T8】int main(){<br/><br/>char * a =(char *)malloc(10)；<br/>char * b =(char *)malloc(10)；<br/>char * c =(char *)malloc(10)；<br/> <br/> printf("a在内存%p \n "，a)；<br/> printf("b在内存%p \n "，b)；<br/> printf("c在内存%p \n "，c)；<br/> <br/>自由(一)；<br/> printf("释放a \ n ")；<br/> <br/> <br/>自由(b)；<br/> printf("释放b \ n ")；<br/> <br/>游离(c)；<br/> printf("释放c \ n ")；<br/>游离(c)；<br/> printf("释放c两次\ n ")；<br/> <br/> <br/>返回0；<br/> <br/> }</stdio.h></p></blockquote><div class="lc ld gp gr le lf"><a href="https://pastebin.com/9iDpnJHV" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">双人免费Pastebin.com</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">自2002年以来，Pastebin.com一直是头号粘贴工具。Pastebin是一个网站，在那里你可以在线存储一组文本…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">pastebin.com</p></div></div><div class="lo l"><div class="na l lq lr ls lo lt lu lf"/></div></div></a></div><p id="d443" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在GCC中编译这个源代码。</p><blockquote class="mt mu mv"><p id="63f3" class="kf kg mw kh b ki kj jr kk kl km ju kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated">pi @ raspberrypi:~/ASM/tmp $ gcc double-free . c-o db</p></blockquote><p id="c805" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以程序里有3个指针。</p><blockquote class="mt mu mv"><p id="e631" class="kf kg mw kh b ki kj jr kk kl km ju kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated">char * a =(char *)malloc(10)；<br/>char * b =(char *)malloc(10)；<br/>char * c =(char *)malloc(10)；</p></blockquote><p id="2793" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以程序中有3个指针，在堆中有三个内存位置。它们被逐个释放，但是在最后一种情况下，指针c被释放了()d两次。</p><p id="aa3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们运行一下，看看会发生什么。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nb"><img src="../Images/a51de16f641e7d9718eb9f6cc7ff8102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Mkxr-x3jVbw5h1NhF_v6g.png"/></div></div></figure><p id="d2f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您在第三个案例中看到的，程序由于双释放损坏而中止。程序中的双重释放错误被发现，执行被中止。</p><p id="0bfc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以问题来了，如果在程序中发现了这个错误，那么这个错误现在怎么还存在，或者我们如何利用它？</p><figure class="nc nd ne nf gt ng"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="179c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们再看一下错误消息，它说:</p><blockquote class="mt mu mv"><p id="12d9" class="kf kg mw kh b ki kj jr kk kl km ju kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated">“***错误在`。/db': double free或corruption(fast top):0x 00021028 * * * "</p></blockquote><p id="5d9b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么什么是fasttop呢？</p><p id="ab73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是防止双免漏洞的简单检查。它检查容器的顶部是否不是我们要添加到容器中的记录。</p><p id="6615" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，当我们释放一个块时，它将被添加到相应的bin中。如果要释放的块与相应库顶部的块相同，则不会添加该块。在快速箱的情况下，这种检查是快速的。所以我们知道我们不能连续两次释放一个块。</p><p id="7625" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么有没有办法绕过这个检查，两次释放一个块呢？</p><p id="ddb9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，因为检查只针对箱中最上面的记录。我们可以通过释放中间的另一个块来轻松地绕过它，并且我们可以再次释放被释放的块。例如，要双重释放指针c(上例)，我们首先释放c，然后<strong class="kh ir">释放a或b </strong>，这将绕过fasttop检查，最后我们可以再次释放指针c。这将再次释放c中的内存位置，导致双重释放错误。</p><p id="8b8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看实际情况</p><p id="f4a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先让我们编辑代码并重新编译代码。</p><blockquote class="mt mu mv"><p id="60f9" class="kf kg mw kh b ki kj jr kk kl km ju kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated"># include<stdio.h><br/># include&lt;malloc . h&gt;<br/>int main(){<br/><br/>char * a =(char *)malloc(10)；<br/>char * b =(char *)malloc(10)；<br/>char * c =(char *)malloc(10)；<br/> <br/> printf("a在内存%p \n "，a)；<br/> printf("b在内存%p \n "，b)；<br/> printf("c在内存%p \n "，c)；<br/> <br/>自由(一)；<br/> printf("释放a \ n ")；<br/> <br/>自由(c)；<br/> printf("释放c \ n ")；<br/>免费(b)；printf("释放b:绕过fastbin顶部检查\ n ")；<br/>自由(c)；<br/> printf("再次释放c \ n ")；</stdio.h></p><p id="99f3" class="kf kg mw kh b ki kj jr kk kl km ju kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated">返回0；<br/> <br/> }</p></blockquote><div class="lc ld gp gr le lf"><a href="https://pastebin.com/WL09Yhk2" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">编辑双自由-Pastebin.com</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">Pastebin.com是自2002年以来排名第一的粘贴工具。Pastebin是一个网站，在那里你可以在线存储一组文本…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">pastebin.com</p></div></div><div class="lo l"><div class="no l lq lr ls lo lt lu lf"/></div></div></a></div><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/9442d48ddc2898b9a8f2bea5e4e891b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9a97ofHYIxeigImjjf1Lg.png"/></div></div></figure><p id="1996" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们现在所看到的，我们已经成功绕过了topcheck，触发了双重释放漏洞。</p><h2 id="39e7" class="lv lw iq bd lx ly lz dn ma mb mc dp md ko me mf mg ks mh mi mj kw mk ml mm mn bi translated">让我们看下一个例子。</h2><blockquote class="mt mu mv"><p id="b28d" class="kf kg mw kh b ki kj jr kk kl km ju kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated"># include<stdio.h><br/># include&lt;malloc . h&gt;<br/>T28】struct s {<br/>int num；<br/>}；<br/>T32】int main(){<br/>struct s * a，*b，*c，*d，*e，* f；</stdio.h></p><p id="750c" class="kf kg mw kh b ki kj jr kk kl km ju kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated">a = malloc(sizeof(struct s))；<br/>printf(" a at % p \ n "，a)；<br/>T2 b = malloc(sizeof(struct s))；<br/> printf("b在%p \n "，b)；<br/>T5】c = malloc(sizeof(struct s))；<br/>printf(" c at % p \ n "，c)；<br/> <br/> <br/>自由(一)；<br/> printf("释放a : %p \n "，a)；<br/> <br/>自由(c)；<br/> printf("释放c : %p \n "，c)；<br/> <br/>自由(b)；<br/> printf("释放b : %p \n "，b)；//绕过top check<br/><br/>free(c)；<br/> printf("再次释放c:% p \ n "，c)；//Double free <br/> <br/> printf("被释放的bin将被添加到相应的bin中\ n ")；<br/> printf("现在我们再次使用malloc将内存分配到三个指针d、e和f \ n ")；<br/> printf("由于指针d、e和f与先前分配的块具有相同的大小，所以它们将被分配刚刚被释放()d并被添加到fastbin的块\ n ")；<br/>d = malloc(sizeof(struct s))；<br/> printf("d在%p \n "，d)；<br/>T27】e = malloc(sizeof(struct s))；<br/>printf(" e at % p \ n "，e)；<br/><br/>f = malloc(sizeof(struct s))；<br/>printf(" f at % p \ n "，f)；<br/><br/>d-&gt;num = 1111；<br/> printf("d- &gt; num被赋值给1111 \ n ")；<br/><br/>f-&gt;num = 2222；<br/> printf("f- &gt; num被赋值给2222 \ n ")；<br/> <br/> printf("现在让我们打印e- &gt; num和d- &gt; num \n的值")；<br/><br/><br/>printf(" d-&gt;num是%d \n "，d-&gt;num)；<br/> printf("f- &gt; num是%d \n "，f-&gt;num)；<br/> <br/> }</p></blockquote><div class="lc ld gp gr le lf"><a href="https://pastebin.com/QZasDRxd" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">双人免费2-Pastebin.com</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">Pastebin.com是自2002年以来排名第一的粘贴工具。Pastebin是一个网站，在那里你可以在线存储一组文本…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">pastebin.com</p></div></div><div class="lo l"><div class="nq l lq lr ls lo lt lu lf"/></div></div></a></div><p id="94df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编译并运行程序。</p><p id="bbd4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们检查输出。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nr"><img src="../Images/f9f4f7288bacf6f5d9269eeacafdba3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NAUjK9OD6qHEH41ZDLkt6A.png"/></div></div></figure><p id="08a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们为指针a、b和c分配三个内存位置，然后我们释放它们，这样它们将被添加到相同大小的fastbin中。然后我们为接下来的三个指针(d，e，f)分配内存。</p><p id="d68f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在结果中看到的,“d”得到了“c”的位置:0x21028(因为c是最后一个被释放的块，它被添加到了fastbin的头部)。</p><p id="8274" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">' e '将获得' b '的内存位置，最后' f '将再次获得' c '的内存位置(0x21028)。</p><p id="436a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯……所以你们都会想这怎么可能呢？</p><p id="85d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在这篇文章的开始已经说过了，以便熟悉快速垃圾箱以及它们是如何工作的。如果你对垃圾箱没有概念，请仔细阅读前面的文章。</p><h2 id="b47b" class="lv lw iq bd lx ly lz dn ma mb mc dp md ko me mf mg ks mh mi mj kw mk ml mm mn bi translated">故障</h2><p id="99ec" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">现在，让我们一步一步地完成这个过程。</p><p id="8425" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们释放“a”时，它将被添加到大小为0x10 (16)的fastbin中。让我们使用gdb来检查这一点。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ns"><img src="../Images/7c11fc47b5a9aaf8c78d8b451e1f704d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oxS2UvM9V7gQitbl7ymVOQ.png"/></div></div></figure><p id="8241" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您现在看到的，块被添加到了fastbin中，但它被添加到了0x8 fastbin中，但块的实际大小是0x10。不要搞混了，最小大小的fastbin是0x10 (16)没有大小为0x8的fastbin。这只是gef中的一个bug。这通常添加在0x10 fastbin中，如块的大小所示。</p><p id="b112" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们想象一下。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nt"><img src="../Images/7ed6860f3b690b4eb3ee94c111a1cb5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5DuDstaRfN2jDMiit4PFTg.png"/></div></div></figure><p id="d319" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新添加的块将被添加到bin列表的头部。(后进先出方式)。此处fwd指针为空，因为bin中没有其他空闲块。</p><p id="c322" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们释放c，看看会发生什么。我们释放“c”而不是“b”的原因是为了绕过顶部检查。我们将在释放c之后释放b。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nu"><img src="../Images/eba330785c60b99d57b8355028594618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EHkcVkjDDNiRNo8x5gJ0cw.png"/></div></div></figure><p id="def5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，c(地址:0x21028)被添加到0x10 fastbin的开头。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nt"><img src="../Images/0b1581b45bca122476c12c711b1a742f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0orW_NcfVcOhPt7Sc01poQ.png"/></div></div></figure><p id="0d8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">块‘a’先前在头部位置，现在头部指向块‘c’，并且块‘c’的正向指针被设置为指向块‘a’的地址。</p><p id="8b64" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么正向指针是用来做什么的呢？</p><p id="e0d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前向指针(fwd)是指向特定fastbin中的下一个块的指针。当fwd为NULL时，表示列表结束。它可用于链接容器中的块。这可以跟踪列表中可用的空闲块。</p><p id="86c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">fwd在双自由攻击中非常重要，我们稍后会看到这一点。</p><p id="889f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们检查组块c来验证这个理论。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nv"><img src="../Images/54983299cb11a95911294be85a81c0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9KPYOFDGYPvwlegej8beA.png"/></div></div></figure><p id="96fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">紫色标记的区域是前向指针，它指向块“a”。但是‘a’的地址是0x21008，正向指针的地址是0x21000。这是因为前向指针指向位于位置0x21000的块‘a’的‘prev size’报头部分。这也是被释放块的元数据的一部分。但是当我们使用gef检查数据块时，它显示数据块从0x21008开始，因为它没有考虑这个“prev size”元数据(在本例中没有设置)。</p><p id="e7d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以这验证了我们的理论。</p><p id="1b94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们释放b并进行检查。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nw"><img src="../Images/8730d6a8aaa73c58f4340ae37c4eb4a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PbKj0r2Yg-9x2jTh-dCXOA.png"/></div></div></figure><p id="41e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，头部指向0x21018处的块‘b’，块‘b’的正向指针被调整为指向块‘c’。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nt"><img src="../Images/5da3ec2f63bd1b4d0d343f7ebed7de66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N4CP3g0QKcISLh1266f26g.png"/></div></div></figure><p id="2671" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是最重要的部分。这就是双重自由发生的地方。我们将再次释放指针c。</p><p id="0b8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在再次释放“c”后用gef检查。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nx"><img src="../Images/09efe42a999011ca9eb5b28c1dd00ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*liw4OV4kIPr_N-XIZqhacw.png"/></div></div></figure><p id="2b30" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您使用“堆箱”命令检查fastbin，您会看到一些奇怪的东西。如果您查看fastbin中的条目，我们释放以触发double free的块‘c’再次被添加到0x10 fastbin的头部。gef已检测到这种情况，并说“检测到循环”。</p><p id="ecc5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们形象化地理解为什么这是一个循环。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nt"><img src="../Images/594b361519f56b5da81d6e5a8fd817a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5f1SZJYTDFkj3AMsHefgZw.png"/></div></div></figure><p id="d833" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当块‘c’被释放时，它再次被添加到fastbin的头部，并且块‘c’的前向指针被重新调整以指向块‘b’。到块“a”的链接从块“c”中移除。所以在fastbin中没有到块“a”的链接。</p><p id="36a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们把这张图改成更准确的表示法。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nt"><img src="../Images/a43000d8438056e9a10615c97f05ad18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bLY0S5rsTUDTFKZ9Buevw.png"/></div></div></figure><p id="8be8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">块b和块c像一个循环一样指向彼此。</p><p id="cdc0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们为指针d、e和f分配内存。</p><blockquote class="mt mu mv"><p id="48c5" class="kf kg mw kh b ki kj jr kk kl km ju kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated">d = malloc(sizeof(struct s))；<br/>printf(" d at % p \ n "，d)；<br/><br/>e = malloc(sizeof(struct s))；<br/>printf(" e at % p \ n "，e)；<br/>T5】f = malloc(sizeof(struct s))；<br/>printf(" f at % p \ n "，f)；</p></blockquote><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ny"><img src="../Images/332461ea0c454ec9c1bbb4a9bf4dbbe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8jhzifMoIt6F_x1oyxURg.png"/></div></div></figure><p id="9a29" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所知，fastbin以LIFO方式工作，因此添加到fastbin中的最后一条记录将首先被删除，或者如果malloc请求相同的大小，则由fastbin中的头指向的块将被分配给下一个malloc请求。因此，指针“d”将获得块“c”(0x 021028)的内存空间，并且头将指向fastbin中的下一个被释放的块，即块“b”。这个位置使用fwd指针来标识。</p><p id="17c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们现在使用“heap bins”命令检查fastbin，我们可以看到位于fastbin头部的块“c”被删除，头部现在指向块“b”(0x 21018)。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nz"><img src="../Images/c36995ea3b5bc344a5d718c849768508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Kn1ZHYZmUFw8ld_d5m89g.png"/></div></div></figure><p id="5752" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是即使我说它被移走了，由于双自由引起的循环，它在技术上并没有被移走。这是因为块‘b’的fwd仍然指向块‘c ’,所以这会欺骗堆分配器，让它认为块‘c’在fastbin中仍然是空闲的和可用的，即使它正在被分配和使用。这是因为堆分配器使用fwd来跟踪bin中的可用空闲块。因此，块“c”仍被视为空闲块，并且在fastbin中可用。这将形成一个循环链，其中头指向块‘b’，块‘b’指向块‘c’，块‘c’也指向块‘b’。</p><p id="b9c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看图表。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nt"><img src="../Images/423c03fc55fe21ca0e8312d1cd1d8543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQaI3412TuTi8EtS1PbQTg.png"/></div></div></figure></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="ddbf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们为指针“e”分配空间。正如你已经猜到的，现在‘e’将获得块‘b’(0x 21018)的内存空间，它位于fastbin的头部。</p><p id="20e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您使用gef进行检查，您可以看到这一点。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oh"><img src="../Images/8b7bb382e6ed080c73e83f5868eaa800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ALuzIFJtjjOHbJ-ifYplg.png"/></div></div></figure><p id="692a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">$r0包含malloc()为指针“e”返回的地址。这包含0x21018，它是fastbin中被释放的块‘b’的地址。同样，fastbin的头现在指向块‘c’，块‘b’的fwd指针指向块‘c’。</p><p id="0ed9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看fastbin中的块图以及gef中“堆箱”的输出。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nt"><img src="../Images/c0952e12676bca06672cfa33ae4c853e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cg0a6w_KQy6_PCt4XMHG4g.png"/></div></div></figure><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oi"><img src="../Images/ed4fb9249b2dbb700e86229360db640b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pJ_I_MhemeBt2X5iI_cwHg.png"/></div></div></figure></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="a0a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果继续执行，指针“f”将被分配到位于列表头部的块“c”(0x 21028)的内存位置，并且头部被更新到块“b”(0x 21018)。</p><p id="92c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们最后一次检查这个。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oj"><img src="../Images/b81ebdae6bd6aea94ebe9b6a78ccd6ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EkACtClUC9sZ57rgyGeXig.png"/></div></div></figure><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ok"><img src="../Images/8fd1c84f05a346d63e9d97d69f766b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJ5sQmzDtHuv3iXlB2v5YQ.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk translated">$ro包含malloc返回的内存位置。</figcaption></figure><p id="005e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以得出结论，作为double-free错误的结果，它返回<strong class="kh ir">块‘b’和块‘c’可互换</strong>。这是因为它形成了一个<strong class="kh ir">环。</strong>如果我们继续分配新的内存，我们只会交替分配<strong class="kh ir"> 0x21028和0x 21018</strong>。</p><p id="28bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过修改这个程序来验证这一点。</p><blockquote class="mt mu mv"><p id="ff8e" class="kf kg mw kh b ki kj jr kk kl km ju kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated">int num<br/><br/>}；<br/><br/><br/>int main(){<br/><br/>struct s * a、*b、*c、*d、*e、*f、*g、* h；<br/><br/>a = malloc(sizeof(struct s))；<br/>printf(" a at % p \ n "，a)；<br/><br/>b = malloc(sizeof(struct s))；<br/> printf("b在%p \n "，b)；<br/>T14】c = malloc(sizeof(struct s))；<br/> printf("c在%p \n "，c)；<br/> <br/> <br/>自由(一)；<br/> printf("释放a : %p \n "，a)；<br/> <br/>自由(c)；<br/> printf("释放c : %p \n "，c)；<br/> <br/>自由(b)；<br/> printf("释放b : %p \n "，b)；//绕过top check<br/><br/>free(c)；<br/> printf("释放c : %p再次\n "，c)；//Double free <br/> <br/> printf("释放的bin将被添加到相应的bin中\ n ")；<br/> printf("现在我们再次使用malloc将内存分配到三个指针d、e和f \ n ")；<br/> printf("由于指针d、e和f与先前分配的块具有相同的大小，所以它们将被分配刚刚被释放()d并被添加到fastbin的块\ n ")；<br/>d = malloc(sizeof(struct s))；<br/> printf("d在%p \n "，d)；<br/>T36】e = malloc(sizeof(struct s))；<br/>printf(" e at % p \ n "，e)；<br/>T39】f = malloc(sizeof(struct s))；<br/>printf(" f at % p \ n "，f)；<br/>T42【g = malloc(sizeof(struct s))；<br/> printf("g在%p \n "，g)；<br/>T45】h = malloc(sizeof(struct s))；<br/> printf("h在%p \n "，h)；<br/><br/>d-&gt;num = 1111；<br/> printf("d- &gt; num被赋值给1111 \ n ")；<br/><br/>f-&gt;num = 2222；<br/> printf("f- &gt; num被赋给2222 \ n ")；<br/> <br/> printf("现在让我们打印e- &gt; num和d- &gt; num \n的值")；<br/><br/><br/>printf(" d-&gt;num是%d \n "，d-&gt;num)；<br/> printf("f- &gt; num是%d \n "，f-&gt;num)；<br/> <br/> }</p></blockquote><div class="lc ld gp gr le lf"><a href="https://pastebin.com/DkPse2iT" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">编辑双自由-Pastebin.com</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">Pastebin.com是自2002年以来排名第一的粘贴工具。Pastebin是一个网站，在那里你可以在线存储一组文本…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">pastebin.com</p></div></div><div class="lo l"><div class="op l lq lr ls lo lt lu lf"/></div></div></a></div><p id="4e31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个程序中，有额外的指针分配更多的内存。让我们检查输出。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oq"><img src="../Images/587bce0b1b3a47ec68e1bd77c898cb26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNojIMOjgIXny4YtYszZ8w.png"/></div></div></figure><p id="3530" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您现在看到的，它只交替返回0x21018和0x21028。不管我们尝试malloc()多少次，堆分配器只会返回这两个内存位置。</p><p id="8908" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来探索程序的最后一部分。</p><blockquote class="mt mu mv"><p id="aafa" class="kf kg mw kh b ki kj jr kk kl km ju kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated">d-&gt; num = 1111；<br/> printf("d- &gt; num被赋值给1111 \ n ")；<br/><br/>f-&gt;num = 2222；printf("f- &gt; num被赋值给2222 \ n ")；<br/> <br/> printf("现在让我们打印e- &gt; num和d- &gt; num \n的值")；<br/> printf("d- &gt; num是%d \n "，d-&gt;num)；<br/> printf("f- &gt; num是%d \n "，f-&gt;num)；<br/> <br/> }</p></blockquote><p id="e46a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们看看这个程序的输出，它将d-&gt;num和f-&gt;num的输出打印为2222，即使两者被赋予不同的值。d-&gt;num被指定为1111，f-&gt;num被指定为2222。那么这是什么原因呢？</p><p id="9193" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你们中的一些人现在可能已经明白了。</p><p id="493a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原因是d和f都指向<strong class="kh ir">同一个内存位置</strong>。</p><p id="2386" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于double free()，e和f都指向0x021028。</p><p id="045d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当d-&gt;num被赋值为‘1111’时，它实际上是将数据写入内存位置‘0x 021028’。稍后，当f-&gt;num被赋值为“2222”时，它也写入位置0x021028，该位置与“d”使用的块相同。所以它将值改写为2222。这就是为什么d-&gt;num的输出变成了‘2222’。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi or"><img src="../Images/bb828f1be585bc7ad0e62262e0671f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6a6R30rD9yM3G_l6IZMrYg.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk translated">输出</figcaption></figure><p id="cc5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这基本上总结了<strong class="kh ir">双免漏洞</strong>的演示。</p><figure class="nc nd ne nf gt ng"><div class="bz fp l di"><div class="os nn l"/></div></figure></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="c457" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下一篇文章中，我们将对双重释放漏洞进行二进制挑战。</p><p id="13ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，再见</p><p id="bfd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有任何疑问，请留言或联系我。</p><p id="ddab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">https://www.facebook.com/i.am.ultralegend<a class="ae lb" href="https://www.facebook.com/i.am.ultralegend" rel="noopener ugc nofollow" target="_blank">脸书</a></p><p id="1c5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想支持我或者学习<strong class="kh ir"> ARM开发</strong>请查看我的课程:<a class="ae lb" href="https://www.udemy.com/course/reverse-engineering-and-binary-exploitation-in-arm/?referralCode=8C725D513E77420A0CBF" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/course/reverse-engineering-and-binary-exploitation-in-ARM/？referral code = 8c 725d 513 e 77420 a0cb</a></p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="a4b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">参考文献</em></p><p id="1b78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/" rel="noopener ugc nofollow" target="_blank">https://azeria-labs . com/heap-exploitation-part-2-glibc-heap-free-bins/</a><a class="ae lb" href="https://heap-exploitation.dhavalkapil.com/attacks/double_free" rel="noopener ugc nofollow" target="_blank">https://heap-exploitation . dhavalkapil . com/attacks/double _ free</a></p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="eac5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mw">来自Infosec的报道:Infosec上每天都会出现很多难以跟上的内容。</em> <a class="ae lb" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="mw">加入我们的每周简讯</em> </strong> </a> <em class="mw">以5篇文章、4个线程、3个视频、2个Github Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</em></p></div></div>    
</body>
</html>