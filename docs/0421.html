<html>
<head>
<title>Fasten your Recon process using Shell Scripting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Shell脚本加速您的侦察过程</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/fasten-your-recon-process-using-shell-scripting-359800905d2a?source=collection_archive---------0-----------------------#2019-11-16">https://infosecwriteups.com/fasten-your-recon-process-using-shell-scripting-359800905d2a?source=collection_archive---------0-----------------------#2019-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="a9be" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">许多新黑客没有利用自动化的力量，但一旦你习惯了，就没有回头路了。</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/fecf80de10804e0b4bb3bd94ab76ad0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMOl23fzkNvkwdR8JLr0Gg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">使用shell脚本进行侦察</figcaption></figure><p id="f8e0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">当你入侵一个系统时，侦察是很重要的一部分，因为它让你了解这个系统，以及当你入侵时你能覆盖多少区域，有时你仅仅通过侦察就能发现很多很酷的漏洞，例如</p><ul class=""><li id="7b88" class="li lj iq jt b ju jv jy jz lf lk lg ll lh lm ko ln lo lp lq bi translated">敏感信息泄露。</li><li id="43bd" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">打开S3桶。</li><li id="94d2" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">子域接管。</li><li id="aa4a" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">错误应用程序的使用。</li></ul><p id="d45e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">所以做侦察不仅能给你提供一堆重要的数据，还能帮助你找到T2的快速漏洞。在本文中，我们将介绍一些我在侦察时使用的自动化技术，它不仅节省时间，还能让我清楚地了解系统的所有部分。</p><h2 id="d5d0" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lg mi mj mk lh ml mm mn mo bi translated">入门指南</h2><p id="aa66" class="pw-post-body-paragraph jq jr iq jt b ju mp jw jx jy mq ka kb lf mr ke kf lg ms ki kj lh mt km kn ko ij bi translated">在我们开始之前，我建议您了解以下主题的基本知识:</p><ul class=""><li id="f102" class="li lj iq jt b ju jv jy jz lf lk lg ll lh lm ko ln lo lp lq bi translated">了解<a class="ae mu" href="https://maker.pro/linux/tutorial/basic-linux-commands-for-beginners" rel="noopener ugc nofollow" target="_blank">基本Linux命令</a>和<a class="ae mu" href="https://www.guru99.com/introduction-to-shell-scripting.html" rel="noopener ugc nofollow" target="_blank"> Shell脚本</a>。</li><li id="aec3" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">基本网络知识和对<a class="ae mu" href="https://www.techopedia.com/definition/438/clientserver-architecture" rel="noopener ugc nofollow" target="_blank">客户端-服务器架构</a>的理解。</li><li id="6a2c" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">了解不同的协议http，ftp，ssh等。</li></ul><h2 id="41a9" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lg mi mj mk lh ml mm mn mo bi translated">方法</h2><p id="712a" class="pw-post-body-paragraph jq jr iq jt b ju mp jw jx jy mq ka kb lf mr ke kf lg ms ki kj lh mt km kn ko ij bi translated">我们将按照下面的方法进行侦察。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mv"><img src="../Images/446b096146b0d18afc59fc1388f65edd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*coGbvxd1o1Qm9KY8eUMN4w.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">侦察接近</figcaption></figure><ul class=""><li id="310d" class="li lj iq jt b ju jv jy jz lf lk lg ll lh lm ko ln lo lp lq bi translated">子域枚举——我们将看到如何自动化我们的子域枚举过程，并能收集尽可能多的域。</li><li id="83f7" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">数据收集—此阶段将重点收集关于主机的不同类型的数据，例如开放端口、JS文件、技术、标头响应等。</li><li id="36e6" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">数据处理——在这个阶段，我们将尝试从收集的数据中抓取不同的资产，并将看到一些快速查找bug的技术。</li></ul><h1 id="5e8b" class="mw lx iq bd ly mx my mz mb na nb nc me nd ne nf mh ng nh ni mk nj nk nl mn nm bi translated">子域枚举</h1><p id="1c5e" class="pw-post-body-paragraph jq jr iq jt b ju mp jw jx jy mq ka kb lf mr ke kf lg ms ki kj lh mt km kn ko ij bi translated">有很多工具可用于子域枚举，下面列出了我使用的一个</p><ul class=""><li id="13ab" class="li lj iq jt b ju jv jy jz lf lk lg ll lh lm ko ln lo lp lq bi translated">子列表3r—<a class="ae mu" href="https://github.com/aboul3la/Sublist3r" rel="noopener ugc nofollow" target="_blank">https://github.com/aboul3la/Sublist3r</a></li><li id="0ece" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">由<a class="nn no ep" href="https://medium.com/u/6dadd1681332?source=post_page-----359800905d2a--------------------------------" rel="noopener" target="_blank">汤姆诺姆</a>https://github.com/tomnomnom/assetfinder<a class="ae mu" href="https://github.com/tomnomnom/assetfinder" rel="noopener ugc nofollow" target="_blank">找到的资产</a></li><li id="d08a" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">谷歌呆子——玩谷歌呆子的时候，最好是手动操作。</li><li id="0791" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">GitHub——有时GitHub也会公开一些组织内部使用的子域。</li><li id="9c16" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated"><a class="ae mu" href="https://crt.sh" rel="noopener ugc nofollow" target="_blank"> crt.sh </a> —它允许你使用通配符，这个工具将帮助你识别一个组织的域结构。</li></ul><p id="06de" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">单独使用上述所有工具将花费大量时间，并且收集的数据需要正确格式化以便进一步处理。因此，让我们消除所有的麻烦，并尝试自动化我们的子域枚举过程。</p><p id="e63d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">在我们开始编写脚本之前，确保您已经在您的机器上下载并安装了<a class="ae mu" href="https://github.com/aboul3la/Sublist3r" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir">子列表3r </strong> </a>、<a class="ae mu" href="https://github.com/tomnomnom/assetfinder" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir"> Assetfinder </strong> </a>和<a class="ae mu" href="https://github.com/tomnomnom/httprobe" rel="noopener ugc nofollow" target="_blank"><strong class="jt ir">http probe</strong></a>。</p><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="afd6" class="lw lx iq nq b gy nu nv l nw nx">##!/bin/bash</span><span id="1aeb" class="lw lx iq nq b gy ny nv l nw nx">#starting sublist3r</span><span id="55b4" class="lw lx iq nq b gy ny nv l nw nx">sublist3r -d $1 -v -o domains.txt</span><span id="2467" class="lw lx iq nq b gy ny nv l nw nx">#running assetfinder</span><span id="bd7a" class="lw lx iq nq b gy ny nv l nw nx">~/go/bin/assetfinder --subs-only $1 | tee -a domains.txt</span><span id="38d7" class="lw lx iq nq b gy ny nv l nw nx">#removing duplicate entries</span><span id="7e25" class="lw lx iq nq b gy ny nv l nw nx">sort -u domains.txt -o domains.txt</span><span id="e984" class="lw lx iq nq b gy ny nv l nw nx">#checking for alive domains</span><span id="33e7" class="lw lx iq nq b gy ny nv l nw nx">echo "\n\n[+] Checking for alive domains..\n"<br/>cat domains.txt | ~/go/bin/httprobe | tee -a alive.txt</span><span id="d12a" class="lw lx iq nq b gy ny nv l nw nx">#formatting the data to json</span><span id="65ea" class="lw lx iq nq b gy ny nv l nw nx">cat alive.txt | python -c "import sys; import json; print (json.dumps({'domains':list(sys.stdin)}))" &gt; alive.json</span><span id="252a" class="lw lx iq nq b gy ny nv l nw nx">cat domains.txt | python -c "import sys; import json; print (json.dumps({'domains':list(sys.stdin)}))" &gt; domains.json</span></pre><p id="123f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">在上面的脚本中，我们使用了<a class="ae mu" href="https://github.com/aboul3la/Sublist3r" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir"> Sublist3r </strong> </a>和<a class="ae mu" href="https://github.com/tomnomnom/assetfinder" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir"> Assetfinder </strong> </a>进行子域枚举，然后使用<strong class="jt ir"> sort </strong>删除重复的条目。我们在上面的脚本中增加了一个步骤来检查实际上有多少个域是活动的，为此我们使用了一个名为<a class="ae mu" href="https://github.com/tomnomnom/httprobe" rel="noopener ugc nofollow" target="_blank"><strong class="jt ir">http probe</strong></a>by<a class="nn no ep" href="https://medium.com/u/6dadd1681332?source=post_page-----359800905d2a--------------------------------" rel="noopener" target="_blank">TomNomNom</a>的工具，并将活动的域保存在另一个名为<strong class="jt ir"> alive.txt </strong>的文件中。</p><p id="7f3b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">要运行该脚本，请使用以下命令</p><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="9bf4" class="lw lx iq nq b gy nu nv l nw nx">$ sudo chmod 755 enum.sh #setting file permissions<br/>$ ./enum.sh example.com</span></pre><p id="09f4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">一旦您将运行该脚本，您将获得以下四个文件domains.txt、domains.json、alive.txt和alive.json，其中包含文本和json格式的所有子域。</p><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="e057" class="lw lx iq nq b gy nu nv l nw nx">├── alive.json<br/>├── alive.txt<br/>├── domains.json<br/>├── domains.txt<br/>└── enum.sh</span><span id="e496" class="lw lx iq nq b gy ny nv l nw nx">0 directories, 5 files</span></pre><p id="ab6e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这是我们完成第一步的地方，如果你愿意，你可以修改脚本并添加更多的工具和修改，或者你可以使用<strong class="jt ir"> Google dorks </strong>和<strong class="jt ir"> GitHub </strong>手动添加更多的域(更多的域意味着更多的数据，这意味着更多的bug)，但如果你想照原样使用它，这完全没问题。</p><h1 id="799e" class="mw lx iq bd ly mx my mz mb na nb nc me nd ne nf mh ng nh ni mk nj nk nl mn nm bi translated">数据收集</h1><h2 id="9993" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lg mi mj mk lh ml mm mn mo bi translated"><strong class="ak">存储子域标题和响应正文</strong></h2><p id="cc44" class="pw-post-body-paragraph jq jr iq jt b ju mp jw jx jy mq ka kb lf mr ke kf lg ms ki kj lh mt km kn ko ij bi translated">我们得到了一堆子域，现在让我们开始处理它们，在这一步，我们将捕获存储在<strong class="jt ir"> alive.txt </strong>中的子域的所有响应头和响应体，我们将使用<strong class="jt ir"> cURL </strong>作为我们的主要工具。</p><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="a160" class="lw lx iq nq b gy nu nv l nw nx">#!/bin/bash</span><span id="a0a5" class="lw lx iq nq b gy ny nv l nw nx">mkdir headers<br/>mkdir responsebody</span><span id="a440" class="lw lx iq nq b gy ny nv l nw nx">CURRENT_PATH=$(pwd)</span><span id="c1d8" class="lw lx iq nq b gy ny nv l nw nx">for x in $(cat $1)<br/>do<br/>        NAME=$(echo $x | awk -F/ '{print $3}')<br/>        curl -X GET -H "X-Forwarded-For: evil.com" $x -I &gt; "$CURRENT_PATH/headers/$NAME"<br/>        curl -s -X GET -H "X-Forwarded-For: evil.com" -L $x &gt; "$CURRENT_PATH/responsebody/$NAME"<br/>done</span></pre><p id="bc54" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">在上面的脚本中，我们遍历存储在<strong class="jt ir"> alive.txt </strong>中的所有域，并发送cURL请求来获取头和响应体，然后将它们存储在<code class="fe nz oa ob nq b">headers</code>和<code class="fe nz oa ob nq b">responsebody</code>目录中。</p><p id="39ab" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">使用以下命令运行脚本</p><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="3b40" class="lw lx iq nq b gy nu nv l nw nx">$ sudo chmod 755 response.sh<br/>$ ./response.sh alive.txt</span></pre><h2 id="62c6" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lg mi mj mk lh ml mm mn mo bi translated">收集JavaScript文件和隐藏端点</h2><p id="9718" class="pw-post-body-paragraph jq jr iq jt b ju mp jw jx jy mq ka kb lf mr ke kf lg ms ki kj lh mt km kn ko ij bi translated">从JavaScript文件中收集数据是Recon过程中最重要的步骤之一。在这一步中，我们将从上一步中收集的<strong class="jt ir">响应正文文本</strong>中收集所有的<strong class="jt ir"> JavaScript文件</strong>。</p><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="4fad" class="lw lx iq nq b gy nu nv l nw nx">#!/bin/bash</span><span id="6331" class="lw lx iq nq b gy ny nv l nw nx">mkdir scripts<br/>mkdir scriptsresponse</span><span id="375d" class="lw lx iq nq b gy ny nv l nw nx">RED='\033[0;31m'<br/>NC='\033[0m'<br/>CUR_PATH=$(pwd)</span><span id="490d" class="lw lx iq nq b gy ny nv l nw nx">for x in $(ls "$CUR_PATH/responsebody")<br/>do<br/>        printf "\n\n${RED}$x${NC}\n\n"<br/>        END_POINTS=$(cat "$CUR_PATH/responsebody/$x" | grep -Eoi "src=\"[^&gt;]+&gt;&lt;/script&gt;" | cut -d '"' -f 2)<br/>        for end_point in $END_POINTS<br/>        do<br/>                len=$(echo $end_point | grep "http" | wc -c)<br/>                mkdir "scriptsresponse/$x/"<br/>                URL=$end_point<br/>                if [ $len == 0 ]<br/>                then<br/>                        URL="<a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/$x$end_point">https://$x$end_point</a>"<br/>                fi<br/>                file=$(basename $end_point)<br/>                curl -X GET $URL -L &gt; "scriptsresponse/$x/$file"<br/>                echo $URL &gt;&gt; "scripts/$x"<br/>        done<br/>done</span></pre><p id="3b67" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">将文件保存为<strong class="jt ir"> jsfiles.sh </strong>并运行以下命令。</p><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="2ff2" class="lw lx iq nq b gy nu nv l nw nx">$ chmod 755 jsfiles.sh<br/>$ ./jsfiles.sh</span></pre><p id="b04f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">上面的脚本将从响应体中抓取所有绝对和相对的JavaScript文件路径，并将根据<code class="fe nz oa ob nq b">scripts</code>目录中的子域隔离所有路径。因此，如果您想查看所有与abc.example.com相关的JavaScript文件，您可以从文件<code class="fe nz oa ob nq b">scripts/abc.example.com</code>中获得。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oc"><img src="../Images/0eefcc0dd64ca22493338c837214f865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MgYvLExysHWKrjx4OznXGA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">JavaScript URLs将根据脚本目录下的域名进行分离。</figcaption></figure><p id="0b2b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">该脚本还会将JavaScript文件内容存储在<code class="fe nz oa ob nq b">scriptresponse/{domainname}</code>目录下，例如所有来自abc.example.com的JavaScript文件内容都将存储在<code class="fe nz oa ob nq b">scriptresponse/abc.example.com/</code>目录下。</p><p id="5d03" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">我们有了JavaScript URLs和它们各自的内容，下一步是从这些文件中收集数据，我们将尝试收集的第一件事是一些隐藏的端点，为此我们将使用一个名为<a class="ae mu" href="https://github.com/jobertabma/relative-url-extractor" rel="noopener ugc nofollow" target="_blank"> relative-url-extractor </a>的工具，作者是<a class="nn no ep" href="https://medium.com/u/95552f4b0e3c?source=post_page-----359800905d2a--------------------------------" rel="noopener" target="_blank"> Jobert Abma，</a>该工具将收集JavaScript文件中存在的所有相对路径，我们这样做的原因是因为我们最终可以获得一些有趣的端点和配置。</p><blockquote class="jn jo jp"><p id="8969" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">确保在您的主目录中克隆相对url提取工具</p></blockquote><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="8d2f" class="lw lx iq nq b gy nu nv l nw nx">#!/bin/bash</span><span id="5fdb" class="lw lx iq nq b gy ny nv l nw nx">#looping through the scriptsresponse directory</span><span id="1322" class="lw lx iq nq b gy ny nv l nw nx">mkdir endpoints</span><span id="7161" class="lw lx iq nq b gy ny nv l nw nx">CUR_DIR=$(pwd)</span><span id="4927" class="lw lx iq nq b gy ny nv l nw nx">for domain in $(ls scriptsresponse)<br/>do<br/>        #looping through files in each domain<br/>        mkdir endpoints/$domain<br/>        for file in $(ls scriptsresponse/$domain)<br/>        do<br/>                ruby ~/relative-url-extractor/extract.rb scriptsresponse/$domain/$file &gt;&gt; endpoints/$domain/$file <br/>        done<br/>done</span></pre><p id="371b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">将脚本保存为<strong class="jt ir"> endpoints.sh </strong>并运行以下命令。</p><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="acf4" class="lw lx iq nq b gy nu nv l nw nx">$ chmod 755 endpoints.sh<br/>$ ./endpoints.sh</span></pre><p id="fec4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">上面的脚本将遍历所有收集的JavaScript文件，并将其传递给我们的relative-url-extractor工具。一旦运行上述脚本，您将拥有包含所有端点相关数据的<code class="fe nz oa ob nq b">endpoints</code>目录。例如，如果你想从域<code class="fe nz oa ob nq b">abc.example.com </code>中知道文件<code class="fe nz oa ob nq b">abc.js </code>中存在的端点，那么它将存在于<code class="fe nz oa ob nq b">endpoints/abc.example.com/abc.js</code>文件中。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi od"><img src="../Images/276572a2e5755bffbfd366e3f9ca16f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pyJSvd96AKNA73Hp5EXC5A.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">JavaScript文件中存在的端点。</figcaption></figure><p id="b0c1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">到目前为止，我们已经收集了足够多的数据，但我们还可以收集一些其他的东西，那就是主机上打开的端口和运行的服务的数量。为此，我们将使用<a class="ae mu" href="https://nmap.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jt ir">【nmap】</strong></a>，我们将在迄今为止收集的所有子域上运行<strong class="jt ir"> nmap </strong>，并将结果存储在<code class="fe nz oa ob nq b">nmapscans</code>目录中。</p><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="65bb" class="lw lx iq nq b gy nu nv l nw nx">#!/bin/bash<br/>mkdir nmapscans</span><span id="ad0c" class="lw lx iq nq b gy ny nv l nw nx">for domain in $(cat $1)<br/>do<br/>        nmap -sC -sV $domain | tee nmapscans/$domain<br/>done</span></pre><p id="f11f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">将脚本保存为<strong class="jt ir"> nmap.sh </strong>并使用以下命令运行它。</p><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="6719" class="lw lx iq nq b gy nu nv l nw nx">$ chmod 755 nmap.sh<br/>$ ./nmap.sh domains.txt</span></pre><p id="f108" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">上面的脚本很简单，它将把所有出现在<strong class="jt ir"> domains.txt </strong>中的域传递到<strong class="jt ir"> nmap </strong>中，并将结果存储在<code class="fe nz oa ob nq b">nmapscans</code>目录中，但是执行起来会花费相当多的时间(只有当你有一堆要扫描的域时)，所以暂时离开这个过程，喝杯咖啡。</p><p id="3f98" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">现在我们几乎已经完成了我们的数据收集阶段，剩下的最后一件事是<strong class="jt ir">截屏，</strong>我们有大量的文本数据，我们还需要一些我们目标的良好视觉效果，截屏有时会导致快速的错误和发现。</p><p id="c865" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">我们将使用<a class="ae mu" href="https://github.com/michenriksen/aquatone" rel="noopener ugc nofollow" target="_blank"> aquatone </a>获取网页截图，为此我们不需要实际的脚本，我们只需要将我们的<strong class="jt ir"> alive.txt </strong>域传递给aquatone，它将为我们生成<strong class="jt ir">截图</strong>。</p><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="094a" class="lw lx iq nq b gy nu nv l nw nx">$ cat alive.txt | aquatone -out ~/example.com/screenshots/</span></pre><p id="0a00" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">我们的数据收集阶段到此结束。到目前为止，我们已经收集了以下数据:</p><ul class=""><li id="c980" class="li lj iq jt b ju jv jy jz lf lk lg ll lh lm ko ln lo lp lq bi translated">子域——更多的域意味着更多的数据要查看。</li><li id="a277" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">响应标头和响应文本—可用于指纹识别，并对文本运行正则表达式以查找不同类型的数据，例如s3存储桶、秘密令牌等。</li><li id="3d42" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">JavaScript文件—查找隐藏的端点、敏感数据泄露、JavaScript劫持和手动代码测试。</li><li id="3dea" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">Nmap扫描—打开主机上运行的端口和技术。</li><li id="c2fe" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">网络截图——用于快速检查和快速发现错误。</li></ul><p id="0ef9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated"><strong class="jt ir">数据收集</strong>阶段并不局限于上面提到的技术，您可以添加更多的技术，但是为了这篇文章，我们将结束<strong class="jt ir">数据收集</strong>阶段，以使事情变得简单一些。</p><h1 id="2c09" class="mw lx iq bd ly mx my mz mb na nb nc me nd ne nf mh ng nh ni mk nj nk nl mn nm bi translated">数据处理</h1><p id="06fb" class="pw-post-body-paragraph jq jr iq jt b ju mp jw jx jy mq ka kb lf mr ke kf lg ms ki kj lh mt km kn ko ij bi translated">这个旅程几乎已经结束了(不完全是，recon实际上是一个永无止境的过程)，我们已经收集了一堆数据，现在下一步是处理数据，找出漏洞和其他有用的信息。</p><p id="9eb9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">最后，我们将编写一个脚本来查找我们收集的数据中的特定字符串，这不仅可以帮助我们一次识别多个资产，还可以帮助我们获得一些敏感数据。</p><blockquote class="jn jo jp"><p id="c121" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">有趣的事实:- 在写这篇文章的时候，我用上面的方法发现了两个信息泄露的错误。</p></blockquote><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="341e" class="lw lx iq nq b gy nu nv l nw nx">#!/bin/bash</span><span id="e917" class="lw lx iq nq b gy ny nv l nw nx">BOLD="\e[1m"<br/>NORMAL="\e[0m"<br/>GREEN="\e[32m"<br/>RED="\e[30m"</span><span id="d652" class="lw lx iq nq b gy ny nv l nw nx">HELP="<br/>${BOLD}[+]USAGE:${NORMAL} ./search.sh  (OPTIONS)</span><span id="43a9" class="lw lx iq nq b gy ny nv l nw nx">-j (string) - search in javascript files<br/>-x (string) - search in header files<br/>-e (string) - search in  html files<br/>-n (string) - search nmap scans<br/>-h - help<br/>"</span><span id="14da" class="lw lx iq nq b gy ny nv l nw nx">#writing code to check for expressions in html<br/>searchhtml() {<br/> local WORD="${1}"<br/> for domain in $(ls responsebody)<br/> do<br/>  echo -e "\n${BOLD}${GREEN}${domain}${NORMAL}"<br/>  RES=$(cat responsebody/$domain | grep -E "${WORD}")<br/>  if [ $(echo $RES | wc -c) -le 1 ]<br/>  then<br/>   echo -e "${BOLD}${RED}No results found${NORMAL}"<br/>  else<br/>   echo $RES<br/>  fi<br/> done<br/>}</span><span id="e050" class="lw lx iq nq b gy ny nv l nw nx">searchheader() {<br/> local WORD="${1}"<br/>        for domain in $(ls headers)<br/>        do<br/>  echo -e "\n${BOLD}${GREEN}${domain}${NORMAL}"<br/>                RES=$(cat headers/$domain | grep -E "${WORD}")<br/>  if [ $(echo $RES | wc -c) -le 1 ]<br/>                then<br/>                        echo -e "${BOLD}${RED}No results found${NORMAL}"<br/>                else<br/>                        echo $RES<br/>                fi</span><span id="c7b8" class="lw lx iq nq b gy ny nv l nw nx">done<br/>}</span><span id="b211" class="lw lx iq nq b gy ny nv l nw nx">searchjs() {<br/> local WORD="${1}"<br/>        for domain in $(ls scriptsresponse)<br/>        do<br/>  for file in $(ls scriptsresponse/$domain)<br/>  do<br/>   echo -e "\n${BOLD}${GREEN}${domain}/${file}${NORMAL}"<br/>                 RES=$(grep --color -E "${WORD}" scriptsresponse/$domain/$file)<br/>                 if [ $(echo $RES | wc -c) -le 1 ]<br/>                 then<br/>                         echo -e "${BOLD}${RED}No results found${NORMAL}"<br/>                 else<br/>                         echo $RES<br/>                 fi</span><span id="ae7c" class="lw lx iq nq b gy ny nv l nw nx">done<br/> done<br/>}<br/>searchnmap() {<br/> local WORD="${1}"<br/>        for domain in $(ls nmapscans)<br/>        do<br/>                echo -e "\n${BOLD}${GREEN}${domain}${NORMAL}"<br/>                RES=$(cat nmapscans/$domain | grep -E "${WORD}")<br/>                if [ $(echo $RES | wc -c) -le 1 ]<br/>                then<br/>                        echo -e "${BOLD}${RED}No results found${NORMAL}"<br/>                else<br/>                        echo $RES<br/>                fi</span><span id="c934" class="lw lx iq nq b gy ny nv l nw nx">done</span><span id="b2fc" class="lw lx iq nq b gy ny nv l nw nx">}</span><span id="0455" class="lw lx iq nq b gy ny nv l nw nx">while getopts j:x:e:n:h OPTIONS<br/>do<br/> case "${OPTIONS}" in<br/>  j) searchjs "${OPTARG}" ;;<br/>  e) searchhtml "${OPTARG}" ;;<br/>  x) searchheader "${OPTARG}" ;;<br/>  n) searchnmap "${OPTARG}" ;;<br/>  h) echo -e "${HELP}" ;;<br/>  *)<br/>   echo "[+] Select a valid option.\n"<br/>   echo -e "${HELP}"<br/>   exit 1<br/>  ;;<br/> esac<br/>done</span></pre><p id="5fa1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">上面的脚本使用命令行选项在HTML、JavaScript、Nmap扫描和头文件中搜索指定的输入。该脚本简单地遍历所有收集的数据，并使用<code class="fe nz oa ob nq b">grep</code>来查找匹配的关键字。</p><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="7af8" class="lw lx iq nq b gy nu nv l nw nx">root@ubuntu:~/example.com$ ./search.sh -h</span><span id="3888" class="lw lx iq nq b gy ny nv l nw nx">[+]USAGE: ./search.sh  (OPTIONS)</span><span id="b187" class="lw lx iq nq b gy ny nv l nw nx">-j (string) - search in javascript files<br/>-x (string) - search in header files<br/>-e (string) - search in  html files<br/>-n (string) - search nmap scans<br/>-h - help</span></pre><p id="cd7f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">下面显示了使用上述脚本的一些示例:</p><pre class="kq kr ks kt gt np nq nr ns aw nt bi"><span id="308c" class="lw lx iq nq b gy nu nv l nw nx">$ ./search.sh -j "admin"<br/>$ ./search.sh -x "nginx"<br/>$ ./search.sh -e "s3.amazonaws"<br/>$ ./search.sh -n "ssh" #searching nmap scans for the string ssh</span></pre><p id="11f6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">在第一个例子中，将在所有的<strong class="jt ir"> JavaScript文件</strong>中搜索字符串<strong class="jt ir"> "admin" </strong>。在第二个示例中，将在我们在数据收集阶段收集的所有<strong class="jt ir">标题响应</strong>中搜索字符串<strong class="jt ir"> "nginx" </strong>，第三个示例将在<strong class="jt ir">响应主体</strong>中查找字符串<strong class="jt ir"> "s3.amazonaws" </strong>。</p><p id="fd10" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated"><strong class="jt ir">自己试试:</strong>如果你愿意，你可以创建一个定制的<strong class="jt ir">单词列表</strong>，并可以编写一个简单的shell脚本，将单词列表中的单词传递给<strong class="jt ir"> search.sh </strong>脚本，以便快速发现资产。</p><p id="41f3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这是我们的<strong class="jt ir">数据处理</strong>阶段的结束，例如，您可以向此阶段添加更多内容；<strong class="jt ir">使用CNAME </strong>检查s3存储桶，<strong class="jt ir">针对所有收集的主机</strong>测试 <a class="ae mu" href="https://hackerone.com/reports/369581" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir"> PUT方法</strong> </a> <strong class="jt ir">，自动执行任务<strong class="jt ir">检查打开的存储桶</strong>等。</strong></p><h1 id="909d" class="mw lx iq bd ly mx my mz mb na nb nc me nd ne nf mh ng nh ni mk nj nk nl mn nm bi translated">结束注释:-</h1><blockquote class="oe"><p id="fbf4" class="of og iq bd oh oi oj ok ol om on ko dk translated">我相信侦查是一个永无止境的过程，你收集的数据越多，它就越少。</p></blockquote><p id="5fe0" class="pw-post-body-paragraph jq jr iq jt b ju oo jw jx jy op ka kb lf oq ke kf lg or ki kj lh os km kn ko ij bi translated">从上面的方法中，我们了解了shell脚本如何能够加速这个过程，并且能够在几分钟内收集大量的数据，您将为自动化编写的脚本将在每次您使用它们并且在寻找bug时遇到新的场景时得到增强。</p><p id="fe7e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">你可以自由地调整上面的脚本和我使用的方法，你可以在上面的recon过程中添加更多的阶段和更多的工具以获得更多的增强，你可以在下面的<strong class="jt ir"> Github仓库中找到所有上面的脚本，</strong>请随意投稿:)。</p><div class="ot ou gp gr ov ow"><a href="https://github.com/shibli2700/Rekon" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd ir gy z fp pb fr fs pc fu fw ip bi translated">shibli 2700/雷康</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">该项目包含多个shell脚本，用于自动执行大多数</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">github.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk kz ow"/></div></div></a></div></div><div class="ab cl pl pm hu pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="ij ik il im in"><p id="42ec" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated"><em class="js">关注</em> <a class="ae mu" href="https://medium.com/bugbountywriteup" rel="noopener"> <em class="js"> Infosec报道</em> </a> <em class="js">获取更多此类精彩报道。</em></p><div class="ot ou gp gr ov ow"><a href="https://medium.com/bugbountywriteup" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd ir gy z fp pb fr fs pc fu fw ip bi translated">信息安全报道</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">收集了世界上最好的黑客的文章，主题从bug奖金和CTF到vulnhub…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">medium.com</p></div></div><div class="pf l"><div class="ps l ph pi pj pf pk kz ow"/></div></div></a></div></div></div>    
</body>
</html>