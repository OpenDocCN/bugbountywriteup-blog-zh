<html>
<head>
<title>How “assertions” can get you Hacked !!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“断言”是如何让你被黑的！！</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/how-assertions-can-get-you-hacked-da22c84fb8f6?source=collection_archive---------0-----------------------#2021-12-22">https://infosecwriteups.com/how-assertions-can-get-you-hacked-da22c84fb8f6?source=collection_archive---------0-----------------------#2021-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d4c8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入探究assert()函数以及利用它的方法！</h2></div><p id="a557" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">各位黑客和开发者，我已经有一段时间没有在这里发表博客了。今天我将讨论<strong class="kh ir">编码+黑客</strong>，特别是关于几乎每一种高级语言中都存在的一个特性，称为“<strong class="kh ir">断言</strong>”。您将了解什么是assert()函数以及在野外利用它们的不同方法。所以抓紧时间，让我们开始吧。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/55b70a91be879c9d8aeafa156c38fe91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKt7fp9beN0DiVghBVrlfw.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">照片由<a class="ae lr" href="https://www.pexels.com/@tima-miroshnichenko?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马体·米罗什尼琴科</a>从<a class="ae lr" href="https://www.pexels.com/photo/close-up-view-of-system-hacking-in-a-monitor-5380664/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</figcaption></figure><h1 id="47f3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是断言？</h1><p id="5aa3" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">Assertion的字面意思是<em class="mp"> </em> <strong class="kh ir"> <em class="mp">“表示你坚信某事为真的陈述”，</em> </strong> <em class="mp"> </em>类似地，有时在编程中，我们假设某些值为真，然后继续执行其余的代码。</p><p id="1b18" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以断言<strong class="kh ir">任何到达本地SQL服务器的请求都必须来自本地主机，因此不需要身份验证就可以继续进行，</strong>这整个陈述已经开始刺激您的黑客感官，您可以想到该断言可能出错的许多方式。</p><p id="359a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在许多不同的场景中，可以使用assert()来捕捉代码中的假设。</p><p id="b62f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">assert()检查一个条件是否为真，如果不为真，则引发一个错误并关闭程序。</p><h1 id="68e8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">assert()与if-else块有什么不同？</h1><p id="0757" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">您可能会问，所有这些assert()函数都是在做检查，然后相应地采取行动，那么为什么不用if-else来代替它呢</p><p id="fb62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">断言就是在代码中记录你的假设。if-else语句是为了处理不同的逻辑场景。让我们从一个简单的例子来理解</p><p id="9c96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如当你写作的时候</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="01a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你的意思是说，在我的<strong class="kh ir"> print_number </strong>函数中，我假设指针总是不为空。如果这是空的，我会非常非常惊讶。我根本不在乎在我的代码中处理这种情况。</p><p id="ef5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果你写</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="d401" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你似乎在说，在我的<strong class="kh ir"> print_number </strong>函数中，我希望人们传递一个空指针。我知道如何处理这种情况，我也处理过这种情况。</p><p id="216d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，有时你会知道如何处理某些情况，你想这样做。然后，使用if-else。有时候，你认为一些事情不会发生，你不在乎去处理它。你只需表达你的惊讶，然后用assert停止程序执行。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="bfb9" class="ls lt iq bd lu lv mz lx ly lz na mb mc jw nb jx me jz nc ka mg kc nd kd mi mj bi translated">与assert()相关的安全隐患！</h1><p id="016e" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">assert()在不同的编程语言中有不同的工作方式，但是它仍然是一个安全相关的问题。</p><h2 id="b776" class="ne lt iq bd lu nf ng dn ly nh ni dp mc ko nj nk me ks nl nm mg kw nn no mi np bi translated">1:访问控制错误</h2><p id="305a" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这主要是由于在优化模式下运行代码而在python中发现的。</p><p id="7cfd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，默认情况下Python以<code class="fe nq nr ns nt b">__debug__</code>为真执行，但是在生产环境中，以优化运行是很常见的。这将<strong class="kh ir">跳过断言</strong>语句，直接进入安全代码</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="07ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这段代码像<code class="fe nq nr ns nt b">python3 assert.py</code>一样执行，那么它就像预期的那样完美地工作。但是，如果它与开关<code class="fe nq nr ns nt b">-O</code>一起使用进行优化，那么就会出现严重的问题。根据官方网站:<code class="fe nq nr ns nt b">-O</code> <em class="mp">删除assert语句和任何以</em> <code class="fe nq nr ns nt b"><a class="ae lr" href="https://docs.python.org/3/library/constants.html#debug__" rel="noopener ugc nofollow" target="_blank"><em class="mp">__debug__</em></a></code>的值为条件的代码</p><p id="bde8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您在<a class="ae lr" href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONOPTIMIZE" rel="noopener ugc nofollow" target="_blank">优化模式</a>下运行这个Python程序时，<em class="mp">断言语句</em>被忽略，任何普通用户都可以成为<strong class="kh ir">超级用户。</strong></p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="4a02" class="ne lt iq bd lu nf ng dn ly nh ni dp mc ko nj nk me ks nl nm mg kw nn no mi np bi translated">2:拒绝服务(DOS)攻击</h2><p id="f95c" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">由于负载分配和更好的系统设计，DoS攻击在过去几年中已经有所下降，但应用程序级DoS仍然是bug-Bounty领域中一个令人兴奋的Bug。由于糟糕的代码编写或开发人员犯的小错误，如错误处理不当，应用程序级DoS仍然可以实现。</p><p id="7d6b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个小例子中，你可以看到一个简单的C++程序，以<code class="fe nq nr ns nt b">Year of Birth</code>为输入，检查它是否是<strong class="kh ir"> &gt; 18 </strong>。乍一看，这一切似乎都很好，但在这段代码中，没有执行任何错误处理，这将直接导致程序在assert检查失败后崩溃。</p><p id="3b65" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里使用错误处理可以很容易地防止这种情况，但是令人惊讶的是，在C和C++这样的语言中，许多开发人员对此并不重视。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="2328" class="ne lt iq bd lu nf ng dn ly nh ni dp mc ko nj nk me ks nl nm mg kw nn no mi np bi translated">3:扭曲的拒绝服务</h2><p id="cdea" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">有时不是你的代码导致这些DoS发生，而是某个库依赖另一个库导致程序意外崩溃。你可以把它想象成一个多米诺骨牌，如果一个assert()为false，它将使代码中的所有函数退出，从而使整个应用程序崩溃。</p><p id="bb7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似的场景发生在<strong class="kh ir"> NodeJS，</strong>它被标记为<strong class="kh ir">CVE-2019–15604</strong>在这个漏洞中，<strong class="kh ir">攻击者可以使用格式错误的证书字符串远程触发TLS服务器上的断言，导致服务器崩溃</strong></p><p id="1bdc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初，<a class="ae lr" href="https://www.linkedin.com/in/rogierschouten" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">罗杰·斯豪滕</strong> </a>于<a class="ae lr" href="https://hackerone.com/reports/746733" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">黑客</strong></a><strong class="kh ir"/>向NodeJS团队提交了一份报告，团队将此视为一个<strong class="kh ir">关键漏洞</strong>，几天后发布了修复程序。</p><ul class=""><li id="8870" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la nz oa ob oc bi translated">CVE-2019–15604的起因是什么？？</li></ul><p id="fcc4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该漏洞利用了NodeJS的<code class="fe nq nr ns nt b">socket</code>库中的<code class="fe nq nr ns nt b">getPeerCertificate()</code>函数。任何人都可以远程连接到TLS服务器并提供特制的x509证书，这将导致断言和进程中止。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="443b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当精心制作的证书被发送到TLS服务器时，抛出了以下错误，它清楚地显示了一个断言被触发，导致整个服务器崩溃。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7173" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该修复程序更详细地解释了该问题。</p><p id="6fe5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">格式错误的证书的关键属性是<a class="ae lr" href="https://nodejs.org/api/tls.html#tlssocketgetpeercertificatedetailed" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">subject altname</strong></a>包含一个类型为<code class="fe nq nr ns nt b">23</code>的字符串，它不能被<code class="fe nq nr ns nt b">X509V3_EXT_print</code>编码成一个字符串</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="9f74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<strong class="kh ir"> X509 </strong>扩展不支持打印到缓冲区，则<strong class="kh ir"> X509V3_EXT_print </strong>会返回不同于<code class="fe nq nr ns nt b">1</code>的值。代码没有因为不可恢复的断言而失败，而是被替换为hashmap中带有JS null值的相关值。</p><p id="5395" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个漏洞显示了在一个小的库中，错误处理中的小疏忽是如何变成一个失败的临界点的。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="fbb5" class="ne lt iq bd lu nf ng dn ly nh ni dp mc ko nj nk me ks nl nm mg kw nn no mi np bi translated"><strong class="ak"> 3:远程代码执行</strong></h2><p id="477a" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">PHP一直是一个疯狂利用的矿井，其中之一是使用assert()函数远程执行代码。简而言之<strong class="kh ir"> assert()+PHP===Server Pwned。</strong></p><p id="b464" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与其他编程语言不同的是，PHP赋予assert()一种特殊的能力，<strong class="kh ir">如果将</strong> <code class="fe nq nr ns nt b"><strong class="kh ir">assertion</strong></code> <strong class="kh ir">作为字符串给出，它将被assert() </strong>视为PHP代码</p><p id="66de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着如果你传递一个<code class="fe nq nr ns nt b">string</code>给assert()，它将作为一个<code class="fe nq nr ns nt b">eval()</code>函数运行系统命令。</p><ul class=""><li id="58a4" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la nz oa ob oc bi translated"><strong class="kh ir">运行时变量泄漏</strong></li></ul><p id="bae0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个运行时变量被用来执行断言检查，那么这个变量有时可能会从内存中泄漏。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="f9bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我做了一个简单的程序，使用断言检查将输入与<code class="fe nq nr ns nt b">NULL</code>进行比较。现在，如果我们传递一个格式错误的输入，我们可以在错误中看到<code class="fe nq nr ns nt b">flag</code>变量的值</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi od"><img src="../Images/30d4368790b0d98a65a50bb5aab090b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1gbo4eqaASD4Hq_tz0UHdQ.png"/></div></div></figure><p id="85fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为PHP中的<code class="fe nq nr ns nt b"><strong class="kh ir">die</strong></code>函数可以在退出程序流之前运行任何系统命令。我们滥用了这个特性，在assert函数中传递了一个字符串。结合这两个问题，我们可以从运行时访问任何随机变量，或者执行系统命令。</p><p id="ce14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以利用任何可能直接接受用户输入而不进行净化的应用程序。为此，我们可以发送像<code class="fe nq nr ns nt b">"die(system(ls));//"</code>这样的有效载荷，它将在系统上运行<code class="fe nq nr ns nt b">ls</code>，而<code class="fe nq nr ns nt b">system()</code>之后的其余代码将被视为注释，因为有效载荷中存在<code class="fe nq nr ns nt b">;//</code>。</p><p id="6116" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里需要关注的最重要的事情是，我们想要发送一个字符串，然后使用<code class="fe nq nr ns nt b">die()</code>函数运行or命令，然后注释掉剩余的代码。这可以帮助我们利用PHP中assert()函数的大多数用例。我们可以把它看作是SQL注入，在这里我们运行我们的查询，然后注释掉查询的其余部分。</p><ul class=""><li id="ad54" class="nu nv iq kh b ki kj kl km ko nw ks nx kw ny la nz oa ob oc bi translated"><strong class="kh ir">绕过LFI检查和strpos()检查</strong></li></ul><p id="a4e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多应用程序使用strpos()来检查文件参数中的恶意输入。<strong class="kh ir"> strpos() </strong>查找子字符串在字符串中第一次出现的位置，如果在给定的字符串中找不到给定的子字符串，则返回False。</p><blockquote class="oe of og"><p id="8f62" class="kf kg mp kh b ki kj jr kk kl km ju kn oh kp kq kr oi kt ku kv oj kx ky kz la ij bi translated">assert("strpos('$file '，'..')=== false”)或die(“侦测到LFI企图！");</p></blockquote><p id="3eff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种过滤器可以在许多CTF甚至在现实生活中找到，以保护应用程序免受LFI攻击。该过滤器检查任何<code class="fe nq nr ns nt b">..</code>模式的<code class="fe nq nr ns nt b">file</code>变量，如果找到，程序终止。</p><p id="36aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用上面使用的相同技术，但是这里我们有一个额外的函数(strpos ),我们需要绕过它，以便直接运行我们的命令到assert函数。</p><p id="5197" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nq nr ns nt b">' and die(system(ls))or '</code>，这个有效负载可以用来脱离strpos()并直接与assert()函数交互，同样我们可以在服务器上运行任意命令。</p><h1 id="cfde" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">缓解措施💡</h1><ul class=""><li id="dca8" class="nu nv iq kh b ki mk kl ml ko ok ks ol kw om la nz oa ob oc bi translated">避免在生产中使用assert()函数</li><li id="c0b0" class="nu nv iq kh b ki on kl oo ko op ks oq kw or la nz oa ob oc bi translated">在代码中使用assert之前，要特别注意您是否在python中运行优化的代码。</li><li id="fa7a" class="nu nv iq kh b ki on kl oo ko op ks oq kw or la nz oa ob oc bi translated">断言应该只用作调试功能。</li><li id="86de" class="nu nv iq kh b ki on kl oo ko op ks oq kw or la nz oa ob oc bi translated">您可以使用它们进行健全性检查，测试应该始终为<code class="fe nq nr ns nt b"><strong class="kh ir">true</strong></code>的条件</li><li id="2db2" class="nu nv iq kh b ki on kl oo ko op ks oq kw or la nz oa ob oc bi translated">断言不应该用于正常的运行时操作，如输入参数检查。</li><li id="1928" class="nu nv iq kh b ki on kl oo ko op ks oq kw or la nz oa ob oc bi translated">根据经验，如果没有激活断言检查，您的代码应该总是能够正确工作。</li><li id="c48b" class="nu nv iq kh b ki on kl oo ko op ks oq kw or la nz oa ob oc bi translated">如果在assert函数中直接使用用户输入，那么尝试净化它。</li></ul></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="ab8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将是这一次，如果你想让我在这里补充的话，请分享你的观点。</p><p id="9156" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">非常感谢你的阅读。喜欢就分享😇😇</p><p id="7697" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kh ir">媒体</strong>和<strong class="kh ir">上跟随我订阅邮件列表💌如果你想在我发表文章时得到它们。✨✨</strong></p><p id="c969" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以在推特上找我:<a class="ae lr" href="https://twitter.com/mayank_pandey01" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">mayank _ pandey 01</strong></a><strong class="kh ir">👻</strong></p></div></div>    
</body>
</html>