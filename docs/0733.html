<html>
<head>
<title>V8 Array Overflow Exploitation: 2019 KCTF Problem 5 小虎还乡</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>V8 Array Overflow Exploitation: 2019 KCTF Problem 5 小虎还乡</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/v8-array-overflow-exploitation-2019-kctf-problem-5-%E5%B0%8F%E8%99%8E%E8%BF%98%E4%B9%A1-1aa51b9b2be6?source=collection_archive---------4-----------------------#2020-08-01">https://infosecwriteups.com/v8-array-overflow-exploitation-2019-kctf-problem-5-%E5%B0%8F%E8%99%8E%E8%BF%98%E4%B9%A1-1aa51b9b2be6?source=collection_archive---------4-----------------------#2020-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d600b9d8babde697604597cd12a70ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J1esjUlYFmmVOFVS"/></div></div></figure><h1 id="c5c4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1.介绍</h1><p id="8e35" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你有没有想过利用动态生成的代码？您知道漏洞利用也可以是源代码而不是数据吗？这个bug的根本原因是v8的JIT编译器中的不一致性。这种不一致诱使JIT编译器动态生成包含数组溢出错误的代码。我们对bug的最后利用是一些源代码。这与利用数据的正常利用非常不同。</p><p id="2c0b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">帖子对开发过程进行了总结。更多详情请访问此<a class="ae lz" href="https://pwnbykenny.com/2020/08/01/v8-array-overflow-exploitation-2019-kctf-problem-5-%e5%b0%8f%e8%99%8e%e8%bf%98%e4%b9%a1/" rel="noopener ugc nofollow" target="_blank"> <em class="ma">链接</em> </a>。该链接还提供背景知识，如对象结构，帮助您理解开发过程。顺便说一下，链接指向我的个人博客。欢迎光临！</p><p id="4134" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果你把这篇文章中的所有代码片段连接起来，你将得到一个产生外壳的漏洞。但是，有时候你需要改变这篇文章中提供的偏移量:fmap_offset，oele_offset，fakeFloat_offset。这里提供的外壳代码是在x86_64 &amp; Linux上测试的。不能保证外壳代码能在其他CPU架构和操作系统上运行。</p><h1 id="3b6a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.V8环境设置</h1><p id="a7ff" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果你从<a class="ae lz" href="https://drive.google.com/drive/folders/1D1yDMHILfvnD_h69tolE_Bj7p1adzzLy?usp=sharing" rel="noopener ugc nofollow" target="_blank">这里</a>下载文件夹，你会看到里面有一个易受攻击的d8。并且可以直接运行:。/d8。</p><h1 id="a41a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.辅助类型转换功能</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/c50212cfd0d81a862fc3d749a486f2ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*jWJzzR39OsSAFxWsTq3Y3Q.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">辅助类型转换功能</figcaption></figure><p id="a15c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">开发中使用了iadd和i2f两个函数。iadd向浮点格式的地址添加整数偏移量。i2f将两个32位整数转换为64位浮点数。</p><h1 id="d9d7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4.在内存中准备对象</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/8ccb0b76bf13b098ba3a1f923c598be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*4uMoJhzHy43QfKHfuGaJdg.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">在内存中准备对象</figcaption></figure><p id="37da" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第9–11行定义了3个数组对象:buggy，obj_arr，float_arr。这三个对象在堆中从低地址到高地址分配。bug是溢出源。第12行使用溢出源将buggy的长度字段改写为new_length。这一行使我们能够用buggy进一步访问obj_arr和float_arr。第14行触发了数组溢出错误。循环触发JIT编译器。JIT编译器动态生成一些代码。代码中存在bug。所以当代码执行时，bug就被触发了。</p><p id="007b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第15–17行定义了3个重要的偏移量。fmap_offset是从buggy到float_arr的类型字段的偏移量。oele_offset是从buggy到obj_arr的元素区域的偏移量。fakeFloat_offset将在后面使用时解释。</p><h1 id="aee5" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.泄露地址和伪造物品</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/7a810e73abd537b85d481a2486b0c0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*UXJzXop6ZWs-WP-PjpnusA.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">原语:addrof，fakeobj</figcaption></figure><p id="4272" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">本节使用了buggy和obj_arr。obj_arr是对象数组。它存储对象的地址。obj_arr中的每个元素都被v8视为一个对象。buggy是双精度数组。它存储原始浮点数，没有任何修改，如<a class="ae lz" href="https://pwnbykenny.com/2020/07/05/v8-objects-and-their-structures/#pointer-tagging" rel="noopener ugc nofollow" target="_blank">指针标记</a>。</p><p id="5af0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了获得给定对象的地址，我们需要首先将这个对象存储到obj_arr中，这样它的地址就是obj_arr的一个元素。接下来，我们使用buggy读取元素，因为它不修改地址。oele_offset是从buggy到obj_arr的第0个元素的偏移量。</p><p id="ab9c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了从给定的地址伪造一个对象，我们首先使用buggy将地址放到obj_arr的第0个元素。接下来，我们使用obj_arr读取地址。这会给我们一个假对象，因为obj_arr中的元素总是被识别为对象。</p><h1 id="e446" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">6.任意读写</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/d23b1a701bcfa2b6b0bd188176f86416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*MGdfTJrYYo7Qf1lBgZ79iQ.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">原语:read64，write64</figcaption></figure><p id="0b80" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">代码中重要的是两个函数:read64和write64。它们被用来访问任意的内存地址。我从头解释一下。</p><p id="4fdd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">fmap_offset是从buggy到float_arr的类型字段的偏移量。第1行检索float_arr的类型。</p><p id="395b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在第2行，我们将我们的假对象保存在fakeArr的元素区域。伪对象是一个双精度数组。我们称之为fakeFloat。它的结构应该与JSArray的结构一致。fakeArr重要的是它的第0、第2和第3个元素。第0个元素是指示fakeFloat是双精度数组的类型值。第二个元素是指向fakeFloat元素区域的指针。我们通过修改指针来进行任意的读写。第三个元素是fakeFloat中的元素数量。不一定要0x10。我们使用i2f将0x10转换为浮点数，因为fakeArr是一个浮点数组。</p><p id="ef79" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第3行获取fakeArr的地址:fakeArr_addr。第4行向fakeArr_addr添加了一个偏移量，这样我们就得到了fakeFloat的地址:fakeFloat_addr。接下来我们用fakeobj让v8认为在地址fakeFloat_addr有一个对象。所以我们现在有了假物体——fake float。</p><p id="0b0d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第6行定义了read64，它执行任意读取。为了读取一个内存地址，我们需要通过修改它的元素区指针，使该地址成为fakeFloat的元素区。这由第14行完成。接下来，我们通过直接使用fakeFloat读取其oth元素来获取地址中的值。</p><p id="aa8a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第7行定义了write64，它允许我们进行任意的写操作。它的机制与read64相同。</p><h1 id="e37f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">7.RWX页面和外壳代码注入</h1><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/a0d7499c2063ac913c242ce2d9df1af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*A82fRjATo-Nf4cvAL2w9dw.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">RWX页面创建&amp;外壳代码注入和执行</figcaption></figure><p id="ebc9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第1行到第8行是由<a class="ae lz" href="https://wasdk.github.io/WasmFiddle/" rel="noopener ugc nofollow" target="_blank"> WasmFiddle </a>生成的wasm相关代码。第1行将原始wasm代码存储在一个数组中。第6行到第8行将其封装到一个函数f中。封装后，原始wasm代码被存储到一个RWX页面中。一个指向页面的指针保存在wasmInstance的结构中。</p><p id="1c3f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第9行获取wasmInstance的地址。第10行遵循它的结构并读出指针。</p><p id="e812" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第11行是我们想要注入到指针指向的地址的外壳代码。外壳代码将生成一个外壳。</p><p id="f0ea" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第16行到第19行准备一个ArrayBuffer对象。我们将其后备存储指针设置为rwx_page_addr。0x20是从ArrayBuffer的开头到其后备存储指针的偏移量。</p><p id="8514" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">第20行到第22行将外壳代码写入rwx_page_addr。在第23行，我们通过调用f来执行shell代码，然后你会看到这个符号:$，这意味着生成了一个shell。</p><h1 id="0416" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">8.摘要</h1><p id="8fa1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">帖子对开发过程进行了总结。更多详情和必要的背景知识，请访问此<a class="ae lz" href="https://pwnbykenny.com/2020/08/01/v8-array-overflow-exploitation-2019-kctf-problem-5-%e5%b0%8f%e8%99%8e%e8%bf%98%e4%b9%a1/" rel="noopener ugc nofollow" target="_blank"> <em class="ma">链接</em> </a>。您将在那里找到更详细的演示。</p></div></div>    
</body>
</html>