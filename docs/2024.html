<html>
<head>
<title>Pythonic Malware Part-2: Reversing Python Executables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python恶意软件第2部分:逆转Python可执行文件</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/pythonic-malware-part-2-reversing-python-executables-1b197bd023ca?source=collection_archive---------1-----------------------#2022-04-22">https://infosecwriteups.com/pythonic-malware-part-2-reversing-python-executables-1b197bd023ca?source=collection_archive---------1-----------------------#2022-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d4a4a94013c884db8771887c32f49f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RqfyqDbuA5dzxWp-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@danielkcheung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张彦宏</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5b3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae kc" href="https://medium.com/bugbountywriteup/pythonic-malware-evading-detection-with-compiled-executables-20194ab0719c" rel="noopener">Python Malware Part-1</a>中，我演示了Python可执行文件如何被用来绕过Windows Defender，并在完全打了补丁的系统上成功启动Meterpreter shells。然而，这提出了一个有趣的问题，为什么更多的APT和威胁团体不使用Python进行恶意软件开发？</p><p id="e197" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然非常有效，一个原因是因为编译的Python很容易被逆转。在没有人工干预或转换为低级语言的情况下，编译Python的默认方式可以让蓝色团队恢复明文源代码。</p><p id="567a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章演示了如何反编译在<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/pythonic-malware-evading-detection-with-compiled-executables-20194ab0719c"> Part-1 </a>中创建的<code class="fe lb lc ld le b">shellcode_loader.exe</code>文件，并恢复正在执行的源代码——即使使用PyInstaller的字节码混淆和AES256加密。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="1e04" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">反编译Python可执行文件</h1><h2 id="d5c8" class="mk ln iq bd lo ml mm dn ls mn mo dp lw ko mp mq ma ks mr ms me kw mt mu mi mv bi translated">1.解包可执行文件</h2><p id="4d33" class="pw-post-body-paragraph kd ke iq kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">反编译<code class="fe lb lc ld le b">shellcode_loader.exe</code>文件的第一步是使用<a class="ae kc" href="https://github.com/extremecoders-re/pyinstxtractor" rel="noopener ugc nofollow" target="_blank">pyinstextractor</a>解包编译后的二进制文件。这将创建一个包含原始Python字节码文件和打包资源的新目录:</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="c573" class="mk ln iq le b gy nj nk l nl nm">&gt;&gt; python pyinstxtractor.py shellcode_loader.exe<br/>[+] Processing shellcode_loader.exe<br/>[+] Pyinstaller version: 2.1+<br/>[+] Python version: 307<br/>...<br/>[+] Possible entry point: shellcode_loader.pyc<br/>[+] Found 179 files in PYZ archive<br/>[+] Successfully extracted pyinstaller archive: shellcode_loader.exe</span></pre><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/b934919b60e0446e38aaf37662114f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yFYiHXulUQSlvZpNC0vIw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">位于新创建的“shellcode_loader.exe_extracted”目录中的解压缩文件。</figcaption></figure><h2 id="dcdf" class="mk ln iq bd lo ml mm dn ls mn mo dp lw ko mp mq ma ks mr ms me kw mt mu mi mv bi translated">2.转换Python字节码</h2><p id="2007" class="pw-post-body-paragraph kd ke iq kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">现在我们有了源代码的字节码(<code class="fe lb lc ld le b">.pyc</code>)版本，我们可以使用<a class="ae kc" href="https://github.com/rocky/python-uncompyle6/" rel="noopener ugc nofollow" target="_blank">uncompile 6</a>将我们的<code class="fe lb lc ld le b">shellcode_loader.pyc</code>转换回人类可读的代码:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/2cc46ddbb8a93f1fbed02b61c94edf46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KiitZDMzVsvrUdtULp5nnw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">转换中。pyc文件返回到。未编译的py。</figcaption></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="9c7a" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">击败PyInstaller的AES256加密</h1><p id="acb7" class="pw-post-body-paragraph kd ke iq kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">成功反转shellcode loader脚本后，我想更深入地挖掘和探索PyInstaller的带有AES加密的字节码混淆。这可以通过在编译时添加<code class="fe lb lc ld le b">--key</code>参数来实现，如下所示:</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="0920" class="mk ln iq le b gy nj nk l nl nm">pyinstaller -F --key MySecretKey12345 shellcode_loader.py</span></pre><h2 id="da2f" class="mk ln iq bd lo ml mm dn ls mn mo dp lw ko mp mq ma ks mr ms me kw mt mu mi mv bi translated">方法1:未加密的源</h2><p id="9a92" class="pw-post-body-paragraph kd ke iq kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">当返回并解压缩新创建的可执行文件时，显示了几个错误，表明可能应用了加密:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/6818e827a80d9d925fb43139dd31d433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hIxiDqvNpO7N1U7pjBkQog.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用pyinstxtractor解包加密的可执行文件。</figcaption></figure><p id="1bfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，仍有可能将<code class="fe lb lc ld le b">shellcode_loader.pyc</code>文件转换回其原始来源——无需应用任何解密方法:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/3e6eabfac7cde764ce9d75e78b335214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d8Q-kxdokPdaSrRXtkEcFA.png"/></div></div></figure><p id="9c94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看终端消息和解压缩的文件，似乎只有资源文件被加密并放在<code class="fe lb lc ld le b">PYZ-00.pyz_extracted</code>目录中。这意味着脚本入口点和主文件不受保护。</p><h2 id="7e65" class="mk ln iq bd lo ml mm dn ls mn mo dp lw ko mp mq ma ks mr ms me kw mt mu mi mv bi translated">方法2:使用解密密钥</h2><p id="f4c4" class="pw-post-body-paragraph kd ke iq kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">假设只有脚本资源被加密，我重新构造了shellcode loader脚本，将主要代码作为资源导入。最终的目录结构如下所示:</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="c121" class="mk ln iq le b gy nj nk l nl nm">|_shellcode_loader.py<br/>|_scloader<br/>  |_ __init__.py </span></pre><p id="a707" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦重新编译和解包，就会显示相同的加密错误消息。然而，这一次，我无法恢复来源:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/df6223d610ecc22c83a079eb511ca6f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4FHDXjGa8IvkRZFTh3qtA.png"/></div></div></figure><p id="e8d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这时我发现了<code class="fe lb lc ld le b">pyimod00_crypto_key.pyc</code>，它包含了运行时用来解密可执行文件的静态密钥:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/5becf6c97946cc2390903cfa80c651ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzaRASwlPeFaucllAeXOSg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在“pyimod00_crypto_key.pyc”的明文中找到PyInstaller的加密密钥。</figcaption></figure><p id="45b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用下面的脚本，可以利用这个密钥来解密Python字节码，并在使用uncompyle6:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="6122" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="3f9b" class="pw-post-body-paragraph kd ke iq kf b kg mw ki kj kk mx km kn ko my kq kr ks mz ku kv kw na ky kz la ij bi translated">在没有额外保护机制的情况下反转Python可执行文件可能是微不足道的。事实上，PyInstaller的<a class="ae kc" href="https://pyinstaller.org/en/stable/operating-mode.html#hiding-the-source-code" rel="noopener ugc nofollow" target="_blank">文档</a>甚至提到他们的AES256加密只能防止“随意”篡改。这只是Python恶意软件在现代企业环境中不太常见的一个原因。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="6d48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！在<a class="ae kc" href="https://m8sec.dev" rel="noopener ugc nofollow" target="_blank"> m8sec.dev </a>了解更多关于我的信息，并关注更多攻击性安全内容。</p><p id="1c1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nv">免责声明:所有内容仅用于教育目的。作者不对信息的使用负责。不要对你不拥有或没有明确许可的系统进行测试。</em></p></div></div>    
</body>
</html>