<html>
<head>
<title>Analyzing CVE-2022–22980 to discover a real exploitable path in the source code review process with CodeQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析CVE-2022–22980，用CodeQL发现源代码审查过程中真正可利用的途径</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/analyzing-cve-2022-22980-to-discover-a-real-exploitable-path-in-the-source-code-review-process-with-145d97717656?source=collection_archive---------0-----------------------#2022-06-27">https://infosecwriteups.com/analyzing-cve-2022-22980-to-discover-a-real-exploitable-path-in-the-source-code-review-process-with-145d97717656?source=collection_archive---------0-----------------------#2022-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4348221252f0fb455a28b4e3de14e131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4r0XtJIgUOmb4eYTjgkDw.jpeg"/></div></div></figure><h1 id="79e1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="1486" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这篇文章中，我将带你开始一段旅程，开始分析CVE-2022–22980，并提取该漏洞的模式，以查询代码库来发现真正的利用途径。</p><p id="9952" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">虽然许多漏洞扫描工具在检测应用程序中易受攻击的组件方面功能强大，但其中一些工具无法证明漏洞是否可被威胁利用。</p><p id="7b5c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">作为这项任务的强大盟友，有<a class="ae lz" href="https://codeql.github.com/" rel="noopener ugc nofollow" target="_blank"> CodeQL </a>。这是一个来自GitHub的语义代码分析引擎开源软件，可以像查询数据一样查询你的代码库。因此，它是一个至关重要的工具，允许我们在整个源代码中搜索漏洞的模式。</p><p id="a081" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在创建过程中，可以细化查询，直到只发现可利用的路径，这将在本文中演示。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="834d" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">CVE分析-2022–22980</h1><p id="bedd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在阅读一些安全漏洞公告时，CVE-2022–22980引起了我的注意。它讨论了Spring Data MongoDB中表达式语言注入的一个修复，该修复可能导致远程代码执行。</p><p id="7d2a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，回顾VMWare 发布的<a class="ae lz" href="https://tanzu.vmware.com/security/cve-2022-22980" rel="noopener ugc nofollow" target="_blank">公告，我们发现了一些可能导致易受攻击情形的要点。</a></p><blockquote class="mm mn mo"><p id="e4e3" class="kw kx mp ky b kz lu lb lc ld lv lf lg mq lw lj lk mr lx ln lo ms ly lr ls lt ij bi translated"><strong class="ky ir">用@Query或@Aggregation注释存储库查询方法</strong></p><p id="2b0c" class="kw kx mp ky b kz lu lb lc ld lv lf lg mq lw lj lk mr lx ln lo ms ly lr ls lt ij bi translated"><strong class="ky ir">带注释的查询或聚合值/管道包含在表达式</strong>中使用参数占位符语法的SpEL部分</p><p id="dd90" class="kw kx mp ky b kz lu lb lc ld lv lf lg mq lw lj lk mr lx ln lo ms ly lr ls lt ij bi translated"><strong class="ky ir">用户提供的输入未被应用程序清理</strong></p></blockquote><p id="11e2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">满足这些条件并在3.4.0、3.3.0到3.3.4以及更早的不受支持的版本中使用Spring数据MongoDB，应用程序很容易出现漏洞。因此，下一步将把这些条件转换成一种模式，并构建一个CodeQL查询来搜索整个代码库。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="4943" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">构建CodeQL查询</h1><p id="7757" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">构建该查询的第一步是确定应用程序使用哪些用户输入。所以<code class="fe mt mu mv mw b">RemoteFlowSources</code>是这个任务的一个好点。它是由CodeQL定义的类，映射远程用户输入的数据流源。</p><p id="0926" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，在这个查询的第一部分，我们需要进行导入，并定义源等于远程流源。</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="ca3b" class="nf jz iq mw b gy ng nh l ni nj">/**<br/> * <a class="ae lz" href="http://twitter.com/kind" rel="noopener ugc nofollow" target="_blank">@kind</a> path-problem<br/> */<br/>import java<br/>import semmle.code.java.dataflow.FlowSources<br/>import semmle.code.java.dataflow.DataFlow<br/>import DataFlow::PathGraph</span><span id="999d" class="nf jz iq mw b gy nk nh l ni nj">class MyConf extends DataFlow::Configuration {<br/>  MyConf() { this = "MyConf" }<br/>  <br/>  override predicate isSource(DataFlow::Node source) {<br/>    exists(RemoteFlowSource remote | source.asParameter() = remote.asParameter())<br/>  }</span></pre><p id="89fd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">一旦定义了哪些是源，就该构建查询的接收部分了。在这一部分，必须满足可开发的条件。因此，定义了三个变量来进行这一阶段。一个用于分配了注释的方法，另一个用于注释的名称，最后一个用于查找对分配了注释的方法的访问。</p><p id="b964" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">定义变量后，有必要执行条件操作来找到正确的接收器。首先，比较方法注释是否等于我们定义的注释，然后比较注释是否等于查询或聚合，然后通过正则表达式在注释中搜索包含<code class="fe mt mu mv mw b">?[0-9]</code>的值，最后定义对方法的访问必须等于我们定义的方法，并且该访问的参数必须等于我们的接收器。</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="b952" class="nf jz iq mw b gy ng nh l ni nj">override predicate isSink(DataFlow::Node sink) {<br/>    exists(Method c, Annotation ann, MethodAccess ma | ann = c.getAnAnnotation() and (ann.toString() = "Query" or ann.toString() = "Aggregation") and ann.getAValue().toString().regexpMatch(".*\\?[0-9].*")<br/>and ma.getMethod() = c and ma.getAnArgument()<br/> = sink.asExpr())<br/>  }</span></pre><p id="c653" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在查询结束时，连接我们构造的查询的所有点的部分被定义。最终的查询如下所示:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="0219" class="nf jz iq mw b gy ng nh l ni nj">/**<br/> * <a class="ae lz" href="http://twitter.com/kind" rel="noopener ugc nofollow" target="_blank">@kind</a> path-problem<br/> */<br/>import java<br/>import semmle.code.java.dataflow.FlowSources<br/>import semmle.code.java.dataflow.DataFlow<br/>import DataFlow::PathGraph</span><span id="3a05" class="nf jz iq mw b gy nk nh l ni nj">class MyConf extends DataFlow::Configuration {<br/>  MyConf() { this = "MyConf" }<br/>  <br/>  override predicate isSource(DataFlow::Node source) {<br/>    exists(RemoteFlowSource remote | source.asParameter() = remote.asParameter())<br/>  }</span><span id="4f17" class="nf jz iq mw b gy nk nh l ni nj">override predicate isSink(DataFlow::Node sink) {<br/>    exists(Method c, Annotation ann, MethodAccess ma | ann = c.getAnAnnotation() and (ann.toString() = "Query" or ann.toString() = "Aggregation") and ann.getAValue().toString().regexpMatch(".*\\?[0-9].*")<br/>and ma.getMethod() = c and ma.getAnArgument()<br/> = sink.asExpr())<br/>  }<br/>}</span><span id="92f8" class="nf jz iq mw b gy nk nh l ni nj">from MyConf conf, DataFlow::PathNode source, DataFlow::PathNode sink<br/>where conf.hasFlowPath(source, sink)<br/>select sink, source, sink, "SpEL Injection found! - CVE-2022-22980"</span></pre></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="4d0f" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">在CodeQL中执行查询</h1><p id="9154" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这个阶段，我们使用了为这个安全问题设计的<a class="ae lz" href="https://github.com/li8u99/Spring-Data-Mongodb-Demo" rel="noopener ugc nofollow" target="_blank">易受攻击的公共应用程序</a>，它将作为我们的代码库。因此，CodeQL数据库是从已定义的代码库创建的。</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="610b" class="nf jz iq mw b gy ng nh l ni nj">codeql database create cveanalysis --language=java</span></pre><p id="8c0c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">一旦创建了数据库，就可以将它导入到VSCode的CodeQL扩展中来运行我们的查询了。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/2363d339508af242a223335f0d7c5684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ihlsg_uoav25UP248Pkzw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">数据库导入和查询完成后的VSCode</figcaption></figure><p id="4059" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在选择了最近上传的数据库之后，就该转到Java选项卡中CodeQL的VSCode工作区，并使用我们的查询编辑默认模板了。最终可以在代码库中运行我们的查询。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/404c809ab14bda1d74d443cbc448a40a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ODvlEweFUy-TkflPqimRFQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询执行的结果</figcaption></figure><p id="e9a7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">可能的观点是，此代码库中存在可利用漏洞的真实路径。有一种可能的观点认为，在这个代码库中存在一个真正的漏洞利用途径。结果给出了源、漏和中间步骤(如果有的话)。在这种情况下，在源和接收器之间有一个简单的路径。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/9f421ddd507aeac64d05b73c2a989848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*koBdulfRAbbEwpQVq1dwsw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">源和汇</figcaption></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="e5d7" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">验证可利用的路径</h1><p id="829b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如前面步骤中所述，此漏洞在其/test端点中接收一个参数，并将其传递给易受攻击的函数。如前面步骤中所述，该漏洞在其<strong class="ky ir"> <em class="mp"> /test </em> </strong>端点上接收一个<strong class="ky ir"> POST </strong>参数，并将其传递给易受攻击的函数。所以通过运行下面的命令，漏洞就实现了:</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/d4e924ea6b32de0d936233848fe98318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X5HLhoebV1yryZhVPWK2VQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">带有恶意负载的cURL命令</figcaption></figure><p id="6bca" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这样，我们就可以确定该文件是在临时目录中创建的，并且实现了远程代码执行。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/d60670f38d628dbd2b8f8d015fbb73a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1QZpztZj47_Uq1uXFyFmg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">代码执行前后</figcaption></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="adcc" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">结论</h1><p id="f64f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">一旦某个漏洞影响了风险管理流程，确定该漏洞在您环境中是否可被利用也很重要。</p><p id="87f8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">CodeQL是一个强大的工具，可以帮助检测源代码中真正可利用的路径，无论是漏洞扫描器的警报还是寻找新漏洞的安全研究。</p><p id="871e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我希望这篇文章可以帮助任何人寻找关于CodeQL和安全代码审查的资源。</p></div></div>    
</body>
</html>