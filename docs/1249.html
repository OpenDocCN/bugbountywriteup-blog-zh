<html>
<head>
<title>EXPLOITATION WITH SHELLCODE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用外壳代码</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/exploitation-with-shellcode-23470cd2aa55?source=collection_archive---------2-----------------------#2021-04-18">https://infosecwriteups.com/exploitation-with-shellcode-23470cd2aa55?source=collection_archive---------2-----------------------#2021-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/656ef62e7108ec16154f8e592e49e525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJs1vy-iGBG8aPIOkbMk3A.png"/></div></div></figure><div class=""/><p id="bd2d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">外壳代码是执行特定操作的一段代码</p><p id="25ed" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">外壳代码是用ASM编写的</p><p id="1331" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">外壳代码是特定于架构的，因此它在不同的处理器类型之间是不可移植的</p><p id="1773" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">外壳代码通常被编写来直接操作处理器寄存器，以便为使用操作码进行的各种系统调用设置它们</p><p id="12d7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当编写了ASM代码来执行所需的操作时，必须将它转换为机器码，并且不包含任何“空字节”，因为它必须不包含任何空字节，因为许多字符串运算符(如strcpy()在遇到它们时会终止</p><h1 id="e71c" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">系统调用(SYSCALL)</h1><p id="599e" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">系统调用(通常缩写为syscall)是一种编程方式，在这种方式下，计算机程序从执行它的操作系统的内核请求服务</p><p id="6f9b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">系统调用在进程和操作系统之间提供了一个重要的接口</p><p id="c1e8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">系统调用只能从用户空间进程进行</p><p id="2948" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">特权系统代码也发出系统调用</p><p id="c370" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">中断会自动将CPU置于某个提升的特权级别，然后将控制权交给内核，由内核决定是否授予调用程序所请求的服务。如果服务被授予，内核执行一组调用程序不能直接控制的特定指令，将特权级别返回给调用程序，然后将控制权返回给调用程序。</p><p id="400b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">系统调用提供了一种方法来管理与硬件的通信以及内核提供的功能，这些功能可能不包括在应用程序的地址空间中</p><p id="8078" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数系统使用环级别(通常为4个特权级别)来提供安全性和保护，防止应用程序直接访问硬件和某些系统功能</p><p id="e3e9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户级程序要访问其地址空间之外的函数，如setuid()，它必须识别所需函数的系统调用号，然后发送中断0x80 (int 0x80)</p><h2 id="f431" class="lz kx jb bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">注意</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="276a" class="lz kx jb mq b gy mu mv l mw mx">The instruction 'int 0x80/syscall' is an assembly instruction that invokes system calls on most *NIX OSs</span></pre><h2 id="aa6d" class="lz kx jb bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">为什么是SYSCALL？</h2><p id="7dee" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">进入内核可以使用硬件中断、硬件陷阱和软件启动陷阱</p><p id="bb70" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不能触发和使用硬件相关的中断和陷阱</p><p id="c6fe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们使用“软件启动的陷阱”来进入内核模式</p><p id="3745" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">系统调用是软件启动陷阱的一个特例。用于启动系统调用的机器指令通常会导致一个由内核专门处理的硬件陷阱</p><p id="0067" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Linux中，系统调用是使用</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1adb" class="lz kx jb mq b gy mu mv l mw mx">lcall7/lcall27 gates (lcall7_func)<br/>           <br/>int0x80 (software interrupt)</span></pre><h2 id="f072" class="lz kx jb bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">工作流程</h2><p id="1885" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">要执行系统调用，需要两个或更多参数</p><p id="9c20" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“系统调用号”被载入“EAX寄存器”</p><p id="a55a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要通过系统调用传递的参数按照系统调用表的顺序存储在寄存器EBX、ECX和EDX(32位)中</p><p id="ae16" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在64位的情况下，QWORD寄存器和R8-R15寄存器用于存储参数</p><h1 id="1c64" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为SYSCALL生成示例ASM代码</h1><h2 id="a4a1" class="lz kx jb bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">示例1</h2><p id="d7c7" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们通过ASM使用syscall来触发exit(0)</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4b3a" class="lz kx jb mq b gy mu mv l mw mx">mov eax,1<br/>mov ebx,0<br/>int 0x80</span></pre><p id="4591" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里EAX装载了1，所以它得到的syscall值为1</p><p id="44f2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">syscall _ value = 1—--&gt; syscall = sys _ exit()</p><p id="84c1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值0被加载到EBX中，以便它可以用作syscall的参数</p><p id="09a1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">int 0x80用于触发中断并执行syscall</p><h2 id="3965" class="lz kx jb bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">示例2</h2><p id="d597" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">使用execve()生成一个“sh”shell</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="eb87" class="lz kx jb mq b gy mu mv l mw mx">mov eax,0x0         //initialization<br/>push edx            //nullbyte to terminate string (0x0)<br/>push 0x68732f2f     //4bytes needed (//sh)['//' is same as '/'] <br/>push 0x6e69622f     //4bytes needed (/bin) little endian<br/>mov ebx, esp        //moving SP into EBX<br/>push edx            //pushing EDX into stack (0x0)<br/>push esp            // ESP above EDX in stack<br/>mov ecx, esp        // ESP stored in ECX for argv<br/>mov eax, 0x0b       //loading eax with syscall value for execve()<br/>int 0x80            //calling syscall to perform interrupt</span></pre><h1 id="ed70" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">关于SYSCALL的更多信息</h1><p id="f7a2" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在终端中键入以下命令</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="47af" class="lz kx jb mq b gy mu mv l mw mx">man syscall<br/>man 'syscall(2)'</span></pre><p id="a1f1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，请参考此<a class="ae my" href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md" rel="noopener ugc nofollow" target="_blank">表</a>了解每个架构的更多syscall值</p><h1 id="e983" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">空字节0x00</h1><h1 id="7315" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">空字节的影响</h1><p id="37ca" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">依赖strcpy()等字符串操作符将数据复制到缓冲区的函数，当这些函数遇到0x00等空字节时，它们会将其转换为字符串终止符。这当然会导致我们的外壳代码失败</p><h1 id="9d31" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">空字节的原因</h1><p id="e382" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">汇编指令导致空字节驻留在外壳代码中</p><p id="1df5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">寄存器初始化不正确</p><h1 id="423f" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">删除空字节</h1><h2 id="b53a" class="lz kx jb bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">类型1</h2><p id="acb5" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">假设您使用的是寄存器EAX(32位/4字节)</p><p id="2ff5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你试图在EAX(32位)中存储一个小数值时</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f1aa" class="lz kx jb mq b gy mu mv l mw mx">mov eax,0x10</span></pre><p id="ab36" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用AX(16位)来存储这些小值(基于大小)</p><p id="e2b9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">低位寄存器AL(8位)用值填充，高位寄存器AH(8位)用空值填充</p><p id="5dbf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当将其转换为外壳代码时，这会导致空字节</p><p id="39e5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代替在整个寄存器中加载小值，</p><p id="49ac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以用它的一半</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="9109" class="lz kx jb mq b gy mu mv l mw mx">mov al,0x10</span></pre><h2 id="f021" class="lz kx jb bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">类型2</h2><p id="3f48" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在这种情况下，我们需要将0作为参数传递给syscall</p><p id="c300" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们不能将0加载到寄存器中，因为它可能会在外壳代码中创建空字节</p><p id="8f3e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了克服这一点，我们可以在寄存器中存储任意值，</p><p id="4b44" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以对寄存器进行异或运算</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="3f96" class="lz kx jb mq b gy mu mv l mw mx">mov ebx,0x10<br/>xor ebx,ebx</span></pre><p id="67ce" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是最好的方法，因为它不会影响EFLAGS寄存器</p><h2 id="b6e5" class="lz kx jb bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">类型3 —我们可以对寄存器进行SUB</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0c29" class="lz kx jb mq b gy mu mv l mw mx">mov ebx,0x10<br/>sub ebx,ebx</span></pre><h2 id="2b8b" class="lz kx jb bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">类型4 — INC或DEC寄存器</h2><p id="ec0e" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">将计数值存储在ECX</p><p id="b0e4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行INC(递增)和DEC(递减)</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="11a1" class="lz kx jb mq b gy mu mv l mw mx">inc ebx<br/>dec edx</span></pre><h2 id="8ff0" class="lz kx jb bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">类型5 —从另一个寄存器移动0</h2><p id="3eb3" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">假设0x00在EDX</p><p id="a968" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">加载EBX中的值并防止空字节</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="961d" class="lz kx jb mq b gy mu mv l mw mx">mov ebx,edx</span></pre><h1 id="0111" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">生成外壳代码</h1><p id="2b83" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们假设一个场景，我们想要从一个攻击媒介调用/产生一个shell</p><p id="4ba6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要打开外壳，我们需要执行外壳代码</p><p id="33a3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们修正一下，我们需要生成“/bin/sh”</p><p id="6962" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们复制这个<a class="ae my" href="https://www.exploit-db.com/exploits/44321" rel="noopener ugc nofollow" target="_blank">执行外壳代码</a></p><h1 id="fc85" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">公共代码结构</h1><p id="4447" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">利用C程序执行外壳代码的常见代码结构是</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0ecd" class="lz kx jb mq b gy mu mv l mw mx">char shellcode[] = "SHELLCODE HERE";<br/>            int main(int argc, char **argv){<br/>                int (*attack)();<br/>                attack = (int (*)())shellcode;<br/>                (int)(*attack)();<br/>            }</span></pre><p id="e9b0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运筹学</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c172" class="lz kx jb mq b gy mu mv l mw mx">char shellcode[] = "SHELLCODE HERE";<br/>            int main(int argc, char **argv){<br/>                    ((int (*)())shellcode)();<br/>            }</span></pre><h1 id="b65e" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">剥削</h1><p id="03a6" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在我们攻击之前，我们需要检查受害者机器的架构</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/3499116b06c4096cba80e062f752d7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/0*zqkEi4oaZYmOPlRK.png"/></div></figure><p id="4fb3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在编辑器中编写ASM代码脚本来处理它</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi na"><img src="../Images/3f810996458d2f24d0e028e355cadb3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sg98YorXDoA5aPN2.png"/></div></div></figure><p id="a78d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们测试从ASM代码生成的漏洞</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/6283ed30b0cf710a13f5b4703c04359e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KJElfODGWk_Wtddn.png"/></div></div></figure><p id="152b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行“objdump”以查看每个ASM指令的十六进制值，从而创建外壳代码</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/7a94d084e8b197551ee9560c85abccc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LCMmk9yv8LsvchQa.png"/></div></div></figure><p id="5ff4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们利用的外壳代码</p><p id="4a11" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">复制外壳代码并将其嵌入到另一个脚本中，以便它可以在可执行内存中运行</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/7201d2f3ada06f2eb083c64bc45b9b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8Czyuzz7cQDCH_uF.png"/></div></div></figure><p id="1d5b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用“-z execstack”和“-nostdlib”编译源代码，以避免“分段错误”，并允许二进制文件在可执行内存中运行</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/d7ce0cdb60bb6cd6814799bb0af018cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R4ougo2wraihCNrt.png"/></div></div></figure><h1 id="48a2" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">剥削结束了</h1><h2 id="9433" class="lz kx jb bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">GitHub Repo中提供了漏洞利用示例</h2><h2 id="e349" class="lz kx jb bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated"><a class="ae my" href="https://github.com/AidenPearce369/ExploitDev" rel="noopener ugc nofollow" target="_blank">aiden peace 369</a></h2></div></div>    
</body>
</html>