<html>
<head>
<title>Executing CSRF With Phone Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用电话验证执行CSRF</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/executing-csrf-with-phone-validation-103c525dd310?source=collection_archive---------2-----------------------#2021-06-04">https://infosecwriteups.com/executing-csrf-with-phone-validation-103c525dd310?source=collection_archive---------2-----------------------#2021-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbeb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何以编程方式获取OTP</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/3f89197d542a7943c67fb2efca14ddd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*IJK27pBimW2rAfGZVnTWqw.png"/></div></figure><p id="f36a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我提交一个Bug Bounty程序的漏洞时，我通常会试图构建一个漏洞利用，尽可能多地自动化概念证明，以:</p><ol class=""><li id="28f5" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">确保100%清楚漏洞可以做我声称的事情。</li><li id="502a" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">简化分流团队和公司的复制——如果复制步骤需要团队简单地导航到您提供的URL，您可以消除任何混淆。</li><li id="6536" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">玩得开心！做东西是学习新技术的好方法。</li></ol><p id="5078" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我最近在一个API上发现了一个跨源资源共享(CORS)漏洞，该漏洞允许用户向他们的帐户添加电话号码。在一个相当常见的流程中，用户首先提交他们的电话号码，应用程序将向该电话号码发送一个六位数的一次性密码(OTP ),然后用户将OTP输入网站，以证明这确实是他们的合法电话号码。</p><p id="bff1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">此流程可以提供验证(通过确保用户输入他们控制的电话号码)和安全性，因为它使攻击者难以利用跨站点请求伪造(CSRF)漏洞，因为您必须进行两次不同的API调用，第一次调用触发的动态值(重要的是在带外交付)将在第二次提交。</p><p id="3279" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我花了几个小时试图使用AWS Pinpoint和Twilio long代码(这是一个普通的10位美国电话号码)来接收OTP，但没有成功，我在这一点上的假设是，有某些检查限制了这种B2B类型的消息传递，而不是只与实际的手机号码进行联系。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="eef0" class="mh mi it bd mj mk ml dn mm mn mo dp mp kz mq mr ms ld mt mu mv lh mw mx my mz bi translated"><strong class="ak">输入</strong>谷歌<strong class="ak">语音</strong></h2><p id="634c" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">我使用谷歌语音已经有几年了，我事实上的标准是将所有收到的短信转发到我的个人电话号码——这是一个额外的便利，允许我通过iOS消息应用程序正常发送短信，而不是切换到谷歌语音应用程序。</p><p id="6913" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">目标应用程序向我的Google Voice号码发送OTP也没有问题，所以我开始尝试使用Google Voice作为应用程序和Twilio之间的中介。Google需要向我的Twilio号码发送一个OTP来验证它，就像应用程序想要验证我的Google号码一样。使用Twilio API，我能够获得代码并完成转发。你可以直接从谷歌支持:【https://support.google.com/voice/answer/9182115】T4了解更多关于设置短信转发的信息。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="a312" class="mh mi it bd mj mk ml dn mm mn mo dp mp kz mq mr ms ld mt mu mv lh mw mx my mz bi translated">体系结构</h2><p id="7c86" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">让这种利用变得现实和无缝的关键是以编程方式检索OTP，并且要快速完成，这需要构建客户端“恶意”JavaScript来执行API调用，并设置第三个由攻击者控制的API来检索OTP。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/87914fd4d62914139b92d266011e91b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*GQZkcp9cKNaXTT-jnmtrug.png"/></div></figure><p id="b1c2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">基本架构如上所示，流程如下:</p><ol class=""><li id="ab26" class="lm ln it ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">受害者访问运行恶意脚本的网页。</li><li id="0d47" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">JavaScript向目标应用程序发送一个带有JSON主体的HTTPS POST请求，其中包括攻击者的电话号码。这触发了预检选项请求，但最终通过回应请求来源的访问控制允许来源报头被允许。</li><li id="c208" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">目标应用程序向攻击者的Google Voice号码发送一个OTP，然后攻击者将该SMS转发给Twilio。</li><li id="e2d1" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">JavaScript向攻击者的API发送HTTPS GET请求，这触发Lambda从Twilio获取代码，并在HTTPS响应中返回它。</li><li id="2c5a" class="lm ln it ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">JavaScript向目标应用程序发送最终的HTTPS POST请求，其中包含攻击者的电话号码和要验证的OTP。</li></ol></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="0973" class="mh mi it bd mj mk ml dn mm mn mo dp mp kz mq mr ms ld mt mu mv lh mw mx my mz bi translated">客户端代码</h2><p id="3dff" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">我绝不是一个JavaScript开发人员——相反，我可以很好地将一些东西组合在一起，让我的开发发挥作用。也就是说，实现这一点的几个关键是强制JavaScript阻塞并等待，以确保三个API调用按顺序发生，并且只在准备好的时候发生(相对于典型JS的异步免费)。</p><p id="34e0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">* *注意:客户端和服务器端代码片段都包含我使用的基本工作代码。然而，为了简单和可读性，我已经删除和更改了一些内容。如果您想要重复这项工作，请使用这些作为基线。**</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7f01" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我将每个API调用设置为一个独立的函数，只有当请求成功完成时，它才会调用下一个函数——即第一个API调用必须在第二个API调用被触发之前完成。此外，在poll_twilio函数中，我添加了递归来重试对攻击者API的调用，直到成功返回OTP代码——这将允许OTP从目标应用程序运行到twilio，并防止在此过程中出现任何延迟时被利用。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="01e7" class="mh mi it bd mj mk ml dn mm mn mo dp mp kz mq mr ms ld mt mu mv lh mw mx my mz bi translated">服务器端代码</h2><p id="05dd" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">在Lambda中，代码只需要做一些事情——轮询任何消息的Twilio，解析它们以查看是否收到了OTP代码，并根据结果返回适当的响应(200或404)。Twilio确实提供了一个Python SDK，但是对于这样一个简单的集成，我选择了REST API。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7fb7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我做的一些设计决定是每次都删除每条信息。如果您在现有号码上配置了转发功能，您就不能假定只有OTP消息会发送到Twilio。我还想确保后续的漏洞利用实例不会试图在庞大的消息队列中进行排序，或者找到旧的、以前有效的OTP代码并将其作为有效代码返回。</p><p id="84eb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，在规模上，这是行不通的。如果多个受害者同时被利用，您需要一种更好的方法来找到正确的OTP代码，这超出了本概念证明的范围。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="ad8c" class="mh mi it bd mj mk ml dn mm mn mo dp mp kz mq mr ms ld mt mu mv lh mw mx my mz bi translated">最后的想法</h2><p id="72c0" class="pw-post-body-paragraph kq kr it ks b kt na ju kv kw nb jx ky kz nc lb lc ld nd lf lg lh ne lj lk ll im bi translated">虽然没有提到，但您需要熟悉AWS API Gateway，并在Twilio上设置一个试用帐户来自己构建这个漏洞。我的客户端代码只是被托管在S3，作为一个有效的空白网页，只包含脚本。</p><p id="e2a3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">尽管这整个POC可能并不需要展示该漏洞，但分流团队和项目都对工作质量进行了评价。此外，其他漏洞目前通过使用OTP得到缓解，并且可以通过这种自动化可靠地被利用。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="6866" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我在社交媒体上不太活跃，但你可以在LinkedIn、T2、Bugcrowd或各种安全漏洞或不和谐的服务器上找到我！</p></div></div>    
</body>
</html>