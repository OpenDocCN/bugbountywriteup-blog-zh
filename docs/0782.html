<html>
<head>
<title>Demystifying Insecure Deserialization in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开PHP中不安全反序列化的神秘面纱</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/demystifying-insecure-deserialization-in-php-684cab9c4d24?source=collection_archive---------0-----------------------#2020-08-22">https://infosecwriteups.com/demystifying-insecure-deserialization-in-php-684cab9c4d24?source=collection_archive---------0-----------------------#2020-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/064fddbb69620410487a07272fd43e52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MmmFxL-hkPh_t6Xg.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">演职员表:PortSwigger</figcaption></figure><h1 id="f30c" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">序列化与反序列化</h1><p id="58ac" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">序列化是将对象转换为顺序字节流的过程，以便可以轻松地存储在数据库中或通过网络传输。反序列化与序列化完全相反。它是将这种连续的字节流转换成功能完整的对象的过程。</p><p id="8763" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">对象的状态也是持久的，这意味着对象的属性及其赋值被保留。防止字段被序列化的过程因语言而异。</p><h1 id="5a17" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">什么是不安全的反序列化？</h1><p id="6394" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">不安全的反序列化是指用户可控制的数据被应用程序反序列化。这使得攻击者能够操纵序列化对象，并将恶意数据传递到应用程序代码中。可以用完全不同类的对象替换序列化的对象。</p><p id="3709" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">几乎不可能实现验证或净化来应对每一种可能发生的情况。这些检查从根本上来说也是有缺陷的，因为它们依赖于在数据被反序列化之后检查数据，在许多情况下，这对于防止攻击来说已经太晚了，您将在后面的利用示例中看到这一点。</p><h1 id="18bd" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">如何防止不安全的反序列化漏洞</h1><p id="4560" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">除非必要，否则应该避免用户输入的反序列化。如果您确实需要对来自不可信来源的数据进行反序列化，请采用可靠的措施来确保数据没有被篡改。例如，您可以实现数字签名来检查数据的完整性。但是，请记住，任何检查都必须在开始反序列化过程之前进行。否则，它们没什么用处。</p><h1 id="4044" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">利用PHP中不安全的反序列化</h1><h2 id="6551" class="mg kg it bd kh mh mi dn kl mj mk dp kp lo ml mm kt ls mn mo kx lw mp mq lb mr bi translated">PHP反序列化的基础</h2><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/6eb29ced8de66ce2544b6de79ef06f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*J-aqcCCW432A3DiuYMj2Gw.png"/></div></figure><p id="b224" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">第2–15行:声明一个名为Car的PHP类，它有3个属性model、manufacturer和colour。出于演示目的，它们中的每一个都有不同的访问说明符。参数化构造函数用于初始化属性。</p><p id="a798" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">第16行:创建一个类Car的对象。</p><p id="799c" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">第18、19行:序列化在第16行创建的对象。序列化创建了一些不可打印的字符，如\x00，所以我们用\\x00替换它，以便我们可以正确地查看输出。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/00e76f8ec39cbace9de13a338316a7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5lBb_EekM465tQ4R1QnN6w.png"/></div></div></figure><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="0bd6" class="mg kg it mz b gy nd ne l nf ng"><strong class="mz iu">O:3:"Car":3:{...}</strong><br/>Objects start with upper case O, followed by the the length of the class name(which is 3 because length of the word car is 3), followed by name of the class i.e. Car, followed by number of attribues in the class which is 3 (model, manufaturer and colour).</span><span id="6f84" class="mg kg it mz b gy nh ne l nf ng"><strong class="mz iu">s:10:"\x00Car\x00model";s:6:"SELTOS";</strong><br/>This is an attribute of the class car with it's corresponding value. 's' means a string attribute followed by the length of the name of attribute. Notice how the access specifier(private) is appended before the attribute name while serialization. \x00ClassName\x00 is the format followed in case of private attributes. This is followed by the type (s: string), length (6 characters in SELTOS) and value (SELTOS) of the attribute (model).</span><span id="c287" class="mg kg it mz b gy nh ne l nf ng"><strong class="mz iu">s:15:"\x00*\x00manufacturer";s:3:"KIA";<br/></strong>This is also similar to the above example however, as this attribute is of protected type, \x00*\x00 is appended before the attribute name.</span><span id="1b2d" class="mg kg it mz b gy nh ne l nf ng"><strong class="mz iu">s:6:"colour";s:5:"WHITE";<br/></strong>For public attributes nothing is appended to the attribute name. The remaining part is similar to the other attributes.</span><span id="2b01" class="mg kg it mz b gy nh ne l nf ng">Some other types of data can also be present like i for integer and b for boolean. The lenghth of the value is not required in this case.<br/>s:6:wheels;i:4; is similar to public int wheels = 4<br/>s:10:twowheeler;b:0; is similar to public boolean twowheeler = false</span></pre><h2 id="181a" class="mg kg it bd kh mh mi dn kl mj mk dp kp lo ml mm kt ls mn mo kx lw mp mq lb mr bi translated">操作序列化对象</h2><p id="cdcc" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">假设有一个web应用程序使用基于序列化的会话机制。用户详细信息以序列化形式存在于会话cookie中。操纵这些数据并提升我们的权限是可能的。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/d81b05af3b2b36eb68c7e7bfbf391d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xuOlXPvbDjLcX9k8GkaA0w.png"/></div></div></figure><p id="df27" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">登录到应用程序后，我们可以看到设置了一个会话cookie，并对其进行了base64编码。解码后的值，我们可以看到它是一个序列化的PHP对象。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ed92db605e567aca1f5276c9d50fa469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*Na9-xVJyxDfa__SYeuA8aQ.png"/></div></figure><p id="251c" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这个cookie中有一个有趣的属性:admin，它被设置为0。我们将该值修改为1，将其编码回base64并保存新的cookie值。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/f8e4743c3776784bf41ffc9e6c81a521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*RwrvugC1OOcpkJjlaPkIeQ.png"/></div></figure><p id="0066" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">刷新页面后，我们可以看到现在可以访问页面的管理部分。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/270162d307d19fce0f98f36e1c194426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBl9w0W51Pp2BSAQtJcAMQ.png"/></div></div></figure><p id="380f" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在后端代码中，我们可以看到应用程序盲目地信任序列化数据(第7行)，并根据对象属性的值提供访问控制(第21行)。因为可以修改该对象属性并提升我们的权限。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/3cf7d9faecd3da408cfd813f9886f3d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GhAXyATYnmd3DtgTZfFNAA.png"/></div></div></figure><h2 id="da6a" class="mg kg it bd kh mh mi dn kl mj mk dp kp lo ml mm kt ls mn mo kx lw mp mq lb mr bi translated">操作PHP数据类型和比较</h2><p id="2f1e" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这段代码基本上是PHP如何处理数据类型和松散比较以及如何操作的概念证明。打开此页面并点击设置/重置按钮后，cookie即被设置。这个cookie是包含一个<code class="fe nn no np mz b">username </code>和一个<code class="fe nn no np mz b">token</code>的类<code class="fe nn no np mz b">Secret </code>的序列化对象。默认情况下，它将显示用户的特权较低，但是，如果用户名为admin，并且令牌设置为超级机密的admin令牌，则可以访问admin部分。在下一节中，我们将看到如何通过操纵PHP比较数据的方式来绕过这些需求。</p><p id="f134" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">PHP的松散比较很奇怪，因为它有以下特点:</p><ul class=""><li id="812c" class="nq nr it lf b lg mb lk mc lo ns ls nt lw nu ma nv nw nx ny bi translated">当比较整数和字符串时，PHP会将字符串转换为整数。这意味着<code class="fe nn no np mz b">5 == "5"</code></li><li id="5b1f" class="nq nr it lf b lg nz lk oa lo ob ls oc lw od ma nv nw nx ny bi translated">当比较一个字母数字字符串和一个数字时，它将首先检查字符串是否以数字开头。如果它以一个数字开始，它将忽略字符串的其余部分。这意味着<code class="fe nn no np mz b">2 == "2 some random string"</code>相当于<code class="fe nn no np mz b">2 == "2"</code>。</li><li id="0d9a" class="nq nr it lf b lg nz lk oa lo ob ls oc lw od ma nv nw nx ny bi translated">如果这个字符串不包含整数，那么它被转换为0，可能是因为它包含0个数字。所以<code class="fe nn no np mz b">0 == "Somestring"</code>为真。</li></ul><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/a79286326cb3ceb784bb1558e5d0e2b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_FRpytyRucZ63bEIFr8fg.png"/></div></div></figure><p id="a0c2" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在这次利用中，我们将做完全相同的事情。我们将把名称改为admin，并将令牌改为整数0。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/29f18ce26e2d8f06a9233f3b8381ffc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OQow0FUVwftZIZ2J9I9smg.png"/></div></div></figure><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/c71b3213e5a4dbd425cdd8c3d3c45085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*SNPgYxlXMULNP0LZ1IFC6Q.png"/></div></div></figure><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/c704ee18293d75bd45f833c036155860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*HkoW4Pbc6ZOK4ahYjFzAQA.png"/></div></figure><p id="6788" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">重新加载页面后，页面现在认为我们是管理员，我们已经绕过了没有超级秘密访问令牌的身份验证检查。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/eb91b81ebbfa15e16cdc477338e55925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*M9LUhZ4cY0c5Uoev82eMpw.png"/></div></figure><p id="3b4c" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">这只适用于反序列化的对象。如果直接从参数中获取密码，它将不起作用，在这种情况下，它将被转换为字符串。这只是因为数据类型在序列化中被保留，并且可以将类型更改为整数。</p><h2 id="f5a5" class="mg kg it bd kh mh mi dn kl mj mk dp kp lo ml mm kt ls mn mo kx lw mp mq lb mr bi translated">魔法方法和任意对象</h2><p id="40c2" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">魔术方法是自动调用的特殊函数。这些函数以双下划线开头，例如<code class="fe nn no np mz b"> __construct()</code>。一旦创建了一个新对象，就会调用<code class="fe nn no np mz b">__construct()</code>方法。开发人员可以实现自己的<code class="fe nn no np mz b">__construct()</code>方法来实现参数化的构造函数。还有其他几种神奇的方法，但我们将重点关注<code class="fe nn no np mz b">__destruct()</code>和<code class="fe nn no np mz b">__wakeup()</code>。</p><p id="fdc6" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">一旦该类的序列化对象被反序列化，就会调用<code class="fe nn no np mz b">__wakeup</code>。__wakeup()的用途是重新建立序列化过程中可能丢失的任何数据库连接，并执行其他重新初始化任务。在PHP代码执行结束时，会为每个PHP对象自动调用<code class="fe nn no np mz b">__destruct()</code>方法。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/1cc2a8add53aae57a5713311e64a4147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NO1OKkrAW7eThfxnmyWYWQ.png"/></div></div></figure><p id="4ea6" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在这段代码中，有一个名为Serialkiller的类，它将用户名作为构造函数的输入。</p><ul class=""><li id="2a8b" class="nq nr it lf b lg mb lk mc lo ns ls nt lw nu ma nv nw nx ny bi translated">之后，它初始化日志和缓存的文件路径。这些文件将被创建在<code class="fe nn no np mz b">/logs</code>和<code class="fe nn no np mz b">/cache</code>目录下。</li><li id="0c3f" class="nq nr it lf b lg nz lk oa lo ob ls oc lw od ma nv nw nx ny bi translated">有一个助手方法<code class="fe nn no np mz b">createFile()</code>创建文件，还有一个<code class="fe nn no np mz b">logEntry()</code>将数据写入文件。</li><li id="346b" class="nq nr it lf b lg nz lk oa lo ob ls oc lw od ma nv nw nx ny bi translated">当脚本执行完成时,<code class="fe nn no np mz b">__destroy()</code>魔术方法删除用户的缓存文件。</li><li id="af73" class="nq nr it lf b lg nz lk oa lo ob ls oc lw od ma nv nw nx ny bi translated">如果文件日志和缓存文件不存在，神奇的方法会重新初始化它，然后创建一个日志条目。</li></ul><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/7a6f5692fbe1063c3a799630079cfcd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*RNS6w_nszQA8cvvZojg2LA.png"/></div></figure><p id="c0a4" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在类声明之后，我们创建一个Serialkiller类的实例，并编写一个测试日志。在第43–50行，我们打印了之前创建的实例的序列化形式。我们用URL编码的形式<code class="fe nn no np mz b">%00</code>替换<code class="fe nn no np mz b">\x00</code>。我们将修改这个输出来创建我们的漏洞。</p><p id="6f1a" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">如果在GET请求中设置了data参数，程序会反序列化任何作为输入给出的内容。我们将用它来测试我们的战功。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/6626723d826e09b63c59980c4357bc27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4GA8zC3fYNIN3MhPtxPCwQ.png"/></div></div></figure><p id="1861" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在执行脚本之后，我们得到了序列化的对象，我们将使用它来开发漏洞。对于第一个漏洞，我们将通过操作__destruct函数从webroot中删除test.txt文件。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div class="gh gi om"><img src="../Images/ccf242797ded5cd917dcd7fb6e44922a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*SFxOdvuU8kr_rwfwuZQ45A.png"/></div></figure><p id="bf74" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">我们将在序列化对象中将cache_file属性的值更改为test.txt，并通过将它作为data参数的输入进行反序列化。在反序列化之后，cache_file属性指向test.txt。当调用__destruct()方法时，它会删除test.txt(第27行)。</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="b79e" class="mg kg it mz b gy nd ne l nf ng">O:12:"Serialkiller":4:{s:24:"%00Serialkiller%00cache_file";s:8:"test.txt";s:22:"%00Serialkiller%00log_file";s:13:"logs/john.log";s:21:"%00Serialkiller%00content";s:12:"Starting log";s:18:"%00Serialkiller%00user";s:4:"john";}</span></pre><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/e24e2b3136f3b819df38e8f9baef4caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0st3556ZkzWauGdkXZtDA.png"/></div></div></figure><p id="d4ea" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">我们可以从下一个截图中验证test.txt文件已经被删除。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/810695d4197135ad15a2f9ed3f2abd59.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*H766wrPcfFOLsFl-Rw-18w.png"/></div></figure><p id="0e1d" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">对于下一个漏洞，我们将通过在服务器上创建一个恶意的PHP文件并执行它来在服务器上执行代码。为此，我们将使用<code class="fe nn no np mz b">__wakeup()</code>函数。</p><p id="c635" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">我们知道一旦对象被反序列化，就会调用<code class="fe nn no np mz b">__wakeup()</code>。在函数内部，它创建一个日志文件并添加一个日志条目。我们将处理变量的值，这样就不用创建日志文件，而是创建一个PHP文件，不用写日志条目，而是在PHP文件中写一些恶意的PHP命令。我们按照下面的步骤来利用这一点</p><ul class=""><li id="d079" class="nq nr it lf b lg mb lk mc lo ns ls nt lw nu ma nv nw nx ny bi translated">我们将有效负载中的<code class="fe nn no np mz b">log_file</code>属性修改为我们想要生成的PHP RCE文件的目标路径(在下面的例子中为<code class="fe nn no np mz b">logs/rce.php</code>)。一旦createFile()被调用，它将检查<code class="fe nn no np mz b">logs/rce.php</code>(这是<code class="fe nn no np mz b">log_file</code>变量的值)文件是否存在，如果它不存在，它将创建它(第21，35行)。</li><li id="69d9" class="nq nr it lf b lg nz lk oa lo ob ls oc lw od ma nv nw nx ny bi translated">类似地，我们将把有效载荷中的<code class="fe nn no np mz b">content</code>属性修改成一些PHP代码，比如<code class="fe nn no np mz b">&lt;?php system('dir C:\\'); ?&gt;</code>。第22行调用的<code class="fe nn no np mz b">logEntry()</code>方法获取<code class="fe nn no np mz b">content</code>变量的值，并将其写入<code class="fe nn no np mz b">log_file</code>。因此，恶意的PHP代码将被写入到<code class="fe nn no np mz b">/logs/rce.php</code>文件中。</li></ul><p id="5cd3" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">有效负载应该如下所示:</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="30e1" class="mg kg it mz b gy nd ne l nf ng">O:12:"Serialkiller":4:{s:24:"%00Serialkiller%00cache_file";s:16:"cache/john.cache";s:22:"%00Serialkiller%00log_file";s:12:"logs/rce.php";s:21:"%00Serialkiller%00content";s:28:"&lt;?php system('dir C:\\'); ?&gt;";s:18:"%00Serialkiller%00user";s:4:"john";}</span></pre><p id="e2b7" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">由于该程序反序列化了GET参数<code class="fe nn no np mz b">data</code>中传递的任何内容，我们可以通过在浏览器上打开以下页面来执行有效负载:</p><pre class="mt mu mv mw gt my mz na nb aw nc bi"><span id="7c9e" class="mg kg it mz b gy nd ne l nf ng">http://localhost/injection.php?data=O:12:"Serialkiller":4:{s:24:"%00Serialkiller%00cache_file";s:16:"cache/john.cache";s:22:"%00Serialkiller%00log_file";s:12:"logs/rce.php";s:21:"%00Serialkiller%00content";s:28:"&lt;?php system('dir C:\\'); ?&gt;";s:18:"%00Serialkiller%00user";s:4:"john";}</span></pre><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/7251a3f65be3a54ecbc10514a027b598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jQiJNFMpGDk6Q1JmbFhVw.png"/></div></div></figure><p id="2cf0" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在执行了上面的有效负载之后，我们导航到在<code class="fe nn no np mz b">http://localhost/logs/rce.php</code>中创建的新PHP文件。我们可以看到执行代码是可能的。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/04d6829d9584a040020354dadc51b302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DO8OZQT7QhIPQXfZuI28vw.png"/></div></div></figure><p id="dbd8" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">还有一种叫做小工具的东西，它是代码本身中的代码片段。这些小工具可以被链接起来利用，但是没有源代码几乎不可能找到它们，而且要花很多时间。我们可以使用<a class="ae or" href="https://github.com/ambionics/phpggc" rel="noopener ugc nofollow" target="_blank"> PHPGGC </a>工具为这些已知的小工具链创建有效负载。</p><p id="f2bf" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">以上例子中使用的所有代码都可以在我的GitHub库<a class="ae or" href="https://github.com/sh4d3s/Insecure-Deserialization" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我计划为Java和。很快就网了。</p><h1 id="95e6" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">进一步阅读</h1><ul class=""><li id="2bdc" class="nq nr it lf b lg lh lk ll lo os ls ot lw ou ma nv nw nx ny bi translated"><a class="ae or" href="https://www.netsparker.com/blog/web-security/untrusted-data-unserialize-php/" rel="noopener ugc nofollow" target="_blank">https://www . net sparker . com/blog/we B- security/untrusted-data-unserialize-PHP/</a></li><li id="9ac6" class="nq nr it lf b lg nz lk oa lo ob ls oc lw od ma nv nw nx ny bi translated"><a class="ae or" href="https://portswigger.net/web-security/deserialization" rel="noopener ugc nofollow" target="_blank">https://portswigger.net/web-security/deserialization</a></li><li id="4d11" class="nq nr it lf b lg nz lk oa lo ob ls oc lw od ma nv nw nx ny bi translated"><a class="ae or" href="https://blog.ripstech.com/2018/new-php-exploitation-technique/" rel="noopener ugc nofollow" target="_blank">https://blog . rips tech . com/2018/new-PHP-exploitation-technique/</a></li></ul></div></div>    
</body>
</html>