<html>
<head>
<title>Firefox: How a website could steal all your cookies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firefox:一个网站如何窃取你所有的cookies</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/firefox-and-how-a-website-could-steal-all-of-your-cookies-581fe4648e8d?source=collection_archive---------0-----------------------#2020-11-16">https://infosecwriteups.com/firefox-and-how-a-website-could-steal-all-of-your-cookies-581fe4648e8d?source=collection_archive---------0-----------------------#2020-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ae4ee9f3c54bc4d00a6a9b39c0d3f610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebUBHE--Garbwlgk6dvU0A.png"/></div></div></figure><p id="6d0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一篇关于CVE-2020–15647的文章，解释了网页如何能够从你的Android设备中窃取文件，包括但不限于来自任何访问过的网站的cookies。</p><h1 id="f201" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍</h1><p id="5717" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">2020年年中，我开始检查安卓浏览器的多种类型的漏洞；在审查Android版Firefox的v68.9.0时，我注意到它在浏览<code class="fe lz ma mb mc b">content://</code> URIs时显示出奇怪的行为。</p><p id="c46e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于上下文，Android中的内容URIs识别<a class="ae md" href="https://developer.android.com/guide/topics/providers/content-providers" rel="noopener ugc nofollow" target="_blank">内容提供商</a>中的数据；它们可以表示多种形式的信息，如文件或数据库信息。</p><p id="07ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数浏览器都支持解析和处理<code class="fe lz ma mb mc b">file://</code>和<code class="fe lz ma mb mc b">content://</code> URI模式。如果您尝试在浏览器中打开本地HTML文件，它很可能会使用您在打开文件时使用的文件浏览器创建的<code class="fe lz ma mb mc b">content://</code> URI。</p><h1 id="3533" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">测试内容:// URI</h1><p id="8c33" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当我测试火狐浏览器对<code class="fe lz ma mb mc b">content</code> URIs的使用时，我注意到地址栏在渲染URI时发生了变化，把我重定向到了一个<code class="fe lz ma mb mc b">file://</code> URI。看起来Firefox正在将内容保存到一个文件中，然后将我重定向到那个创建的文件——这个文件被保存在内部临时文件夹<code class="fe lz ma mb mc b">/data/data/org.mozilla/firefox/cache/contentUri/</code>中。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/79026b49bc4be06ffb3c2287af7fd595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*Eybf5c6o5jCC0dkLzfe-Ng.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">Firefox文件下载/重定向例程</figcaption></figure><p id="0d4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还注意到创建的文件与提供者返回的显示名称(<code class="fe lz ma mb mc b">_display_name</code>)同名，如果它已经存在，Firefox不会更改名称(因此会覆盖文件)。</p><h1 id="8d5a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">许可</h1><p id="e268" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">内容提供商的问题是，一般来说，应用程序需要特定的URI权限才能从其他应用程序和提供商获取内容。这可以防止应用程序访问来自其他提供商的文件，除非它们被明确授予权限(当轻按“打开方式”或“共享方式”并选择一个应用程序来访问文件时就是这种情况)。然而，当从它们自己的内容提供商访问URIs时，应用程序不需要走这条路线。</p><p id="ec05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Firefox有一个权限为<code class="fe lz ma mb mc b">org.mozilla.firefox.fileprovider</code>的<a class="ae md" href="https://developer.android.com/training/secure-file-sharing/setup-sharing" rel="noopener ugc nofollow" target="_blank">文件内容提供者</a>，其配置如下:</p><pre class="mf mg mh mi gt mn mc mo mp aw mq bi"><span id="0aa0" class="mr kx iq mc b gy ms mt l mu mv">&lt;paths xmlns:android="<a class="ae md" href="http://schemas.android.com/apk/res/android" rel="noopener ugc nofollow" target="_blank">http://schemas.android.com/apk/res/android</a>"&gt;<br/>    &lt;root-path name="root" path="."/&gt;<br/>&lt;/paths&gt;</span></pre><p id="f390" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个问题，因为使用了根路径配置；我可以在Firefox中打开几乎任何文件，只要它有权限。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/a175e2b06ff499816dcbea57ec08af87.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*5GYqKCZG7eSOKuBHNSPD8w.gif"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">显示私有Firefox文件的内容</figcaption></figure><p id="fc44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们知道我们可以打开任何文件，让我们尝试向外界公开文件内容。​</p><h1 id="364a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">利用文件的SOP://</h1><p id="1fb8" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">火狐处理跨域请求的方式很好的记录了。为了利用这个漏洞，您只需要知道一个文件可以访问它自己的内容(即通过<code class="fe lz ma mb mc b">new XMLHttpRequest().open("GET", window.location, true)</code>)，因为来源是相同的。</p><p id="6d2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果一个文件可以请求它自己的内容，并且这些内容可以被替换，我就可以用另一个同名的文件来伪造一个文件的内容，对吗？</p><p id="5bc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我从简单的测试开始—我需要通过从外部目录打开一个文件来检索私有文件的内容。在这种情况下我选择了<code class="fe lz ma mb mc b">/data/user/0/org.mozilla.firefox/files/mozilla/profiles.ini</code>；该文件包含有关cookie数据库在设备中存储位置的信息。</p><p id="c2b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了检索这个文件，我需要创建一个同名的文件，保存在<code class="fe lz ma mb mc b">/sdcard/Download/profiles.ini</code>中。像第一段一样，我将使用<code class="fe lz ma mb mc b">XMLHttpRequest</code>来检索<code class="fe lz ma mb mc b">window.location</code>。</p><p id="84b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lz ma mb mc b">/sdcard/Download/profiles.ini</code></p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8769" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了加载这个脚本，我们还将在同一个文件中创建一个iframe，它加载一个<code class="fe lz ma mb mc b">content://</code> URI，指向我们实际尝试读取的文件；通过使用<code class="fe lz ma mb mc b">content://</code> URI打开，我们将利用Firefox将文件复制到另一个位置并通过<code class="fe lz ma mb mc b">file://</code>访问它。​</p><p id="f16e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lz ma mb mc b">/sdcard/Download/profiles.ini</code></p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/cf55a3dfdbab42ffedc6b67bfcd96228.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*PHU2Kf7ujHMFEgKaUy7o1g.gif"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">显示/data/user/0/org . Mozilla . Firefox/files/Mozilla/profiles . ini的内容</figcaption></figure><p id="73f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">综上所述，打开我们创建的文件:</p><ol class=""><li id="c1f9" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated">Firefox打开<code class="fe lz ma mb mc b">content://org.mozilla.firefox.fileprovider/root/sdcard/Download/profiles.ini</code>，这是文件<code class="fe lz ma mb mc b">/sdcard/Download/profiles.ini</code>的内容URI表示</li><li id="3ca6" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">Firefox获取其提供商提供的内容并保存在<code class="fe lz ma mb mc b">/data/data/org.mozilla.firefox/cache/contentUri/profiles.ini</code>中</li><li id="6590" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">Firefox将用户重定向到步骤2中的文件，并以<code class="fe lz ma mb mc b">file://</code> URI作为前缀</li><li id="27fa" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">HTML页面一旦呈现，iframe就会请求其<code class="fe lz ma mb mc b">src</code>字段中的<code class="fe lz ma mb mc b">content://</code> URI，该字段与当前打开的文件同名(尽管在不同的位置)，<code class="fe lz ma mb mc b">content://org.mozilla.firefox.fileprovider/root/data/user/0/org.mozilla.firefox/files/mozilla/profiles.ini</code></li><li id="7232" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">Firefox用步骤4中的文件内容替换步骤3中打开的文件内容</li><li id="eb1b" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">在短暂的延迟之后，页面会提示它自己的内容(现在已经在第4步中更改为其他文件的内容</li></ol><p id="e50f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在有一个跨域的问题，因为一个<code class="fe lz ma mb mc b">file://</code> URI可以访问另一个<code class="fe lz ma mb mc b">file://</code> URI的内容，如果文件共享相同的名称。再者，因为我们用的是火狐的提供商；该提供商的<code class="fe lz ma mb mc b">root-path</code>配置意味着我们可以利用这一点来访问设备上的任何文件。​</p><h1 id="9132" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">升级到远程</h1><p id="7594" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">下一个问题是检查是否有可能使用<code class="fe lz ma mb mc b">android-app</code>意图URIs将这个漏洞转换成远程可执行的概念证明。</p><p id="64aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">深度链接功能通常使用意图URIs；你可以在这里和<a class="ae md" href="https://simonmarquis.github.io/Android-App-Linking/" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多。</p><p id="7a6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将设置一个Python服务器来分配下一个漏洞。我们首先需要一个与我们要偷的文件同名的文件。在这种情况下，我们的远程网页应该能够触发下载我们创建的<code class="fe lz ma mb mc b">profiles.ini</code>文件。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a48d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文件下载后，我们需要打开它；我们将使用深度链接内容URI继续利用Firefox将下载的文件移动到其内部目录:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="601d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这应该和以前一样；它将请求Firefox(<code class="fe lz ma mb mc b">android-app</code>URI的<code class="fe lz ma mb mc b">org.mozilla.firefox</code>部分)用动作<code class="fe lz ma mb mc b">android.intent.action.VIEW</code>打开内容URI <code class="fe lz ma mb mc b">content://org.mozilla.firefox.fileprovider/root/sdcard/Download/profiles.ini</code>，将其内容下载到<code class="fe lz ma mb mc b">/data/data/org.mozilla.firefox/cache/contentUri/profiles.ini</code>并用<code class="fe lz ma mb mc b">file://</code> URI打开。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/47ce0b4d58720cb86e4d814a49b9bd2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*t02gg57J-jJXdrgECbeZNg.gif"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">远程访问profiles.ini的内容</figcaption></figure><p id="d6ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它起作用了——敏感文件的内容已经打印出来。你可以点击查看完整代码<a class="ae md" href="https://gist.github.com/kanytu/7fe0640c87b0f3e57bda51e784a7255d" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="92fe" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论和最终想法</h1><p id="16fb" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如上所述，仅通过让受害者访问网页，就有可能从设备中窃取文件。在真实的攻击场景中，恶意文件会将读取的内容发送到攻击者控制的服务器，而不是以警报模式输出内容。</p><p id="fbd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我提交漏洞时，我展示的概念证明强调了窃取Firefox的cookie数据库的能力，这是一个sqlite数据库，包含来自被访问域的所有cookie。</p><p id="b83e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是概念验证的示例:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/7f92ef77b9de944f296798bb02a28319.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*gyHaBFbDuaynMTSqmCpZ3Q.gif"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">远程访问cookies.sql的内容</figcaption></figure><p id="f3dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae md" href="https://i.imgur.com/UDBW0Jk.png" rel="noopener ugc nofollow" target="_blank">这张图</a>展示了漏洞利用的工作原理:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/0217e24d83c3e24f5a13702b9e393f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-f0DEdRG5-DgFAmzZo0og.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">将用户的cookies发送到恶意服务器的完整PoC示意图</figcaption></figure><p id="3fea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在撰写本报告时，Firefox Fennec (v68.9.0)已接近“生命尽头”，将被不容易受到攻击的菲尼克斯所取代。即便如此，Firefox认为这是一个关键问题，并在很短的时间内修补了漏洞，将版本推至(v68.10.1)。这只是表明这些家伙是多么认真地对待他们平台中的安全问题。他们也非常专业，很容易沟通。</p><p id="92eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章是我2020年在Android浏览器上发现的一系列文章的一部分。敬请关注其他浏览器(如Brave和三星浏览器)的后续报道！</p><h1 id="1e61" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">时间表</h1><p id="8d06" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">2020年6月20日—向Mozilla报告了该问题</p><p id="436a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2020年6月22日—内部调查开始</p><p id="cb62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2020年6月25日—确认并解决问题(在同一天👏🏼)</p><p id="6e08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2020年7月6日—在Play Store上发布的修复版本(v68.10.1)</p><p id="77de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2020-07-07-奖金分配(5000美元)</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="5a80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">推特</strong> : <a class="ae md" href="https://twitter.com/kanytu" rel="noopener ugc nofollow" target="_blank"> @kanytu </a></p><p id="66f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">LinkedIn</strong>:<a class="ae md" href="http://www.linkedin.com/in/kanytu" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/kanytu</a></p><p id="50b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">哈克罗内:</strong>T12】https://hackerone.com/kanytu</p><p id="9418" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nv">特别感谢</em><a class="ae md" href="https://twitter.com/_heydean" rel="noopener ugc nofollow" target="_blank"><em class="nv">@ hey dean</em></a><em class="nv">审阅本文，并感谢</em><a class="ae md" href="https://twitter.com/fabiopirespt" rel="noopener ugc nofollow" target="_blank"><em class="nv">@ fabiopirespt</em></a><em class="nv">提供完整的PoC图表帮助。</em></p></div></div>    
</body>
</html>