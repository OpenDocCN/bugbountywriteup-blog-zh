<html>
<head>
<title>The toddler’s introduction to Heap exploitation (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学走路的孩子对堆利用的介绍(第1部分)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8?source=collection_archive---------0-----------------------#2022-03-08">https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8?source=collection_archive---------0-----------------------#2022-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="503c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的<a class="ae kl" href="https://valsamaras.medium.com/the-toddlers-introduction-to-dynamic-memory-allocation-300f312cd2db" rel="noopener">介绍性</a>帖子中，我一直在谈论动态内存分配，并提到了用于解决这个问题的各种解决方案。在这篇文章中，我将重点关注GNU C库的内存分配，它是基于<strong class="jp ir">ptmalloc 2</strong>(pthreads malloc)，并且是从<strong class="jp ir"> dlmalloc </strong>(道格·李的malloc)中派生出来的。</p><h1 id="6ca6" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">堆组织图</h1><p id="2a25" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">分配给每个程序的堆根据三个主要部分进行组织:</p><ul class=""><li id="e3aa" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated"><strong class="jp ir"> arena，</strong>表示分配给每个线程的内存区域，而<strong class="jp ir">包含对一个或多个堆</strong>的引用。主线程的竞技场称为<strong class="jp ir">“主竞技场”，没有多个堆。</strong></li><li id="770e" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><strong class="jp ir">堆，</strong>这是一个连续的内存区域，被<strong class="jp ir">细分为块</strong>，属于一个竞技场。</li><li id="e280" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><strong class="jp ir">块</strong>是一个小范围的内存，可以分配、释放或与相邻的块组合成更大的范围。每个块存在于一个堆中，属于一个竞技场。</li></ul><p id="3e53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得我上一篇文章中的<strong class="jp ir">停车场</strong>吗？如果我们把竞技场比作一个有多层和多个车位的停车楼，那么我们将会有一个类似于下图的结构:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/b20b11a2f5c9bd28f49595c9c6834b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mx3Y9BZWaplu4aZyV6kdpg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">竞技场，停车场环境中的堆和块</figcaption></figure><p id="1798" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着P-Acme(我们的停车公司)的需求不断增长，新的建筑开始建造，新的员工开始管理这些建筑。类似地，当一个新线程被创建时，系统给它分配一个新的竞技场。竞技场的数量是有限制的，所以当达到这个限制时，程序必须重用现有的竞技场。下面的程序创建了两个线程，而每个线程都将获得一个单独的竞技场:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mt"><img src="../Images/52a6b2ac552258464283f1e7cd3fb51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AcpU9b5gPUp59cUoZmn2eg.png"/></div></div></figure><h1 id="33dc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">ptmalloc实现概述</h1><p id="1df3" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">现在我们对堆结构有了一个概念，让我们对ptmalloc分配器有一个全面的了解。</p><p id="99ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了给“<strong class="jp ir">主竞技场”分配内存，</strong> malloc调用了<strong class="jp ir"> sbrk </strong>函数，尽管请求了内存大小，系统还是会分配132 KB的内存。主线程中的更多malloc调用将继续使用同一个arena，而在内存耗尽的情况下，堆大小将会增加。对于每个新线程，通过调用<strong class="jp ir"> mmap函数</strong>创建不同的arena ( <strong class="jp ir">线程arena) </strong>，并再次分配132 KB。竞技场的最大数量<strong class="jp ir">是系统中CPU数量</strong>的八倍(除非用户另有说明)。</p><p id="50a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Glibc使用一个名为<a class="ae kl" href="https://github.com/lattera/glibc/blob/master/malloc/malloc.c" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> malloc_state </strong> </a> <strong class="jp ir">的C结构来维护每个竞技场的信息</strong>。对于主竞技场，该信息存储在一个全局变量中，而对于其他竞技场，该信息存储在线程竞技场本身中:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="033f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来是<a class="ae kl" href="https://github.com/lattera/glibc/blob/master/malloc/arena.c" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">heap _ info</strong></a><strong class="jp ir"/>C struct，带有堆元数据信息:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="46ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，每个堆都有自己的头，除了属于主竞技场的那个。最后，我们有<strong class="jp ir"> malloc_chunk </strong> C struct，正如你可能猜到的，它包含关于一个块的信息。到目前为止，我们所讨论的概念的高级概述可以在下面找到:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mw"><img src="../Images/50e7b3c9b8531ac41a747c7072bcb139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QrTqr5-10idlbvBnFvjVNw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">图来源:<a class="ae kl" href="http://core-analyzer.sourceforge.net/index_files/Page335.html" rel="noopener ugc nofollow" target="_blank">http://core-analyzer . SourceForge . net/index _ files/page 335 . html</a></figcaption></figure><p id="71d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于Glibc的malloc是面向块的，我们将重点关注malloc_chunk(上面的绿色块),并深入了解它是如何构造的。</p><h2 id="f929" class="mx kn iq bd ko my mz dn ks na nb dp kw jy nc nd la kc ne nf le kg ng nh li ni bi translated">大块</h2><p id="135c" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果您检查<strong class="jp ir"> malloc_chunk C </strong>结构，您会注意到<strong class="jp ir"> fd </strong>、<strong class="jp ir"> bk </strong>、<strong class="jp ir"> fb_nextsize </strong>和<strong class="jp ir"> bk_nextsize </strong>属性仅在<strong class="jp ir"> chunk </strong>空闲时使用<strong class="jp ir"> mchunk_prev_size </strong></p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9485" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> mchunk_size </strong>表示当前块的大小，由于它是8字节的倍数，最后3位(姑且称之为|A|M|P|)用作标志，表示以下状态之一:</p><ul class=""><li id="87b0" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">一个标志被用来通知分配器这个块是否来自主竞技场(A == 1)或者不是(A == 0)。</li><li id="63ba" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><strong class="jp ir"> M标志</strong>被设置为1，那么这个块是通过对mmap的一次调用来分配的，根本不是堆的一部分。</li><li id="4303" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><strong class="jp ir"> P标志</strong>指示前一个块被使用(P==1)或空闲(P==0)，因此，在第二种情况下，它可以安全地与当前块固化在一起:</li></ul><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nj"><img src="../Images/2112a8db0ed636a5b0917604a56cb340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50IPuyp09SxJfsxKwGEUcQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><a class="ae kl" href="https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/" rel="noopener ugc nofollow" target="_blank">https://azeria-labs . com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/</a></figcaption></figure><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nk"><img src="../Images/0b81dfe1561510deb65591ec8b0e9ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HMC0LVAV5ObmIjyy90Dv8w.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">根据先前组块的分配，在时间t和时间t+1的组块_n状态</figcaption></figure><p id="01f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，由于块在内存中彼此相邻，如果您知道堆中第一个块的地址(最低地址),则可以使用大小信息遍历堆中的所有块。</p><h1 id="d5bc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">分配停车位</h1><p id="1e5e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我们暂时忘记多个竞技场，专注于主要的一个。为了理解块分配是如何工作的，我们将使用停车位的概念，并看看Alice(停车场员工)如何处理请求:</p><ul class=""><li id="ada6" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">爱丽丝有一份所有空闲停车位的清单，写在叫做<strong class="jp ir">箱</strong>的笔记本上。请注意，一辆汽车可以占用多个插槽，因此当一辆汽车退出停车场时，Alice会将空闲的插槽添加到她的列表中。</li><li id="b958" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">当一辆车进入停车场时，Alice计算出需要多少个车位，并在她的列表中搜索合适的车位。如果她找到一个，她就把它从清单上删除，然后开一张停车罚单给司机。该票包含索引、停车位的大小以及指示前一个(相邻的)停车位是否被使用的标记。这将有助于她统一汽车出口处的停车区域。</li><li id="7242" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">如果没有空位，她会尝试创建新的空位(在停车位尽头的某个地方——最上面的那块)。如果没有空位，她会要求公司延长停车时间。如果公司批准，Alice将把汽车送到新的位置，否则她将拒绝进入(malloc返回null)。</li></ul><p id="6ec6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">暂时就这些了:)，接下来的部分保持联系！</p><h1 id="a97e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">参考</h1><p id="39b6" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">[1]https://virtual-index.com/programming/pointers<a class="ae kl" href="https://virtual-index.com/programming/pointers" rel="noopener ugc nofollow" target="_blank"/></p><p id="487b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2]<a class="ae kl" href="http://blog.k3170makan.com/2018/11/glibc-heap-exploitation-basics.html" rel="noopener ugc nofollow" target="_blank">http://blog . k 3170 makan . com/2018/11/glibc-heap-exploitation-basics . html</a></p><p id="1522" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[3]<a class="ae kl" href="https://sensepost.com/blog/2017/painless-intro-to-the-linux-userland-heap/" rel="noopener ugc nofollow" target="_blank">https://sense post . com/blog/2017/无痛-intro-to-the-Linux-userland-heap/</a></p><p id="918a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[4]<a class="ae kl" href="http://core-analyzer.sourceforge.net/index_files/Page335.html" rel="noopener ugc nofollow" target="_blank">http://core-analyzer . SourceForge . net/index _ files/page 335 . html</a></p><p id="ed03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[5]<a class="ae kl" href="http://blog.k3170makan.com/2018/12/glibc-heap-exploitation-basics.html" rel="noopener ugc nofollow" target="_blank">http://blog . k 3170 makan . com/2018/12/glibc-heap-exploitation-basics . html</a></p><p id="8c90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[6]<a class="ae kl" href="https://blog.k3170makan.com/2019/03/glibc-heap-exploitation-basics.html" rel="noopener ugc nofollow" target="_blank">https://blog . k 3170 makan . com/2019/03/glibc-heap-exploitation-basics . html</a></p><p id="b519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[7]<a class="ae kl" href="https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/" rel="noopener ugc nofollow" target="_blank">https://azeria-labs . com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/</a></p></div></div>    
</body>
</html>