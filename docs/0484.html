<html>
<head>
<title>Writing a Bootloader</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写引导加载程序</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/writing-a-bootloader-931da062f25b?source=collection_archive---------0-----------------------#2020-01-30">https://infosecwriteups.com/writing-a-bootloader-931da062f25b?source=collection_archive---------0-----------------------#2020-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="67da" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">什么是引导加载程序？</h1><p id="b14b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di"/>boot loader是一个特殊的程序，在开机或复位期间，每次计算机初始化可引导设备时都会执行该程序，将内核映像加载到内存中。这个应用程序非常接近硬件和CPU的架构。所有x86电脑都以实模式启动。在这种模式下，您只有16位指令。我们的引导程序运行在实模式下，我们的引导程序是一个16位程序。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/3629033d2a85e67ccdc55b79a03cc164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/0*XLayt5zmspJjR-NJ.png"/></div></figure><h1 id="bf58" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">这是如何工作的？</h1><p id="bf2c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di"> W </span>当你打开电脑时，BIOS想要启动一个必须在硬盘、软盘、光盘等地方找到的操作系统。BIOS搜索操作系统的顺序是用户可配置的。接下来，BIOS读取可引导磁盘的第一个512字节扇区。通常，一个扇区的大小是512字节。这就是所谓的主引导记录(MBR)。BIOS只是将MBR的内容加载到内存位置“0x7c00 ”,并跳转到该位置开始执行MBR中的任何代码。我们的引导程序大小也应该是512字节。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi md"><img src="../Images/7593d846f27e0ab365b7eefca9c96bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/0*NL0pV_atzxPA1Iz8.png"/></div></figure><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi me"><img src="../Images/ddd35d1e8550d118a59e57a1fc5078d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*JP5aekAUGAX0RHZ7xJhOIQ.png"/></div></figure><p id="d933" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">代码440字节磁盘签名4字节Null2字节分区表64字节MBR签名2字节esTotal512字节</p><p id="aac6" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">引导过程是:</p><ul class=""><li id="9beb" class="mk ml it kq b kr mf kv mg kz mm ld mn lh mo ll mp mq mr ms bi translated">打开电脑，BIOS开始运行</li><li id="d24b" class="mk ml it kq b kr mt kv mu kz mv ld mw lh mx ll mp mq mr ms bi translated">BIOS按照用户可配置的引导顺序寻找MBR。</li><li id="3838" class="mk ml it kq b kr mt kv mu kz mv ld mw lh mx ll mp mq mr ms bi translated">BIOS从指定的介质将一个512字节的引导扇区加载到内存位置“0x7c00 ”,并开始执行它。</li><li id="392c" class="mk ml it kq b kr mt kv mu kz mv ld mw lh mx ll mp mq mr ms bi translated">这512个字节然后继续加载操作系统本身或更复杂的引导加载程序。</li></ul><h1 id="e0a4" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">BIOS中断</h1><p id="b655" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi lm translated">这些中断帮助操作系统和应用程序调用BIOS的功能。这是在引导加载程序之前加载的，在与I/O通信时非常有用。由于我们没有操作系统级中断，这是唯一有用的选项。</p><p id="7ae9" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">例如使用BIOS中断调用将字符打印到屏幕上。</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="322b" class="nd jr it mz b gy ne nf l ng nh">mov ah, 0x0e    ; function number = 0Eh : Display Character<br/>mov al, 'O'     ; AL = code of character to display<br/>int 0x10        ; call INT 10h, BIOS video service</span></pre><p id="0e2d" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">这是一个用美国电话电报公司语法编写的简单的引导加载程序。</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="79b4" class="nd jr it mz b gy ne nf l ng nh">/*<br/> * Title: A Simple Bootloader in AT&amp;T Assembly<br/> * Author: Osanda Malith Jayathissa (<a class="ae ni" href="http://twitter.com/OsandaMalith" rel="noopener ugc nofollow" target="_blank">@OsandaMalith</a>)<br/> * Website: <a class="ae ni" href="http://OsandaMalith.wordpress.com" rel="noopener ugc nofollow" target="_blank">http://OsandaMalith.wordpress.com</a><br/> */ <br/> .code16<br/> .section .text<br/> .global main<br/>main:</span><span id="76b4" class="nd jr it mz b gy nj nf l ng nh">/* <br/> Disk description table, to make it a valid floppy<br/> FAT12 file system format<br/>*/<br/> jmp _start<br/> .byte 144 #NOP <br/> .ascii “OsandaOS” #OEMLabel <br/> .word 512 #BytesPerSector <br/> .byte 1 #SectorsPerCluster <br/> .word 1 #ReservedForBoot <br/> .byte 2 #NumberOfFats <br/> .word 224 #RootDirEntries (224 * 32 = 7168 = 14 sectors to read) <br/> .word 2880 #LogicalSectors <br/> .byte 0xf0 #MediumByte <br/> .word 9 #SectorsPerFat <br/> .word 18 #SectorsPerTrack <br/> .word 2 #Sides <br/> .long 0 #HiddenSectors <br/> .byte 0 #LargeSectors <br/> .byte 0 #DriveNo <br/> .byte 0x29 #Signature (41 for Floppy)<br/> .long 0x12345678 #VolumeID<br/> .ascii “My First OS” #VolumeLabel<br/> .ascii “FAT12 “ #FileSystem</span><span id="f19e" class="nd jr it mz b gy nj nf l ng nh">_start:<br/> movw $0, %ax<br/> movw %ax, %ss<br/> movw %ax, %ds<br/> movw %ax, %es<br/> movw $string, %si<br/>loop:<br/> movb $0xe, %ah<br/> movb (%si), %al<br/> cmpb $0, %al<br/> je done<br/> int $0x10<br/> addw $1, %si<br/> jmp loop<br/>done:<br/> jmp done #infinite loop</span><span id="785c" class="nd jr it mz b gy nj nf l ng nh">string:<br/> .ascii “Welcome to <a class="ae ni" href="http://twitter.com/OsandaMalith" rel="noopener ugc nofollow" target="_blank">@OsandaMalith</a>’s First OS :)”<br/> .byte 0<br/> .fill 0x1fe — (. — main) ,1,0 #Pad remainder of boot sector with 0s<br/> .word 0xaa55 #The standard PC boot signature</span></pre><p id="2e6e" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated"><a class="ae ni" href="https://github.com/OsandaMalith/bootloader/blob/master/loader.S" rel="noopener ugc nofollow" target="_blank">https://github . com/OsandaMalith/boot loader/blob/master/loader。S </a> <br/>汇编链接代码。我已经明确指定在0x7c00加载文本部分，它将计算绝对寻址。</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="724e" class="nd jr it mz b gy ne nf l ng nh">as --32 -o loader.o loader.S</span><span id="3b58" class="nd jr it mz b gy nj nf l ng nh">ld -m elf_i386 loader.o --oformat=binary -o loader.bin  -Ttext 0x7c00</span></pre><p id="37a6" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">在NASM使用英特尔语法也是如此。</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="7c26" class="nd jr it mz b gy ne nf l ng nh">%if 0; <br/> * Title: A Simple Bootloader in NASM<br/> * Author: Osanda Malith Jayathissa (<a class="ae ni" href="http://twitter.com/OsandaMalith" rel="noopener ugc nofollow" target="_blank">@OsandaMalith</a>)<br/> * Website: <a class="ae ni" href="http://OsandaMalith.wordpress.com" rel="noopener ugc nofollow" target="_blank">http://OsandaMalith.wordpress.com</a><br/>%endif;</span><span id="b89e" class="nd jr it mz b gy nj nf l ng nh">BITS 16</span><span id="d496" class="nd jr it mz b gy nj nf l ng nh">jmp short _start ; Jump past disk description section<br/> nop <br/> <br/>; Disk description table, to make it a valid floppy<br/>OEMLabel db “OsandaOS” ; Disk label<br/>BytesPerSector dw 512 ; Bytes per sector<br/>SectorsPerCluster db 1 ; Sectors per cluster<br/>ReservedForBoot dw 1 ; Reserved sectors for boot record<br/>NumberOfFats db 2 ; Number of copies of the FAT<br/>RootDirEntries dw 224 <br/>LogicalSectors dw 2880 ; Number of logical sectors<br/>MediumByte db 0F0h ; Medium descriptor byte<br/>SectorsPerFat dw 9 ; Sectors per FAT<br/>SectorsPerTrack dw 18 ; Sectors per track (36/cylinder)<br/>Sides dw 2 ; Number of sides/heads<br/>HiddenSectors dd 0 ; Number of hidden sectors<br/>LargeSectors dd 0 ; Number of LBA sectors<br/>DriveNo dw 0 ; Drive No: 0<br/>Signature db 41 ; Drive signature: 41 for floppy<br/>VolumeID dd 12345678h ; Volume ID: any number<br/>VolumeLabel db “My First OS”; Volume Label: any 11 chars<br/>FileSystem db “FAT12 “ ; File system type: don’t change!</span><span id="1624" class="nd jr it mz b gy nj nf l ng nh">_start:<br/> mov ax, 07C0h ; move 0x7c00 into ax<br/> mov ds, ax ; set data segment to where we’re loaded</span><span id="906b" class="nd jr it mz b gy nj nf l ng nh">mov si, string ; Put string position into SI<br/> call print_string ; Call our string-printing routine</span><span id="1d02" class="nd jr it mz b gy nj nf l ng nh">jmp $ ; infinite loop!</span><span id="8654" class="nd jr it mz b gy nj nf l ng nh">string db “Welcome to <a class="ae ni" href="http://twitter.com/OsandaMalith" rel="noopener ugc nofollow" target="_blank">@OsandaMalith</a>’s First OS :)”, 0<br/>print_string: <br/> mov ah, 0Eh ; int 10h ‘print char’ function<br/>.loop:<br/> lodsb ; load string byte to al<br/> cmp al, 0 ; cmp al with 0<br/> je .done ; if char is zero, ret<br/> int 10h ; else, print<br/> jmp .loop<br/>.done:<br/> ret<br/> times 510-($-$$) db 0 ; Pad remainder of boot sector with 0s<br/> dw 0xAA55 ; The standard PC boot signature</span></pre><p id="7667" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated"><a class="ae ni" href="https://github.com/OsandaMalith/bootloader/blob/master/loader.nasm" rel="noopener ugc nofollow" target="_blank">https://github . com/OsandaMalith/boot loader/blob/master/loader . nasm</a><br/>以二进制为格式汇编文件。</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="316d" class="nd jr it mz b gy ne nf l ng nh">nasm -f bin -o loader.bin loader.nasm</span></pre><p id="0415" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">如果你使用文件工具，你会看到这是一个合法的1.4兆软盘和32位引导扇区。</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="568a" class="nd jr it mz b gy ne nf l ng nh">$ file loader.bin <br/>loader.bin: DOS floppy 1440k, x86 hard disk boot sector</span></pre><p id="5e1b" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">如果你在十六进制编辑器中打开我们的引导程序，你会看到我们的512大小的程序，最后应该会有我们的引导签名0xaa55。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/fe95373cff8c3b1453b5b57b79bfc1b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/0*O5p2DfzBCJPQKG8a.png"/></div></div></figure><p id="78b9" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">之后，将二进制文件转换成软盘映像。</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="1ddf" class="nd jr it mz b gy ne nf l ng nh">dd status=noxfer conv=notrunc if= loader.bin of=floppy.flp</span></pre><p id="364f" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">您还可以使用UltraISO等工具将二进制文件转换为ISO文件。你可以刻录并在你的电脑上尝试，而不是模仿。使用Qemu来测试我们新创建的引导程序🙂</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="2595" class="nd jr it mz b gy ne nf l ng nh">qemu-system-i386 -fda floppy.flp</span></pre><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi np"><img src="../Images/8d98ba16ff8440b67daa9e7092771452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eky8tCkYkcSwxuu1.png"/></div></div></figure><p id="99f7" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">你可以开发出这样的东西🙂</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi gj"><img src="../Images/fd922daafd72020ede600983e4bb2529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vPjrt-8fZax4iQZY.png"/></div></div></figure><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nq"><img src="../Images/5e60c07951903254a66dfbb6c5964c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MO1TvL-ruKEZK9OW.jpg"/></div></div></figure><h1 id="3573" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">C中的引导程序</h1><p id="d2e7" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di">我们</span>可以用C使用内联汇编写一个简单的bootloader。我将展示一个打印“Hello”的简单示例。</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="bc1b" class="nd jr it mz b gy ne nf l ng nh">__asm__(“.code16\n”);<br/>__asm__(“jmpl $0x0000, $main\n”);<br/> <br/>void main() {<br/> __asm__ __volatile__(“movb $’H’ , %al\n”);<br/> __asm__ __volatile__(“movb $0x0e, %ah\n”);<br/> __asm__ __volatile__(“int $0x10\n”);<br/> <br/> __asm__ __volatile__(“movb $’e’ , %al\n”);<br/> __asm__ __volatile__(“movb $0x0e, %ah\n”);<br/> __asm__ __volatile__(“int $0x10\n”);<br/> <br/> __asm__ __volatile__(“movb $’l’ , %al\n”);<br/> __asm__ __volatile__(“movb $0x0e, %ah\n”);<br/> __asm__ __volatile__(“int $0x10\n”);<br/> <br/> __asm__ __volatile__(“movb $’l’ , %al\n”);<br/> __asm__ __volatile__(“movb $0x0e, %ah\n”);<br/> __asm__ __volatile__(“int $0x10\n”);<br/> <br/> __asm__ __volatile__(“movb $’o’ , %al\n”);<br/> __asm__ __volatile__(“movb $0x0e, %ah\n”);<br/> __asm__ __volatile__(“int $0x10\n”);<br/> <br/>}<br/></span></pre><p id="7061" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated"><a class="ae ni" href="https://github.com/OsandaMalith/bootloader/blob/master/loader.c" rel="noopener ugc nofollow" target="_blank">https://github . com/OsandaMalith/boot loader/blob/master/loader . c</a>T5】这将是链接器中指定为“test.ld”的链接器脚本</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="995f" class="nd jr it mz b gy ne nf l ng nh"><br/>.ENTRY(main);<br/>SECTIONS<br/>{<br/> . = 0x7C00;<br/> .text : AT(0x7C00){ *(.text); }<br/> .sig : AT(0x7DFE) { SHORT(0xaa55); }<br/>}</span></pre><p id="53d1" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">https://github . com/OsandaMalith/boot loader/blob/master/test . LD<br/>然后使用GCC编译，我们只生成一个目标文件，并使用指定链接器脚本的链接器手动链接。</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="4629" class="nd jr it mz b gy ne nf l ng nh">gcc -m32 -c -Os -march=i686 -ffreestanding -Wall -Werror -o loader.o loader.c<br/>ld -m elf_i386 -static -Ttest.ld -nostdlib — nmagic -o test.elf test.o<br/>objcopy -O binary loader.elf loader.bin<br/>dd status=noxfer conv=notrunc if=loader.bin of=floppy.flp</span></pre><p id="9b50" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">之后，使用Qemu引导我们的映像🙂</p><pre class="lw lx ly lz gt my mz na nb aw nc bi"><span id="6ee8" class="nd jr it mz b gy ne nf l ng nh">qemu-system-i386 -fda floppy.flp</span></pre><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nr"><img src="../Images/7b47abf19e679ac8e1591232d36fef4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L-3Vf-wcrcxtUsDc.png"/></div></div></figure><p id="e35c" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">使用BIOS中断，你可以编写漂亮的程序到你的电脑的引导区🙂</p><h1 id="4da3" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">参考</h1><p id="b3ce" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae ni" href="http://duartes.org/gustavo/blog/post/how-computers-boot-up/" rel="noopener ugc nofollow" target="_blank">http://duartes.org/gustavo/blog/post/how-computers-boot-up/</a><br/><a class="ae ni" href="http://wiki.osdev.org/" rel="noopener ugc nofollow" target="_blank">http://wiki.osdev.org</a><br/><a class="ae ni" href="http://mikeos.sourceforge.net/" rel="noopener ugc nofollow" target="_blank">http://mikeos.sourceforge.net/</a><br/>T18】https://en.wikipedia.org/wiki/BIOS_interrupt_call</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="9c1e" class="pw-post-body-paragraph ko kp it kq b kr mf kt ku kv mg kx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated"><em class="nz">关注</em> <a class="ae ni" href="https://medium.com/bugbountywriteup" rel="noopener"> <em class="nz"> Infosec报道</em> </a> <em class="nz">获取更多此类精彩报道。</em></p><div class="oa ob gp gr oc od"><a href="https://medium.com/bugbountywriteup" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">信息安全报道</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">收集了世界上最好的黑客的文章，主题从bug奖金和CTF到vulnhub…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or mb od"/></div></div></a></div></div></div>    
</body>
</html>