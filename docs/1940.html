<html>
<head>
<title>The toddler’s introduction to Heap exploitation (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学走路的孩子对堆利用的介绍(第2部分)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-part-2-d1f325b74286?source=collection_archive---------0-----------------------#2022-03-12">https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-part-2-d1f325b74286?source=collection_archive---------0-----------------------#2022-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="650a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的<a class="ae kl" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8" rel="noopener">上一篇文章</a>中，我一直在谈论ptmalloc分配器上下文中的堆结构。我经历了一些基本的概念，像竞技场、子堆和块，我用了一个真实的例子来简化这些概念，并(希望)帮助记忆它们。在这一部分，我将关注<strong class="jp ir"> free </strong>函数的后果，关注分配器如何以最有效的方式<em class="km">管理释放的内存。</em></p><h1 id="5c82" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">释放一个块</h1><p id="78e2" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">回想一下第1部分，当一个块被使用时，它携带关于其大小的信息，以及由表示大小的数字的最后三位表示的另外三个标志(我们将它们命名为|<strong class="jp ir">A</strong>|<strong class="jp ir">M</strong>|<strong class="jp ir">P</strong>|)。由于块大小总是8字节(对于32位系统)或16字节对齐(对于64位系统)，这些最后的位在大小计算期间被忽略，因此二进制值<strong class="jp ir"> 1111 </strong>(二进制)仍将计为8字节。最后三位表示该块是否来自主竞技场，是否是通过调用mmap分配的，以及前一个块是否在使用中。有了这些信息，并且由于块在内存中彼此相邻，如果有人知道堆中任何块的地址，那么就有可能使用由大小指示的值遍历所有块。</p><p id="4ac4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当函数<strong class="jp ir"> free </strong>被调用时，分配器将首先执行健全性检查来验证块的有效性(例如，对齐、边界、是否已经空闲等)。)如果一切正常，它将使用(现在)未使用的数据区来存储下面描述的值:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/55cec0e77b88bcc051daa4fbb0cf4950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hYXXc71Y13zRem9rmLqIwA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated"><a class="ae kl" href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/" rel="noopener ugc nofollow" target="_blank">https://azeria-labs . com/heap-exploitation-part-2-glibc-heap-free-bins/</a></figcaption></figure><p id="ac75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意FWD和BCK指针，因为它们的值将被用于将块整合到一个名为<strong class="jp ir">bin的列表中。</strong></p><blockquote class="mg mh mi"><p id="f03a" class="jn jo km jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">现实生活中的一个例子:</em> </strong> <em class="iq"> </em>回到我们的停车模型，目前我们已经看到的是，当Alice为进来的汽车找到合适的空闲空间<strong class="jp ir">时，她将它从她的可用性列表中移除，并给司机一张票。这张票包含汽车可以占用多少车位，以及关于竞技场、相邻车位的信息，以及它是否属于扩展区域(记住，如果爱丽丝找不到车位，她可以请求公司延长停车时间)。<strong class="jp ir">在离开</strong>的路上，她收到了返回的机票，她必须将该位置添加回她的可用列表中。</strong></p><p id="32de" class="jn jo km jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">因为她使用的是一个简单的笔记本，所以每次她都很难找到一个大小合适的地方，她必须一页一页地搜索才能找到合适的地方。为了避免车辆在停车队列中堆积，她必须想出一个方法来加速这个过程，这就是我们接下来要看到的。</p></blockquote><h1 id="c5c7" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">爱丽丝的宁滨</h1><p id="166f" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">当爱丽丝从一辆驶出的汽车上收到一张停车票时，她将它添加到她的<strong class="jp ir">未分类的</strong>堆中，希望上面的槽的数量将匹配即将到来的停车要求。如果这没有发生，她就把它放在她办公室表面的一个短“堆”里。这样她就能快速追踪到它，并将其分配给一辆即将到来的车辆。</p><p id="9cc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了形象化Alice的解决方案，我们可以将彩票想象成纸牌游戏中的扑克牌，其中每张牌都根据一些特定的特征被添加到特定的一堆中。她在这间办公室只能有<strong class="jp ir"> 64堆</strong>牌，每堆可以有<strong class="jp ir"> 7张</strong>。现在，想象一辆进来的汽车必须占用2个停车位。Alice只需从两张票中拿起第一张票，交给司机:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mm"><img src="../Images/76f34411c2d89c7ae7b7f33a5c6b1bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJTpnr4JDMu1JuDXHDLj1Q.png"/></div></div></figure><p id="51d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当一堆票没有更多的空间或者她不能创建一个新的时候，她就用一个特别设计的叫做<strong class="jp ir">垃圾箱</strong>的柜子来存放票。每个抽屉指的是一个<strong class="jp ir"> x </strong>车位的大小，例如第一个抽屉装的是<strong class="jp ir">1号位</strong>的票，第二个抽屉装的是<strong class="jp ir">2号位</strong>的票等等，这样她就很容易非常有效地再次跟踪车位。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mn"><img src="../Images/ac52c19d522e65cfe7a780d7d331fa2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t2hxf69O75DNwIsw7Aa33w.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">垃圾箱</figcaption></figure><p id="f007" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在忙碌的日子里，她必须更有创造力，因为上面描述的解决方案是不够的。所以她用了两个储物箱。在第一个盒子(<strong class="jp ir">小盒子</strong>)中，她将彩票放在一个特定的尺寸上，每个子盒子包含一个尺寸的彩票。在第二个(<strong class="jp ir">大箱子)</strong>中，她放入大尺寸的票，每个子箱子包含特定范围的票:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mo"><img src="../Images/499fceca227e6e67c8a014812a0b69ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qdm8ZrfKSXA1LAKg6x93fQ.png"/></div></div></figure><p id="8cf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到这一点，我们来看看ptmalloc对应的宁滨是怎样的。</p><h1 id="5446" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">Ptmalloc的宁滨</h1><p id="0456" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们正处于调用了<strong class="jp ir"> free </strong>函数的时刻，被释放的块必须被索引以备将来重用。添加到数据段中的<strong class="jp ir"> FWD </strong>和<strong class="jp ir"> BCK </strong>指针(记住空闲块和已用块之间的区别)将被用来将块整合到一个双向或单向<a class="ae kl" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank">链表:</a></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/6b46ed2d66f5c9e8efd419bd61ff362d.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*bfMtx5WMMPI0ybAXNt_8dw.png"/></div></figure><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/b8c7a7a560e78b13f025b4a638a32f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*PIu7NxBEpbbYkcaI_gryLA.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Linked_list" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Linked_list</a></figcaption></figure><p id="19a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">但是如果每个空闲块，不管大小，都集成在一个列表中，效果会如何呢？</em></p><p id="853a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与Alice的简单笔记本方法类似，分配器必须迭代空闲块列表，以找到满足内存请求的块。如你所知，这对于大量的分配是非常无效的。为了解决这个问题，分配器维护了一系列名为<strong class="jp ir">bin</strong>的列表，并使用它们根据块的大小对块进行索引。Ptmalloc使用5种类型的bin:<strong class="jp ir">tcache，fast，unsorted，small and large </strong>:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mr"><img src="../Images/0180b10dac5a56021bd7c58ec6b5b31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1WXblE4F6T1qwVVZbZHWw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">使用gdb探索堆箱</figcaption></figure><blockquote class="mg mh mi"><p id="21a3" class="jn jo km jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated"><strong class="jp ir"> tcache: </strong>包含属于单线程的块的<strong class="jp ir">单链表元</strong>。每个bin包含一个大小的块，所以数组是按块大小索引的(间接)。例如，如果我们调用malloc 8次来分配0x20、0x20、0x30、0x30、0x40、0x40、0x50、0x50字节，则tcache将如下所示:</p></blockquote><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ms"><img src="../Images/3655683112d4b5fb63d136ee38e791b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QrKpTUXyPqnegKw7Bhw6SA.png"/></div></div></figure><p id="0181" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个箱的组块数由<strong class="jp ir"> tcache_count </strong>变量设定阈值，箱数由<strong class="jp ir"> tcache_bins </strong> [1]设定阈值:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/2f889f727ed6cb33213e064582257667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*JDgezLUDDuSioTaRlg8zmw.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">Ubuntu 20.04中的glibc 2.31堆分配</figcaption></figure><p id="70a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以如果我们分配<strong class="jp ir"> 0x20字节</strong> <strong class="jp ir">超过</strong>的7倍，就会调用另一个bin桶来方便组块。例如，9个0x20字节的分配产生以下堆排列:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi mu"><img src="../Images/768f7d05ab5d9b79696bc0d6d1611b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bhum8DQIygyKlQjUCufGGg.png"/></div></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><blockquote class="mg mh mi"><p id="5391" class="jn jo km jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">一个包含最近释放的小块的列表数组。快速箱不是双重链接的。单链接会更快，而且因为块不会从这些列表的中间移除，所以双链接是不必要的。此外，与常规bin不同，它们甚至不以FIFO顺序处理(它们使用更快的LIFO ),因为在通常使用快速bin的瞬态上下文中，排序并不重要[1]。</p></blockquote><p id="44d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它实际上是一个指针数组，其中每个指针都指向一个单向链表的顶部，该链表包含特定大小的块(16、24、32、40、48、56、64、72、80和88字节加上块的元数据):</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nc"><img src="../Images/e04402dcf936fd63834ae55c00c6ebf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zbsi-ZftkkqYVvPVK3G1RA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated"><a class="ae kl" href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/" rel="noopener ugc nofollow" target="_blank">https://sploitfun . WordPress . com/2015/02/10/understanding-glibc-malloc/</a></figcaption></figure><p id="f623" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，假设有一个32字节的malloc请求，那么分配器将引用地址为<strong class="jp ir"> 0xb7fd8410，</strong>的条目，它将删除最上面的块(列表中的第一个)，并将指针设置为指向第二个条目。要了解从tcache到fastbins的交换，请参见下图:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nd"><img src="../Images/0363578ca26d24d8978349d60b6975ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*roN8zL7YCNM5zAijbwDwow.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">前七个分配已保存到tcache，下一个分配已移动到fastbins。</figcaption></figure><blockquote class="mg mh mi"><p id="1987" class="jn jo km jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated"><strong class="jp ir">小箱子:</strong>共有62个，每个小箱子存放大小相同(固定)的大块。在32位系统上，每个小于512字节的块(或在64位系统上小于1024字节的块)都有一个相应的小bin。由于每个小容器只存储一种大小的块，它们是自动排序的，所以在这些列表中插入和删除条目的速度非常快[2]。小容器是双重链接的，因此可以从中间移除大块。</p><p id="2da5" class="jn jo km jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated"><strong class="jp ir">大容器:</strong>它们有63个，与小容器的主要区别在于它们不是存储固定大小的块，而是存储大小范围内的块[1]。</p></blockquote><p id="aeef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更具体地说，ptmalloc定义了[3]:</p><ul class=""><li id="213d" class="ne nf iq jp b jq jr ju jv jy ng kc nh kg ni kk nj nk nl nm bi translated">32个箱，用于存储大小为<a class="ae kl" href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1478" rel="noopener ugc nofollow" target="_blank"> 64字节的块</a>。因此，bin[64]将包含大小在512到568之间的双重链接结构(malloc_chunk ),大小为576到632的bin[65],大小为640到696的bin[66],等等…</li><li id="ef86" class="ne nf iq jp b jq nn ju no jy np kc nq kg nr kk nj nk nl nm bi translated">16个容器，用于存储大小为<a class="ae kl" href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1479" rel="noopener ugc nofollow" target="_blank"> 512字节的块</a>。</li><li id="9d5b" class="ne nf iq jp b jq nn ju no jy np kc nq kg nr kk nj nk nl nm bi translated">8个用于存储大小为<a class="ae kl" href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1480" rel="noopener ugc nofollow" target="_blank"> 4096字节的块</a>。</li><li id="ff51" class="ne nf iq jp b jq nn ju no jy np kc nq kg nr kk nj nk nl nm bi translated">4个用于存储大小为<a class="ae kl" href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1481" rel="noopener ugc nofollow" target="_blank"> 32768字节的块的存储仓</a>。</li><li id="abdd" class="ne nf iq jp b jq nn ju no jy np kc nq kg nr kk nj nk nl nm bi translated">2个用于存储大小为<a class="ae kl" href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1482" rel="noopener ugc nofollow" target="_blank"> 262144字节间隔</a>的块的容器。</li><li id="3282" class="ne nf iq jp b jq nn ju no jy np kc nq kg nr kk nj nk nl nm bi translated">1个容器包含剩余大小的<a class="ae kl" href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1483" rel="noopener ugc nofollow" target="_blank">块。</a></li></ul><blockquote class="mg mh mi"><p id="4f76" class="jn jo km jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated"><strong class="jp ir">未分类的容器:</strong>当块被释放时，它们最初被存储在单个容器中(双重链接)。之后在malloc对它们进行分类，以便给它们一个快速重用的机会。这也意味着排序逻辑只需要存在于一个点上——其他人只需将空闲的块放入这个容器中，它们稍后会被排序。“未排序的”容器只是常规容器的第一个[4]。</p></blockquote><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ns"><img src="../Images/a920bcca51d6a068ed7efb7ad2e8eff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igso5FwRiPJyk1TWxDBFdg.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">https://developpaper.com/chunks-and-bins-in-memory/<a class="ae kl" href="https://developpaper.com/chunks-and-bins-in-memory/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="bcdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个帖子到此为止！下一集见。</p><h1 id="2820" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">参考</h1><p id="d47c" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">[1]https://sourceware.org/git/gitweb.cgi?<a class="ae kl" href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407" rel="noopener ugc nofollow" target="_blank">p = glibc.gita = blobf = malloc/malloc . c；h = 6e 766d 11 BC 85 b 6480 fa 5c 9 F2 a 76559 F8 ACF 9 deb 5；hb=HEAD#l1407 </a></p><p id="dd2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2]<a class="ae kl" href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/" rel="noopener ugc nofollow" target="_blank">https://azeria-labs . com/heap-exploitation-part-2-glibc-heap-free-bins/</a></p><p id="ac66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[3]<a class="ae kl" href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/" rel="noopener ugc nofollow" target="_blank">https://sploitfun . WordPress . com/2015/02/10/understanding-glibc-malloc/</a></p><p id="23a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://sourceware.org/glibc/wiki/MallocInternals" rel="noopener ugc nofollow" target="_blank">https://sourceware.org/glibc/wiki/MallocInternals</a></p></div></div>    
</body>
</html>