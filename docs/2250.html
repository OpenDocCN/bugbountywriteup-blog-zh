<html>
<head>
<title>Analyzing Android Encryption Processes with Frida</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Frida分析Android加密过程</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/analyzing-android-encryption-processes-with-frida-a3ab2622fce9?source=collection_archive---------4-----------------------#2022-08-06">https://infosecwriteups.com/analyzing-android-encryption-processes-with-frida-a3ab2622fce9?source=collection_archive---------4-----------------------#2022-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7442" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">移动应用程序通常使用HTTP协议与服务器通信。移动应用对会话、用户信息、特定于要执行的动作的参数进行加密，并通过HTTP协议传输到服务器，以便在代理软件干扰的情况下不被检测到。服务器解密加密的数据并继续处理。</p><p id="728a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文是“Frida ile Android ifre leme i̇şlemlerini i̇nceleme”的英文翻译，用Frida分析RSA和AES加密。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="56d5" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">RSA加密</h1><p id="1123" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">为了更好地理解加密过程在Android应用程序中是如何执行的，将对<strong class="jp ir">OWASP</strong><a class="ae kl" href="https://github.com/OWASP/MSTG-Hacking-Playground" rel="noopener ugc nofollow" target="_blank">T5】MSTG黑客游乐场 </a>应用程序进行分析。</p><p id="989e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在移动仿真器或设备上安装应用程序的APK文件后，应用程序会打开如下屏幕:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/0eed22e44d456472af8d5c10a9132262.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/0*XajXYLxvcFY728mD"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">OWASP MSTG-黑客-游乐场</figcaption></figure><p id="4498" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于加密操作，需要登录到<strong class="jp ir"> OMTG-DATAST-001-KEYSTORE </strong>模块。<br/>登录模块后，打开以下页面:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/8e1f804af98e9fd01a0e454073899a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/0*x3lJBpfVTtrsmIBT"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">OWASP MSTG-黑客-游乐场OMTG-DATAST-001-密钥库</figcaption></figure><p id="a2c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当在android设备上分析该模块时，确定在“明文”字段中输入的值被再次加密和解密。</p><p id="9215" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用“jadx-gui”工具分析APK文件时，执行“encrypt”加密过程的函数(<strong class="jp ir"> sg.vp.owasp_mobile。OMTG_Android。检测到OMTG_DATAST_001_KeyStore </strong>)。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/2dc44ba0dabf963b12725779e6590fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iNWmDdPKTLnyxMfD"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated"><strong class="bd kv"> sg.vp.owasp_mobile。OMTG_Android。OMTG_DATAST_001_KeyStore </strong></figcaption></figure><p id="49e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要逐行检查代码:</p><blockquote class="mo mp mq"><p id="6714" class="jn jo mr jp b jq jr js jt ju jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj kk ij bi translated">145–146:使用密钥库，可以获得RSA加密所需的“公钥”值。<br/> 157:从输入字段读取要加密的数据。<br/> 163:使用所需的参数创建了“密码”对象。<br/> 164:调用“Cipher”对象的“init”函数，执行加密操作。<br/>166–173:获得的加密数据用base64编码并打印在屏幕和日志上。</p></blockquote><p id="65e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">执行加密的实际代码块位于第163和164行。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/eba2bc86f3b67778ee9b18530330c6fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/0*Ev_IdLgufL_c9pAI"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">零</figcaption></figure><p id="2323" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过检查代码行顶部的行，可以获得从哪里导入“Cipher”对象。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/6291d1bb448dbb1bc42fca354a88997e.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/0*mk48MS4dQD4f12Os"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">javax.crypto .密码</figcaption></figure><p id="9143" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“Cipher”对象的源代码可从<a class="ae kl" href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/tip/src/share/classes/javax/crypto/Cipher.java" rel="noopener ugc nofollow" target="_blank">http://Hg . open JDK . Java . net/jdk8u/JDK/file/tip/src/share/classes/javax/crypto/Cipher . Java</a>获得。</p><p id="1969" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Frida，可以通过挂钩“init”函数来分析加密过程。要挂钩“init”函数，首先必须确定函数的参数。当检查以上URL中的源代码时，已经确定“init”函数因不同的值而“过载”。该应用程序在其第一个参数中采用类型为“int”的键值，在其第二个参数中采用类型为“RSAPublicKey”的键值。</p><p id="40ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当分析重载函数时，可以用调用“init”函数的代码的参数来确定运行的函数。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/427519b675ea9a16abc246f0aad8e741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/0*e-4GlcHUeQUDrQ8A"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">javax.crypto.Cipher.init</figcaption></figure><p id="2b19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">必要的参数确定后，就可以用frida来挂接函数了。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="be14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当运行frida代码时，应用程序和Frida界面的输出如下图所示。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi na"><img src="../Images/9bd86266dcb1eaeba5b1aa8d14668f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/0*NqzsfF5oOpzRJszP"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">OWASP MSTG-黑客-游乐场OMTG-DATAST-001-密钥库</figcaption></figure><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nb"><img src="../Images/01c16820d216612ade350dfb60333ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H6nC1C-H9v-8303d"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">弗里达接口</figcaption></figure><p id="a3e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“init”函数已成功挂钩，但应用程序抛出了一个错误，因为在挂钩时没有执行该函数要执行的操作。为了防止这种情况，可以编写下面的frida代码。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2c52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码将再次调用init函数并运行操作。通过这种方式，它的功能被连接起来，操作可以在不干扰流程的情况下继续进行。</p><p id="5cad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个步骤之后，可以调用“javax.crypto.Cipher”对象的所有函数，并且可以检索必要的信息。例如，调用“getOpmodeString”函数的frida代码:</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nc"><img src="../Images/04980a696ea35d7cf48dd72caeab0146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fVlI-RPAYnNNiRM8"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">弗里达接口</figcaption></figure><p id="f55d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">加密算法也可以通过使用相应Java(“javax . crypto . cipher”)对象的“getAlgorithm”函数来获得。</p><p id="a007" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要获得“Key”值，应该分析“java.security.Key”类的源代码:</p><p id="ddbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“Key”值可以通过使用<a class="ae kl" href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/7fcf35286d52/src/share/classes/java/security/Key.java" rel="noopener ugc nofollow" target="_blank">https://Hg . open JDK . Java . net/jdk8u/jdk8u/JDK/file/7 fcf 35286d 52/src/share/classes/Java/security/Key . Java</a>对象的“getEncoded”方法获得。用于获取“关键”值的弗里达代码:</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0181" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面给出了上述frida代码的输出。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nd"><img src="../Images/d4bea2b75fa16f0eea8f6d2c1c5cb62c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KhkVI_-Nha9fosNl"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">弗里达接口</figcaption></figure><p id="88c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当检查“java.security.Key”对象时，可以理解相关函数返回一个字节数组:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/7ab18b5a750bb9be3f377670b40f91d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/0*9gFO_UyUndzykDXG"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">javax.crypto .密码</figcaption></figure><p id="a7ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使字节数组更容易理解，可以使用java语言的“java.util.Base64”对象的函数:</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nf"><img src="../Images/a10eb80cdea930c045f46b35609fd7bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fnDfwolDhYvORHso"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">弗里达接口</figcaption></figure></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="58dd" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">AES加密</h1><p id="fe4f" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">“AES/CBC”加密算法通常用于在移动应用中加密服务器和客户端之间的数据。在https://github.com/Serhatcck/android_aes_encryption<a class="ae kl" href="https://github.com/Serhatcck/android_aes_encryption" rel="noopener ugc nofollow" target="_blank">T3分析android应用程序将有助于理解相关算法是如何工作的。</a></p><p id="7f00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当应用程序安装在android设备上时，它会打开一个简单的界面。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ng"><img src="../Images/c210cb60e33f44db200124be842ef1d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5rjOk8_az2asAHmE"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">serhatcck/Android _ AES _ encryption</figcaption></figure><p id="a9b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用应用程序上的按钮执行加密过程时，会出现两种不同的情况。当点击“随机密钥加密”按钮时，每次交易都会显示不同的值。当点击“加密”按钮时，加密的数据是相同的。</p><p id="84ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当分析应用程序的源代码时，已经确定匹配“随机密钥加密”按钮的函数在每次操作中产生不同的“IV秘密”和“秘密密钥”值。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nh"><img src="../Images/9085669e5a6f64dd419330aa75380d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kgp3aA9lMNsYm320"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">serhatcck/Android _ AES _ encryption</figcaption></figure><p id="5090" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现已确定，与“加密”按钮匹配的函数只产生一次“IV秘密”和“秘密密钥”值。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ni"><img src="../Images/e5a134e79e7a49f2a0dc36f42c15dfcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tLyWpxZ4p1MsP2iL"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">serhatcck/Android _ AES _ encryption</figcaption></figure><p id="3629" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当检查应用程序的源代码时，已经确定执行加密过程的函数是“加密”函数:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nj"><img src="../Images/2f4b4f0e7cbb24a5ec9afc8eaf7963ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sDMQTlOIWrai2H5H"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">serhatcck/Android _ AES _ encryption</figcaption></figure><p id="317a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上图所示，该应用程序使用了“javax.crypto.Cipher”对象的三变量init函数。</p><p id="71e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下代码块可用于将相关函数与frida挂钩。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="235f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">挂钩函数后，我们可以用下面的frida代码获得关于函数的信息:</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="914f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当上面的代码块运行时，它将输出如下内容:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/363d278c022ff862f8eab08b90b900af.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/0*9AH6X0zc-CBtCNZR"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">弗里达接口</figcaption></figure><p id="fbd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以成功获取“密钥”值，但无法获取“Iv密钥”值。“javax . crypto . spec . ivparameterspec”对象也必须被挂钩，以便获得“Iv Key”值。当分析应用程序中的源代码时，已经确定创建“Iv Key”值的函数是采用单字节数组作为参数的函数:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/c6e20cb981b26741283fa5867204f615.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/0*npy2qgNtwOnzekT3"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">serhatcck/Android _ AES _ encryption</figcaption></figure><p id="3a78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于挂钩上述函数的frida代码如下所示:</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="07a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Frida代码的输出如下。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/666655454c0d470459c1446f500d1214.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/0*e0IE4HjiYSCzUh1Y"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">弗里达接口</figcaption></figure><p id="b8ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的一点是，虽然“Iv Key”值总是在按下“RANDOM KEY ENCRYPT”按钮时输出，但只有在第一次按下“ENCRYPT”按钮时才会给出。由于“加密”按钮所连接的功能每次都不会创建新的“Iv键”值，因此“$init”功能不会被触发，并且“Iv键”值不会显示在输出中。</p><p id="d81e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用获得的“秘密密钥”和“Iv密钥”值，发送的密文可以被解码或者任何期望的文本可以被加密。</p><p id="7ddb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以更改相关的frida代码，以提供更详细的信息:</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d085" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相关Frida代码的输出如下图所示:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/75a31fb3c9ff84903af549a07c014246.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/0*5tXBlsc1GgtxjdiP"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">弗里达接口</figcaption></figure><p id="e322" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在https://codeshare.frida.re/@Serhatcck/java-crypto-viewer/的<a class="ae kl" href="https://codeshare.frida.re/@Serhatcck/java-crypto-viewer/" rel="noopener ugc nofollow" target="_blank">得到一个更加定制化的弗里达代码版本。</a></p></div></div>    
</body>
</html>