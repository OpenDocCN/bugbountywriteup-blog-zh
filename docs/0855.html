<html>
<head>
<title>Memory Analysis For Beginners With Volatility Coreflood Trojan: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Volatility Coreflood特洛伊木马初学者的内存分析:第1部分</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/memory-analysis-for-beginners-with-volatility-coreflood-trojan-part-1-89981433eeb6?source=collection_archive---------0-----------------------#2020-10-02">https://infosecwriteups.com/memory-analysis-for-beginners-with-volatility-coreflood-trojan-part-1-89981433eeb6?source=collection_archive---------0-----------------------#2020-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="96e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎来到我的挥发性记忆分析系列。在开始这个系列之前，我想确保我们都了解了Windows的内部知识。如果你不确定你是否了解这些主题，你应该继续读一点。</p><p id="2d8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要了解Windows中内存工作原理的基础知识。我会在文章中尽可能多的解释。除此之外，无论你有什么不明白的，都欢迎你去阅读！</p><p id="70ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阅读列表:</p><ul class=""><li id="d55c" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">核心态</li><li id="7843" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">用户状态</li><li id="efbc" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">虚拟内存</li><li id="2665" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">Windows进程</li></ul><p id="5123" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一点背景知识:</p><p id="55f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内存取证(有时也称为内存<strong class="jp ir"> </strong>分析)是指对计算机内存转储中的易变数据进行分析。信息安全专业人员进行内存取证，以调查和识别不会在硬盘数据上留下易于检测的痕迹的攻击或恶意行为。</p><p id="8d8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过内存取证实践，专家可以获得运行时系统活动，如开放的网络连接或最近执行的命令和进程。</p><p id="6b6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在程序在计算机上执行之前，它们被加载到内存中，使用内存取证非常重要。每个被创建、检查或删除的程序或数据都存储在ram中。这包括图像、所有网络浏览活动、加密密钥、网络连接或注入的代码片段。在许多情况下，某些人为因素只能在RAM中找到，例如崩溃时出现的开放网络连接。攻击者可以开发仅驻留在内存而非磁盘中的恶意软件，使其对标准计算机取证方法几乎不可见。这使得内存取证工具的需求非常大。</p><p id="8357" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Volatility是一个高级的内存取证框架。它为调查人员提供了许多自动工具，使用高级内存分析技术来揭示主机上的恶意活动。它是用python实现的，而且是开源的！我建议查看他们的git存储库。</p><p id="5d79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Volatility的git回购和文件:</p><div class="kz la gp gr lb lc"><a href="https://github.com/volatilityfoundation/volatility" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd ir gy z fp lh fr fs li fu fw ip bi translated">波动率基础/波动率</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">一个高级内存取证框架。通过创建一个……</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq lr lc"/></div></div></a></div><p id="6604" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Volatility的恶意软件专用命令文档</p><div class="kz la gp gr lb lc"><a href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference-Mal" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd ir gy z fp lh fr fs li fu fw ip bi translated">波动率基础/波动率</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">尽管所有的Volatility命令都可以以某种方式帮助你搜索恶意软件，但是有一些是专门设计的…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="ls l ln lo lp ll lq lr lc"/></div></div></a></div><p id="2b0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个系列中，我想对Coreflood特洛伊木马进行取证搜索。</p><blockquote class="lt lu lv"><p id="c978" class="jn jo lw jp b jq jr js jt ju jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq"> Coreflood </em> </strong> <em class="iq">是一个由一群俄罗斯黑客创建并于2010年发布的</em> <a class="ae ma" href="https://en.wikipedia.org/wiki/Trojan_horse_(computing)" rel="noopener ugc nofollow" target="_blank"> <em class="iq">木马</em> </a> <em class="iq">和</em> <a class="ae ma" href="https://en.wikipedia.org/wiki/Botnet" rel="noopener ugc nofollow" target="_blank"> <em class="iq">僵尸网络</em> </a> <em class="iq">。联邦调查局在受感染系统的名单上包括“大约17个州或地方政府机构，包括一个警察局；三个机场；两家国防承包商；五家银行或金融机构；大约30所学院或大学；大约20家医院或医疗保健公司；以及数百家企业。”</em><a class="ae ma" href="https://en.wikipedia.org/wiki/Coreflood#cite_note-1" rel="noopener ugc nofollow" target="_blank"><em class="iq">【1】</em></a><em class="iq">它存在于全球超过230万台计算机上，截至2011年5月，它仍然是一种威胁。—维基百科</em></p></blockquote><p id="b9ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此下载。vmem文件):</p><p id="2b58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ma" href="https://github.com/mgoffin/malwarecookbook/blob/master/16/6/coreflood.vmem.zip" rel="noopener ugc nofollow" target="_blank">https://github . com/MgO ffin/malware cookbook/blob/master/16/6/core flood . vmem . zip</a></p><p id="55c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本系列的目标是通过使用易失性来理解这种恶意软件正在做什么，并试图解释我的发现和我的内存取证方法。我会尽我所能揭开所有关于Coreflood的证据，以了解这个恶意软件背后的动机到底是什么。希望能从这次法医分析中学到一些新的东西，教大家一些新的东西！</p><p id="0f30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了开始调查，我想从主机上运行的进程的简单列表开始，看看是否有任何明显可疑的进程使用<strong class="jp ir"> pslist </strong>命令运行。</p><p id="1b80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Windows使用_EPROCESS结构的循环双向链表来跟踪所有活动进程。这个列表位于内核中。Volatility利用这一事实，寻找指向内核_EPROCESS结构列表开始的PsActiveProcessHead指针。Volatility遍历这个列表来枚举正在运行的进程。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mb"><img src="../Images/03db9f0f3f227587f8dfde32e6147f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cph05olSj-8-wc-ZQOCZJA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">主机上运行的进程列表:volatility-f coreflood.exe PS list命令输出</figcaption></figure><p id="204d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所见，似乎一切正常，但有几件事引人注目。Internet explorer正在运行，cmd也在运行，似乎正确的做法是检查出站连接，也许恶意软件伪装成Internet Explorer，并利用Internet Explorer定期通信的事实来隐藏自己与C&amp;C的通信？</p><p id="c7a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可能是一个好主意，看看cmd在那里做什么，但我们将稍后再做。</p><p id="7a11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个直观的操作是查看出站连接。如果我们发现没有可疑的出站连接通过IE，我们可能需要在其他地方寻找恶意活动。</p><p id="fc1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用了<strong class="jp ir"> connscan </strong>命令来检查之前终止的和当前活动的连接。</p><p id="bafe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">"要使用池标记扫描找到<code class="fe mq mr ms mt b">_TCPT_OBJECT</code>结构，请使用connscan命令。除了活动的连接之外，它还可以找到以前已经终止的连接中的工件。”—易失性文件</p><p id="31fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其工作方式是扫描物理内存中的四字节签名0x 54455054(“TCPT”)，并解析出接下来的28个字节作为完整的<code class="fe mq mr ms mt b">_TCPT_OBJECT</code>。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mu"><img src="../Images/644e9bb8e71bff808264b97562a9d623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XsFE7id8B_4q8YGNhRQiNg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">volatility-f core flood . vmem conns can输出</figcaption></figure><p id="99aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来主机正在合法地通信，所有的通信都是由IEXPLORE.EXE的pid 2044创建的。我查了这些IP的地理位置。它们都是在一些大公司下注册的，比如微软、美国电话电报公司等等…有可能关于IPs的数据已经改变了，因为这是一个正在调查的旧vmem文件。也可能是黑客注册的关于这些IP地址的一些假数据来欺骗调查人员。</p><p id="6637" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确保没有恶意通信，我们应该检查入站连接以确保安全。我将使用<strong class="jp ir"> sockscan </strong>命令，sockscan命令扫描内存中的<code class="fe mq mr ms mt b">_ADDRESS_OBJECT</code>。通过扫描这个内存结构的内存，我们可以深入了解以前打开的和当前打开的套接字。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mv"><img src="../Images/e9e68b091ffdefec09a8d61dff5d9429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53bAcsZBJfg38id4UPppqg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">volatility-f core flood . vmem socks can的输出</figcaption></figure><p id="6e82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所见，有一些非常奇怪的入站连接进入pid 2044，或者我们称之为:IEXPLORE.EXE。这看起来很可疑，我认为是时候拿出我们的大枪了，我怀疑在这个过程中可能隐藏着恶意软件。</p><p id="29ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候拿出Volatility的大枪，使用它提供的强大的恶意软件分析工具了。</p><p id="f6df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先使用的命令是<strong class="jp ir"> malfind </strong>命令。该命令用于在进程内存中查找注入的代码。它通过寻找已分配内存的部分(通过查看<a class="ae ma" href="https://www.sciencedirect.com/science/article/pii/S1742287607000503#:~:text=The%20Virtual%20Address%20Descriptor%20tree,entry%20in%20the%20VAD%20tree." rel="noopener ugc nofollow" target="_blank"> VAD树数据结构</a>)并检查它们是否有未映射到磁盘上任何文件的可执行代码的提示来实现这一点。</p><p id="3ae3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“VAD节点还引用许多可能对调查者有用的其他内核结构……从那里，如果该区域用于映射文件(如加载的DLL ),则可以引用相应的_FILE_OBJECT结构并提取文件名。这可以为调查者提供一种列出进程加载的模块的替代方法，然后可以与其他方法(例如，<a class="ae ma" href="https://www.sciencedirect.com/science/article/pii/S1742287607000503#bib14" rel="noopener ugc nofollow" target="_blank"> Walters，2006 </a>描述的方法)进行比较，以找到库注入和隐藏模块的证据。”——科学指导</p><p id="3181" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于检查一段内存是否包含注入代码的方法是通过<strong class="jp ir">检查VAD的页面权限，比如execute。</strong>如果内存中的某个部分有<strong class="jp ir">执行</strong>权限，而<strong class="jp ir">它没有映射</strong>到磁盘上的任何可执行文件，这是一个可能是代码注入的明确警告。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mw"><img src="../Images/037c47c1de6c7718d22d2aadd938531a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rm5UDEq9CO1m_Soj7e82ow.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">volatility-f core flood . vmem malfind—命令输出看起来像是一些误报</figcaption></figure><p id="1830" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在上面的图片中看到的，看起来命令输出并没有告诉我们太多。看起来似乎<strong class="jp ir"> malfind </strong>的输出是相当良性的。</p><p id="bff0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可能是恶意软件没有将任何显式PE(可移植可执行文件)加载到内存中，而只是注入了一些外壳代码，或者图像头被分页。也可能是恶意软件通过调用注入的DLL的ImageBase上的VirtualFree从内存中清除了PE的头以避免检测。也可能是因为某种原因，这部分内存被分页或无法访问。无论如何，我们不能确定，因为这里没有恶意活动的具体证据。</p><p id="2642" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用的下一个命令是<strong class="jp ir"> apihooks </strong>:</p><p id="a3f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“这发现IAT，吃，内嵌风格的钩子，和几个特殊类型的钩子。对于内联钩子，它检测对直接和间接位置的调用和JMPs以及对内核内存中未知代码页的调用。”—易失性文件</p><p id="4261" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了理解这里到底发生了什么，我们需要快速回顾一下IAT和EAT。</p><p id="709e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一次加载可执行文件时，Windows加载程序负责读入文件PE结构并将可执行文件映像加载到内存中。它需要的另一个步骤是加载应用程序使用的所有dll，并将它们映射到进程地址空间。</p><p id="d465" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可执行文件还列出了它需要每个dll提供的所有函数。因为函数地址不是静态的，所以必须开发一种机制，允许在运行时改变这些变量，而不需要改变所有编译的代码。</p><p id="0691" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是通过使用导入地址表(IAT)实现的。这是一个函数指针表，在加载dll时由windows加载程序填充。</p><p id="cd24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">EAT的工作方式与IAT相同，除了库会将函数导出到图像可执行文件，其中程序会将函数导入到IAT中(我不会深入细节)。</p><p id="6b2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两种存储器结构可以被恶意软件操纵，以便使可执行文件调用某个其他函数，而不是想要调用的函数。</p><p id="dbac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想专门在IEXPLORE.EXE的T2上使用apihooks，因为根据T4足球扫描的输出，我已经怀疑它可能被篡改了。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/a37f4c5108ae67afa2d5c13ad28a86d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*L7vrZZPEjhfkw3VAr_IVAQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">我们将使用apihooks并将输出保存在一个文本文件中</figcaption></figure><p id="4005" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">惊喜！为了调用同一个函数，Internet Explorer被挂了十几次。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi my"><img src="../Images/bfa032700350059ec49f68d84cd4d722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LhIwcEtaXR0vM6rSZVXedw.png"/></div></div></figure><p id="f2e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在上面看到保存在文本文件中的apihooks命令的输出。这是不同功能挂钩中的一个。都是调用同一个地址0x7ff82a6e</p><p id="c39b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，我们可以看到恶意软件钩住了WINHTTP.dll的LoadLibrary。</p><p id="d10d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LoadLibrary可用于将库模块加载到进程的地址空间中，并返回一个句柄，该句柄可在GetProcAddress中用于获取DLL函数的地址。LoadLibrary是挂钩的一个非常明显的选择，因为我们知道许多PE使用其他dll，因此导入它们的功能。</p><p id="f848" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要找出恶意软件想要达到的目的。为了做到这一点，我们需要尝试深入恶意软件试图执行的代码。因此，我们将使用Volatility的<strong class="jp ir"> volshell </strong>。Volshell是一个强大的工具，我们可以用它来浏览我们的记忆。我们可以跳到记忆的某个部分，看看里面有什么，然后丢弃或读取里面的任何东西。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mz"><img src="../Images/2c44d1443e2f55b2e5326497ecca864d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qV4D2gZkD3I9hwRzc7FyFA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">键入volshell命令，然后按照流程操作。</figcaption></figure><p id="7970" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在键入volshell命令后，我使用了cc( <context command="" to="" change="" into="" the="" memory="" context="" of="" certain="" process.="" i="" used="" pid="" iexplore.exe="" as="" an="" argument="" in="" order="" dive="" context.=""/></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi na"><img src="../Images/e128290ad0cbeae40f1fd8223464b606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGGwzlommUOCuWd8RGeAXA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">The highlighted text above (top to bottom) shows us the address that was hooked and under it, also highlighted is the address the malware wants our code to go to.</figcaption></figure><p id="f31b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">As we can see above, the relevant address we want to disassemble in order to find out what are malware is doing. I copied this address as an argument into the volshell command dis(<copied_addres>)，如上面我们的流程图中所示。</copied_addres></p><p id="ca24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的最终输出应该是恶意注入的代码:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nb"><img src="../Images/c95d0d6c8aa811aea1b1ef72d4381761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJZnbir24cxEnxGryZBWQA.png"/></div></div></figure><p id="e178" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将不得不等待本系列的一部分来尝试并找出这段恶意代码在做什么。也许你可以同时自己试试。</p><p id="15ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总结一下这部分的内容。我们使用volatility来发现在我们的主机上运行的可疑或恶意代码。我们从一些基本操作开始，比如确保没有任何我们可以立即发现的可疑情况，比如可疑进程或流向不寻常IP地址的流量。我们最终拿出我们的大枪，试图看看我们的恶意软件是否通过将代码注入无辜的进程而隐藏起来，我们发现了一些有趣的事情。在下一部分中，我将更深入地研究代码，并尝试了解这个恶意软件到底想要达到什么目的。</p><p id="7ba1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望你读得愉快，下期再见。</p></div></div>    
</body>
</html>