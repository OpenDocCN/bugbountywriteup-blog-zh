<html>
<head>
<title>Into the art of Binary Exploitation 0x000004[Reviving of Satanic-ROP]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">进入二进制开发的艺术0x 000004[撒旦-ROP的复活]</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/into-the-art-of-binary-exploitation-0x000004-reviving-of-satanic-rop-5ab604b52341?source=collection_archive---------1-----------------------#2021-12-03">https://infosecwriteups.com/into-the-art-of-binary-exploitation-0x000004-reviving-of-satanic-rop-5ab604b52341?source=collection_archive---------1-----------------------#2021-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><ul class=""><li id="f4ef" class="jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">魔法的延续…！！</li></ul><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/81736722192ed6947f553b6fe58bbdb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YOtLqPDclsJTPLcGAn61jQ.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">NX的全面淘汰</figcaption></figure><p id="27b3" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">嘿爱好者✋✋，<br/>我带着我的冒险二进制开发系列的第四部分又回来了。首先，我想为这些裂缝道歉。工作很忙碌，还存在一些健康问题。目前，手术后我很好。让我们把这些都分开，现在是时候开始了。</p><blockquote class="ll lm ln"><p id="af0d" class="kw kx kf jp b jq jr ky kz js jt la lb lo lc ld le lp lf lg lh lq li lj lk ka ij bi translated">我们已经研究了什么是缓冲区溢出&amp;它如何通过利用NX来抵抗外壳代码的执行。如果你是这个话题的新手，有几个术语可能不常见。因此，如果你能更好地理解过去的部分，那将是非常理想的。万一你卡住了或者完全走了，没关系。这需要一点练习。</p></blockquote><p id="89c4" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">在深入我们的主题之前，我想告诉你一个绕过NX的常用策略。</p><h1 id="1deb" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">返回到libc攻击</h1><p id="57f0" class="pw-post-body-paragraph kw kx iq jp b jq mp ky kz js mq la lb ju mr ld le jw ms lg lh jy mt lj lk ka ij bi translated">因此，在进入攻击阶段之前，我将澄清一个关于libc的简介。Libc通常被用作“<strong class="jp ir">标准C库</strong>”的简写。这是一个标准函数库，所有C程序都可以使用。您可以查看Linux手册以获得更好的想法:)</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/2a1905f2ca16360b0f3d8ed7c67e18ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aaP3EchEA0hGGu7OPr2saw.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">Linux程序员手册</figcaption></figure><p id="1fd6" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">每次你从事C语言编程时，你肯定会用到一个或另一个内置的功能，比如printf、scanf、puts等等。所有的标准C能力都被编译成一个文件，命名为“<strong class="jp ir">标准C库</strong>或<strong class="jp ir"> libc </strong>。C标准库为任务、I/O处理、内存管理、数学计算、宏(“宏指令”)提供了数据定义和函数——它是一种规则或模式，指示某些输入应该如何映射到替换输出。通过将程序员可访问的计算指令安排为单个程序解释，宏被用于使编程任务不那么乏味和不那么容易出错。libc还提供其他一些操作系统服务。一些语言在它们自己的库中包含了标准C库的功能。该库可能会被修改以更好地适应语言的结构，但是操作语义是可以比较的。例如，C++语言在命名空间td中包含了C标准库的功能。在Python 2中，举例来说，内置的记录对象被定义为“利用C的stdio包实现”。Rust有一个名为libc的工具箱，它允许几个C函数。同样，很多…很多…事情要谈。</p><blockquote class="ll lm ln"><p id="0c46" class="kw kx kf jp b jq jr ky kz js jt la lb lo lc ld le lp lf lg lh lq li lj lk ka ij bi translated">libc包含了任何C程序都可以使用的所有标准功能。它在执行时“链接”到二进制文件。从利用的角度来看，理解libc非常重要，因为我们可以将控制流转移到libc函数。现在我们将重点关注<strong class="jp ir">系统功能</strong>。</p></blockquote><p id="e766" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">在常规的堆栈溢出攻击中，我们知道没有堆栈保护。因此，我们用注入堆栈的外壳代码的地址覆盖返回地址，并执行它。然而，如果易受攻击的程序的堆栈被保护(NX位被设置)，我们就不能再执行我们的外壳代码。这些都是我们之前讨论过的，这就是我们如何开始ROP或面向返回的编程。</p><blockquote class="ll lm ln"><p id="b1d6" class="kw kx kf jp b jq jr ky kz js jt la lb lo lc ld le lp lf lg lh lq li lj lk ka ij bi translated">在ret-to-libc(ret 2 libc)技术中，返回地址将用指向libc库中system()函数的内存地址覆盖。</p></blockquote><h1 id="af93" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">c库函数—系统()</h1><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="2b17" class="na ls iq mw b gy nb nc l nd ne">The C library function  <strong class="mw ir">int system(const char *command)</strong> passes the command name or program name specified by command to the host environment to be executed by the command processor and returns after the command has been completed.</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/fa2be5bb9ddd3a8825e8a2395ca4300a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFLDA0M2ELxJnm0eLiEfqQ.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">够了吗？；)</figcaption></figure><h2 id="e4e6" class="na ls iq bd lt nf ng dn lx nh ni dp mb ju nj nk mf jw nl nm mj jy nn no mn np bi translated">剥削的概念</h2><blockquote class="ll lm ln"><p id="a01f" class="kw kx kf jp b jq jr ky kz js jt la lb lo lc ld le lp lf lg lh lq li lj lk ka ij bi translated">当我们将返回指针覆盖到system()函数的地址时，程序就会跳转到system()函数。当命令参数被执行时我们传递的命令。我们希望易受攻击的程序产生外壳，所以我们让易受攻击的程序调用<strong class="jp ir">系统("/bin/sh ")。</strong></p></blockquote><h2 id="8fe5" class="na ls iq bd lt nf ng dn lx nh ni dp mb ju nj nk mf jw nl nm mj jy nn no mn np bi translated">例子</h2><p id="ee38" class="pw-post-body-paragraph kw kx iq jp b jq mp ky kz js mq la lb ju mr ld le jw ms lg lh jy mt lj lk ka ij bi translated">让我们举个例子。如果你注意到代码是我自己做的，让我的追求者了解情况，那就太理想了。<strong class="jp ir">在“我们触及核心话题”之前，不要预测真实环境中的这种场景(这些都是公平的必需品)</strong></p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">例子</figcaption></figure><p id="35e3" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">函数溢出易受攻击。所以表演不要出错，让我们开始吧。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ns"><img src="../Images/1a65683159e0292b97e2ab071a9e435f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLUhSNgERo2WtP69HgttyQ.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">分段故障</figcaption></figure><blockquote class="ll lm ln"><p id="3877" class="kw kx kf jp b jq jr ky kz js jt la lb lo lc ld le lp lf lg lh lq li lj lk ka ij bi translated">万一你迷路了或没有得到什么，这意味着要么你没有覆盖基本的，否则，你没有贡献时间在前面的部分。</p></blockquote><p id="5ef0" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated"><strong class="jp ir">分段故障</strong>！！&amp;通过python确定偏移量。现在是调试的时候了。</p><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="d354" class="na ls iq mw b gy nb nc l nd ne">python2 -c 'print("A"*72)' &gt; exp</span><span id="6f28" class="na ls iq mw b gy nt nc l nd ne">gdb -q ./ret2libc</span><span id="b978" class="na ls iq mw b gy nt nc l nd ne">r &lt; exp</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nu"><img src="../Images/340b2965c36f21d30a354a7c83aa7260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_DrewfL_8_BZsnDN0NsDgw.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">rbp溢出</figcaption></figure><p id="4cb3" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">很明显，我们将控制指令指针rip来执行我们想要的指令。我在上面精确地美化了剥削的概念。我会让它发生的。首先，让我们使用ldd来发现libc的基址。</p><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="6eab" class="na ls iq mw b gy nb nc l nd ne">Cmd: <strong class="mw ir">ldd </strong></span><span id="24f5" class="na ls iq mw b gy nt nc l nd ne">Ldd is a Linux command-line utility that’s utilized in case a user needs to know the shared library conditions of an executable or indeed that of a shared library. It<strong class="mw ir"> </strong>prints the shared objects (shared libraries) required by each program or shared object specified on the command line.</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/e4cc8b44e6a15406f3ec9684bb437b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BPK-VtaQp3yNvxBWj168Kg.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">ldd</figcaption></figure><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nv"><img src="../Images/609427427a2def4d3ab78e717983931e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-RuL4X84UDUGS3oPjDhBA.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">libc.so.6</figcaption></figure><p id="a1de" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">这里我们得到了libc的基地址。现在让我们算出弹出shell的“系统函数”&amp; argument“/bin/sh”的地址。</p><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="7658" class="na ls iq mw b gy nb nc l nd ne">Cmd: <strong class="mw ir">readelf</strong></span><span id="585e" class="na ls iq mw b gy nt nc l nd ne"><em class="kf">readelf is a program for displaying various information about object files on Unix-like systems such as objdump.</em></span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/9c7812eb5e7bacc7cb90082e1e575d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8aC07c3hstLWtKDDjtJnEQ.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">readelf</figcaption></figure><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="92f4" class="na ls iq mw b gy nb nc l nd ne">Cmd: <strong class="mw ir">strings</strong></span><span id="3da3" class="na ls iq mw b gy nt nc l nd ne"><em class="kf">It could be a complex task for a human to discover out content from an executable file. The binary files, such as program records, contain human-readable content. It basically focuses on determining the contents of and extricating content from the binary files.</em></span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/0dbcbdf849d17bd9a760d328203090d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ACDldfRPZwLEscjCznwHww.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">用线串</figcaption></figure><p id="d52c" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">我们利用这些命令来查找“系统函数”的地址&amp;参数“/bin/sh”&amp;如果您对相应的标志有任何疑虑，请查阅Linux手册。</p><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="c00e" class="na ls iq mw b gy nb nc l nd ne">Cmd: <strong class="mw ir">readelf -s /usr/lib/libc.so.6 | grep system</strong></span><span id="6d64" class="na ls iq mw b gy nt nc l nd ne">Cmd: <strong class="mw ir">strings -a -t x /usr/lib/libc.so.6 | grep /bin/sh</strong></span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/75910c42cf623f9cf18275d02e6fb88f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RiMUxLx131_WTd8X-h0veQ.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">我们都拿到了:)</figcaption></figure><p id="6b3d" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">我们将利用二进制文件中的小汇编片段，称为“小工具”这些小工具通常从堆栈中弹出一个或多个寄存器，然后调用ret。我们可以用这些小工具建立一个假的调用栈来连续执行它们，将我们控制的值弹出到寄存器中，然后跳转到系统结束(如第— &gt; <a class="ae nw" href="https://7h3h4ckv157.medium.com/?p=b4658238ee62" rel="noopener"> 0x000002 </a>部分所述)。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/a490e2e9b2361eaf6f9e026b3e7b490a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pAyqRETwMKJp8rxX2DVzdQ.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">pop rdi</figcaption></figure><h1 id="6eef" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated"><strong class="ak">漏洞利用开发</strong></h1><p id="06a1" class="pw-post-body-paragraph kw kx iq jp b jq mp ky kz js mq la lb ju mr ld le jw ms lg lh jy mt lj lk ka ij bi translated">我们已经理解了一切需要剥削的东西。通过使用python2，让我们开发我们的漏洞&amp;弹出外壳:)</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">利用. py</figcaption></figure><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/699e94dcffa4359e40104feea5fa2398.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ncaN2A2cXgmojqCxbO5Ag.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">利用. py</figcaption></figure><p id="9c9d" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">理想情况下，我通过python编写了一个巧妙的利用脚本。现在让我们运行它。</p><blockquote class="nx"><p id="aadc" class="ny nz iq bd oa ob oc od oe of og ka dk translated">耶！我们绕过了没有外壳代码的NX。</p></blockquote><figure class="oh oi oj ok ol kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/1daf2ab184f5889f3f1c143fdfc066a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hlrXwc8HuRS94Nx7bEDo_A.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">我们拿到壳了</figcaption></figure><blockquote class="nx"><p id="dae4" class="ny nz iq bd oa ob om on oo op oq ka dk translated">这个策略成功了。稳定的外壳被弹出。我们有效绕过了NX bit的安全实现。</p></blockquote></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><blockquote class="ll lm ln"><p id="df12" class="kw kx kf jp b jq jr ky kz js jt la lb lo lc ld le lp lf lg lh lq li lj lk ka ij bi translated">你是否遗漏了栈上的外壳代码注入？<br/>大概你会觉得，即使我们注入，也因为NX位而弹出不了壳。</p></blockquote><blockquote class="nx"><p id="dde8" class="ny nz iq bd oa ob om on oo op oq ka dk translated"><em class="oy">正如我常说的，</em> <strong class="ak"> <em class="oy">黑客永不言弃！</em> </strong></p></blockquote><h1 id="55f3" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc oz me mf mg pa mi mj mk pb mm mn mo bi translated">功能介绍:mprotect()</h1><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="bc43" class="na ls iq mw b gy nb nc l nd ne"><em class="kf">'m' for memory &amp; 'protect' for protection</em></span></pre><p id="82c3" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">映射内存区域，也称为共享内存区域，可以作为在进程间交换数据的大型池。在类Unix操作系统中，<strong class="jp ir"> mprotect() </strong>是一个POSIX系统调用，用于控制内存保护。mprotect()是一种保护功能。它为内存映射设置保护。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/6aa16ea7174323139adccdb92ce4d979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BI9dqOhXjR3gGPUnuGwZbw.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">更多信息，请查阅Linux手册</figcaption></figure><h2 id="44af" class="na ls iq bd lt nf ng dn lx nh ni dp mb ju nj nk mf jw nl nm mj jy nn no mn np bi translated">摘要</h2><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="64ca" class="na ls iq mw b gy nb nc l nd ne"><strong class="mw ir"><em class="kf">#include &lt;sys/mman.h&gt;</em></strong></span><span id="40de" class="na ls iq mw b gy nt nc l nd ne"><strong class="mw ir"><em class="kf"> int mprotect(void *addr, size_t len, int prot); </em></strong></span></pre><h2 id="e81e" class="na ls iq bd lt nf ng dn lx nh ni dp mb ju nj nk mf jw nl nm mj jy nn no mn np bi translated">使用的参数:</h2><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="5a59" class="na ls iq mw b gy nb nc l nd ne"><strong class="mw ir"><em class="kf">addr</em></strong>: <em class="kf">Is the starting address of the region for which the protection has to be changed.</em></span><span id="6502" class="na ls iq mw b gy nt nc l nd ne"><strong class="mw ir"><em class="kf">len</em></strong>: <em class="kf">Is the length of the region, in bytes, whose protection has to be changed</em>.</span><span id="98b7" class="na ls iq mw b gy nt nc l nd ne"><strong class="mw ir"><em class="kf">prot</em></strong><em class="kf">: Is the desired protection of the memory mapped region.</em></span></pre><p id="074d" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">既然清楚了addr &amp; len，现在我们来谈谈<strong class="jp ir"> prot </strong>。</p><p id="355b" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">mprotect()函数将访问保护更改为由<em class="kf"> prot </em>指定的访问保护，用于包含从地址<em class="kf"> addr </em>开始并延续到<em class="kf"> len </em>字节的进程地址空间的任何部分的整个页面。参数<em class="kf"> prot </em>指定是否允许对正在映射的数据进行读、写、执行或某种访问组合。</p><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="1b8d" class="na ls iq mw b gy nb nc l nd ne"><strong class="mw ir">PROT_NONE:</strong> <em class="kf">The memory cannot be accessed at all.</em><br/><br/><strong class="mw ir">PROT_READ: </strong><em class="kf">The memory can be read.</em><br/><br/><strong class="mw ir">PROT_WRITE:</strong> <em class="kf">The memory can be modified.</em><br/><br/><strong class="mw ir">PROT_EXEC:</strong> <em class="kf">The memory can be executed.</em></span></pre><h1 id="83a8" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated"><strong class="ak">剥削</strong></h1><p id="d5d5" class="pw-post-body-paragraph kw kx iq jp b jq mp ky kz js mq la lb ju mr ld le jw ms lg lh jy mt lj lk ka ij bi translated">有许多技术可以通过使用mprotect()函数来绕过NX堆栈。让我们通过在堆栈&amp;上注入外壳代码来执行一个合适的区域。</p><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="7828" class="na ls iq mw b gy nb nc l nd ne"><em class="kf">function: </em></span><span id="e606" class="na ls iq mw b gy nt nc l nd ne"><strong class="mw ir">mprotect(void *addr, size_t len, int prot);</strong></span><span id="906e" class="na ls iq mw b gy nt nc l nd ne">1. Pass the stack address on<strong class="mw ir"> *addr</strong></span><span id="209b" class="na ls iq mw b gy nt nc l nd ne">2. The desirable size as <strong class="mw ir">len </strong>(here we choose stack length in hex)</span><span id="470b" class="na ls iq mw b gy nt nc l nd ne">3. Finally, <strong class="mw ir">PROT_EXEC</strong> has to be set in <strong class="mw ir">prot</strong> for making the selected area executable.</span><span id="7638" class="na ls iq mw b gy nt nc l nd ne"><strong class="mw ir">PROT_EXEC</strong>: <em class="kf">The memory can be used to store instructions which can then be executed.</em></span></pre><blockquote class="ll lm ln"><p id="b5f5" class="kw kx kf jp b jq jr ky kz js jt la lb lo lc ld le lp lf lg lh lq li lj lk ka ij bi translated">“--”<br/>“r-”<br/>“-w-”；<br/>“rw-”；<br/>“-x”；<br/>“r-x”；<br/>"-wx "；<br/>“rwx”；</p></blockquote><p id="2647" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">所以我们需要在<strong class="jp ir"> RDI </strong>寄存器中设置堆栈地址，在<strong class="jp ir"> RSI </strong>寄存器中设置长度，在<strong class="jp ir"> RDX </strong>寄存器中设置值<strong class="jp ir"> 0x7 (rwx) </strong>。(64位的调用约定是RDI、RSI等中的参数……)</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/cb6a510d6323377d79152e339e43b65b.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/1*lB8iK_hs76hKLSdMSXCmBw.gif"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">我们在这里已经讨论过:<a class="ae nw" rel="noopener ugc nofollow" target="_blank" href="/into-the-art-of-binary-exploitation-0x000002-sorcery-of-rop-b4658238ee62"> 0x000002 </a></figcaption></figure><p id="10a8" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated"><em class="kf">万一你看起来完全迷路了，没关系！需要时间去理解。尝试在技术层面进行概述，而不是记忆。</em></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pd"><img src="../Images/68a7655fce915d877d26cf34fec5a581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Bc2UXWNui5j3u7tASF0JZA.gif"/></div></div></figure><blockquote class="ll lm ln"><p id="1da0" class="kw kx kf jp b jq jr ky kz js jt la lb lo lc ld le lp lf lg lh lq li lj lk ka ij bi translated">我正在利用我们处理过的相同的二进制来阐述ret2libc。所以是时候建立我们的功勋了。</p></blockquote><p id="5172" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated"><em class="kf">通过调试，可以发现mprotect的地址。</em></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/b9443321377d11162f73e20bf9798ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4A7t8CN1BIRCP2EzV-8og.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated"><mprotect/></figcaption></figure><p id="01c7" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated"><em class="kf">堆栈地址必须在addr中传递。我们必须通过调试来检查堆栈。所有这些概念以前都讨论过。所以我要催一下题目。我们需要将堆栈地址放入RDI寄存器</em></p><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="e847" class="na ls iq mw b gy nb nc l nd ne"><em class="kf">The next step is to set </em>the length (len) in the <strong class="mw ir">RSI</strong> register and the value <strong class="mw ir">0x7</strong> (rwx) in the <strong class="mw ir">RDX</strong> register.</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/f87b15793083451c6f07a36d3639ca5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFNpAin2olWjKdnVlmYtiQ.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">我通常利用radare2寻找rdi、rsi等简单的工具。</figcaption></figure><p id="2f5d" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated"><em class="kf">在ret之前，pop rsi小工具后面是pop r15指令。</em></p><blockquote class="ll lm ln"><p id="cb3a" class="kw kx kf jp b jq jr ky kz js jt la lb lo lc ld le lp lf lg lh lq li lj lk ka ij bi translated">流行rsi <br/>流行r15 <br/> ret</p><p id="d831" class="kw kx kf jp b jq jr ky kz js jt la lb lo lc ld le lp lf lg lh lq li lj lk ka ij bi translated">注:因此，我们必须构建一个漏洞，以丰富r15的垃圾。</p></blockquote><p id="c67a" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">利用ldd，我们可以确定libc地址(已经检查过)。利用<a class="ae nw" href="https://github.com/JonathanSalwan/ROPgadget" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> ROPgadget </strong> </a>，能够发现小工具RDX。(在我们的二进制文件中找不到RDX，我们必须查看libc)。</p><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="19c1" class="na ls iq mw b gy nb nc l nd ne">ROPgadget.py --binary &lt;path-to-libc&gt;  | grep "pop rdx ; ret"</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/e268cbf3f6838ab9402387037f8b5194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gK2IzPDNV2tX2GsREZ9rw.png"/></div></div></figure><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="fa7d" class="na ls iq mw b gy nb nc l nd ne"><em class="kf">By invoking the mprotect() function we made the stack zone executable &amp; hence, we were able to infuse our shellcode. The rip pointed zone (shellcode) was then executed, and we got the shell.</em></span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/e5a6ebec65f9de8c9c0e1ca6946971ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xD8yXHyjVI9HW3bRRN6ngA.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">任务完成</figcaption></figure><p id="d10f" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated"><em class="kf">同样，我们可以通过其他技术弹出外壳</em>。<em class="kf"> NX给出了几个级别的保证，但不是几吨。这在某种程度上限制了攻击者处理初始问题的灵活性，但是考虑到他可以利用这个漏洞来执行shell，这就不太安全了。</em></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/05c18bbcb99221469e8b12299fb3951a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*D_ck3gzwgwurGDd7o4ygTQ.gif"/></div></figure><blockquote class="nx"><p id="d650" class="ny nz iq bd oa ob om on oo op oq ka dk translated">要吸取的教训:<br/> <strong class="ak"> NX不能“单枪匹马”地保护一个程序不被利用。</strong></p></blockquote><figure class="oh oi oj ok ol kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pf"><img src="../Images/1d01ab8b6b541a87ba5b7253673aac54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xt3TI7CIKmvAvCbP7QStYQ.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">- NX RIP -</figcaption></figure></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><h1 id="3ec7" class="lr ls iq bd lt lu pg lw lx ly ph ma mb mc pi me mf mg pj mi mj mk pk mm mn mo bi translated">一切都结束了吗？有什么安全的编译吗？</h1><blockquote class="ll lm ln"><p id="586d" class="kw kx kf jp b jq jr ky kz js jt la lb lo lc ld le lp lf lg lh lq li lj lk ka ij bi translated"><em class="iq">没有所谓的“</em> <strong class="jp ir"> <em class="iq">安全编译</em> </strong> <em class="iq">”有一些安全缓解措施，但根据漏洞的种类，您通常可以绕过它们。</em></p></blockquote><p id="6ee5" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">那都完成了吗？我们绕过所有的安全技术了吗？</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/3476804df998963f013a55629831db4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*4iWro5UFSLCE8BmJ7k9YLw.gif"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">好问题…</figcaption></figure><blockquote class="ll lm ln"><p id="1393" class="kw kx kf jp b jq jr ky kz js jt la lb lo lc ld le lp lf lg lh lq li lj lk ka ij bi translated">最简单的回答是:没有</p></blockquote><h1 id="b139" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">强大的ASLR</h1><p id="ec35" class="pw-post-body-paragraph kw kx iq jp b jq mp ky kz js mq la lb ju mr ld le jw ms lg lh jy mt lj lk ka ij bi translated"><strong class="jp ir">地址空间布局随机化(ASLR) </strong>是一种计算机安全技术，旨在防止利用内存损坏漏洞。ASLR随机编排进程关键数据范围的地址空间位置，包括可执行文件的基址和堆栈位置、加载和库，以阻止攻击者可靠地跳转。攻击者试图对NX启用的二进制文件执行return-to-libc攻击时，必须找到要执行的代码(就像我们之前绕过NX一样)。攻击者需要的位置是随机放置的，并且增加了安全性。如果攻击者不知道目标进程使用的地址，那么ROP、ret-to-libc和其他利用机制将会是疯狂的。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/07d0bb95246f44cc65b598b307440f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*sY1WNvRlc06L1nCAOyGOGg.png"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">ASLR概念</figcaption></figure><p id="5e5e" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated">ASLR在64位系统上工作得更好，因为这些系统提供了更大的熵(随机化潜力)。ASLR通过随机化它使用的内存布局的偏移量，使攻击者更难成功执行缓冲区溢出攻击，从而增强了系统的控制流完整性。注意“checksec”不会把你牵连到ASLR，因为保护是<em class="kf">机器</em>的属性，而不是<em class="kf">二进制</em>的属性。下面显示的命令将告诉您ASLR是否在您的系统上启用。</p><pre class="kh ki kj kk gt mv mw mx my aw mz bi"><span id="2d26" class="na ls iq mw b gy nb nc l nd ne">cat /proc/sys/kernel/randomize_va_space</span><span id="2fc6" class="na ls iq mw b gy nt nc l nd ne">Output</span><span id="a8f1" class="na ls iq mw b gy nt nc l nd ne">0 = Disabled<br/>1 = Conservative Randomization<br/>2 = Full Randomization</span></pre></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><blockquote class="nx"><p id="0c42" class="ny nz iq bd oa ob oc od oe of og ka dk translated"><strong class="ak">“所以我们接下来的任务是绕过NX+ASLR”</strong></p></blockquote><blockquote class="ll lm ln"><p id="27be" class="kw kx kf jp b jq pm ky kz js pn la lb lo po ld le lp pp lg lh lq pq lj lk ka ij bi translated">NX &amp; ASLR的浪漫创造了一个有影响力的债券内置保护。我们需要努力。一旦ASLR被绕过，使用面向返回的编程来利用NX通常是很简单的。</p></blockquote><blockquote class="nx"><p id="744f" class="ny nz iq bd oa ob om on oo op oq ka dk translated">我们能做到吗？我们如何打破它…？</p></blockquote><blockquote class="ll lm ln"><p id="49aa" class="kw kx kf jp b jq pm ky kz js pn la lb lo po ld le lp pp lg lh lq pq lj lk ka ij bi translated">这需要一种实用的招魂术</p></blockquote><p id="618a" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated"><em class="kf">我不想把它写得太长，花时间在你的头上，所以暂时，我现在就结束这个话题。你需要花些力气来弄清楚事情是如何运作的。我个人也厌恶填鸭式喂养。在接下来的文章中，我将演示如何做到这一点。在那之前，保持好奇。别忘了和我联系。</em></p><p id="fbdf" class="pw-post-body-paragraph kw kx iq jp b jq jr ky kz js jt la lb ju lc ld le jw lf lg lh jy li lj lk ka ij bi translated"><strong class="jp ir"> <em class="kf">我的推特</em>id:</strong><strong class="jp ir">@</strong><a class="ae nw" href="https://twitter.com/7h3h4ckv157" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">7h 3 H4 ckv 157</strong></a></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pr"><img src="../Images/1a2bf08846ca2778280bcddaa842594f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nj7Vsb4mxJEaF4hpFuX14Q.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">待续..！！</figcaption></figure></div></div>    
</body>
</html>