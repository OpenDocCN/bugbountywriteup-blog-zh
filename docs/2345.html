<html>
<head>
<title>Anti-Reversing Techniques (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">防逆转技术(一)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/anti-reversing-techniques-part-1-3200db42f1e3?source=collection_archive---------0-----------------------#2022-09-06">https://infosecwriteups.com/anti-reversing-techniques-part-1-3200db42f1e3?source=collection_archive---------0-----------------------#2022-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/84d357ac4f45705c15c4cc869f64a5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*wETJGR1u9MkZbwtPXXVRFw.png"/></div></figure><h2 id="5d75" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">介绍</h2><p id="d0ad" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">防逆转技术对于保护您的代码非常有用，特别是如果您的业务依赖于该代码，或者无论出于什么原因您可能必须保护它不被逆转或破解，但在其他情况下，恶意软件作者往往会使用防逆转技术来使分析恶意软件或逆转它的过程更加困难。本文中提到的技术并不是唯一使用的技术，它也可以从非常简单的调用Windows API到复杂的技术，如编写VM混淆器来隐藏代码流，在这一系列文章中，我们将重点关注Windows x86二进制文件。</p><p id="b1c3" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">让我们开始吧…</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="c1e0" class="lx jv iq bd jw ly lz ma jz mb mc md kc me mf mg kg mh mi mj kk mk ml mm ko mn bi translated">调试器检测</h1><p id="6145" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">恶意软件分析师和逆向工程师使用的主要工具之一是调试器，那么什么是调试器呢？</p><p id="affb" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">调试器是一种用于测试和控制其他软件的软件，换句话说，它让你看到正在发生的事情，比如在一个点上停止软件的执行，查看堆栈和寄存器等...。</p><p id="2dfb" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">恶意软件作者在恶意软件中倾向于做的是检测它是否在调试器下，最简单的反调试技术之一是:</p><h2 id="b01d" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak"> IsDebuggerPresent(): </strong></h2><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mo"><img src="../Images/eba329136899b1161c35927cc0b1bb89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7XiGsDs4aEmvsP2sD7ewg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><a class="ae nb" href="https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/windows/win32/API/debug API/nf-debug API-isdebuggerpresent</a></figcaption></figure><p id="29f8" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">从函数名来看，它显然是检查调用进程是否被调试，要使用这个函数，我们不需要任何参数:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/7edd11181c28fe13eacffb1a3fcc1908.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*oTzF0OHnOXuUWYcgDUMerA.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">密码</figcaption></figure><p id="bfff" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">如果我们在没有调试器的情况下运行可执行文件，它将继续显示消息“未检测到调试器”:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nd"><img src="../Images/a12f6fa8b280ebc4650070302a761e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qlfXBz6EjxryiE8Z7UXCag.png"/></div></div></figure><p id="0811" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">但是在调试器下，它将检测到它正在被调试，并继续执行ExitProcess()函数并终止——顺便说一下，不是任何调试检测都会导致软件终止，恶意软件作者可以改变工作流程来欺骗分析师:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/679f82e75dd7f65cea882c9d815140cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*rJv1oTkqn-bOP9UdqRYA1A.png"/></div></figure><p id="39ad" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">那么检测是怎么发生的！？要回答这个问题，我们首先需要了解什么是(TEB)和(PEB):</p><ul class=""><li id="7274" class="nf ng iq ks b kt ll kx lm kd nh kh ni kl nj lk nk nl nm nn bi translated"><strong class="ks ir">线程环境块(TEB): </strong>是一个数据结构，存储进程中当前运行线程的信息，每个线程都有自己的TEB结构，在Win32环境中<strong class="ks ir"> FS </strong>寄存器总是指向TEB，而在Win64环境中是<strong class="ks ir"> GS </strong>寄存器。</li><li id="989a" class="nf ng iq ks b kt no kx np kd nq kh nr kl ns lk nk nl nm nn bi translated"><strong class="ks ir">流程环境块(PEB):</strong>PEB是一个包含流程相关数据的结构，当查看<strong class="ks ir"> TEB </strong>时，我们会发现一个指向<strong class="ks ir"> PEB </strong>结构的指针。</li></ul><p id="3038" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">关于这个话题的更多信息，这篇博客文章值得一读:</p><p id="5e22" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated"><a class="ae nb" href="https://ntopcode.wordpress.com/2018/02/26/anatomy-of-the-process-environment-block-peb-windows-internals/" rel="noopener ugc nofollow" target="_blank">进程环境块剖析(PEB) (Windows内部)</a></p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nt"><img src="../Images/d27ff509e2e0df2f4a6f06c852c0f779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xp2Pz6b56pp-qi46bu0t3A.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><a class="ae nb" href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/windows/win32/API/winternl/ns-winternl-teb</a></figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nu"><img src="../Images/f9d25b8e7d66b116fd49250e256fb5a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZgUL8__55qwVhhOWi9JSQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><a class="ae nb" href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/windows/win32/API/winternl/ns-winternl-peb</a></figcaption></figure><p id="bb6d" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">从<strong class="ks ir"> PEB </strong>结构中我们可以看到，第二个字节是正在调试的<strong class="ks ir">成员</strong>，这是函数<strong class="ks ir"> IsDebuggerPresent </strong>检查的，以确定进程是否正在调试中。如果是，则值为1，否则为0。如果我们跟踪对函数<strong class="ks ir"> IsDebuggerPresent </strong>的调用，我们会发现:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nv"><img src="../Images/71a5610bab55278e243ce4c2ccb2c0f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8xFQQ4A71dk6eelkH5vVA.png"/></div></div></figure><ul class=""><li id="8b70" class="nf ng iq ks b kt ll kx lm kd nh kh ni kl nj lk nk nl nm nn bi translated">第1行:将<strong class="ks ir"> TEB </strong>结构的地址移动到<strong class="ks ir"> eax </strong>寄存器中。</li><li id="1abf" class="nf ng iq ks b kt no kx np kd nq kh nr kl ns lk nk nl nm nn bi translated">第二行:将<strong class="ks ir"> PEB </strong>结构的地址移动到<strong class="ks ir"> eax </strong>寄存器，即<strong class="ks ir"> TEB </strong>地址+ 30 = <strong class="ks ir"> PEB </strong>地址。</li><li id="1ce4" class="nf ng iq ks b kt no kx np kd nq kh nr kl ns lk nk nl nm nn bi translated">第3行:将正在调试的<strong class="ks ir">成员值移动到<strong class="ks ir"> eax </strong>寄存器。</strong></li><li id="9ef8" class="nf ng iq ks b kt no kx np kd nq kh nr kl ns lk nk nl nm nn bi translated">第4行:返回要测试的eax值。</li></ul><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/dae3ff165748dfc73709fc950b181858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*Io7w1-gz2a7bl9_3hX220Q.png"/></div></figure><p id="5576" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">测试完寄存器<strong class="ks ir"> eax </strong>后，根据结果，我们将进入<strong class="ks ir">退出进程</strong>或跳转并继续执行软件。现在，为了绕过这种反调试技术，我们在返回后将<strong class="ks ir"> eax </strong>寄存器的值从<strong class="ks ir"> 0x1 </strong>更改为<strong class="ks ir"> 0x0 </strong>，或者我们可以更改<strong class="ks ir"> PEB </strong>结构中被调试的<strong class="ks ir">成员的值，这是最好的方法， 我们可以转到<strong class="ks ir">内存映射</strong>并寻找<strong class="ks ir"> PEB </strong>的地址，即<strong class="ks ir"> 7EFDE000 </strong>并右键单击，然后<strong class="ks ir">跟随转储，</strong>或者在软件的入口点，您总是会发现<strong class="ks ir"> ebx </strong>寄存器指向<strong class="ks ir"> PEB </strong>结构，也<strong class="ks ir">跟随转储，</strong>之后我们右键单击值&gt;二进制</strong></p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nx"><img src="../Images/c0b64e5ba96caf1143019aeb249d04c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wKByoVfeeZSSHTJFOQEWhg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">x64dbg:跟随PEB转储</figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ny"><img src="../Images/0a0fbbb8c50306f1f0916320a36dc0f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*In_Io5t3pXEHgwReEGwHmA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">入口点的x64dbg: ebx寄存器</figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nz"><img src="../Images/2c8ff3e5800c9302dece535857b68717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ViHh8DUi7RuKY4nEEdyGMA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">x64dbg:编辑被调试成员的值</figcaption></figure><p id="8915" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">但是调用<strong class="ks ir"> IsDebuggerPresent </strong> API对于分析师来说是非常明显的，这就是为什么有时恶意软件作者会手动进行这种检查，例如:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oa"><img src="../Images/6b38c6b68da2195cfb4660d733d2082a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXxAbQnmiIDI37PJFX9d8w.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">密码</figcaption></figure><p id="dfda" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">在调试器下，我们的代码看起来像这样:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/ab35a70fea3ca69ab8d5d6cf8a8c8acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*eUBYEHwFOIjHJmqExLU6XQ.png"/></div></figure><p id="1e6f" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">这里也使用了相同的旁路技术。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h2 id="c8cf" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak"> NtGlobalFlag: </strong></h2><p id="6e08" class="pw-post-body-paragraph kq kr iq ks b kt ku kv kw kx ky kz la kd lb lc ld kh le lf lg kl lh li lj lk ij bi translated">在win32环境中，PEB结构在(偏移量x68)处有一个名为NtGlobalFlag的成员或字段，如果正在调试进程，则该进程将具有值<strong class="ks ir"> 0x70 </strong>和<strong class="ks ir"> 0x0 </strong>，否则将具有值【】0x0 。</p><p id="f6a9" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">要绕过这种反调试技术，您必须像过去的技术一样将值更改为<strong class="ks ir"> 0x0 </strong>:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oc"><img src="../Images/7d62bf5e7457b6711fe25c9d08acb0ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8rgSEni3qhBKol5jei9pA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">x64dbg:编辑NtGlobalFlag成员的值</figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/f5c1dcda3d929cb0d2c8afcb2b98c9c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*EpKK4dqb-X9RpOtsEM2vdA.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">检查NtGlobalFlag的实现</figcaption></figure><p id="f94d" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated"><strong class="ks ir">注意</strong>:当调试器附加到进程时，该成员的值不变</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h2 id="a5e0" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">checkremotebuggerpresent:</strong></h2><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oe"><img src="../Images/3f89233ca499cdecd80cd2a67fb8a0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IK9XPAwLlWrkDDEBkRevqA.png"/></div></div></figure><p id="8bce" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">该函数检查该进程是否正在被另一个进程调试，它有两个参数，如上图所示，重要的是它是<strong class="ks ir">ZwQueryInformationProcess</strong>的包装器:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nu"><img src="../Images/4871104f5cd79f6b312d153ebe4c667c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbcQuDdJzNBbnDdhxEg0aA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">一个许可证告诉<a class="ae nb" href="https://docs.microsoft.com/en-us/windows/win32/procthread/zwqueryinformationprocess" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/windows/win32/proc thread/zwqueryinformationprocess</a></figcaption></figure><p id="0e41" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">该函数将通过指定<strong class="ks ir"> ProcessDebugPort </strong>的第二个参数来检索关于进程是否在调试器下的信息:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi of"><img src="../Images/2cca636405997801f14f2908b54293b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UkGsiJ2wwEW3fVOuAIUylA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><a class="ae nb" href="https://docs.microsoft.com/en-us/windows/win32/procthread/zwqueryinformationprocess" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/windows/win32/proc thread/zwqueryinformationprocess</a></figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi og"><img src="../Images/3b84b850eb5cb569c575be92eb311d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bLUq0HhuJXxIANmMUjTbqg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">x64dbg:在CheckRemoteDebuggerPresent函数内部</figcaption></figure><p id="0f18" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">如上图所示，传递给<strong class="ks ir">ZwQueryInformationProcess</strong>的第二个参数是7，它将检索关于进程的信息，看它是否在调试器下。为了绕过该技术，我们需要<strong class="ks ir"> NOP </strong>上图中突出显示的两条指令，原因是<strong class="ks ir"> eax </strong>寄存器将被设置为1，指令<strong class="ks ir"> SETNE </strong> -如果零标志被清除，则将操作数中的字节设置为1，否则将操作数设置为0 -然后将<strong class="ks ir"> eax </strong>中的值移动到<strong class="ks ir"> ESI </strong>寄存器在从该例程返回后指向要比较的位置:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oh"><img src="../Images/91fe36034a40d7a56b87c44e56f25b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aks-rnp5ft0osGg0Ic6_ig.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">x64dbg:在CheckRemoteDebuggerPresent函数内部</figcaption></figure><p id="9f81" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">从例程返回后，我们看到值0与<strong class="ks ir"> ESP </strong>指向的位置之间的比较，在右下角出现了<strong class="ks ir"> NOP </strong>后的值，指令是<strong class="ks ir"> 0 </strong>，正常情况下是<strong class="ks ir"> 1，</strong>，所以在继续执行后，我们将得到消息“未检测到调试器”:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oi"><img src="../Images/3b726ddf4a6abf27953ebf03ea172d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YaCi5u14LL7TIL5O1vpmg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">x64dbg:比较从CheckRemoteDebuggerPresent返回后的结果</figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oj"><img src="../Images/fa12aea314417b7705c69c8a55b27f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPcYxtNnGCKhOJUHbIuGmw.png"/></div></div></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/0967c68ea2da32151fb0379dbb466984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*wPKz18lcQYkMSZ773nMOpw.png"/></div></figure></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="b139" class="pw-post-body-paragraph kq kr iq ks b kt ll kv kw kx lm kz la kd ln lc ld kh lo lf lg kl lp li lj lk ij bi translated">感谢您的阅读，并希望它是有益的，尽快看到你(第二部分)🙂。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h2 id="8481" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae nb" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4个线程、3个视频、2个Github Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>