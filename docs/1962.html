<html>
<head>
<title>The mystery of SQLMap’s --eval</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQLMap-eval的奥秘</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-mystery-of-sqlmaps-eval-f6c7bf43e1f?source=collection_archive---------4-----------------------#2022-03-22">https://infosecwriteups.com/the-mystery-of-sqlmaps-eval-f6c7bf43e1f?source=collection_archive---------4-----------------------#2022-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9724" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">掌握利用最复杂的SQL注入的能力</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/b40961126e2ded673c53dd17587bd390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*hmFmaZOYX5ERa2rQzH_pXQ.jpeg"/></div></figure><p id="6439" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时候你需要四种元素的力量来自动开发SQL注入。<br/>那是<code class="fe ku kv kw kx b">--eval</code>给你的，下面是如何接管这个权力。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="08a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据具体情况，您可能需要修改请求的不同部分。<br/> <code class="fe ku kv kw kx b">SQLMap</code>使用python的<code class="fe ku kv kw kx b">exec()</code>方法来执行你的脚本。该工具将请求的不同部分作为局部变量传递给该方法。这样，您可以访问和修改它们。</p><p id="466f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请求的post主体可以是不同的数据类型，比如JSON、XML等。为了提供对每种类型元素的访问，<code class="fe ku kv kw kx b">SQLMap</code>通过<a class="ae lf" href="https://github.com/sqlmapproject/sqlmap/blob/master/lib/core/settings.py#L835" rel="noopener ugc nofollow" target="_blank">这些正则表达式</a>来识别类型。然后询问您是否希望该工具处理数据:<br/> <code class="fe ku kv kw kx b">JSON/XML/... data found in POST/PUT/... body. Do you want to process it?</code> <br/>显然，如果您希望一切按预期运行，您需要回答是。</p><h1 id="1b41" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">访问请求的不同部分</h1><h2 id="ab34" class="me lh iq bd li mf mg dn lm mh mi dp lq jy mj mk lu kc ml mm ly kg mn mo mc mp bi translated">上呼吸道感染</h2><p id="2c97" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">没有查询字符串的请求的URI可以通过<code class="fe ku kv kw kx b">uri</code>参数访问。<br/>如果用户在URL的<em class="kt">路径</em>中指定了一个定制的注入点，那么<code class="fe ku kv kw kx b">uri</code>参数也将包含URL编码的注入负载。</p><p id="f6cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">举例:</strong> <br/> <em class="kt">命令:<br/> </em> <code class="fe ku kv kw kx b">sqlmap -u “http://example.com/path?id=123"</code> <br/> <em class="kt">局部变量:<br/> </em> <code class="fe ku kv kw kx b">uri --&gt; http://example.com/path</code></p><p id="c514" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kt">命令:<br/> </em> <code class="fe ku kv kw kx b">sqlmap -u “http://example.com/path*?id=123"</code> <br/> <em class="kt">局部变量:<br/> </em> <code class="fe ku kv kw kx b">uri --&gt; http://example.com/path&lt;URL-ENCODED PAYLOAD&gt;</code></p><h2 id="08b7" class="me lh iq bd li mf mg dn lm mh mi dp lq jy mj mk lu kc ml mm ly kg mn mo mc mp bi translated">获取查询</h2><p id="4b87" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">每个GET查询参数的值，加上注入的有效负载(如果有的话)，都可以通过带有原始GET参数名称的局部变量来访问。<br/> <strong class="jp ir">示例:</strong> <br/> <em class="kt">命令:<br/> </em> <code class="fe ku kv kw kx b">sqlmap -u "http://example.com/path?param1=123&amp;param2=456&amp;class.id=789"</code> <br/> <em class="kt">局部变量:</em><br/><code class="fe ku kv kw kx b">param1 --&gt; 123</code><br/><code class="fe ku kv kw kx b">param2 --&gt; 456</code><br/><code class="fe ku kv kw kx b">EVAL_636c6173732e6964 --&gt; 789</code>(阅读下面的注释)</p><p id="4282" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:</strong>如果参数名包含特殊字符或者是python中的保留关键字，在将变量传递给<code class="fe ku kv kw kx b">exec()</code>方法之前，<code class="fe ku kv kw kx b">SQLMap</code>根据以下模式更改其名称:<br/> <code class="fe ku kv kw kx b">EVAL_&lt;HEX OF ORIGINAL NAME&gt;</code> <br/>它适用于传递给<code class="fe ku kv kw kx b">exec()</code>方法的所有变量。<br/>包括cookies和POST数据。</p><h2 id="fe85" class="me lh iq bd li mf mg dn lm mh mi dp lq jy mj mk lu kc ml mm ly kg mn mo mc mp bi translated">饼干</h2><p id="5457" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated"><code class="fe ku kv kw kx b">Cookie</code>头的内容，加上注入的有效载荷(如果有的话)，可以通过<code class="fe ku kv kw kx b">cookie</code>变量访问。<br/> <em class="kt">命令:<br/> </em> <code class="fe ku kv kw kx b">sqlmap -u "http://example.com/path?id=123" --cookie=”C1=123; C2=456"</code> <br/> <em class="kt">局部变量:<br/> </em> <code class="fe ku kv kw kx b">cookie --&gt; C1=123; C2=456</code></p><h2 id="4d4c" class="me lh iq bd li mf mg dn lm mh mi dp lq jy mj mk lu kc ml mm ly kg mn mo mc mp bi translated">头球</h2><p id="598a" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">与请求头相关的<code class="fe ku kv kw kx b">exec()</code>方法中有两个字典:<br/> <code class="fe ku kv kw kx b">_locals['headers']</code> <br/> <code class="fe ku kv kw kx b">_locals['auxHeaders']</code> <br/>您可以通过<code class="fe ku kv kw kx b">headers</code>字典访问请求头，但是修改它不会影响请求。<br/>要修改最终请求的头，你需要<code class="fe ku kv kw kx b">update()</code>字典。<br/>默认情况下<code class="fe ku kv kw kx b">auxHeaders</code>的值为<code class="fe ku kv kw kx b">None</code>。这意味着您需要将所有的头——无论修改与否——添加到<code class="fe ku kv kw kx b">auxHeaders</code>字典中。<br/> <strong class="jp ir">示例:</strong> <br/>假设您想要修改<code class="fe ku kv kw kx b">User-Agent</code>头的值，并添加一个自定义认证头<code class="fe ku kv kw kx b">X-Auth</code>。<br/>这可以是代码:</p><pre class="km kn ko kp gt mv kx mw mx aw my bi"><span id="09f3" class="me lh iq kx b gy mz na l nb nc"># _locals['auxHeaders'] is None here<br/>_locals['headers']['User-Agent'] = "pentesting, no worries!!"<br/>_locals['headers']['X-Auth'] = "My_Secret_Token"<br/>_locals['auxHeaders'].update(_locals['headers'])</span></pre><h2 id="611f" class="me lh iq bd li mf mg dn lm mh mi dp lq jy mj mk lu kc ml mm ly kg mn mo mc mp bi translated">帖子正文</h2><p id="9aa4" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated"><code class="fe ku kv kw kx b">SQLMap</code>使用正则表达式识别六种类型的发布数据:</p><p id="b805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JSON <br/> JSON类(<a class="ae lf" href="https://github.com/sqlmapproject/sqlmap/blob/master/lib/core/settings.py#L842" rel="noopener ugc nofollow" target="_blank"> regex </a> ) <br/> XML <br/>多部分<br/>数组类(<a class="ae lf" href="https://github.com/sqlmapproject/sqlmap/blob/master/lib/core/settings.py#L848" rel="noopener ugc nofollow" target="_blank"> regex </a> ) <br/>基于表单</p><p id="f0ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要了解类似JSON和类似array的数据类型，请参考识别它们的正则表达式。</p><p id="72b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在写这篇文章的时候，<code class="fe ku kv kw kx b">SQLMap</code>只解析<code class="fe ku kv kw kx b">form-based</code>和<code class="fe ku kv kw kx b">json</code>数据类型。<br/>对于其他数据类型，你没有访问元素的值。</p><p id="31a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是您仍然可以通过声明一个与元素名称同名的变量来修改元素的值。<code class="fe ku kv kw kx b">SQLMap</code>使用<a class="ae lf" href="https://github.com/sqlmapproject/sqlmap/blob/master/lib/request/connect.py#L1399" rel="noopener ugc nofollow" target="_blank"> a regex </a>将原始值替换为新值。<br/>注意，这个实现有数据类型<code class="fe ku kv kw kx b">array-like</code>的问题，但是你可以在这里找到解决方案<a class="ae lf" href="https://github.com/sqlmapproject/sqlmap/pull/5013#issuecomment-1061416373" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="0e4d" class="me lh iq bd li mf mg dn lm mh mi dp lq jy mj mk lu kc ml mm ly kg mn mo mc mp bi translated">有效载荷</h2><p id="9d79" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated"><code class="fe ku kv kw kx b">SQLMap</code>注入到请求中的SQL负载可以通过<code class="fe ku kv kw kx b">_locals['payload']</code>变量访问。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="d1ac" class="me lh iq bd li mf mg dn lm mh mi dp lq jy mj mk lu kc ml mm ly kg mn mo mc mp bi translated">长脚本</h2><p id="6f9b" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">当你要执行的代码是几行时，可以在终端:<br/> <code class="fe ku kv kw kx b">sqlmap ... --eval="#first_line; #second_line; #third_line"</code>中添加脚本作为<code class="fe ku kv kw kx b">--eval</code>的值</p><p id="7ea1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果您的脚本较长，那么在终端中编写整个脚本并不是一个好主意。相反，您可以在一个<code class="fe ku kv kw kx b">.py</code>文件中编写您的代码，并将其作为一个模块导入:<br/> <code class="fe ku kv kw kx b">sqlmap ... --eval="import myModule; #use_functions_of_myModule"</code></p><h2 id="3787" class="me lh iq bd li mf mg dn lm mh mi dp lq jy mj mk lu kc ml mm ly kg mn mo mc mp bi translated">排除故障</h2><p id="6739" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">如果你想在<code class="fe ku kv kw kx b">SQLMap</code>内部调试你的代码或者想熟悉环境，你可以使用<code class="fe ku kv kw kx b">ipdp</code>模块。它给你一个调试外壳，你可以四处移动，看看发生了什么。<code class="fe ku kv kw kx b">locals()</code>方法可以是一个很好的起点。<br/> <code class="fe ku kv kw kx b">sqlmap ... --eval=”import ipdb; ipdb.set_trace()”</code></p><h2 id="0965" class="me lh iq bd li mf mg dn lm mh mi dp lq jy mj mk lu kc ml mm ly kg mn mo mc mp bi translated">新的实现</h2><p id="cc7e" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">如您所见，对于<code class="fe ku kv kw kx b">--eval</code>标志还有改进的空间。<br/>所以我重写了<code class="fe ku kv kw kx b">--eval</code>标志的<a class="ae lf" href="https://github.com/sqlmapproject/sqlmap/blob/master/lib/request/connect.py#L1274" rel="noopener ugc nofollow" target="_blank">代码</a>。在这个新的实现中，以统一的方式支持所有数据类型。另外，我将原始的<code class="fe ku kv kw kx b">GET</code> / <code class="fe ku kv kw kx b">POST</code>数据作为局部变量访问。因此，如果用户需要修改请求，而<em class="kt">已经本地存在的变量</em>没有用，他可以使用原始数据并以他需要的方式解析它。</p><p id="ee65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">文档:<br/> </strong>用户可以访问这些字典作为本地变量:</p><p id="f195" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ku kv kw kx b">headers</code>:所有的请求头。修改这个字典<em class="kt">将</em>影响请求。<br/> <code class="fe ku kv kw kx b">get_data</code>:已处理的获取查询数据<br/> <code class="fe ku kv kw kx b">post_data</code>:已处理的发文主体。无论数据类型是什么，用户都可以访问<strong class="jp ir">该数据类型的所有</strong>元素和属性。<br/> <code class="fe ku kv kw kx b">get_query</code>:原始获取查询数据<br/> <code class="fe ku kv kw kx b">post_body</code>:原始发文体数据</p><p id="0326" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong>:修改<code class="fe ku kv kw kx b">get_query</code>或<code class="fe ku kv kw kx b">post_body</code>会覆盖对<code class="fe ku kv kw kx b">get_data</code>和<code class="fe ku kv kw kx b">post_data</code>所做的相应更改。</p><p id="b676" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代号:</strong></p><pre class="km kn ko kp gt mv kx mw mx aw my bi"><span id="ec75" class="me lh iq kx b gy mz na l nb nc">if conf.evalCode:<br/>            delimiter = conf.paramDel or DEFAULT_GET_POST_DELIMITER<br/>            variables = {"uri": uri, "get_query": get, "headers": headers, "post_body": post, "get_data": {}, "post_data": {}, "lastPage": threadData.lastPage, "_locals": locals()}<br/>            original_get = get<br/>            original_post = post<br/>            if get:<br/>                for part in get.split(delimiter):<br/>                    if '=' in part:<br/>                        name, value = part.split('=', 1)<br/>                        name = name.strip()<br/>                        value = urldecode(value, convall=True)<br/>                        variables['get_data'][name] = value<br/>            if kb.postHint:<br/>                if kb.postHint in (POST_HINT.XML, POST_HINT.SOAP):<br/>                    variables['post_data'] = xmltodict.parse(post)<br/>                if kb.postHint == POST_HINT.JSON:<br/>                    variables['post_data'] = json.loads(post)<br/>                if kb.postHint == POST_HINT.JSON_LIKE:<br/>                    if json_like_type == 3:<br/>                        post = re.sub(r'(,|\{)\s*([^\'\s{,]+)\s*:', '\g&lt;1&gt;"\g&lt;2&gt;":', post)<br/>                    if json_like_type == 4:<br/>                        post = re.sub(r'(,|\{)\s*([^\'\s{,]+)\s*:', "\g&lt;1&gt;'\g&lt;2&gt;':", post)<br/>                    if json_like_type in (2, 4):<br/>                        post = post.replace("\\'", REPLACEMENT_MARKER).replace('\"','\\"').replace("'",'"').replace(REPLACEMENT_MARKER, "'")<br/>                    variables['post_data'] = json.loads(post)<br/>                if kb.postHint == POST_HINT.MULTIPART:<br/>                    multipart = MultipartDecoder(bytes(post, 'utf-8'), contentType)<br/>                    boundary = '--' + multipart.boundary.decode('utf-8')<br/>                    for part in multipart.parts:<br/>                        name = re.search(r'"([^\"]*)"', part.headers._store[b'content-disposition'][1].decode('utf-8')).group(1)<br/>                        value = part.text<br/>                        variables['post_data'][name] = value<br/>                if kb.postHint == POST_HINT.ARRAY_LIKE:<br/>                    post = re.sub(r"\A%s" % delimiter, "", post)<br/>                    array_name = re.findall(r"%s(.*?)\[\]=" % delimiter, post)[0].strip()<br/>                    variables['post_data'] = []<br/>                    for value in post.split("%s[]=" % array_name)[1:]:<br/>                        variables['post_data'].append(value.replace(delimiter, ""))<br/>            elif post:<br/>                for part in post.split(delimiter):<br/>                    if '=' in part:<br/>                        name, value = part.split('=', 1)<br/>                        name = name.strip()<br/>                        value = urldecode(value, convall=True, spaceplus=kb.postSpaceToPlus)<br/>                        variables['post_data'][name] = value</span><span id="13c5" class="me lh iq kx b gy nd na l nb nc">evaluateCode(conf.evalCode, variables)</span><span id="32c7" class="me lh iq kx b gy nd na l nb nc">if kb.postHint:<br/>                if kb.postHint in (POST_HINT.XML, POST_HINT.SOAP):<br/>                    post = xmltodict.unparse(variables['post_data'])<br/>                if kb.postHint == POST_HINT.JSON:<br/>                    post = json.dumps(variables['post_data'])<br/>                if kb.postHint == POST_HINT.JSON_LIKE:<br/>                    post = json.dumps(variables['post_data'])<br/>                    if json_like_type in (3, 4):<br/>                        post = re.sub(r'"([^"]+)":', '\g&lt;1&gt;:', post)<br/>                    if json_like_type in (2, 4):<br/>                        post = post.replace('\\"', REPLACEMENT_MARKER).replace("'", "\\'").replace('"', "'").replace(REPLACEMENT_MARKER, '"')<br/>                if kb.postHint == POST_HINT.MULTIPART:<br/>                    for name, value in variables['post_data'].items():<br/>                        post = re.sub(r"(?s)(name=\"%s\"(?:; ?filename=.+?)?\r\n\r\n).*?(%s)" % (name, boundary), r"\g&lt;1&gt;%s\r\n\g&lt;2&gt;" % value.replace('\\', r'\\'), post)<br/>                if kb.postHint == POST_HINT.ARRAY_LIKE:<br/>                    post = array_name + "[]=" + (delimiter + array_name + "[]=").join(variables['post_data'])<br/>            else:<br/>                post = delimiter.join(f'{key}={value}' for key, value in variables['post_data'].items())</span><span id="8688" class="me lh iq kx b gy nd na l nb nc">uri = variables['uri']<br/>            get = delimiter.join(f'{key}={value}' for key, value in variables['get_data'].items())<br/>            auxHeaders.update(variables['headers'])<br/>            cookie = variables['headers']['Cookie'] if 'Cookie' in variables['headers'] else None<br/>            get = variables['get_query'] if variables['get_query'] != original_get else get<br/>            post = variables['post_body'] if variables['post_body'] != original_post else post</span></pre><p id="fb90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要将这些库添加到<code class="fe ku kv kw kx b">thirdparty</code>文件夹:<br/><a class="ae lf" href="https://github.com/martinblech/xmltodict" rel="noopener ugc nofollow" target="_blank">xmltodict</a><br/><a class="ae lf" href="https://github.com/requests/toolbelt" rel="noopener ugc nofollow" target="_blank">requests _ toolblet</a></p><p id="276f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有关该实现的更多信息，请参考Github上的<a class="ae lf" href="https://github.com/sqlmapproject/sqlmap/pull/5013" rel="noopener ugc nofollow" target="_blank">拉请求</a>。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="86d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有帮助吗？ <br/>我不要求你给我买杯咖啡，<br/>教我点东西… <br/>不和:<code class="fe ku kv kw kx b"><strong class="jp ir">REND#9702</strong></code></p></div></div>    
</body>
</html>