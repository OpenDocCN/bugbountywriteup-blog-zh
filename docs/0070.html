<html>
<head>
<title>Haxing Minesweeper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哈星扫雷艇</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/haxing-minesweeper-e79ece9f5d16?source=collection_archive---------0-----------------------#2018-04-07">https://infosecwriteups.com/haxing-minesweeper-e79ece9f5d16?source=collection_archive---------0-----------------------#2018-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2615" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated">最近，我在推特上发布了一张我凭记忆看着雷区赢得扫雷游戏的截图。我贴这个没有任何原因，只是为了好玩，因为我很高兴我终于赢得了这场比赛。我曾经在2002年在Windows XP中玩这个游戏，但我从来没有赢过这个游戏，我甚至不知道这个游戏是如何工作的，直到今天我读到它是如何工作的😀</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="6ede" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在几分钟内，我的通知被淹没，我没想到会得到这么多喜欢。有人问我这方面的教程。我想就此写一篇简短的博文。如果我错过了什么，请原谅。</p><p id="82a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在发了那张截图之后，我看到了@DidierStevens的博客<a class="ae le" href="https://blog.didierstevens.com/2017/07/09/video-mimikatz-minesweeper/" rel="noopener ugc nofollow" target="_blank">的帖子</a>，他展示了一个来自@ gentilkiwi的关于用Mimikatz入侵扫雷的视频。在Mimkatz中包含这样的功能真是太棒了。让我们试着在XP中为扫雷编写一个简单的脏黑客。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/a404fe820843a9783af645efad0708e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*iXdwyZaOS93745Ea"/></div></figure><p id="4910" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Windows XP中你可以从<code class="fe li lj lk ll b">%systemroot%\system32\winmine.exe</code> <br/>找到二进制文件，如果你没有Windows XP，你仍然可以从<a class="ae le" href="http://www.minesweeper.info/downloads/WinmineXP.html" rel="noopener ugc nofollow" target="_blank">这里</a>下载原始的二进制文件。</p><p id="222f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们看看二进制文件是否启用了ASLR。DLL特征获得了0x8000的值，该值为“<em class="lm">IMAGE _ DLLCHARACTERISTICS _ TERMINAL _ SERVER _ AWARE</em>”。已经确认这个PE编译时没有ASLR保护。我们可以很容易地硬编码地址，如果我们正在为此编写一个黑客。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/7f03c6531dd76a0b549cf5b4437f5da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*4cTas5D3Z-GqXUxC"/></div></figure><p id="774d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看从'<em class="lm">gdi32.dll</em>'导入的函数，我们可以确定该程序使用的是微软视窗图形设备接口(GDI)。这是显而易见的，因为这是一个游戏😊我们还可以看到从'<em class="lm">advapi32.dll</em>'使用的注册表API，这意味着我们可以怀疑应用程序访问了注册表。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/4773fff3da837229ca15b57abe2ecc78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*tF8vBPMI2dJFLAiU"/></div></figure><p id="9e9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">分数存储在注册表中，值从注册表中读取。如果您检查所有导入并找到对'<em class="lm"> RegQueryValueExW </em> ' API的引用，并找到一个断点，您就可以找到注册表的位置。另一个简单的方法是挂钩API😊</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/5b40776d771d7f387e9feacafeee5919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/0*TmvacFGsDqYwDDF8"/></div></figure><p id="958c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">命中断点后，您可以看到堆栈上的参数，并且可以在注册表中打开该位置。</p><p id="0508" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe li lj lk ll b">HKEY_CURRENT_USER\software\Microsoft\winmine</code></p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lo"><img src="../Images/172574a49d6c84b39e7128b602726a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/0*qSlemWa0gdtgXLz7"/></div></div></figure><p id="4465" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以修改名称、分数和其他选项，如颜色、难度、高度、宽度等。“名称1”的值对应于十六进制的“时间1”的分数值。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/950b461ba5b070deb11f95ddd2153445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*AMHRyxCu0v5cklw9"/></div></figure><p id="a1a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们在'<a class="ae le" href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd183362(v=vs.85).aspx" rel="noopener ugc nofollow" target="_blank"><em class="lm">BeginPaint</em></a>' API上打一个断点。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/3507491267be9a73939accf2f4504b82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/0*zlR4WMKJwC6CCQ7N"/></div></figure><p id="6386" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们进入函数内部</p><p id="6efc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe li lj lk ll b">01001C4C |. E8 720E0000 CALL Winmine_.01002AC3</code></p><p id="4b79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后再次进入函数内部。</p><pre class="kx ky kz la gt lu ll lv lw aw lx bi"><span id="1e9a" class="ly lz it ll b gy ma mb l mc md">01002AE6 |. 56 PUSH ESI ; /Arg1<br/>01002AE7 |. E8 BBFBFFFF CALL Winmine_.010026A7 ; \Winmine_.010026A7</span></pre><p id="c1da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会看到'<a class="ae le" href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd183370(v=vs.85).aspx" rel="noopener ugc nofollow" target="_blank"><em class="lm">BitBlt</em></a><em class="lm"/>API用来一个一个的绘制方块。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/1bc814014b9b82b8ad90ce8ac643ea73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*nmJFRjctzg_ESJl_"/></div></figure><p id="e98c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们检查寄存器，EBX包含雷场0x010056360，ESI寄存器用于递增每个字节。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi me"><img src="../Images/05f78c9c56d6b4dd874e01dc3c05001a.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/0*M63g75czeOVAub4F"/></div></figure><p id="466d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们转储EBX寄存器，我们可以从0x01005340确定起始点。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/35568e4028cfa2328af65205b48329e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/0*TRVgK1669j51C3DY"/></div></figure><p id="659b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将0x20添加到EBX，我们可以确定每个字段的结尾。</p><p id="396d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe li lj lk ll b">0100271D |. 83C3 20 |ADD EBX,20</code></p><p id="d204" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们要打开游戏的流程。为此，我们将使用FindWindow并获得窗口的句柄，然后将其传递给'<em class="lm"> GetWindowThreadProcessId </em>'，一旦我们获得'<em class="lm"> dwProcessId </em>'我们就可以将该值传递给'<em class="lm"> OpenProcess </em> ' API。你也可以使用这里讨论的<a class="ae le" href="https://osandamalith.com/2016/05/28/parent-process-detection/" rel="noopener ugc nofollow" target="_blank">中的<em class="lm">createtoolhelp 32 snapshot</em>技术。</a></p><pre class="kx ky kz la gt lu ll lv lw aw lx bi"><span id="8108" class="ly lz it ll b gy ma mb l mc md">HWND window = FindWindow(NULL, L"Minesweeper");<br/>if (window == NULL)<br/>    return wprintf(L"[-] Failed to find Minesweeper process");<br/> <br/>GetWindowThreadProcessId(window, &amp;dwProcessId);<br/>HANDLE process = OpenProcess(PROCESS_VM_READ, FALSE, dwProcessId);</span></pre><p id="454f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将分配缓冲区来存储雷区数据。</p><pre class="kx ky kz la gt lu ll lv lw aw lx bi"><span id="80c4" class="ly lz it ll b gy ma mb l mc md">LPBYTE buffer = (LPBYTE)malloc(size);<br/>if (buffer == NULL)<br/>    return wprintf(L"[-] Failed to allocated memory");</span></pre><p id="0247" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们将编写一个无限循环，使用“ReadProcessMemory”API从内存的起始地址读取内存，这样每当我们单击一个字段时，这些字段都会得到更新。我们可以在字段中每行的末尾使用0x20。</p><pre class="kx ky kz la gt lu ll lv lw aw lx bi"><span id="5b5e" class="ly lz it ll b gy ma mb l mc md">while (true) {<br/>        BOOL ret = ReadProcessMemory(process, (LPVOID)start, buffer, size,<br/>            &amp;dwRead);<br/> <br/>        if (ret == NULL) return wprintf(L"[-] Failed to read memory");<br/> <br/>        for (size_t i = 0, j = 0; i &lt; size; i++, j++) {<br/>            if (j == 0x20) {<br/>                puts("");<br/>                j = 0;<br/>            }<br/>            printf("%c", buffer[i]);<br/>        }<br/>        Sleep(1500);<br/> <br/>        system("cls");<br/>    }</span></pre><p id="cb7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们只是使用'<em class="lm"> ReadProcessMemory </em> ' API从内存中转储了思维场😊</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/38fd9a50271a6b5b14b3d193318c5ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*Y7ALdPf8Za2hZLXz"/></div></figure><p id="92cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是完整的源代码。<br/><a class="ae le" href="https://github.com/OsandaMalith/GameHacking/blob/master/Minesweeper/Hack.c" rel="noopener ugc nofollow" target="_blank">https://github . com/OsandaMalith/game hacking/blob/master/mineesweeper/hack . c</a></p><pre class="kx ky kz la gt lu ll lv lw aw lx bi"><span id="d04e" class="ly lz it ll b gy ma mb l mc md">#include "stdafx.h"<br/> <br/>#include &lt;stdio.h&gt;<br/>#include &lt;tchar.h&gt;<br/>#include &lt;windows.h&gt;<br/> <br/>#define start 0x1005340<br/>#define end 0x10056A0<br/> <br/>int _tmain(int argc, _TCHAR* argv[]) {<br/>    DWORD dwProcessId = 0;<br/>    DWORD dwRead = 0;<br/>    HWND window = FindWindow(NULL, L"Minesweeper");<br/>    if (window == NULL)<br/>        return wprintf(L"[-] Failed to find Minesweeper process");<br/> <br/>    GetWindowThreadProcessId(window, &amp;dwProcessId);<br/>    HANDLE process =  OpenProcess(PROCESS_VM_READ, FALSE, dwProcessId);<br/> <br/>    DWORD size = end - start;<br/> <br/>    LPBYTE buffer = (LPBYTE)malloc(size);<br/>    if (buffer == NULL)<br/>        return wprintf(L"[-] Failed to allocated memory");<br/> <br/>    while (true) {<br/>        wprintf(L"[+] Minesweeper Dirty hack\n");<br/>        wprintf(L"[+] Author: <a class="ae le" href="http://twitter.com/OsandaMalith" rel="noopener ugc nofollow" target="_blank">@OsandaMalith</a>\n");<br/>        wprintf(L"[+] Website: <a class="ae le" href="https://osandamalith.com\n\n" rel="noopener ugc nofollow" target="_blank">https://osandamalith.com\n\n</a>");<br/> <br/>        BOOL ret = ReadProcessMemory(process, (LPVOID)start, buffer, size,<br/>            &amp;dwRead);<br/>        if (ret == NULL) return wprintf(L"[-] Failed to read memory");<br/>         <br/>        BYTE field = NULL;<br/> <br/> <br/>        for (size_t i = 0, j = 0; i &lt; size; i++, j++) {<br/>            if (j == 0x20) {<br/>                puts("");<br/>                j = 0;<br/>            }<br/>            printf("%c", buffer[i]);<br/>        }<br/>        Sleep(1500);<br/> <br/>        system("cls");<br/>    }<br/>    return 0;<br/>}</span></pre><p id="d689" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以修改字节值并打印出类似这样的内容，我将把这留给您😊</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/cec4b1053b976e8a638c0ace42d25bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/0*klsjbvzZwzMhfmQo"/></div></figure><p id="d7ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以检查我的朋友Ophir Harpaz已经很好地修补了她制作的程序，如果al == 0x8f是一个地雷，请将其更改为代码洞内的0x0E标志。<br/><a class="ae le" href="https://github.com/ophirharpaz/Patched-Minesweeper" rel="noopener ugc nofollow" target="_blank">https://github.com/ophirharpaz/Patched-Minesweeper</a></p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/ba4d7f0efcdff8045452d65ef9cf99f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/0*BfW3w3VA_MGJ8ciw"/></div></figure><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/4a53c5c6de2e0038cc3b3129752fd55a.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/0*LlSIHFIOKRTrHUtx"/></div></figure><p id="2ef8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这篇文章对你开始破解简单游戏有用😉</p><h1 id="99ac" class="mj lz it bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">翻译</h1><p id="80c0" class="pw-post-body-paragraph jq jr it js b jt ng jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj nk kl km kn im bi translated">хакинг扫雷舰—<a class="ae le" href="https://howtorecover.me/khaking-minesweeper" rel="noopener ugc nofollow" target="_blank">https://howtorecover.me/khaking-minesweeper</a></p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="lc ld l"/></div></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="bea8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lm">原载于2018年4月7日</em><a class="ae le" href="https://osandamalith.com/2018/04/07/haxing-minesweeper/" rel="noopener ugc nofollow" target="_blank"><em class="lm">http://osandamalith.com</em></a><em class="lm">。</em></p></div></div>    
</body>
</html>