<html>
<head>
<title>Linux Kernel Communication — Netfilter Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux内核通信— Netfilter钩子</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/linux-kernel-communication-part-1-netfilter-hooks-15c07a5a5c4e?source=collection_archive---------0-----------------------#2019-01-22">https://infosecwriteups.com/linux-kernel-communication-part-1-netfilter-hooks-15c07a5a5c4e?source=collection_archive---------0-----------------------#2019-01-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ede711a930d16503376938d73f72c25b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hl0U4B-FmbmwS-H0wuqlDQ.png"/></div></div></figure><p id="febf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我一直对事物如何工作很感兴趣，尤其是计算机如何工作。大约一年前，我发现自己在研究Linux内核，或者更准确地说，我发现自己在研究如何创建自己的可加载内核模块(LKM)，这样我就可以做任何事情(嗯，几乎任何事情)。</p><p id="b6ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想做的第一件事是构建一个LKM，它可以从外部获取任何命令，解析它，然后执行它。起初，我想到使用一个套接字作为监听器，在单个端口上，使用单个协议，这样它将成为我的通信工具；但是后来我想到了别的事情——为什么不监控进入机器的每个数据包呢？这样我就不需要担心为更多的端口或协议创建更多的套接字。</p><h1 id="1ceb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">内核</h1><p id="bad3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">内核是每个操作系统的中心。它包含所有的定义和指令，让机器知道如何管理它的资源。</p><p id="fc82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Linux机器的内存(RAM)分为两个空间，内核空间和用户空间。在Linux机器中，CPU有两种执行模式，内核模式和用户模式。用户模式是用户程序的非特权(即只能访问存储器的用户空间)模式，而内核模式是用于任何内核目的的特权模式。当处于内核模式时，CPU认为内核知道自己在做什么，因此会执行每一条指令，而不会问任何问题。</p><p id="3044" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更多阅读请参见参考文献<a class="ae lz" href="http://www.linfo.org/kernel.html" rel="noopener ugc nofollow" target="_blank">【1】</a></p><h1 id="677f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Netfilter挂钩</h1><p id="92a2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">什么是网络过滤器？</p><p id="e7a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自netfilter项目文档:</p><blockquote class="ma mb mc"><p id="6e37" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">netfilter是一个用于数据包处理的框架，在普通的Berkeley套接字接口之外。它有四个部分。首先，每个协议都定义了“钩子”(IPv4定义了5个钩子)，它们是数据包遍历协议栈时定义明确的点。在每一个点上，协议都将使用数据包和挂钩号调用netfilter框架。</p></blockquote><p id="73b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，netfilter是一个工具，它赋予你使用回调来解析、改变或使用数据包的能力。</p><p id="fd11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Netfilter提供了一种叫做netfilter hooks的东西，这是一种使用回调在内核中过滤数据包的方法。有5种不同的netfilter挂钩:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="54a6" class="mq kx iq mm b gy mr ms l mt mu">A Packet Traversing the Netfilter System:</span><span id="22c2" class="mq kx iq mm b gy mv ms l mt mu">   ---&gt;[1]---&gt;[ROUTE]---&gt;[3]---&gt;[4]---&gt;<br/>                 |            ^<br/>                 |            |<br/>                 |         [ROUTE]<br/>                 v            |<br/>                [2]          [5]<br/>                 |            ^<br/>                 |            |<br/>                 v            |</span></pre><ol class=""><li id="fa92" class="mw mx iq ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated">NF _ IP _ PER _ routing—当一个包到达机器时调用这个钩子。</li><li id="af45" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">NF_IP_LOCAL_IN —当一个包的目的地是机器本身时，这个钩子被调用。</li><li id="6667" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">NF_IP_FORWARD —当数据包发往另一个接口时，会调用此挂钩。</li><li id="265d" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">NF_IP_POST_ROUTING —当一个包在返回网络和机器外部的途中时调用。</li><li id="9e35" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated">NF_IP_LOCAL_OUT —当一个数据包在本地创建并被发送出去时，这个钩子被调用。</li></ol><h1 id="2275" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">在内核中使用Netfilter钩子</h1><p id="f11d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">要在内核中使用netfilter钩子，您需要创建一个钩子函数，并使用接收struct <code class="fe nk nl nm mm b">nf_hooks_ops*</code>的<code class="fe nk nl nm mm b">nf_register_hook</code>或接收<code class="fe nk nl nm mm b">struct net*</code>和<code class="fe nk nl nm mm b">struct nf_hooks_ops</code>的<code class="fe nk nl nm mm b">nf_register_net_hook</code>来注册它。您需要根据内核版本选择函数。该<code class="fe nk nl nm mm b">struct</code>包含以下字段:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="716e" class="mq kx iq mm b gy mr ms l mt mu">struct <strong class="mm ir">nf_hook_ops</strong> {<br/>	<em class="md">/* User fills in from here down. */</em><br/>	nf_hookfn		*hook;<br/>	struct net_device	*dev;<br/>	void			*priv;<br/>	u_int8_t		pf;<br/>	unsigned int		hooknum;<br/>	<em class="md">/* Hooks are ordered in ascending priority. */</em><br/>	int			priority;<br/>};</span></pre><ul class=""><li id="a6e1" class="mw mx iq ka b kb kc kf kg kj my kn mz kr na kv nn nc nd ne bi translated">钩子——一个指向函数的指针，一旦钩子被触发，这个函数就会被调用。这个函数来自类型<code class="fe nk nl nm mm b">nf_hookfn</code>，它在不同版本的内核中有不同的签名。我建议您根据您工作的内核版本来搜索正确的签名(参见参考文献[2])。确保这个函数返回<code class="fe nk nl nm mm b">NF_DROP</code>(丢弃包)<code class="fe nk nl nm mm b">NF_ACCEPT</code>(让包继续它的旅程)或<code class="fe nk nl nm mm b">NF_QUEUE</code>(如果你想将包排队到用户空间处理)。</li><li id="a555" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nn nc nd ne bi translated">hook num——钩子标识符之一(例如<code class="fe nk nl nm mm b">NF_IP_POST_ROUTING</code>)。</li><li id="a963" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nn nc nd ne bi translated">pf —协议族标识符(例如，IPv4的<code class="fe nk nl nm mm b">PF_INET</code>)。</li><li id="0c3f" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nn nc nd ne bi translated">优先级—挂钩的优先级(如果系统中注册了其他挂钩)。该优先级可以是enum <code class="fe nk nl nm mm b">nf_ip_hook_priorities</code>中定义的优先级之一，enum<code class="fe nk nl nm mm b">nf_ip_hook_priorities</code>在<code class="fe nk nl nm mm b">netfilter_ipv4.h</code>文件中定义(如<code class="fe nk nl nm mm b">NF_IP_PRI_FIRST</code>、<code class="fe nk nl nm mm b">NF_IP_PRI_RAW</code>)。</li><li id="4870" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nn nc nd ne bi translated">现在，您可以忽略<code class="fe nk nl nm mm b">*dev</code>和<code class="fe nk nl nm mm b">*priv</code>字段。<br/>只是为了好玩，我直接从Linux内核源代码文档中添加一段引文—<br/>“<em class="md">struct net _ DEVICE—设备结构。</em> <br/> <em class="md">其实，这整个结构是一个很大的错误。它将I/O </em> <br/> <em class="md">数据与严格意义上的“高级”数据混合在一起，它必须了解INET模块中使用的</em> <br/> <em class="md">几乎每一种数据结构。”</em></li></ul><h1 id="7a11" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">代码示例</h1><p id="bb59" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在本例中，我将向您展示一个简单的LKM，它丢弃任何UDP数据包(目的地为端口53 — DNS的UDP数据包除外)，并接受任何TCP数据包。任何其他数据包都将被丢弃。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="edb6" class="mq kx iq bd ky nq nr dn lc ns nt dp lg kj nu nv lk kn nw nx lo kr ny nz ls oa bi translated">代码概述</h2><ul class=""><li id="1fcb" class="mw mx iq ka b kb lu kf lv kj ob kn oc kr od kv nn nc nd ne bi translated">第21行—检查<code class="fe nk nl nm mm b">skb</code> ( <code class="fe nk nl nm mm b">sk_buf</code> —套接字缓冲区)是否为空，如果是，则让该数据包继续其路由。</li><li id="7f17" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nn nc nd ne bi translated">第24行—提取IP协议报头，以便我们稍后可以使用它来获得有关数据包的更多详细信息。</li><li id="4223" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nn nc nd ne bi translated">第25行和第31行—使用我们之前提取的IP报头，并检查该数据包使用了哪种协议。</li><li id="0a82" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nn nc nd ne bi translated">第27行—检查UDP报头的端口。</li><li id="e9bb" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nn nc nd ne bi translated">第48行和第53行—注册和注销挂钩。</li></ul><h2 id="4e1d" class="mq kx iq bd ky nq nr dn lc ns nt dp lg kj nu nv lk kn nw nx lo kr ny nz ls oa bi translated">生成文件</h2><p id="a02a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">要编译一个LKM，你可以使用一个叫做<code class="fe nk nl nm mm b">Makefile</code>的东西，它是一个包含指令和设置的文件，这些指令和设置稍后会被<code class="fe nk nl nm mm b">bash</code>中的<code class="fe nk nl nm mm b">make</code>命令读取和执行。对于这段代码，我写了下面的<code class="fe nk nl nm mm b">Makefile</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9a85" class="mq kx iq mm b gy mr ms l mt mu">obj-m := LKM.o<br/>LKM-objs += simple_netfilter_LKM.o</span><span id="4a60" class="mq kx iq mm b gy mv ms l mt mu">all:<br/> make -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) modules<br/> rm -r -f *.mod.c .*.cmd *.symvers *.o</span><span id="1fdd" class="mq kx iq mm b gy mv ms l mt mu">clean:<br/> make -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) clean</span></pre><h2 id="94fb" class="mq kx iq bd ky nq nr dn lc ns nt dp lg kj nu nv lk kn nw nx lo kr ny nz ls oa bi translated">编译和测试</h2><p id="ee25" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">将LKM编译并插入<code class="fe nk nl nm mm b">bash</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8e65" class="mq kx iq mm b gy mr ms l mt mu"># make<br/># insmod LKM.ko</span></pre><p id="56f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和<code class="fe nk nl nm mm b">rmmod LKM</code>将其移除。</p><p id="a89c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我强烈推荐使用Wireshark或其他嗅探工具来查看模块如何影响你机器上的网络流量。</p><h1 id="a43c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">参考</h1><p id="fee4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="http://www.linfo.org/kernel.html" rel="noopener ugc nofollow" target="_blank">【1】</a>关于内核Linux信息工程<br/><a class="ae lz" href="https://elixir.bootlin.com/" rel="noopener ugc nofollow" target="_blank"/><strong class="ka ir"><em class="md">bootlin</em></strong>—内核源代码分版本<br/><a class="ae lz" href="http://www.tldp.org/LDP/lkmpg/2.6/html/" rel="noopener ugc nofollow" target="_blank"/>【Hello World】LKM教程<br/><a class="ae lz" href="http://www.tldp.org/LDP/lkmpg/2.6/html/x181.html" rel="noopener ugc nofollow" target="_blank">【4】</a>编译一个基本的LKM<br/><a class="ae lz" href="https://www.wireshark.org" rel="noopener ugc nofollow" target="_blank"/>Wireshark官网</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/918a2b73782dd8dd1b6e6c9f9a8e3935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q-ZeOzSII3kZ1_SrkIpCDA.png"/></div></div></figure></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><p id="7557" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="md">关注</em> <a class="ae lz" href="https://medium.com/bugbountywriteup" rel="noopener"> <em class="md"> Infosec报道</em> </a> <em class="md">获取更多此类精彩报道。</em></p><div class="om on gp gr oo op"><a href="https://medium.com/bugbountywriteup" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd ir gy z fp ou fr fs ov fu fw ip bi translated">信息安全报道</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">收集了世界上最好的黑客的文章，主题从bug奖金和CTF到vulnhub…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd jw op"/></div></div></a></div></div></div>    
</body>
</html>