<html>
<head>
<title>Learn Rust Tryhackme Writeup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Rust Tryhackme的文章</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/learn-rust-tryhackme-writeup-55ab1e5be76c?source=collection_archive---------0-----------------------#2021-04-28">https://infosecwriteups.com/learn-rust-tryhackme-writeup-55ab1e5be76c?source=collection_archive---------0-----------------------#2021-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="333b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">这是Tryhackme room“学会生锈”的一篇文章</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/fbb2884a99fc011867199eb1367c5b4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*9LHzjTq2X7BwtiVOeZrt6Q.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">https://tryhackme.com/room/rust<a class="ae kr" href="https://tryhackme.com/room/rust" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="2120" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">房间链接:</strong><a class="ae kr" href="https://tryhackme.com/room/rust" rel="noopener ugc nofollow" target="_blank">https://tryhackme.com/room/rust</a><br/><strong class="ku ir">注:此房免费</strong></p><h1 id="e34b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">任务1:什么是铁锈？</h1><h1 id="ae2b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">介绍</h1><p id="4aaf" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">Rust是一种新的编程语言，由一个小团队在2015年创建，后来被Mozilla(创建和维护Firefox的组织)采用。</p><p id="5c43" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">它是一种编译的低级语言，旨在(并成功地)达到与C++相同的速度，但同时结合了一些更高级的语言特性，如Python或JavaScript。</p><p id="cbe5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Rust有3个目标:</p><ul class=""><li id="8e6f" class="ml mm iq ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">快的</li><li id="2141" class="ml mm iq ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">安全的</li><li id="6778" class="ml mm iq ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">多产的</li></ul><h1 id="8755" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">快的</h1><p id="3442" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">Rust的目标是在性能方面与C++相似。</p><p id="e8c9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Rust是静态类型的，这意味着变量的数据类型在编译时是已知的。与我们不知道类型的情况相比，这允许编译器进一步优化代码。</p><p id="d683" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Rust不使用垃圾收集(尽管它是一种低级编程语言)。垃圾收集是程序试图从垃圾中回收内存的地方。垃圾是程序不再使用的对象占用的内存。</p><p id="b7f4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Go是一种高级编程语言，语法上类似于Python，但速度更快&amp;编译时使用垃圾收集。这在Discord造成了巨大的开销，迫使他们从Go切换到Rust。<a class="ae kr" href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f" rel="noopener ugc nofollow" target="_blank">https://blog . discord . com/why-discord-is-switching-from-go-to-rust-a 190 bbca 2 B1 f</a></p><p id="81c6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">需要注意的是，Python和JavaScript使用垃圾收集。这些抽象可能会导致问题(如Discord的情况)，这就是为什么许多人选择低级编程语言。</p><h1 id="adf0" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">安全的</h1><p id="b1e1" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">Rust是完全内存安全的。这意味着Rust不可能利用内存漏洞，除非您明确指定不安全的Rust代码。</p><p id="8433" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">微软安全响应中心表示，CVE MSRC分配的任务中有70%是内存安全问题。用微软自己的话说:</p><p id="fa21" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">“这意味着，如果该软件是用Rust编写的，70%的安全问题很可能已经消除。我们不是唯一一家报告了这些发现的公司。</p><p id="bcb2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有时程序员必须执行不安全的操作。Rust提供了包装这些不安全动作的工具，因此Rust编译器可以静态地执行不安全的代码。</p><p id="91f0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">所有权的概念保证了内存的安全性。所有Rust代码都遵循以下规则:</p><ul class=""><li id="6572" class="ml mm iq ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">每个值都有一个变量，称为所有者。</li><li id="a1aa" class="ml mm iq ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">一次只能有一个所有者。</li><li id="e63f" class="ml mm iq ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">当所有者超出范围时，该值将被丢弃。</li></ul><p id="1b25" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">值可以在变量之间移动或借用，但任何值都不能有一个以上的所有者。</p><p id="dffc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们看一个Python失败的例子:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="acb2" class="ne lp iq na b gy nf ng l nh ni">squares = (val * val for val in range(100))<br/>print(min(squares))                 <br/>print(max(squares))</span></pre><p id="044e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们想要的是:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="1bdd" class="ne lp iq na b gy nf ng l nh ni">0<br/>9801</span></pre><p id="c531" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是我们得到的是:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="28cc" class="ne lp iq na b gy nf ng l nh ni">&gt;&gt;&gt; print(min(squares))<br/>0<br/>&gt;&gt;&gt; print(max(squares))<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>ValueError: max() arg is an empty sequence</span></pre><p id="4cf1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是因为min改变了变量squares。这很奇怪，因为我们只想要最小值——而不是改变整个变量！</p><p id="5b89" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在Rust中，相同的代码是:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="e1c0" class="ne lp iq na b gy nf ng l nh ni">fn main()<br/>   let squares = (0..100).map(|val| val * val); <br/>   println!("{:?}", squares.min());   <br/>   println!("{:?}", squares.max());      <br/>}</span></pre><p id="36e8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当我们试图编译它时，Rust告诉我们:</p><p id="8859" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我将在后面的任务中详细讨论这一点，但重要的是<strong class="ku ir"> Python允许函数改变它们不拥有的变量，而Rust不允许。</strong></p><p id="7143" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">PS:请注意Rust编译器是如何明确指出值、行、确切的字符、错误发生的位置以及解释为什么不允许该代码的完整错误消息的。而Python只是说。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="1059" class="ne lp iq na b gy nf ng l nh ni">max() arg is an empty sequence</span></pre><h1 id="dc79" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">生产力</h1><p id="75ed" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">Rust的第三大目标很奇怪。生产力！</p><p id="1635" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Rust提供了开发人员高效工作所需的所有工具，随平台本身一起提供。</p><p id="ba53" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><em class="nj">注:以下列表读作:</em></p><ul class=""><li id="18df" class="ml mm iq ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated"><em class="nj">工具</em></li></ul><p id="0c9e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><em class="nj">上述工具的说明。</em></p><p id="a974" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">其中包括:</p><ul class=""><li id="0f8c" class="ml mm iq ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">货物</li></ul><p id="97f7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">拉斯特版的NPM或派皮。下载其他人创建的包。</p><ul class=""><li id="15b9" class="ml mm iq ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">克利皮</li></ul><p id="0f5e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">微软Clippy，但重新设想了Rust来帮助开发。</p><ul class=""><li id="5533" class="ml mm iq ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">RustFmt</li></ul><p id="f89a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">自动格式化Rust代码</p><ul class=""><li id="0e6f" class="ml mm iq ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">货物测试</li></ul><p id="2d41" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Rust开发人员创建的内置测试应用程序。</p><ul class=""><li id="b35b" class="ml mm iq ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">货物单据</li></ul><p id="7214" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用文档注释(用Markdown编写)为您的代码自动生成文档。在发布到Cargo后，该文档将被发送到<a class="ae kr" href="http://docs.rs" rel="noopener ugc nofollow" target="_blank"> docs.rs </a>。更不用说用文档编写的例子是自动为你测试的。没有更多未经测试的文档示例！</p><ul class=""><li id="1b77" class="ml mm iq ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">铁锈分析仪</li></ul><p id="b6bd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">认为IDE更聪明。Rust Analyzer会清楚地标记您的代码有什么问题，为什么它是错误的，冲突和导致错误的确切字符，90%的情况下它会提供“自动修复”功能，自动为您修复这些错误。</p><ul class=""><li id="483d" class="ml mm iq ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">生锈的书和文件</li></ul><p id="709e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Rust有一本书，叫做《书》,里面详细介绍了你想知道的关于Rust的一切。整洁的章节，易于搜索，并在您的处置免费。如果这还不够好的话，感谢Rust的文档注释，你将使用的几乎每个库都有大量的在线文档。</p><p id="1448" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有了所有这些工具，编译一个Rust程序并在其中发现bug是非常罕见的。其实这种情况我只经历过一次。99%的情况下，工具和语言早在我点击compile之前就已经掌握了。</p><h1 id="784b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="6069" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">如果你正在寻找速度极快、内存安全，但同时保持良好的生产力的东西，Rust就是适合你的语言。</p><p id="f760" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">作为Pentesters，我们的工作是为开发者提供解决方案。一开始，告诉Python开发人员低级语言是一个很好的选择听起来很奇怪。</p><p id="61a8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是Rust可以帮你，因为它支持用其他语言编写的函数调用(外来函数接口)。</p><p id="21a4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以使用Rust来重写安全或性能关键代码，这些代码将与我们现有的代码库协作。</p><p id="dea9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里有一个调用C代码的例子</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="acdb" class="ne lp iq na b gy nf ng l nh ni">extern "C" {<br/>    fn abs(input: i32) -&gt; i32;<br/>}</span><span id="4b01" class="ne lp iq na b gy nk ng l nh ni">fn main() {<br/>    unsafe {<br/>        println!("C believes that the absolute value of -3 is: {}", abs(-3));<br/>    }<br/>}</span></pre><p id="5168" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题1: </strong>就性能而言，Rust与其他什么语言相似？</p><blockquote class="nl nm nn"><p id="b658" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:c++ </strong></p></blockquote><p id="227d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.2: </strong>这个任务中提到了什么著名的从Go转到Rust的公司？</p><blockquote class="nl nm nn"><p id="ec93" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:不和谐</strong></p></blockquote><p id="8cc6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题3: </strong>微软安全中心报告称，他们分配给CVE的内存安全问题占多大比例？包括%符号。</p><blockquote class="nl nm nn"><p id="769b" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:70% </strong></p></blockquote><p id="605e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题4:</strong>Rust版的NPM或PyPi是什么？</p><blockquote class="nl nm nn"><p id="64d0" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:货物</strong></p></blockquote><h1 id="95ef" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">任务2:安装和工具</h1><p id="d900" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">在我们深入语言之前，让我们安装Rust。</p><p id="8089" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Rust推荐使用工具<code class="fe nr ns nt na b">rustup</code>来管理Rust的多个版本。如果您熟悉Python，您可能已经使用virtualenvs实现了类似的结果。也就是同一台机器上不同版本的Python。</p><p id="2036" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是Rust团队为提高生产力而创造的另一个伟大的工具。</p><p id="dd73" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用以下命令安装RustUp:</p><p id="1f02" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></p><p id="84ba" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个命令也可以在Rust网站<a class="ae kr" href="https://www.rust-lang.org/tools/install" rel="noopener ugc nofollow" target="_blank">https://www.rust-lang.org/tools/install</a>上找到</p><p id="da91" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">此命令将为您的操作系统安装Rust的稳定版本。</p><p id="8ee8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">铁锈有三种味道。稳定版、测试版和夜间版。</p><p id="0802" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Stable是Rust的最新稳定版本(稳定版本通常每6周发布一次)。测试版定期更新。当语言本身更新时，每夜更新。</p><p id="a666" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在，让我们安装一些Rust工具来帮助我们的开发。</p><p id="16c5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们刚刚运行的命令也安装了<code class="fe nr ns nt na b">Cargo</code>，</p><p id="e7ac" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Cargo是Rust的包管理器。所有的软件包都被上传到<a class="ae kr" href="https://crates.io" rel="noopener ugc nofollow" target="_blank"> https://crates.io </a>并且做了很多很酷的事情。</p><p id="42aa" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">3个核心货物指令是:</p><p id="d0ae" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">货物安装</strong></p><p id="ac3a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">从<a class="ae kr" href="http://Crates.io" rel="noopener ugc nofollow" target="_blank">板条箱中安装一个包装</a></p><p id="4454" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">货物发布</strong></p><p id="8b2c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">发布一个包到<a class="ae kr" href="http://crates.io" rel="noopener ugc nofollow" target="_blank"> crates.io </a></p><p id="585c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">货物更新</strong></p><p id="79d9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">更新所有本地包</p><p id="c0a0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是，因为我们正在开发RustCode，所以还有3个更重要的命令</p><p id="544a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">货物测试</strong></p><p id="3355" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为我们的代码运行测试</p><p id="e455" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">货物fmt </strong></p><p id="6454" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">运行格式化工具。这个工具自动格式化你的代码(应用参数<code class="fe nr ns nt na b">--all</code>来格式化所有代码)。类似Python的黑色但是内置。</p><p id="0ba5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">货物夹子</strong></p><p id="1dc0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">微软Clippy但生锈！Clippy将指出代码中的常见错误，并帮助您纠正它们。</p><p id="63b7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">社区工具</strong></p><p id="24a7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有一个工具，是一个基于社区的工具——它被视为Rust生态系统的绝对必要工具。</p><p id="9057" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">那个工具是铁锈分析仪。想象一个更智能、更先进的IDE。Rust-Analyzer将在您编写代码时分析您的代码，在您编译之前发现错误，并提供自动修复选项来自动修复错误。</p><p id="0212" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Rust-Analyzer声明他们最受支持的版本是VS Code，但是他们也可以在许多其他平台上使用。</p><p id="7955" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">值得注意的是，Rust的主要工具是由Rust开发者自己编写的。在像Python这样的语言中，我们可能会争论<code class="fe nr ns nt na b">setuptools</code>或<code class="fe nr ns nt na b">poetry</code>是否正确。或者说<code class="fe nr ns nt na b">pytest</code>是否比<code class="fe nr ns nt na b">unittest</code>好。争论该用什么工具是拖延症。Rust说“这些是你要用的工具”就是这样。这提高了生产率，因为您不必担心使用什么工具，但可能会因为工具可能不完全完整而阻碍开发。</p><p id="b9b5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问1: </strong>我们用来装铁锈的工具叫什么？</p><blockquote class="nl nm nn"><p id="dcf1" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:Rustup </strong></p></blockquote><p id="952b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问2: </strong>我们如何使用cargo安装rustscan软件包？</p><blockquote class="nl nm nn"><p id="9822" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答:货物安装生锈扫描</strong></p></blockquote><p id="e186" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">问题3: 我们运行什么命令来格式化我们的代码？</p><blockquote class="nl nm nn"><p id="67e2" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答:货物fmt </strong></p></blockquote><h1 id="e9aa" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">任务三:你好，世界！</h1><p id="bb51" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">如果没有一个基本的“你好，世界！”就不是一个编程教程。</p><p id="629f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">创建一个新文件夹，并在终端中键入:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="1b23" class="ne lp iq na b gy nf ng l nh ni">cargo init</span></pre><p id="b144" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这使得货物初始化一个新的铁锈库。Cargo将为您处理大部分工作。</p><p id="0b66" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">文件结构如下:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="bbb5" class="ne lp iq na b gy nf ng l nh ni">- Cargo.toml<br/>- src/<br/>    - main.rs</span></pre><p id="117d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">cargo.toml</code>是我们Rust项目的配置文件。它包括我们的依赖项、项目名称、作者、我们正在使用的Rust版本等等。</p><p id="de8c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当我们刚刚运行<code class="fe nr ns nt na b">cargo init</code>时，我们的文件看起来会像这样:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="2df2" class="ne lp iq na b gy nf ng l nh ni">[package]<br/>name = "Hello_world"<br/>version = "0.1.0"<br/>authors = ["bee &lt;bee@fake.com&gt;"]<br/>edition = "2018"<br/># See more keys and their definitions at <a class="ae kr" href="https://doc.rust-lang.org/cargo/reference/manifest.html" rel="noopener ugc nofollow" target="_blank">https://doc.rust-lang.org/cargo/reference/manifest.html</a></span><span id="89d2" class="ne lp iq na b gy nk ng l nh ni">[dependencies]</span></pre><p id="0852" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">文件夹<code class="fe nr ns nt na b">src</code>中的<code class="fe nr ns nt na b">main.rs</code>文件是我们编写代码的主文件。每一个单独的Rust项目<strong class="ku ir">都必须</strong>有一个主文件，每一个主文件都必须有一个主函数。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="44f8" class="ne lp iq na b gy nf ng l nh ni">fn main() {<br/>    println!("Hello, world!");<br/>}</span></pre><p id="76aa" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">趣事</strong>原C本《你好，世界！在单词world上有一个大写字母。</p><p id="ad0b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在Rust中，我们用花括号来表示代码块。和分号来表示表达式的结束。</p><p id="6844" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了打印Rust，我们使用宏<code class="fe nr ns nt na b">println!</code>。</p><p id="b0c2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们知道<code class="fe nr ns nt na b">println</code>是一个宏，因为它被称为感叹号。简而言之，宏允许我们编写更多的代码。更简单地说，我们可以创建自己语法来翻译不同的代码。</p><p id="c517" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了运行这个程序，我们执行:</p><p id="2683" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">cargo run</code></p><p id="3aa7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这将导致:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="366b" class="ne lp iq na b gy nf ng l nh ni">➜ cargo run <br/>   Compiling hello_world v0.1.0 (/tmp/hello_world)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.21s<br/>     Running `target/debug/hello_world`<br/>Hello, world!</span></pre><p id="8fc1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">该命令:</p><ul class=""><li id="fdbb" class="ml mm iq ku b kv kw ky kz lb mn lf mo lj mp ln mq mr ms mt bi translated">用未优化的版本编译代码(以提高编译速度)</li><li id="dd31" class="ml mm iq ku b kv mu ky mv lb mw lf mx lj my ln mq mr ms mt bi translated">运行代码</li></ul><p id="8d76" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您还会注意到已经创建了一个新文件夹，<code class="fe nr ns nt na b">target</code>。</p><p id="d516" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">target</code>包含我们项目的二进制文件。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="31b1" class="ne lp iq na b gy nf ng l nh ni">- Cargo.toml<br/>- src/<br/>    - main.rs<br/>- target/<br/>    - debug/<br/>        = build/<br/>        - deps/<br/>        - examples/<br/>        - hello_world<br/>        - hello_world.d<br/>        - incremental/</span></pre><p id="8edc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">目前，唯一重要的文件是<code class="fe nr ns nt na b">hello_world</code></p><p id="17cd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个文件实际上是我们程序的二进制文件。</p><p id="415b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以通过在目录中运行ls -l来判断它是一个二进制文件</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="3fc8" class="ne lp iq na b gy nf ng l nh ni">drwxr-xr-x    - bee 31 Jul 23:35 build<br/>drwxr-xr-x    - bee 31 Jul 23:35 deps<br/>drwxr-xr-x    - bee 31 Jul 23:35 examples<br/>.rwxr-xr-x 2.9M bee 31 Jul 23:35 hello_world<br/>.rw-r--r--   72 bee 31 Jul 23:35 hello_world.d<br/>drwxr-xr-x    - bee 31 Jul 23:35 incremental</span></pre><p id="a173" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">要构建我们的项目而不运行它，请运行:</p><p id="47f9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">cargo build</code></p><p id="905d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在我们可以直接运行二进制代码了。</p><p id="8aab" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">./target/debug/hello_world</code></p><p id="9869" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这和<code class="fe nr ns nt na b">cargo run</code>完全一样，但是2个命令。</p><p id="0b82" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当我们想要构建我们的项目并优化它时，用发布概要文件运行它:</p><p id="e1a3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">cargo build --release</code></p><p id="ca70" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用普通货舱快速检查代码。使用release参数在Rust编译器允许的范围内最大限度地优化代码。</p><p id="2409" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们称<code class="fe nr ns nt na b">--release</code>为概要文件，特别是发布概要文件。Rust编译器根据你的需要有不同的优化级别。</p><p id="23d4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题1: </strong>我们如何初始化一个新的Rust项目？</p><blockquote class="nl nm nn"><p id="9e44" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">回答:货物初始化</strong></p></blockquote><p id="eade" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.2: </strong>什么字符代表一个宏？</p><blockquote class="nl nm nn"><p id="9788" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">回答:！</strong></p></blockquote><p id="8368" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.3: </strong>每个Rust项目需要什么作为文件？</p><blockquote class="nl nm nn"><p id="3468" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:main.rs </strong></p></blockquote><p id="164f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们想给Rust项目添加一个依赖项，我们应该编辑什么文件？</p><blockquote class="nl nm nn"><p id="26e4" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:cargo.toml </strong></p></blockquote><p id="3744" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">问题5: 我们如何运行Rust项目？</p><blockquote class="nl nm nn"><p id="9777" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答:货物运行</strong></p></blockquote><p id="3c24" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题6: </strong>我们如何用发布概要文件构建RustScan项目(优化程度最高)？</p><blockquote class="nl nm nn"><p id="acec" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答:货物构建-发布</strong></p></blockquote><p id="a8b6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问7: </strong>发布二进制文件存储在什么文件夹下？</p><blockquote class="nl nm nn"><p id="c10d" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">回答:目标/发布</strong></p></blockquote><p id="a568" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题8: </strong>使用优化级别，Rust有多少个发布配置文件？</p><blockquote class="nl nm nn"><p id="81e1" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:4 </strong></p></blockquote><h1 id="7875" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">任务4:变量</h1><p id="718d" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">默认情况下，Rust中的所有变量都是不可变的。</p><p id="5c03" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是一个安全特性，也是一个生产力特性。不变的变量意味着您不必跟踪值何时改变，不变的变量对于并发性来说非常好</p><p id="39b6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们来看看实际情况。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="5628" class="ne lp iq na b gy nf ng l nh ni">fn main() {<br/>     let x = 5;<br/>     println!("The value of x is: {}", x);<br/>     x = 1;<br/>     println!("The value of x is: {}", x);<br/> }</span></pre><p id="55ec" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这段代码不编译**。**它返回错误:</p><p id="bb52" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">error[E0384]: cannot assign twice to immutable variable </code>x`<br/>-&gt;src/main . RS:4:5<br/>|<br/>2 |设x = 5；<br/> | - <br/> | | <br/> |对` x` <br/>的第一次赋值| help:使这个绑定可变:` mut x` <br/> 3 | println！(“x的值为:{}”，x)；<br/>4 | x = 1；<br/> | ^^^^^不能对不可变变量赋值两次</p><p id="192c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">错误告诉了我们需要知道的一切。</p><p id="8531" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">cannot assign twice to immutable variable</code></p><p id="158a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是在告诉我们，我们在给一个不可变的变量(一个不能改变的变量)赋值，两次。这是不可能的。</p><p id="c6ce" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们得到编译时错误是很重要的，因为这可能导致错误和未定义的行为——这可能导致不安全的代码。在Rust中，一旦一个不可变的变量被设置，Rust保证它在它的生命周期中永远不会改变。</p><p id="3d5b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了使变量可变，我们将mut关键字放在它的前面，如下所示:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="b295" class="ne lp iq na b gy nf ng l nh ni">fn main() {     let mut x = 9;     println!("The value of x is:  {}", x);     let x = 4;     println!("The value of x is: {}", x); }</span></pre><p id="caaa" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这段代码可以正确编译和运行:</p><p id="e5cb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">➜ cargo run </code> <br/>编译hello _ world v 0 . 1 . 0(/tmp/hello _ world)<br/>在0.14秒内完成dev [unoptimized + debuginfo]目标<br/>运行` target/debug/hello _ world`<br/>x的值为:9<br/>x的值为:4</p><p id="e5d4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">无法更改变量值可能会让您想起其他大多数语言都有的另一个编程概念:常量。像不可变变量一样，常量是绑定到名称上的值，不允许更改，但是常量和变量之间有一些不同。</p><p id="a03c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有关任务，请参考该代码。</p><p id="78f3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题1 </strong></p><p id="afb4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">fn main() {</code> <br/>设x:u32 = 5；<br/> println！(“x的值为:{}”，x)；<br/> x = "你好"；<br/> println！(“x的值为:{}”，x)；<br/> }</p><p id="4a3e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题2 </strong></p><p id="545c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">fn main() {</code> <br/>设x:u32 = 5；<br/> println！(“x的值为:{}”，x)；<br/>x = 5；<br/> println！(“x的值为:{}”，x)；<br/> }</p><p id="941a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.1: </strong>问题1，这段代码编译了吗？t(真)或F(假)</p><blockquote class="nl nm nn"><p id="d3ed" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:F </strong></p></blockquote><p id="9839" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问2: </strong>问题1返回的错误码是什么？</p><blockquote class="nl nm nn"><p id="2310" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:E0308 </strong></p></blockquote><p id="7944" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题3: </strong>问题2中的代码编译了吗？t(真)或F(假)</p><blockquote class="nl nm nn"><p id="f76f" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:F </strong></p></blockquote><p id="a480" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问4: </strong>返回的错误<strong class="ku ir">消息</strong>是什么？</p><blockquote class="nl nm nn"><p id="1c75" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答:不能给不可变变量赋值两次</strong></p></blockquote><h1 id="5560" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">任务5:常量变量</h1><p id="1216" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">铁锈也有常数。这些值不仅在默认情况下是不可变的，而且永远是不可变的。</p><p id="795a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">常量可以在任何范围内声明，包括全局范围。这意味着我们可以在代码的任何部分使用它们的值，或者同时在多个地方使用它们的值。</p><p id="44d2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">常量只能是常量，不能设置为函数调用或任何其他在运行时可能改变的值。</p><p id="58b9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们用关键字<code class="fe nr ns nt na b">const</code>声明常量，如下所示:</p><p id="215d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">const HUNDRED_THOUSAND: u32 = 100_000;</code></p><p id="a23c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">注意在Rust中，我们如何使用<code class="fe nr ns nt na b">_</code>字符来表示数字中的一个空格，而不影响值本身。这纯粹是为了可读性。</p><p id="6ea7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">还要注意，用全大写字母命名常量是一种传统。</p><p id="4535" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">遮蔽</strong></p><p id="4d5b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我要给你看一些一开始可能没有意义的东西。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="a478" class="ne lp iq na b gy nf ng l nh ni">fn main(){<br/>    let x = 6;<br/>    let x = x + 1;<br/>    println!("{}", x)<br/>}</span></pre><p id="5ecd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这叫做<em class="nj">遮蔽</em>。Rustaceans (Rust程序员)说:</p><p id="38b9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><em class="nj">“第一个变量被第二个变量遮蔽”</em></p><p id="703f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这意味着第二个变量值在使用时出现。一旦定义了不可变变量，我们就可以改变它的类型。</p><p id="2785" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下面是官方Rust文档对这一原理的解释(根据示例进行了编辑)</p><p id="b346" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">“这个程序首先将x绑定到值6。然后它通过重复let x =来隐藏x，取原始值并加1，这样x的值就是7。</p><p id="5c6d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过使用let，我们可以对变量执行转换，但在所有转换完成后，变量仍然是不可变的。</p><p id="c318" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们用关键字<code class="fe nr ns nt na b">let</code>有效地创建了一个新变量，这意味着我们可以改变值的类型。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="f193" class="ne lp iq na b gy nf ng l nh ni">let word = "hello";<br/>let word = word.len();</span></pre><p id="4b27" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是允许的。</p><p id="8ebc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然而，如果我们试图使用mut，它将不会被允许——因为mut不能改变类型。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="d3d3" class="ne lp iq na b gy nf ng l nh ni">let mut word = "hello";<br/>word = word.len();</span></pre><p id="a5ae" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi">.</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="9c49" class="ne lp iq na b gy nf ng l nh ni">error[E0308]: mismatched types<br/> --&gt; src/main.rs:3:12<br/>  |<br/>3 |     word = word.len();<br/>  |            ^^^^^^^^^^ expected `&amp;str`, found `usize`</span></pre><p id="9c4f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问1: </strong>我们如何在Rust中定义一个常数？</p><blockquote class="nl nm nn"><p id="5c4a" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:常量</strong></p></blockquote><p id="9611" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.2: </strong>我们可以对一个常数进行阴影化吗？t(真)或F(假)</p><blockquote class="nl nm nn"><p id="5f90" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:F </strong></p></blockquote><p id="7b9a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问3: </strong>一旦定义了不可变变量，我们用什么来改变它的类型？</p><blockquote class="nl nm nn"><p id="6cb1" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:阴影化</strong></p></blockquote><p id="c530" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问4: </strong>代码“CONST word = "yes " "会编译吗？t(真)或F(假)</p><blockquote class="nl nm nn"><p id="e22d" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:F </strong></p></blockquote><p id="7514" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.5: </strong>我们有“let word = "hello " "，如何获取变量的长度？</p><blockquote class="nl nm nn"><p id="469f" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:word.len() </strong></p></blockquote><h1 id="7f17" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">任务6:数据结构</h1><p id="40d9" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">在Rust中，我们经常会看到编译器抱怨我们的变量和函数没有类型提示。我们前面看到了CONST的类型提示。类型提示定义了变量在编译时的数据类型。</p><p id="6735" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">let ports: u32 = 65535</code></p><p id="494d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">: u32</code>表示变量<code class="fe nr ns nt na b">ports</code>的大小为<code class="fe nr ns nt na b">u32</code>。</p><p id="b5ec" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">整数中的<code class="fe nr ns nt na b">u</code>表示无符号，<code class="fe nr ns nt na b">32</code>是它有多少位。</p><p id="9c11" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">无符号整数只能是正数，有符号整数可以是正数也可以是负数。</p><p id="0f8d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">整数的范围从16位到128位。有些操作系统不能使用高于u32的整数，使用如此大的整数类型可能会降低某些系统上的程序速度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nu"><img src="../Images/f7b7baeb278b79490dfc817907ba26d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*63F1khwVAVx2V8BMn-N_Fw.png"/></div></div></figure><p id="29e6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当您探索Rust时，您会遇到许多不同的数据类型。对我来说，试图教他们所有人是愚蠢的，所以我选择只教我认为现在能帮助你理解Rust的东西。</p><p id="8bea" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们已经看到了整数是如何工作的，但是字符串呢？</p><h1 id="85fc" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">用线串</h1><p id="48d6" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">锈中有两种类型的弦。<code class="fe nr ns nt na b">String</code>和<code class="fe nr ns nt na b">&amp;str</code>。</p><p id="2de9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">String</code>是一个可增长的分配数据结构，而<code class="fe nr ns nt na b">str</code>是内存中某处不可变的固定长度字符串。</p><p id="f41d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">&amp;str</code>是<code class="fe nr ns nt na b">string.</code>的一个<code class="fe nr ns nt na b">string slice</code></p><p id="49a1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">弦乐对于Rust新手来说比较混乱，但这些是核心原理。<a class="ae kr" href="https://doc.rust-lang.org/book/ch08-02-strings.html" rel="noopener ugc nofollow" target="_blank">这里列出了有关字符串的相关Rust book页面，以了解更多信息。</a></p><p id="3e78" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题1: </strong>给定数字-6，这是有符号的还是无符号的？</p><blockquote class="nl nm nn"><p id="5c8f" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">回答:署名</strong></p></blockquote><p id="8927" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题2: </strong>给定数字65536，我们能把它归入的最小无符号数据类型是什么？</p><blockquote class="nl nm nn"><p id="5f46" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:u32 </strong></p></blockquote><p id="705a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问3:</strong>rust中最小的有符号整数是多少？</p><blockquote class="nl nm nn"><p id="b259" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:i16 </strong></p></blockquote><p id="e864" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题4: </strong>创建一个名为“tryhackme”的可变u32变量，并给它分配数字9</p><blockquote class="nl nm nn"><p id="13e0" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">回答:让mut tryhackme:u32 = 9；</strong></p></blockquote><p id="679e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.5: </strong>字符串切片用什么数据类型表示？</p><blockquote class="nl nm nn"><p id="fe40" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">回答:&amp; str </strong></p></blockquote><p id="38d1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">问6: 假设你有一个变量x，你想把这个变量作为一个字符串输入。你会写什么？在变量中包括X，但不包括字母或=部分。</p><blockquote class="nl nm nn"><p id="1819" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:x: String </strong></p></blockquote><h1 id="f825" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">任务7:功能</h1><p id="d2c1" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">我们前面已经看到了一种特殊的函数，即<code class="fe nr ns nt na b">main</code>函数。</p><p id="934b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">main</code>函数是<code class="fe nr ns nt na b">main</code>文件第一个调用的函数，也是第一个调用的文件。</p><p id="b51b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Rust写的每个二进制文件都需要一个<code class="fe nr ns nt na b">main</code>文件，每个主文件都需要一个<code class="fe nr ns nt na b">main</code>函数。</p><p id="fc14" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Rust中的函数定义为:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="58bf" class="ne lp iq na b gy nf ng l nh ni">fn hello() -&gt; u16{<br/>    println!("hello!");<br/>    6<br/>}</span></pre><p id="7ff3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">主函数和这个一样，但是在二进制文件中它不返回任何东西。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="3b38" class="ne lp iq na b gy nf ng l nh ni">fn main(){<br/>    println!("I do not return!")<br/>}</span></pre><p id="23d5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在，你可能已经注意到在<code class="fe nr ns nt na b">hello</code>函数中，我们在末尾有一个6。</p><p id="1725" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><em class="nj">“什么？？?"我能听到你说。</em></p><p id="28d4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Rust返回函数的最终表达式。</p><p id="4fb7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">或者，我们可以使用<code class="fe nr ns nt na b">return</code>语句提前返回。然而，用它来返回函数末尾的值不是很好——Rustaceans和Clippy会不喜欢这样😢</p><p id="6975" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">6</code>是一个返回6的表达式，所以我们的<code class="fe nr ns nt na b">hello</code>函数返回6。</p><p id="7bd2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们的主函数不返回任何东西，这是应该的。</p><p id="be78" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们给函数添加一些参数。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="b0ec" class="ne lp iq na b gy nf ng l nh ni">fn print_name(name: String){<br/>    println!("{}", name);<br/>}</span></pre><p id="a1e1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们的函数参数必须包含每个参数的类型。</p><p id="354b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在让我们试着让这个函数返回一些东西。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="54a5" class="ne lp iq na b gy nf ng l nh ni">fn print_name(name: String) -&gt; u16{<br/>    println!("{}", name);<br/>    6;<br/>}</span></pre><p id="6df7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当我们返回数据时，我们必须输入返回数据的类型。</p><p id="e5f0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这看起来很烦人，但是它让编写干净的代码变得容易多了。</p><p id="26c2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">比较这两个函数，一个在Pythonic伪代码中，一个在Rust中。注意:我们只有定义。</p><p id="9b1b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">def to_ip_address(ip):</code></p><p id="8cc0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现已生锈:</p><p id="2733" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nr ns nt na b">fn to_ip_address(ip: String) -&gt; IpAddr{</code></p><p id="71b0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过添加类型，我们可以清楚地看到我们正在接受一个字符串，并将其转换为IP地址。</p><p id="b26d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过适当的函数命名和类型提示，我们可以从它们的定义中知道大多数函数是做什么的。干净的代码怎么样😜</p><p id="1500" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题1 </strong></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="a8dc" class="ne lp iq na b gy nf ng l nh ni">fn hello(){<br/>    8172192: u16;<br/>}</span></pre><p id="c7ee" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题2 </strong></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="7d46" class="ne lp iq na b gy nf ng l nh ni">fn return(){<br/>    6;<br/>}</span></pre><p id="3432" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题3 </strong></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="caa7" class="ne lp iq na b gy nf ng l nh ni">fn test(name) {<br/>    println!("{}", name);<br/>}<br/>test("bee");</span></pre><p id="ced5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问1: </strong>问题1会返回8172192吗？t(真)或F(假)</p><blockquote class="nl nm nn"><p id="54ca" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:F </strong></p></blockquote><p id="45f2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问2: </strong>例2会运行吗？t(真)或F(假)</p><blockquote class="nl nm nn"><p id="2b96" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:F </strong></p></blockquote><p id="d1c1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">问题3: 我们应该给问题3的论点什么类型？</p><blockquote class="nl nm nn"><p id="b054" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">回答:&amp; str </strong></p></blockquote><p id="fe27" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.4: </strong>函数中的最后一个表达式(返回)需要有分号。t(真)或F(假)</p><blockquote class="nl nm nn"><p id="27b2" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:F </strong></p></blockquote><p id="9be1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问5: </strong>每个函数都需要返回一些东西。t(真)或F(假)</p><blockquote class="nl nm nn"><p id="5965" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:F </strong></p></blockquote><p id="65fb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问6:</strong>Rust中的函数可以嵌套在其他函数中。t(真)或F(假)</p><blockquote class="nl nm nn"><p id="c613" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:T </strong></p></blockquote><p id="77ad" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.7: </strong>我们用什么关键字从函数中提前返回？</p><blockquote class="nl nm nn"><p id="2f6b" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">回答:返回</strong></p></blockquote><p id="d5b0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题8: </strong>你嵌套了一个名为main的函数，在另一个名为main的函数里面。这能跑吗？t(真)或F(假)</p><blockquote class="nl nm nn"><p id="a79a" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:T </strong></p></blockquote><h1 id="06b6" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">任务8:循环</h1><p id="1ab2" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">这里有3个锈环。</p><h1 id="dbe3" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">环</h1><p id="4f2e" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">关键字<code class="fe nr ns nt na b">loop</code>永远循环，或者直到我们明确地告诉它停止。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="6d20" class="ne lp iq na b gy nf ng l nh ni">fn main(){<br/>    loop {<br/>        println!("TryHackMe Rocks!");<br/>    }<br/>}</span></pre><p id="ad5c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以用ctrl+c中断，也可以让Rust用break中断</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="b15d" class="ne lp iq na b gy nf ng l nh ni">fn main(){<br/>    loop {<br/>        println!("TryHackMe Rocks!");<br/>        break;<br/>    }<br/>}</span></pre><h1 id="2577" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">条件While循环</h1><p id="2a64" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">Rust也有while循环，当条件为真时循环。</p><p id="2fca" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">看看这个例子中的一些代码，摘自<a class="ae kr" href="https://doc.rust-lang.org/book/ch03-05-control-flow.html" rel="noopener ugc nofollow" target="_blank"> Rust Book </a>:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8962" class="ne lp iq na b gy nf ng l nh ni">fn main() {<br/>    let mut number = 3;</span><span id="a0d8" class="ne lp iq na b gy nk ng l nh ni">while number != 0 {<br/>        println!("{}!", number);</span><span id="fb18" class="ne lp iq na b gy nk ng l nh ni">number -= 1;<br/>    }</span><span id="3242" class="ne lp iq na b gy nk ng l nh ni">println!("LIFTOFF!!!");<br/>}</span></pre><h1 id="63c0" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">对于循环</h1><p id="a66c" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">Rust还有for循环，我们可以用它来迭代集合中的元素。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8797" class="ne lp iq na b gy nf ng l nh ni">fn main() {<br/>    let a = [10, 20, 30, 40, 50];</span><span id="8e92" class="ne lp iq na b gy nk ng l nh ni">for element in a.iter() {<br/>        println!("the value is: {}", element);<br/>    }<br/>}</span></pre><p id="3209" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">注意a.iter，我们用这个把a变成iterable。这将很快变得对我们非常重要。</p><p id="6043" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题1: </strong>我们如何打破循环？</p><blockquote class="nl nm nn"><p id="86c3" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">回答:破</strong></p></blockquote><p id="d69d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.2: </strong>最简单的关键字做无限循环？</p><blockquote class="nl nm nn"><p id="1ef0" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:循环</strong></p></blockquote><p id="eb80" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.3: </strong> Turn let a = [10，20]；变成我们可以迭代的东西。</p><blockquote class="nl nm nn"><p id="3dea" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:a.iter() </strong></p></blockquote><p id="9b79" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.4: </strong> While循环也可以是无限的。t(真)或F(假)。</p><blockquote class="nl nm nn"><p id="056f" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:T </strong></p></blockquote><h1 id="ec69" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">任务9:零成本抽象</h1><p id="5ba5" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">这个任务是从我的博客上复制的，我曾经在那里写过关于<a class="ae kr" href="https://bees.substack.com/p/vtubers-random-algorithms-constraints" rel="noopener ugc nofollow" target="_blank">零成本抽象的文章</a>。</p><p id="72f6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Rust有一个非常酷的东西，叫做零成本抽象。这在其他低级语言中也存在，但作为一个Python冲浪爱好者，我以前从未遇到过。</p><p id="2e23" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">零成本抽象是:</p><blockquote class="nl nm nn"><p id="5687" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated">“你不用的东西，你不用付钱。如果你用手工编码，你也不会做得更好。”</p></blockquote><p id="a2ae" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们来谈谈这个句子的两个部分。</p><blockquote class="nl nm nn"><p id="b8f8" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated">“不用的东西，不用付钱。”</p></blockquote><p id="33a7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这种语言不应该为一个不被使用的特性付出全局代价。假设使用for循环，这种语言需要一些大容量的1gb文件来降低其他所有东西的速度。如果我们从来不使用for循环，我们仍然为for循环付费！</p><blockquote class="nl nm nn"><p id="d39e" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated">"而你所使用的，如果你手工编码，你不会做得更好."</p></blockquote><p id="2ddb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">关键是。</p><p id="eee6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">假设你写了一些代码，一个计算斐波那契数的函数。你把这段代码编译成汇编。</p><p id="a986" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在让我们假设你手写汇编来做同样的功能——计算斐波纳契数，但这次是在汇编中。</p><p id="611d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在汇编中写它意味着我们要么得不到性能，要么会失去性能。</p><p id="598f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过使用零成本抽象，我们编写了抽象的代码(不是手写的汇编),如果我们试图手写汇编，我们不会做得更好。现在那很酷！</p><p id="39fc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在，让我们探索迭代器。</p><p id="4b9a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">迭代器是用Rust处理一系列项的一种方式，很像for循环。</p><p id="7636" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们之前看到过<code class="fe nr ns nt na b">a.iter()</code>。这段代码将变量<code class="fe nr ns nt na b">a</code>变成了一个遍历<code class="fe nr ns nt na b">a</code>条目的迭代器。但是这段代码本身并没有做任何有用的事情。</p><p id="6451" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是因为迭代器是懒惰的T2。你必须告诉他们做一些事情来从他们那里获得价值。</p><p id="6feb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们来看一个真实的例子。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="cf07" class="ne lp iq na b gy nf ng l nh ni">let a = vec![1, 2, 3];<br/>let a_iter = a.iter();<br/>for val in a_iter {<br/>    println!("The value is {}, val);<br/>}</span></pre><p id="404b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们通过在for循环中调用迭代器来让它做一些事情。</p><p id="a918" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在我们可以使用一些漂亮的函数式编程技巧让代码做一些事情并<code class="fe nr ns nt na b">consume</code>ITER。要对迭代器中的每个数求平方，然后求和，我们可以这样做:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="b7b5" class="ne lp iq na b gy nf ng l nh ni">let a = vec![1, 2, 3];<br/>a.iter()<br/>.map(|&amp;i| i * i<br/>.sum()</span></pre><p id="b533" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">注意，在Rust中，我们可以用新的行来分隔方法的应用。</p><p id="4869" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这只是迭代器所能做的一小部分。在这里阅读<a class="ae kr" href="https://doc.rust-lang.org/book/ch13-02-iterators.html#processing-a-series-of-items-with-iterators" rel="noopener ugc nofollow" target="_blank">锈书上关于它们的整章。</a></p><p id="d7f3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然而，让我们回到手头的重要任务。零成本抽象。</p><p id="2c2d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在Rust中，迭代器是零成本的抽象。For循环不是。这是根据<a class="ae kr" href="https://doc.rust-lang.org/book/ch13-04-performance.html" rel="noopener ugc nofollow" target="_blank">锈书。</a></p><p id="6e6d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过使用迭代器，我们利用了奇妙的零成本抽象。加速我们的整个计划。</p><p id="12e4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.1: </strong>迭代器比较懒。t(真)或F(假)。</p><blockquote class="nl nm nn"><p id="046e" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:T </strong></p></blockquote><p id="f42b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题2: </strong> For循环在Rust一书中被明确地称为零成本抽象。t(真)或F(假)。</p><blockquote class="nl nm nn"><p id="09d4" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:F </strong></p></blockquote><p id="3319" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问3: </strong>零成本抽象在Python或JavaScript T(rue)或F(alse)这样的高级语言中很常见。</p><blockquote class="nl nm nn"><p id="b49d" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:F </strong></p></blockquote><h1 id="728e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">任务10:人造丝</h1><p id="6f8c" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">Rayon是Rust的外部机箱，通常我不会包含外部库。然而，它实在是太棒了，而且与我刚刚提到的最后几个任务非常吻合。</p><p id="b337" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">人造丝让多线程变得简单。不，真的。这非常容易。</p><p id="4282" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">转到<a class="ae kr" href="https://crates.io/crates/rayon" rel="noopener ugc nofollow" target="_blank"> Crates.io </a>并复制包含带有版本号的板条箱的大黑盒。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nz"><img src="../Images/27c3a76d81d3f9dd46dc306b3b756305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*x3o6owD9jeE6t1pg.png"/></div></div></figure><p id="d4ca" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在进入cargo.toml，并将其包含在dependencies部分。复制粘贴过来就行了。</p><p id="2889" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">好了，现在让我们把最后一个任务中的iter变成多线程。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="ebc5" class="ne lp iq na b gy nf ng l nh ni">fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {<br/>    input.iter()<br/>         .map(|&amp;i| i * i)<br/>         .sum()<br/>}</span></pre><p id="2b23" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是我们之前的代码。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="7bb4" class="ne lp iq na b gy nf ng l nh ni">use rayon::prelude::*;<br/>fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {<br/>    input.par_iter() // &lt;-- just change that!<br/>         .map(|&amp;i| i * i)<br/>         .sum()<br/>}</span></pre><p id="648b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是我们的多线程代码。</p><p id="f1a9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">看看这有多简单！我们把iter()改成par_iter()就大功告成了。我们现在是多线程的。</p><p id="72e6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题1: </strong>我们用什么板条箱来轻松制作iter多线程？</p><blockquote class="nl nm nn"><p id="9bf6" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:人造丝</strong></p></blockquote><p id="1fbd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">问题2: 我们如何告诉Rust在我们的程序中包含一个外部的板条箱？我们把这个信息放在什么文件里？</p><blockquote class="nl nm nn"><p id="9c92" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:cargo.toml </strong></p></blockquote><p id="b283" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题3: </strong>使用人造丝将a.iter()变成多线程并行iter</p><blockquote class="nl nm nn"><p id="7371" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:a.par_iter() </strong></p></blockquote><p id="1148" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题4: </strong>我们去什么网站买板条箱？</p><blockquote class="nl nm nn"><p id="fc15" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:crates.io </strong></p></blockquote><h1 id="990d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">任务11: If语句</h1><p id="760e" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated"><strong class="ku ir">问题1: </strong>我们可以基于一行T(rue)或F(alse)上的if语句给变量赋值</p><blockquote class="nl nm nn"><p id="09eb" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:T </strong></p></blockquote><h1 id="54c8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">任务12:错误处理</h1><p id="234f" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">现在我们来了解一下铁锈的内部结构，它有助于保护铁锈的安全。错误处理。</p><p id="a6e6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在Rust中，任何<em class="nj">可以</em>出错的东西都会返回一个结果。具体来说<code class="fe nr ns nt na b">Result&lt;T, E&gt;</code>。<code class="fe nr ns nt na b">T</code>是你要找的结果，<code class="fe nr ns nt na b">E</code>是错误。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="6d86" class="ne lp iq na b gy nf ng l nh ni">enum Result&lt;T, E&gt; {<br/>    Ok(T),<br/>    Err(E),<br/>}</span></pre><p id="42de" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">每当您打开一个文件时，该文件可能不在那里，或者可能无法成功打开该文件。它将返回一个结果，而你必须以这种方式处理它。</p><p id="d4df" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在Python中，异常处理是交给用户的。如果你想打开一个文件，请便。但是不要忘记写一个异常，如果文件不存在的话！</p><p id="d4d4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">但是在Rust中，无论什么(除非你明确地告诉编译器忽略它)错误都必须被处理。</p><p id="267d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们看一个例子。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="fa30" class="ne lp iq na b gy nf ng l nh ni">use std::fs::File;</span><span id="bceb" class="ne lp iq na b gy nk ng l nh ni">fn main() {<br/>    let f = File::open("hello.txt");<br/>}</span></pre><p id="a4c2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们打开一个文件。这个文件不是存储在f中，实际上存储的是一个结果枚举。</p><p id="61de" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有两种方法可以检查某个东西是否返回结果。</p><ol class=""><li id="0120" class="ml mm iq ku b kv kw ky kz lb mn lf mo lj mp ln oa mr ms mt bi translated">Rust Analyzer会告诉我们返回类型是什么。</li><li id="abb4" class="ml mm iq ku b kv mu ky mv lb mw lf mx lj my ln oa mr ms mt bi translated">我们给一个我们知道是错误的类型赋值，编译器会告诉我们。</li></ol><p id="b3b1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果我们赋值<code class="fe nr ns nt na b">let f: u32 = File::open("hello.txt");</code>，编译器会告诉我们。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="d328" class="ne lp iq na b gy nf ng l nh ni">--&gt; src/main.rs:4:18<br/>  |<br/>4 |     let f: u32 = File::open("hello.txt");<br/>  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `std::result::Result`<br/>  |            |<br/>  |            expected due to this<br/>  |<br/>  = note: expected type `u32`<br/>             found enum `std::result::Result&lt;std::fs::File, std::io::Error&gt;`</span></pre><p id="a3c5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在我们知道我们必须处理错误，但问题是如何处理。</p><p id="36eb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我将向你展示三种方法。</p><p id="f6b6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">1.打开</p><p id="bf7d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">Unwrap是最容易实现的。它告诉Rust“我很确定这不会失败，所以继续下去，接受这个值”。如果它真的失败了，好吧，锈恐慌！</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="c303" class="ne lp iq na b gy nf ng l nh ni">use std::fs::File;</span><span id="bb05" class="ne lp iq na b gy nk ng l nh ni">fn main() {<br/>    let f = File::open("hello.txt").unwrap();<br/>}</span></pre><p id="cfc6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">2.比赛</p><p id="edae" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果您熟悉Python，那么Match就是您所期望的工作方式。</p><p id="3e9f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们为Ok做一件事，为错误做另一件事。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="747c" class="ne lp iq na b gy nf ng l nh ni">use std::fs::File;</span><span id="4abe" class="ne lp iq na b gy nk ng l nh ni">fn main() {<br/>    let f = File::open("hello);<br/>    match f {<br/>        Ok(file) =&gt; file,<br/>        Err(_) =&gt; panic!("Couldn't open file."),<br/>    }<br/>}</span></pre><p id="cfea" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果结果是<code class="fe nr ns nt na b">Ok</code>，这意味着结果是成功的，我们可以直接获取文件。</p><p id="161e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果是一个<code class="fe nr ns nt na b">Err</code>，这意味着发生了一个错误，我们需要做些什么。在这种情况下，程序会崩溃。</p><p id="625d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi">3. ?</p><p id="ec56" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">那个？操作员声明“如果结果正常，继续此功能。否则，如果它是一个Err，将它沿堆栈向上传播回调用我的函数。”</p><p id="9b14" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了说明这一点，让我们看看我从Rust的博客文章中截取的这个例子。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="95c1" class="ne lp iq na b gy nf ng l nh ni">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {<br/>    let f = File::open("username.txt");</span><span id="641d" class="ne lp iq na b gy nk ng l nh ni">let mut f = match f {<br/>        Ok(file) =&gt; file,<br/>        Err(e) =&gt; return Err(e),<br/>    };</span><span id="676e" class="ne lp iq na b gy nk ng l nh ni">let mut s = String::new();</span><span id="13a7" class="ne lp iq na b gy nk ng l nh ni">match f.read_to_string(&amp;mut s) {<br/>        Ok(_) =&gt; Ok(s),<br/>        Err(e) =&gt; Err(e),<br/>    }<br/>}</span></pre><p id="7e25" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们在这个代码中有两个匹配。有点不守规矩。理想情况下，如果我们无法打开文件，或无法读取字符串，我们会将一个错误传播回堆栈，说明此函数失败。</p><p id="943b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果没有，我们应该返回Ok结果。这样，调用我们的函数将接收到一个更容易处理的<code class="fe nr ns nt na b">Result</code>类型，而不需要我们处理多个<code class="fe nr ns nt na b">match</code>语句。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="4c47" class="ne lp iq na b gy nf ng l nh ni">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {<br/>    let mut f = File::open("username.txt")?;<br/>    let mut s = String::new();</span><span id="1972" class="ne lp iq na b gy nk ng l nh ni">f.read_to_string(&amp;mut s)?;</span><span id="4f89" class="ne lp iq na b gy nk ng l nh ni">Ok(s)<br/>}</span></pre><h1 id="6c15" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="d8eb" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">这是Rust中最重要的概念之一。错误通常不会发生，因为每个错误都必须以某种方式处理。这有助于保护代码的安全。</p><p id="af09" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> Q.1: </strong>打开文件返回的数据类型是什么？</p><blockquote class="nl nm nn"><p id="31b2" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:结果</strong></p></blockquote><p id="a970" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题2: </strong>用类型提示写一个通用结果的数据类型</p><blockquote class="nl nm nn"><p id="ee3c" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">答案:结果T，E&gt;T9】</strong></p></blockquote><p id="d99e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题3: </strong>我们在一个函数中，我们得到一个结果枚举。如果结果是好的，我们想在这个函数中继续工作。如果结果是Err，我们希望返回带有Err的父函数。我们应该用什么？</p><blockquote class="nl nm nn"><p id="5132" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">回答:？</strong></p></blockquote><p id="25eb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">问题4: </strong>我们确信我们的结果将总是返回Ok，我们应该使用什么？</p><blockquote class="nl nm nn"><p id="dacc" class="ks kt nj ku b kv kw jr kx ky kz ju la no lc ld le np lg lh li nq lk ll lm ln ij bi translated"><strong class="ku ir">回答:解开</strong></p></blockquote><h1 id="a78c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">任务13:挑战</h1><p id="b182" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">挑战文件1。</p><p id="1ebd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">“M3I6r2IbMzq9”为正文。</p><p id="d3e6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">文本用以下内容加密:</p><p id="2c42" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">明文-&gt; ROT13 -&gt; base64 -&gt; rot13</p><p id="58cb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">走相反的路，解密文件。</p><p id="afea" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">rot13 -&gt; base64 -&gt; ROT13 -&gt;明文</p><p id="5bb2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你会注意到这两种方式的顺序是一样的，所以你不必担心顺序。确保ROT13在里面。</p><p id="3223" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您可能会遇到终身借用检查器问题。</p><p id="0eeb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果你这样做，这里有一些提示:</p><p id="5b4d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">1.谷歌是你的朋友。</p><p id="602d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">2.<a class="ae kr" href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html" rel="noopener ugc nofollow" target="_blank">https://doc . rust-lang . org/book/ch04-02-references-and-borrowing . html</a></p><p id="4fc6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">3.不要试图同时做这么多事情。将它分解成最基本的需求，然后慢慢构建，看看是什么导致了错误。</p><p id="712f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">问题1: 挑战1</p><p id="4085" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">答案:THM{****}</p><p id="ae54" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">提示:- 你学哪种语言</p><p id="43b3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">你可以在:<br/><strong class="ku ir">LinkedIn:-</strong><a class="ae kr" href="https://www.linkedin.com/in/shamsher-khan-651a35162/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/shamsher-khan-651a35162/</a><br/><strong class="ku ir">Twitter:-</strong><a class="ae kr" href="https://twitter.com/shamsherkhannn" rel="noopener ugc nofollow" target="_blank">https://twitter.com/shamsherkhannn</a><br/><strong class="ku ir">Tryhackme:-</strong><a class="ae kr" href="https://tryhackme.com/p/Shamsher" rel="noopener ugc nofollow" target="_blank">https://tryhackme.com/p/Shamsher</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/09e5bbba06c7688a702aeec8570d243c.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*Vve7XR6kstH7qA5iQQ-kYA.png"/></div></figure><p id="21a2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如需更多演练，请在出发前继续关注… <br/></p><p id="31dd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">访问我的其他演练:-</p><p id="b444" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">感谢您花时间阅读我的演练。<br/>如果你觉得有帮助，请点击👏按钮👏(高达40倍)并分享<br/>它来帮助其他有类似兴趣的人！+随时欢迎反馈！</p></div></div>    
</body>
</html>