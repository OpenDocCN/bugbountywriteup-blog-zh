<html>
<head>
<title>Intro to Bug Bounty Automation: Tool Chaining with Bash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bug Bounty自动化简介:Bash工具链</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/intro-to-bug-bounty-automation-tool-chaining-with-bash-13e11348016f?source=collection_archive---------1-----------------------#2021-02-17">https://infosecwriteups.com/intro-to-bug-bounty-automation-tool-chaining-with-bash-13e11348016f?source=collection_archive---------1-----------------------#2021-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="558c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Bash脚本是一个简单的概念，它可以让bug赏金猎人自动化重复的任务，并在高级漏洞上花费更多的时间，通常会导致更高的回报。</p><p id="2a47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工具链就是这样，使用Bash脚本来集成以预定义模式执行的多个工具。这篇文章讨论了工具链在bug赏金自动化中的使用，并介绍了一个新的枚举工具添加到你的侦查过程中！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/691b1afab9ce3c02cdfcf2d1c21717fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qtP-0rzg3A3icwo4qVfmIQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae lb" href="https://unsplash.com/s/photos/program?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="0783" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">介绍</h2><p id="bf9c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">自动化是bug赏金猎人的最新趋势，每天都有新的框架发布。这包括从具有用户界面和后端数据库的成熟解决方案到定制Bash脚本的集合。所有这些都有其用途，这取决于用户偏好的控制水平和测试深度。</p><p id="3ce4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">bug bounty自动化的一些明显优势包括:</p><ul class=""><li id="1ae4" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">轻松识别易受攻击的漏洞。</li><li id="9a3f" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">持续侦察以捕捉变化的环境。</li><li id="2e32" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">通过自动化重复性任务最大化时间和利润。</li></ul><h2 id="c5b9" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">Bash脚本</h2><p id="3923" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Bash脚本可以很好地介绍自动化领域，因为它非常灵活。用户能够使用他们现有的工具和方法立即开始。无需构建框架的每个组件，只需添加最适合您流程的开源工具。这就是为什么这种方法也有利于不精通任何特定语言但了解被测试的基本技术的猎人。</p><p id="b30a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Bash的另一个好处是语言独立性。这使得猎人可以选择最适合的工具，而不用考虑底层的编程语言。我看到和使用的许多bug bounty工具都是用Python或Go编写的。Bash允许两者都被执行、解析并合并到进一步的自动化过程中；假设所有工具和依赖项都已预装。</p><h2 id="ece6" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">例子</h2><p id="60d4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">例如，下面的脚本将使用<a class="ae lb" href="https://github.com/m8sec/subscraper" rel="noopener ugc nofollow" target="_blank">sub craper</a>执行子域枚举，并将结果传递给<a class="ae lb" href="https://github.com/tomnomnom/httprobe" rel="noopener ugc nofollow" target="_blank"> Tomnomnom的http probe</a>来检查活动主机。任何添加到<em class="mo"> out_of_scope.txt </em>的地址或DNS名称将在主动枚举之前被删除，以遵守计划指南:</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="14c4" class="lc ld iq mq b gy mu mv l mw mx">#!/usr/bin/env bash<br/>#Usage: ./enum.sh domain(dot)com</span><span id="b5b8" class="lc ld iq mq b gy my mv l mw mx">TARGET=$1<br/>python3 subscraper.py $TARGET -o subdomains.txt<br/>cat subdomains.txt |grep -v "$(cat out_of_scope.txt)"|httprobe</span></pre><p id="c2a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个更复杂的实现来自N <a class="ae lb" href="https://github.com/nahamsec/lazyrecon" rel="noopener ugc nofollow" target="_blank"> ahamsec的lazyrecon </a>。它使用Bash脚本链接各种工具和技术，在传统的recon过程中自动执行多个步骤。然后生成一个用户友好的HTML报告来显示结果数据。</p><h2 id="5496" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">SubWalker【工具掉落！]</h2><p id="0a76" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">自动化的另一个意想不到的应用是提高精确度。范围内的每个IP地址和子域都是发现更多漏洞的机会。因此，我们希望确保我们的工具尽可能提供最准确、最全面的结果。</p><p id="e05b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最近的搜索中，我发现子域枚举工具的结果各不相同，甚至那些使用相似资源的工具也是如此。下面演示了三个针对同一个全域性程序的枚举工具，并比较了所识别的子域数量:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/78a94f23695e6c9cceb92c738351a826.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*L7y5yoaAWJSG0fIt18zixQ.png"/></div></figure><p id="79ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，结果的数量并不一致，并且因工具而异。因此，为了确保我得到最准确的结果，同时保持只运行一个命令的简单性，我创建了<a class="ae lb" href="https://github.com/m8sec/SubWalker" rel="noopener ugc nofollow" target="_blank"> SubWalker </a>！</p><p id="0c2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">https://github.com/m8sec/SubWalker<strong class="jp ir">地铁</strong> - <a class="ae lb" href="https://github.com/m8sec/SubWalker" rel="noopener ugc nofollow" target="_blank">地铁</a></p><p id="0832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Subwalker是一个简单的Bash脚本，它链接了3个常见的子域枚举工具:<a class="ae lb" href="https://github.com/m8r0wn/subscraper" rel="noopener ugc nofollow" target="_blank">sub craper</a>、<a class="ae lb" href="https://github.com/tomnomnom/assetfinder" rel="noopener ugc nofollow" target="_blank"> AssetFinder </a>和<a class="ae lb" href="https://github.com/aboul3la/Sublist3r" rel="noopener ugc nofollow" target="_blank"> Sublist3r </a>。每个都同时执行以减少时间，并分析结果以提供一个没有重复的输出文件。该工具独特的计数技术允许将结果和重叠的结果结合起来，以确保准确性和有效性。假设每个工具都使用被动方法来收集信息，这种方法不会对目标域产生任何额外的干扰或开销。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/ca263966ddf962d17c0cd3959a75018d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*K9ocGPUy_kwxUq2iqydHpA.png"/></div></figure><p id="f3c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">包装完毕</strong></p><p id="3b5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，自动化不应该完全取代手工测试。通常只有通过手动分析和用户交互才能发现结果。然而，Bash脚本是自动化重复任务的一个很好的方式，可以腾出时间花在更高级的发现上，这通常会带来更高的回报。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="24db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！在<a class="ae lb" href="https://m8sec.dev/" rel="noopener ugc nofollow" target="_blank"> m8sec.dev </a>找到更多关于我的信息，并关注更多关于我的bug bounty旅程的文章。</p><p id="466e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mo">免责声明:所有内容仅用于教育目的。作者不对信息的使用负责。不要对你不拥有或没有明确许可的系统进行测试。</em></p></div></div>    
</body>
</html>