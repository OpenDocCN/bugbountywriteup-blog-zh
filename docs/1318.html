<html>
<head>
<title>Upgrading XSS Hunter with a basic reverse JavaScript shell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用基本的逆向JavaScript shell升级XSS·亨特</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/upgrading-xss-hunter-with-a-basic-reverse-javascript-shell-db00172e32f9?source=collection_archive---------0-----------------------#2021-05-13">https://infosecwriteups.com/upgrading-xss-hunter-with-a-basic-reverse-javascript-shell-db00172e32f9?source=collection_archive---------0-----------------------#2021-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8a0ee3dfb70362d6af08c81fe11ea292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8-GYjc5CPQWbVNXWaUnMw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">反向外壳接口</figcaption></figure></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><p id="b099" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated"><em class="lk">在您开始阅读本文之前，请记住这是一个非常基础的反向外壳，仍然需要大量的工作来充分利用它。一些限制是:</em></p><ul class=""><li id="5b73" class="ll lm it ko b kp kq kt ku kx ln lb lo lf lp lj lq lr ls lt bi translated"><em class="lk">如果多个有效载荷在多个页面上处于活动状态，可能会出现错误。有效负载在所有激活的页面上执行，但是多个页面可能彼此不同，当它们都发送回响应时，接口只保存其中一个页面。</em></li><li id="651d" class="ll lm it ko b kp lu kt lv kx lw lb lx lf ly lj lq lr ls lt bi translated"><em class="lk">反向shell接口被放置在web服务器上，这意味着当您没有适当的授权时，每个人都可以找到它。这也意味着对手可以找到它并恶意利用它。</em></li></ul></div><div class="ab cl kf kg hx kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="im in io ip iq"><p id="6477" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">最近，我发现了我的第一个盲人XSS，我很快注意到，很难弄清楚你的盲人XSS有什么可能，以及它能产生什么影响。为了解决这个问题，我尝试了几种有效载荷，但是觉得需要实时执行有效载荷。正因为如此，我想出了做一个反向外壳的主意，当我收到XSS·亨特的电子邮件通知我XSS已经被触发时，我就可以使用它。唯一的问题是，只有当受害者停留在易受攻击的页面上时，反向外壳才会工作。一旦他转到另一个页面或关闭该页面，连接就会丢失。</p><p id="dab2" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">这种反向shell并不是最好的解决方案，但是对于初学者来说，尝试一下还是很有帮助的。对我来说，这是一个有趣的小项目。</p><p id="9615" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">为了开始这个项目，我打开记事本，开始写下我希望shell如何工作。</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lz"><img src="../Images/7ef2322bda83b1e3763a71d2fc71b5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4G1yZq8U_V3ZunCW67g59w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">笔记</figcaption></figure><h1 id="c9f2" class="me mf it bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">创建外壳</h1><h2 id="f8b2" class="nc mf it bd mg nd ne dn mk nf ng dp mo kx nh ni ms lb nj nk mw lf nl nm na nn bi translated">第1部分:没有响应的有限反向外壳</h2><p id="e414" class="pw-post-body-paragraph km kn it ko b kp no kr ks kt np kv kw kx nq kz la lb nr ld le lf ns lh li lj im bi translated">我首先创建了一些向受害者发送有效载荷的东西，但是还没有将响应发送回接口。代码非常简单，页面上有一个表单，在提交时，向自己发送一个post请求(index.php)。页面上的PHP会将post请求中的有效负载写入一个JavaScript文件。接口代码如下所示:</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b3b9d1b47268c05343101a31eac41103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*uTQLPWBSbnUYiLIoHSDamw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">interface.php第一部分</figcaption></figure><p id="187a" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">现在是时候编写将在受害者的浏览器中运行的JavaScript了。正如您在我的笔记中看到的，我不确定应该使用什么间隔来发出网络请求，但我认为1秒是一个不错的开始，但如果您希望它更快或更慢，请随意更改。反向外壳的代码是这样的。</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f9b281017951150b80eca2306cbd0bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*uujOR1rL7DEyNVT7xtsUkw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">reverse.js第1部分</figcaption></figure><p id="ce73" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated"><code class="fe nv nw nx ny b">payloadURL</code>变量应该被更改到您自己的有效负载脚本的位置。如果您复制了我的代码，payload.js与您的interface.php位于同一个文件夹中。</p><h2 id="a1dd" class="nc mf it bd mg nd ne dn mk nf ng dp mo kx nh ni ms lb nj nk mw lf nl nm na nn bi translated">第2部分:带有响应的反向外壳</h2><p id="bba4" class="pw-post-body-paragraph km kn it ko b kp no kr ks kt np kv kw kx nq kz la lb nr ld le lf ns lh li lj im bi translated">在我的代码中，一旦服务器收到响应，它就将它写入文件。点击<code class="fe nv nw nx ny b">execute</code>按钮2秒后，将从文件中读取响应，并反映在页面上。这可能不是最好的方法，但是如果你的受害者的网速不错，并且你的有效负载不需要很长时间来执行的话，这种方法也可以。如果你遇到问题，你可以随时调高interface.php的睡眠时间。</p><p id="604a" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">首先，我编辑了reverse.js，这样它就可以在POST请求中向interface.php发送响应。Response.js现在看起来像这样:</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c830b28b846b807e5703d7130d532f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*eHBCjVKZOd2_t1c0ZEsZmw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">reverse.js部分2</figcaption></figure><p id="e8a3" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">再次将<code class="fe nv nw nx ny b">interfaceURL</code>的值改为自己接口的URL。我还添加了一个检查来设置响应为“undefined ”(如果没有定义的话),因为否则当执行没有响应的有效负载时，接口会一直显示旧的响应。</p><p id="52c6" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">现在，应对措施应该在interface.php进行。如前所述，响应被写入文件，并在点击<code class="fe nv nw nx ny b">execute</code>2秒后反映出来。interface.php的代码现在看起来像这样:</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/37d543f1677b7825dd374aae68dfc8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*yZ8HM5zXfp4ZRoRJpWimUw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">interface.php第二部</figcaption></figure><p id="11d6" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">作为一个好的实践，我使用php函数<code class="fe nv nw nx ny b">htmlspecialchars()</code>来防止网页上反射XSS。</p><h1 id="25f6" class="me mf it bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">与XSS·亨特一起设置外壳</h1><p id="e06a" class="pw-post-body-paragraph km kn it ko b kp no kr ks kt np kv kw kx nq kz la lb nr ld le lf ns lh li lj im bi translated">首先，你需要确保interface.php和reverse.js可以通过互联网访问。为此，我使用了托管服务，但你也可以自己托管并设置端口转发。</p><p id="f1c0" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">完成后，您需要将reverse.js链接到您的XSS猎人，这样一旦盲XSS被触发，它就会在受害者的浏览器中执行。为此，登录XSS·亨特，进入<code class="fe nv nw nx ny b">settings</code>，在额外的JavaScript有效负载URI下，将URI添加到reverse.js脚本中。最后，滚动到底部并点击<code class="fe nv nw nx ny b">Update Settings</code>按钮。</p><p id="f8d7" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">信不信由你，但事实就是这样，一切都已经完成，你已经准备好测试它了。</p><h1 id="bcaf" class="me mf it bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">测试外壳</h1><ol class=""><li id="0e61" class="ll lm it ko b kp no kt np kx ob lb oc lf od lj oe lr ls lt bi translated">创建一个简单的html文件，其中包含您的XSS猎人有效负载的URL(例如:<code class="fe nv nw nx ny b">username.xss.ht</code>)。并打开该文件。</li></ol><figure class="ma mb mc md gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/b9110da9542839067a398f29bfb311a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*iABwKvNBqtxWis6HvNBZfA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">html测试页面</figcaption></figure><p id="0d21" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">2.在您的公共web服务器上打开您的interface.php文件。并输入<code class="fe nv nw nx ny b">alert()</code>来查看它在您的html测试页面上触发。回应会是<code class="fe nv nw nx ny b">undefined</code>。</p><p id="0912" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">3.输入<code class="fe nv nw nx ny b">2+2</code>，注意响应将是<code class="fe nv nw nx ny b">4</code>。</p><p id="d170" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">恭喜你。就这样，你得到了一个非常简单的JavaScript反向shell:)。</p><p id="2221" class="pw-post-body-paragraph km kn it ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj im bi translated">请随意修改您的代码进行改进！</p></div></div>    
</body>
</html>