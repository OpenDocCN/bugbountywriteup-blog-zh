<html>
<head>
<title>Poison — A Port Forwarding Privesc HackTheBox Walkthrough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">毒药—端口转发特权黑客邮箱演练</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/poison-a-port-forwarding-privesc-hackthebox-walkthrough-afb1d6f7a7f6?source=collection_archive---------1-----------------------#2018-09-09">https://infosecwriteups.com/poison-a-port-forwarding-privesc-hackthebox-walkthrough-afb1d6f7a7f6?source=collection_archive---------1-----------------------#2018-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0d82f5d794dfe9e2ebac981aca893744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKhZRBRSYeM0RkGHYdyPrw.png"/></div></div></figure><h1 id="31f2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">摘要</h1><p id="daa2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Poison是一种运行web服务器的Linux主机，容易受到本地文件包含的攻击。这被用来枚举本地用户并恢复包含编码凭据的文件。这些被组合起来以获得对机器的SSH访问。本地枚举返回了一个以根用户身份运行的VNC进程，该进程只接受本地连接。端口转发与从主机恢复的密钥相结合，通过VNC返回了具有root权限的终端。</p><h1 id="3d87" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">侦察</h1><p id="0dcb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我开始在这台主机上进行侦察，通过扫描来枚举服务版本，并在默认情况下<code class="fe lu lv lw lx b">nmap</code>检查的1000个公共端口上运行默认脚本:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="db49" class="mg jz iq lx b gy mh mi l mj mk">nmap -sV -sC 10.10.10.84</span></pre><blockquote class="ml mm mn"><p id="e573" class="kw kx mo ky b kz mp lb lc ld mq lf lg mr ms lj lk mt mu ln lo mv mw lr ls lt ij bi translated"><code class="fe lu lv lw lx b">-sV</code> —枚举服务版本<br/> <code class="fe lu lv lw lx b">-sC</code> —运行默认脚本</p></blockquote><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">纳米粒子加速器</figcaption></figure><p id="bb88" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">这返回了两个服务，SSH和HTTP。每一个都在FreeBSD主机上运行。</p><p id="97f8" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">列举的第一个服务是HTTP。访问web服务器会立即返回一个执行php文件的门户:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/d9fd47bcd62217fe6e0fa061abfa02a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bo69f5KAdo1BOaxxm57j1A.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">index.html</figcaption></figure><p id="2e40" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">运行<code class="fe lu lv lw lx b">listfiles.php</code>返回一个数组，该数组包含来自默认web目录的多个文件，该目录包含本地。主页上引用的php脚本。还有一个名为<code class="fe lu lv lw lx b">pwdbackup.txt</code>的文件:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/e1171aa3bc02a7a6860c0d9171dbe6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iqmqz2d8iK2UsMZ3PKSUbg.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">listfiles.php</figcaption></figure><p id="0c86" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">查看URL可以清楚地看到<code class="fe lu lv lw lx b">listfiles.php</code>文件是如何被引用的:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="ad3f" class="mg jz iq lx b gy mh mi l mj mk">http://10.10.10.84/browse.php?file=listfiles.php</span></pre><p id="4ecc" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">为了查看<code class="fe lu lv lw lx b">pwdbackup.txt</code>的内容，只需替换URL中的文件名:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="e83d" class="mg jz iq lx b gy mh mi l mj mk">http://10.10.10.84/browse.php?file=pwdbackup.txt</span></pre><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/56281bc0f44f14963498a932d24ed6a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgTSREjq0dkFfmnk2pkY1g.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">pwdbackup.txt</figcaption></figure><p id="482d" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">在测试这个URL时，我决定看看系统上的其他文件是否可以被抓取:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="e62f" class="mg jz iq lx b gy mh mi l mj mk">http://10.10.10.84/browse.php?file=../../../../../etc/passwd</span></pre><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/6bd2f0e7cfaf19e4903464218976131b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hoB_S_GxjlsEtPYSTqzyww.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">/etc/密码</figcaption></figure><p id="80ce" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">这成功了！然而，它不可读或不容易解析。这可以通过查看页面的源代码来轻松解决:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/1f2a3dea73c52138cd5b0fef0efb1860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3KffJTlHz_oys4KSPGSyQ.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">较好的</figcaption></figure><p id="9ae4" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">此时，已经从主机枚举了用户列表和编码密码。现在是时候将这两个工件放在一起并获得对系统的本地访问了。</p><h1 id="b607" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">局部访问</h1><p id="d4fb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">文件<code class="fe lu lv lw lx b">pwdbackup.txt</code>包含一个提示，密码已经“被编码了至少13次”。它似乎是base64编码的。为了快速恢复密码，并且不用费心确定字符串被编码了多少次(实际上正好是13次)，我编写了一个python脚本来解码字符串，直到它变成明文:</p><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">decode.py</figcaption></figure><p id="0c5a" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">为了枚举系统上拥有有效登录shell的用户，我使用了<code class="fe lu lv lw lx b">grep</code>来过滤掉<code class="fe lu lv lw lx b">/usr/sbin/nologin</code> shell:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="a2ab" class="mg jz iq lx b gy mh mi l mj mk">grep -v “nologin” passwd</span></pre><blockquote class="ml mm mn"><p id="02cc" class="kw kx mo ky b kz mp lb lc ld mq lf lg mr ms lj lk mt mu ln lo mv mw lr ls lt ij bi translated"><code class="fe lu lv lw lx b">-v</code> —反向匹配</p></blockquote><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">用户</figcaption></figure><p id="51a0" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">用户<code class="fe lu lv lw lx b">root</code>和<code class="fe lu lv lw lx b">charix</code>都有交互式的<code class="fe lu lv lw lx b">/bin/csh</code>外壳。FreeBSD中的默认备份帐户用户<code class="fe lu lv lw lx b">toor</code>没有分配shell。用户<code class="fe lu lv lw lx b">uucp</code>是FreeBSD中的另一个默认帐户，没有交互式shell。</p><p id="44de" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">使用解码的密码和用户名<code class="fe lu lv lw lx b">charix</code>授权SSH访问机器。</p><h1 id="ced4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">权限提升</h1><p id="b69d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在<code class="fe lu lv lw lx b">charix</code>用户的主目录中，有一个名为<code class="fe lu lv lw lx b">secrets.zip</code>的文件。将文件传输到主机并使用用户密码解压缩，会返回一个带有“非ISO扩展ASCII文本”的文件:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="8200" class="mg jz iq lx b gy mh mi l mj mk">[|Ֆz!</span></pre><p id="250b" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">查看以root用户身份运行的进程会返回一个有趣(并且非常冗长)的进程:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="60b0" class="mg jz iq lx b gy mh mi l mj mk">ps -U root</span></pre><blockquote class="ml mm mn"><p id="84de" class="kw kx mo ky b kz mp lb lc ld mq lf lg mr ms lj lk mt mu ln lo mv mw lr ls lt ij bi translated"><code class="fe lu lv lw lx b">-U</code> —指定用户</p></blockquote><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">根进程</figcaption></figure><p id="7f08" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">有一个以root用户身份运行的<code class="fe lu lv lw lx b">Xvnc</code>会话。研究此过程的每个参数，可以确定存在连接到此VNC会话的身份验证密钥，并且它仅侦听本地连接。</p><p id="205c" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">我们可以通过运行<code class="fe lu lv lw lx b">sockstat</code>来确认监听端口5091正在监听连接:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="9bc3" class="mg jz iq lx b gy mh mi l mj mk">sockstat -P tcp</span></pre><blockquote class="ml mm mn"><p id="b85e" class="kw kx mo ky b kz mp lb lc ld mq lf lg mr ms lj lk mt mu ln lo mv mw lr ls lt ij bi translated"><code class="fe lu lv lw lx b">-P</code> —指定协议</p></blockquote><figure class="ly lz ma mb gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">sockstat</figcaption></figure><p id="2db8" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">VNC是一个图形用户界面程序。因为只有SSH可以访问机器，所以不能从远程shell启动VNC会话；没有弹出窗口可供VNC会话生成。我们也不能远程连接到VNC会话，因为它只监听本地连接。</p><p id="312b" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">为了实现这一点，我们必须通过SSH建立我们的VNC连接，这个过程在本文的<a class="ae nh" href="https://cects.com/ssh-local-and-remote-port-forwarding-with-vnc/" rel="noopener ugc nofollow" target="_blank">和图表</a>中有非常有效的描述和解释:</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4d2379d6ac9abeb6b9c617d5efb3f18d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mr-Z5A1qUaSirj_XaJL27Q.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">VNC港口运输</figcaption></figure><h2 id="7e8d" class="mg jz iq bd ka ni nj dn ke nk nl dp ki lh nm nn km ll no np kq lp nq nr ku ns bi translated">第一步:</h2><p id="e917" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">设置端口转发以到达5901 vnc会话:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="6008" class="mg jz iq lx b gy mh mi l mj mk">ssh -L 5902:localhost:5901 charix@10.10.10.84</span></pre><p id="f8cc" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">在整个步骤2中保持运行。</p><h2 id="1479" class="mg jz iq bd ka ni nj dn ke nk nl dp ki lh nm nn km ll no np kq lp nq nr ku ns bi translated">第二步:</h2><p id="07be" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">回到我的机器上，我将<code class="fe lu lv lw lx b">vncviewer</code>连接到本地端口5902，这将通过SSH隧道将连接反弹到端口5901的Poison上。由于流量通过SSH隧道，它看起来像是到VNC进程的本地连接，我们能够使用从<code class="fe lu lv lw lx b">secret.zip</code>提取的文件/密钥进行身份验证:</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="8c0f" class="mg jz iq lx b gy mh mi l mj mk">vncviewer localhost:5902 -passwd secret</span></pre><p id="8a5d" class="pw-post-body-paragraph kw kx iq ky b kz mp lb lc ld mq lf lg lh ms lj lk ll mu ln lo lp mw lr ls lt ij bi translated">这将在VNC上空返回一个根壳。</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/2531acbb7b4f10d0293749e89cee2cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oFI2-L8eG78ozulNZqh4ug.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">我是root</figcaption></figure></div></div>    
</body>
</html>