<html>
<head>
<title>OWASP Top 10: 1-Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OWASP前10:1-注入</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/owasp-top-10-1-injection-39a9272e36b4?source=collection_archive---------7-----------------------#2021-04-16">https://infosecwriteups.com/owasp-top-10-1-injection-39a9272e36b4?source=collection_archive---------7-----------------------#2021-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="5d35" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="db53" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当OWASP谈到注入缺陷时，它指的是允许从低影响问题(HTML注入)到严重错误(SQLi允许删除表)的任何缺陷。基本上任何介于两者之间的东西都可以在这里提到，比如LDAP注入、OS命令注入等等。这些漏洞都有一个共同点，它们的根本原因。它们都是因为开发人员将用户的未初始化数据传递给解释器而发生的。</p><h1 id="d7a1" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">这是什么？</h1><p id="cb01" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果您是一名开发人员，您现在可能已经编写了一些查询，这些查询有时也会接受用户输入，例如:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="d14f" class="lv jr it lr b gy lw lx l ly lz">SELECT * FROM PRODUCTS WHERE TEXT LIKE '%" . $_GET['q'] . "%';</span></pre><p id="9360" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated">如果我们不对用户输入进行适当的净化，这一行看起来很简单的代码可能会搞砸很多事情。恶意用户可能会在此处输入引号，这会中断SQL语句并允许执行用户提交的查询。你可以想象这是不可取的，我们有许多不同类型的注射。今天我们将讨论其中的几个，我们将从不同的角度来看。我们还需要注意，SQL注入只是这个难题的一小部分，我们还将讨论命令注入。</p><h1 id="f516" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">SQL注入</h1><h2 id="c5e4" class="lv jr it bd js mf mg dn jw mh mi dp ka kz mj mk ke ld ml mm ki lh mn mo km mp bi translated">黑客的视角</h2><p id="01e3" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">作为一名黑客，我的观点是试图依赖这样一个事实，即开发人员将需要清理我的所有数据，如果他们忘记这样做，即使只有一点，我也可能有一个可能的攻击切入点。这就是为什么我的测试策略非常依赖于测试我看到的每一个参数，甚至是我没有直接看到的参数。</p><p id="86c6" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated">由于我们可以测试SQLi和盲SQLi，这就使事情变得复杂了。在盲SQLi中，服务器不会返回任何值供我们处理，我们只能通过发送一个已知会导致延迟的查询来测试此方法，但这会带来几个问题:</p><ul class=""><li id="513f" class="mq mr it kq b kr ma kv mb kz ms ld mt lh mu ll mv mw mx my bi translated">任何滞后都会导致响应延迟，看起来像是盲目的SQLi触发了，而实际上并没有触发</li><li id="0ce0" class="mq mr it kq b kr mz kv na kz nb ld nc lh nd ll mv mw mx my bi translated">您需要知道您的目标使用什么数据库，这样您就可以为该服务器指定一个命令</li><li id="83b3" class="mq mr it kq b kr mz kv na kz nb ld nc lh nd ll mv mw mx my bi translated">对于本来就很慢的调用，盲目的SQLi测试更加困难，您将不得不等待很长时间，看看它是否被正确应用</li></ul><p id="50bf" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated">考虑到这一点，如果我们对正在执行的数据库查询有所怀疑，并且可以控制，我们将尝试测试我们可以为SQLi找到的每一个参数。一个典型的实际例子，你会发现登录时有SQLi，虽然这可能发生在pentest上，但它不会发生在bug bounty目标上。这太明显了，我们必须在javascript文件、隐藏的表单字段、waybackmachine和我们能想到的任何东西中寻找那些隐藏的参数。</p><p id="38c5" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated">我们通常用单引号和双引号进行测试</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="1f42" class="lv jr it lr b gy lw lx l ly lz">'"</span></pre><p id="bd07" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated">当我们看到一个SQL错误时，我们将进一步调查，或者使用像<a class="ae ne" href="http://sqlmap.py" rel="noopener ugc nofollow" target="_blank"> SQLmap.py </a>这样的工具，或者手动调查，尽管我们必须注意这对于盲SQLi不起作用。</p><h2 id="a794" class="lv jr it bd js mf mg dn jw mh mi dp ka kz mj mk ke ld ml mm ki lh mn mo km mp bi translated">开发人员的视点</h2><p id="a45a" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当涉及到SQLi保护时，开发人员的工作非常艰难，他们不仅要清理用户可以直接控制的每个参数，还必须考虑对应用程序的间接影响。例如，可能有正在运行的获取文件的批处理作业，这些文件的内容经常需要清理，但这并不总是容易的。</p><p id="2ab4" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated">当第三方应用程序开始发送我们的应用程序数据时，它很容易变得一塌糊涂，并且很容易疏忽和忘记整理一条信息，这可能会引发连锁反应，您不想从您的工资支票中扣除。</p><p id="e90f" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated">作为一名开发人员，您应该遵循一些基本的安全原则来消除或避免这类攻击。</p><ul class=""><li id="e063" class="mq mr it kq b kr ma kv mb kz ms ld mt lh mu ll mv mw mx my bi translated">最小需求特权原则:如果您有一个只需要从数据库中读取数据的查询，那么我们可能不需要一个可以写入甚至删除数据的用户。如果可能的话，我们应该尽可能地将我们的用户隔离开来，这样如果我们真的被黑客攻击了，黑客就可能拥有最少的特权</li><li id="08f9" class="mq mr it kq b kr mz kv na kz nb ld nc lh nd ll mv mw mx my bi translated">异议关系映射:开发人员还可以创建对象，然后将这些对象映射到特定的数据库字段。当需要执行查询时，查询将发生在数据对象集合上，而不再发生在数据库本身上，这为SQLi消除了一个很大的攻击媒介</li><li id="88d2" class="mq mr it kq b kr mz kv na kz nb ld nc lh nd ll mv mw mx my bi translated">准备好的语句:对于需要直接与数据库交互的地方，总是建议使用准备好的语句。使用它们比直接创建数据库请求更安全。</li><li id="7333" class="mq mr it kq b kr mz kv na kz nb ld nc lh nd ll mv mw mx my bi translated">无论我们决定做什么，在用户输入与我们的程序交互时，净化用户输入是至关重要的</li></ul><h1 id="da19" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">操作系统命令注入</h1><h2 id="f5b0" class="lv jr it bd js mf mg dn jw mh mi dp ka kz mj mk ke ld ml mm ki lh mn mo km mp bi translated">这是什么？</h2><p id="c3c8" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我们可以控制传递给shell的参数时，就会发生命令注入。如果输入没有得到安全的处理和适当的清理，我们可以在输入中插入一个命令，并让shell执行它。根据该shell的功能和权限，我们可以执行各种命令。</p><figure class="lm ln lo lp gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nf"><img src="../Images/b031446ecad4836b70def5ff81df170d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1HCMaEzroObeYi0t1cVs9Q.png"/></div></div></figure><p id="f2de" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated">这个理论听起来很简单，但是发现这种漏洞一点也不简单。</p><h1 id="4e62" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">攻击策略</h1><p id="f347" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">命令注入如此难以发现的原因是因为我们从来不知道我们的哪个进程将触发后端shell执行。这意味着我们需要模糊我们找到的每一个参数，但是你可能想知道用什么字符来模糊。为了确定这一点，我们首先需要讨论哪些命令分隔符可以使用，以及哪些命令。</p><h1 id="665e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">分离器</h1><p id="0a13" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">以下命令分隔符在基于Windows和Unix的系统上都有效:</p><ul class=""><li id="53dd" class="mq mr it kq b kr ma kv mb kz ms ld mt lh mu ll mv mw mx my bi translated"><code class="fe nn no np lr b">&amp;</code></li><li id="589f" class="mq mr it kq b kr mz kv na kz nb ld nc lh nd ll mv mw mx my bi translated"><code class="fe nn no np lr b">&amp;&amp;</code></li><li id="65c6" class="mq mr it kq b kr mz kv na kz nb ld nc lh nd ll mv mw mx my bi translated"><code class="fe nn no np lr b">|</code></li><li id="56fd" class="mq mr it kq b kr mz kv na kz nb ld nc lh nd ll mv mw mx my bi translated"><code class="fe nn no np lr b">||</code></li></ul><p id="dab7" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated">以下命令分隔符仅适用于基于Unix的系统:</p><ul class=""><li id="a3e2" class="mq mr it kq b kr ma kv mb kz ms ld mt lh mu ll mv mw mx my bi translated"><code class="fe nn no np lr b">;</code></li><li id="5256" class="mq mr it kq b kr mz kv na kz nb ld nc lh nd ll mv mw mx my bi translated">换行(<code class="fe nn no np lr b">0x0a</code>或<code class="fe nn no np lr b">\\n</code>)</li></ul><p id="627e" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated">在基于Unix的系统上，您还可以使用反斜杠或美元字符在原始命令中执行插入命令的内联执行:</p><ul class=""><li id="2f85" class="mq mr it kq b kr ma kv mb kz ms ld mt lh mu ll mv mw mx my bi translated"><code class="fe nn no np lr b">injected command</code></li><li id="e748" class="mq mr it kq b kr mz kv na kz nb ld nc lh nd ll mv mw mx my bi translated"><code class="fe nn no np lr b">$(</code>注入命令<code class="fe nn no np lr b">)</code></li></ul><h1 id="bd01" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">命令</h1><p id="c29d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面是在Linux和Windows平台上有用的一些命令的摘要:</p><p id="0cfa" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated"><a class="ae ne" href="https://www.notion.so/8ed7d380f0a740dfbdb72395dccf7cc8" rel="noopener ugc nofollow" target="_blank"> Linux和windows命令</a></p><h1 id="c847" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">模糊列表</h1><p id="90fd" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在此基础上，我们可以创建一个模糊列表，包含所有分隔符和所有可能的命令。我将把这个留给你，因为它应该是一个很好的练习。如果你对此有任何问题，请随时联系我。</p><p id="0a48" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated">通过使用burp intruder模糊您可以在这个世界列表中找到的每个参数。</p><p id="b0c3" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated">正如你在截图中看到的，我们加载了模糊列表并标记了我们想要测试的参数。</p><figure class="lm ln lo lp gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nq"><img src="../Images/4d173f1e90b6a3517a9a1c3e4c7c6386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVAO9rvFXTcn1SY7M1BEIw.png"/></div></div></figure><figure class="lm ln lo lp gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nr"><img src="../Images/3201aca39466a9a695296f33f84e27b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*orgU3FbZFIhM3ohMiTWb3g.png"/></div></div></figure><h1 id="0ae1" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">盲目命令注入</h1><p id="1968" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以通过向环回地址发出执行ping命令的请求来测试盲命令注入。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="a854" class="lv jr it lr b gy lw lx l ly lz">&amp; ping -c 10 127.0.0.1 &amp;</span></pre><p id="e7fb" class="pw-post-body-paragraph ko kp it kq b kr ma kt ku kv mb kx ky kz mc lb lc ld md lf lg lh me lj lk ll im bi translated">同样，将这一点添加到您的模糊列表中，并注意这种攻击媒介的响应时间。如果超过10秒，我们可能有一个盲目的命令注入，但要注意可能会出现延迟，并给出一个错误的肯定。</p></div></div>    
</body>
</html>