<html>
<head>
<title>Let’s talk about buffer overflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们来谈谈缓冲区溢出</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/lets-talk-about-buffer-overflow-54764101030b?source=collection_archive---------1-----------------------#2020-08-17">https://infosecwriteups.com/lets-talk-about-buffer-overflow-54764101030b?source=collection_archive---------1-----------------------#2020-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6a91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当放入固定长度<strong class="js iu">缓冲器</strong>的额外数据超过<strong class="js iu">缓冲器</strong>所能管理的数量时，就会发生<strong class="js iu">缓冲器溢出</strong>，或<strong class="js iu">缓冲器溢出</strong>。</p><p id="adad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">缓冲区溢出可能是软件安全漏洞最广为人知的形式。大多数软件开发人员都知道什么是缓冲区溢出漏洞，但是与旧的和新开发的应用程序相对应的缓冲区溢出攻击仍然非常明显。部分困难是由于缓冲区溢出可能发生的方式种类繁多，部分困难是由于经常用来防止缓冲区溢出的容易出错的过程。</p><p id="a4c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在典型的缓冲区溢出利用中，攻击者将数据传输到一个程序，并将其存储在一个过小的堆栈缓冲区中。结果是调用堆栈上的数据被覆盖，包括函数的返回指针。数据设置返回指针的值，以便当函数返回时，它将控制权交给包含在攻击者数据中的恶意代码。</p><p id="07f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管这种类型的堆栈缓冲区溢出在一些策略和开发社区中仍然很普遍，但也混合了其他类型的缓冲区溢出，包括堆缓冲区溢出和其他缓冲区之间的逐个错误。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/2342c9e35209c4ecf86654bb1ea1838f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D89RU58NsgWw2ohreS_7Fg.png"/></div></div></figure><p id="b76a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在代码级别，缓冲区溢出漏洞通常需要破坏程序员的理论。C和C++中的许多内存操作函数不执行边界终止，并且很容易覆盖它们所操作的缓冲区的指定边界。即使是有界函数，比如<code class="fe la lb lc ld b">strncpy()</code>，如果使用不当也会导致漏洞。大多数缓冲区溢出的问题是内存操作和对数据大小或组成的错误假设的结合。</p><p id="d8b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">缓冲区溢出漏洞通常出现在以下代码中:</p><p id="1c6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">-依赖外部数据来控制其行为。</p><p id="c370" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">-取决于在代码的快速范围之外实施的数据的特征。</p><ul class=""><li id="7cf4" class="le lf it js b jt ju jx jy kb lg kf lh kj li kn lj lk ll lm bi translated">非常复杂，以至于程序员无法准确预测它的行为。</li></ul><p id="09c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是第二种情况的一部分，其中代码依赖于未在本地验证的数据部分。在这个模式中，一个名为<code class="fe la lb lc ld b">lccopy()</code>的函数将一个序列作为其参数，并返回一个字符串的堆分配副本，其中所有大写字母都转换为小写字母。该函数不会对其输入进行边界检查，因为它希望<code class="fe la lb lc ld b">str</code>总是小于<code class="fe la lb lc ld b">BUFSIZE</code>。如果攻击者绕过调用代码中的检查，或者如果代码中的更改占用了<code class="fe la lb lc ld b">str</code> false的大小，那么<code class="fe la lb lc ld b">lccopy()</code>将溢出<code class="fe la lb lc ld b">buf</code>，对<code class="fe la lb lc ld b">strcpy()</code>进行无限制调用。</p><pre class="kp kq kr ks gt ln ld lo lp aw lq bi"><span id="7a17" class="lr ls it ld b gy lt lu l lv lw">char *lccopy(const char *str) {<br/>char buf[BUFSIZE];<br/>char *p;</span><span id="2c8a" class="lr ls it ld b gy lx lu l lv lw">strcpy(buf, str);<br/>for (p = buf; *p; p++) {<br/>if (isupper(*p)) {<br/>*p = tolower(*p);<br/>}<br/>}<br/>return strdup(buf);<br/>}</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="34b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的示例代码演示了一个简单的缓冲区溢出，这通常是由代码依赖外部数据来控制其行为的第一种情况引起的。代码使用<code class="fe la lb lc ld b">gets()</code>将任意数量的数据读入堆栈缓冲区。因为没有办法限制这个函数读取的数据的数量，所以代码的安全性依赖于用户总是输入少于<code class="fe la lb lc ld b">BUFSIZE</code>的字符。</p><pre class="kp kq kr ks gt ln ld lo lp aw lq bi"><span id="6bd2" class="lr ls it ld b gy lt lu l lv lw">...<br/>char buf[BUFSIZE];<br/>gets(buf);<br/>...<br/></span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="7949" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个例子展示了在C++中通过使用<code class="fe la lb lc ld b">&gt;&gt;</code>操作符将输入读入<code class="fe la lb lc ld b">char[]</code>字符串来模仿<code class="fe la lb lc ld b">gets()</code>函数的不安全行为是多么容易。</p><pre class="kp kq kr ks gt ln ld lo lp aw lq bi"><span id="8848" class="lr ls it ld b gy lt lu l lv lw">...<br/>char buf[BUFSIZE];<br/>cin &gt;&gt; (buf);<br/>...</span></pre><p id="c584" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本例中的代码也依赖于用户输入来管理其行为，但是它通过使用有界内存复制函数<code class="fe la lb lc ld b">memcpy()</code>增加了一个间接层。这个函数接受一个目标缓冲区、一个引用缓冲区和要复制的字节数。buffer的信息由对的有界调用填充，但是用户指定<code class="fe la lb lc ld b">memcpy()</code>复制的字节数。</p><pre class="kp kq kr ks gt ln ld lo lp aw lq bi"><span id="a99a" class="lr ls it ld b gy lt lu l lv lw">...<br/>char buf[64], in[MAX_SIZE];<br/>printf("Enter buffer contents:\n");<br/>read(0, in, MAX_SIZE-1);<br/>printf("Bytes to copy:\n");<br/>scanf("%d", &amp;bytes);<br/>memcpy(buf, in, bytes);<br/>...</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="d913" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码描述了第三种情况，在这种情况下，代码非常复杂，其性能很难预测。这段代码来自流行的libPNG图像解码器，它被许多应用程序使用，包括Mozilla和一些其他浏览器。</p><p id="33b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该代码看起来安全地执行了边界检查，因为它检查了变量length的大小，稍后它将使用该变量来控制由<code class="fe la lb lc ld b">png_crc_read()</code>复制的数据量。然而，在测试长度之前，代码会对<code class="fe la lb lc ld b">png_ptr-&gt;mode</code>进行检查，如果检查失败，就会发出警告，处理继续进行。由于<code class="fe la lb lc ld b">length</code>是在<code class="fe la lb lc ld b">else if</code>块中测试的，如果第一次检查失败的话，<code class="fe la lb lc ld b">length</code>将不会被测试，并且在对<code class="fe la lb lc ld b">png_crc_read()</code>的调用中被盲目使用，潜在地允许堆栈缓冲区溢出。</p><p id="2465" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这个例子中的代码不是我们见过的最复杂的，但是它演示了为什么在执行内存操作的代码中应该最小化复杂性。</p><pre class="kp kq kr ks gt ln ld lo lp aw lq bi"><span id="daa8" class="lr ls it ld b gy lt lu l lv lw">if (!(png_ptr-&gt;mode &amp; PNG_HAVE_PLTE)) {<br/>/* Should be an error, but we can cope with it */<br/>png_warning(png_ptr, "Missing PLTE before tRNS");<br/>}<br/>else if (length &gt; (png_uint_32)png_ptr-&gt;num_palette) {<br/>png_warning(png_ptr, "Incorrect tRNS chunk length");<br/>png_crc_finish(png_ptr, length);<br/>return;<br/>}<br/>...<br/>png_crc_read(png_ptr, readbuf, (png_size_t)length);</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="cbae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此示例还演示了第三种情况，其中程序的复杂性使其暴露于缓冲区溢出。在这种情况下，暴露是由于其中一个函数的不明确的接口，而不是代码的结构(如前一个示例中的情况)。</p><p id="a973" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">getUserInfo()</code>该函数采用多字节字符串形式的用户名和指向用户信息结构的指针，并用用户信息填充该结构。因为Windows身份验证使用Unicode作为用户名，所以参数<code class="fe la lb lc ld b">username</code>首先从多字节字符串转换为Unicode字符串。<code class="fe la lb lc ld b">(UNLEN+1)*sizeof(WCHAR)*sizeof(WCHAR)</code>字节，到<code class="fe la lb lc ld b">unicodeUser</code>数组，该数组只分配了<code class="fe la lb lc ld b">(UNLEN+1)*sizeof(WCHAR)</code>字节。如果<code class="fe la lb lc ld b">username</code>字符串包含的字符多于<code class="fe la lb lc ld b">UNLEN</code>字符，那么对<code class="fe la lb lc ld b">MultiByteToWideChar()</code>的调用将溢出缓冲区<code class="fe la lb lc ld b">unicodeUser</code>。</p><pre class="kp kq kr ks gt ln ld lo lp aw lq bi"><span id="986d" class="lr ls it ld b gy lt lu l lv lw">void getUserInfo(char *username, struct _USER_INFO_2 info){<br/>WCHAR unicodeUser[UNLEN+1];<br/>MultiByteToWideChar(CP_ACP, 0, username, -1,<br/>unicodeUser, sizeof(unicodeUser));<br/>NetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&amp;info);<br/>}</span></pre><h1 id="a0c6" class="mf ls it bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">建议</h1><p id="0b8d" class="pw-post-body-paragraph jq jr it js b jt nc jv jw jx nd jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">切勿使用固有不安全的功能，如<code class="fe la lb lc ld b">gets()</code>，避免使用难以安全使用的功能，如<code class="fe la lb lc ld b">strcpy()</code>。将无界函数如<code class="fe la lb lc ld b">strcpy()</code>替换为它们的有界等价函数，如<code class="fe la lb lc ld b">strncpy()</code>或<code class="fe la lb lc ld b">strsafe.h </code>中定义的WinAPI函数。</p><p id="b5ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管谨慎使用有界函数可以极大地降低缓冲区溢出的风险，但这种迁移不能盲目进行，而且其本身不足以确保安全性。每当您操作内存(尤其是字符串)时，就会发现缓冲区溢出漏洞通常发生在以下代码中:</p><p id="657b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">-依赖外部数据来控制其行为</p><p id="9e4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">-依赖于在代码直接范围之外实施的数据属性</p><p id="d3a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">-非常复杂，程序员无法准确预测它的行为。</p><p id="1be1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，请考虑以下原则:</p><p id="77ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">-切勿相信外部来源会为内存操作提供正确的控制信息。</p><p id="a8b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">-永远不要相信你的程序所操作的数据的属性会在整个程序中得到维护。在对数据进行操作之前，对数据进行完整性检查。</p><p id="7a01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">-限制内存操作和边界检查代码的复杂性。保持简单，清楚地记录您执行的检查、您测试的假设，以及在输入验证失败的情况下程序的预期行为。</p><p id="5446" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">-当输入数据太大时，要小心截断数据并继续处理它。截断会改变输入的含义。</p><ul class=""><li id="1d69" class="le lf it js b jt ju jx jy kb lg kf lh kj li kn lj lk ll lm bi translated">不要依赖StackGuard或不可执行堆栈等工具来防止缓冲区溢出漏洞。这些方法不能解决堆缓冲区溢出和更微妙的堆栈溢出，这些溢出会改变控制程序的变量的内容。此外，这些方法中的许多很容易被击败，即使它们正常工作，它们也只能解决问题的症状而不能解决问题的原因。</li></ul></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="faa1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Windows上，不太安全的函数<code class="fe la lb lc ld b">memcpy()</code>可以用它们更安全的版本代替，比如<code class="fe la lb lc ld b">memcpy_s()</code>。然而，这仍然需要谨慎行事。因为<code class="fe la lb lc ld b">_s</code>函数族提供的参数验证各不相同，依赖它会导致意想不到的行为。此外，错误地指定目标缓冲区的大小仍然会导致缓冲区溢出。</p></div></div>    
</body>
</html>