<html>
<head>
<title>Let’s Figure out how Notepad Supports Unix Line Endings (Part I)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们弄清楚记事本是如何支持Unix行尾的(第一部分)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/lets-figure-out-how-notepad-supports-unix-line-endings-part-i-26d54b29cf93?source=collection_archive---------0-----------------------#2018-05-11">https://infosecwriteups.com/lets-figure-out-how-notepad-supports-unix-line-endings-part-i-26d54b29cf93?source=collection_archive---------0-----------------------#2018-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="295a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微软最近<a class="ae kl" href="https://blogs.msdn.microsoft.com/commandline/2018/05/08/extended-eol-in-notepad/" rel="noopener ugc nofollow" target="_blank">宣布</a>记事本将支持Unix和Mac行尾，从当前的Windows 10 Insider预览版(RS5)开始。这是一个很棒的新功能！看了这个公告，很好奇微软内部是怎么实现这个功能的。在这篇文章中，我将向你展示我是如何通过逆向工程解决这个问题的。微软为大多数Windows可执行文件提供了<a class="ae kl" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/microsoft-public-symbols" rel="noopener ugc nofollow" target="_blank"> PDB符号</a>，所以要反转它们并不难。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d6e227f67b9f2c4b6f8ce54594ecee32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76zvjQxI1-AlE_OPQ0rPHA.jpeg"/></div></div></figure><p id="2d54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要准备反转，请在记事本中打开一个Linux文件，然后将WinDbg附加到notepad.exe进程，或者直接在WinDbg下启动记事本。</p><p id="cfd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">起初，我以为对不同行尾的处理是在notepad.exe本身实现的。因此，我在WinDbg中列出了notepad.exe的符号，试图找出是否有任何行尾相关的函数:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="9bdd" class="ld le iq kz b gy lf lg l lh li">0:000&gt; x notepad!*Linux*<br/>0:000&gt; x notepad!*Unix*<br/>0:000&gt; x notepad!*LineEnd*</span></pre><p id="20ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们都不返回任何内容，所以显然行尾不是由记事本处理的。记事本使用<a class="ae kl" href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb775458.aspx" rel="noopener ugc nofollow" target="_blank">编辑控件</a>作为其输入区域。因此，我的下一个猜测是它们受Windows控件支持，通过Windows APIs向记事本公开。</p><p id="0d20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了简单起见，我用下面的命令枚举所有已加载模块的符号:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="4792" class="ld le iq kz b gy lf lg l lh li">0:000&gt; x *!*Linux*<br/>0:000&gt; x *!*Unix*<br/>0:000&gt; x *!*LineEnd*</span></pre><p id="94e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，最后一个命令返回三个符号:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="39f1" class="ld le iq kz b gy lf lg l lh li">6f725110 COMCTL32!EditML_GetLineEndingType (&lt;no parameter info&gt;)6f7254e6 COMCTL32!EditML_SetLineEndingType (&lt;no parameter info&gt;)6f7250e2 COMCTL32!EditML_GetLineEndingCharacter (&lt;no parameter info&gt;)</span></pre><p id="a890" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确保这三个功能确实相关，我决定检查它们是否已经存在于Windows 10版本1803中:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="4b1d" class="ld le iq kz b gy lf lg l lh li">0:000&gt; x comctl32!*LineEnd*<br/>0:000&gt; vertarget<br/>Windows 10 Version 17134 MP (4 procs) Free x86 compatible<br/>Product: WinNt, suite: SingleUserTS<br/>17134.1.x86fre.rs4_release.180410–1804</span></pre><p id="57c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">的确，它们是新功能——只存在于Windows 10预览版上。这三个函数表明编辑公共控件支持行尾，在<code class="fe lj lk ll kz b">comctl32.dll</code>中实现。注意<code class="fe lj lk ll kz b">user32.dll</code>和<code class="fe lj lk ll kz b">comctl32.dll</code>有不同的编辑控件实现，应用程序可以选择使用哪一个。<code class="fe lj lk ll kz b">comctl32.dll</code>实现比<code class="fe lj lk ll kz b">user32.dll</code>更新，支持更多特性。这里我们只需要分析<code class="fe lj lk ll kz b">comctl32.dll</code>。</p><p id="9a85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，在这三个函数上设置断点:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="2f05" class="ld le iq kz b gy lf lg l lh li">0:001&gt; bm comctl32!*LineEnding*<br/>1: 6f7c5110 @!”COMCTL32!EditML_GetLineEndingType”<br/>2: 6f7c54e6 @!”COMCTL32!EditML_SetLineEndingType”<br/>3: 6f7c50e2 @!”COMCTL32!EditML_GetLineEndingCharacter”<br/>0:001&gt; g</span></pre><p id="59af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">立即命中断点1:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="efb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顾名思义，功能<code class="fe lj lk ll kz b">UpdateStatusBarEOL</code>(帧#07)的目的是更新状态栏上的行尾指示器。该函数调用<code class="fe lj lk ll kz b">SendMessageW </code>向编辑控件发送窗口消息，以获取行尾类型。消息ID是0x150D。调用堆栈还表明这个窗口消息最终由<code class="fe lj lk ll kz b">COMCTL32!EditML_GetLineEndingType</code>处理。它的返回值随后被传递回<code class="fe lj lk ll kz b">SendMessageW</code>的调用者，在本例中是<code class="fe lj lk ll kz b">UpdateStatusBarEOL</code>。</p><p id="4916" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了理解<code class="fe lj lk ll kz b">COMCTL32!EditML_GetLineEndingType</code>返回值的含义，我把<code class="fe lj lk ll kz b">Notepad!UpdateStatusBarEOL</code>反过来:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="10a1" class="ld le iq kz b gy lf lg l lh li">// global variables:<br/>const wchar_t szEOLCRLF[] = L” Windows (CRLF)”;<br/>const wchar_t szEOLCRLF[] = L” Macintosh (CR)”;<br/>const wchar_t szEOLCRLF[] = L” Unix (LF)”;</span><span id="367d" class="ld le iq kz b gy lo lg l lh li">void UpdateStatusBarEOL()<br/>{<br/>    wchar_t buf[0x80];<br/>    int lineEndingType = SendMessageW(hwndEdit, 0x150D, 0, 0);<br/>    switch (lineEndingType)<br/>    {<br/>    case 1:<br/>        StringCchPrintfW(buf, 0x80, szEOLCRLF);<br/>        break;<br/>    case 2:<br/>        StringCchPrintfW(buf, 0x80, szEOLCR);<br/>        break;<br/>    case 3:<br/>        StringCchPrintfW(buf, 0x80, szEOLLF);<br/>        break;<br/>    default:<br/>        StringCchPrintfW(buf, 0x80, szEOLCRLF);<br/>    }<br/>    SendMessageW(hwndStatus, 0x040B, 1, buf);<br/>}</span></pre><p id="95d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面的代码中，我们知道类型代码1对应于CRLF，2对应于CR，3对应于LF。</p><p id="ffd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可惜，<code class="fe lj lk ll kz b">COMCTL32!EditML_SetLineEndingType</code>从来不叫。所以为了弄清楚如何调用它，我在IDA Pro中打开了comctl32.dll，并搜索了这个函数。IDA Pro的一个很好的特性是，您可以通过选择函数定义并按X:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lp"><img src="../Images/602a1613ed382bd212bf56f844aa180c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwV3yy-4zVig0iEA6DgIxA.jpeg"/></div></div></figure><p id="1cc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lj lk ll kz b">COMCTL32!EditML_SetLineEndingType</code>由<code class="fe lj lk ll kz b">COMCTL32!EditML_WndProc</code>调用，这显然是编辑控件的窗口过程回调。这个窗口程序的主体基本上是一个大的跳转表。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lq"><img src="../Images/bbdd91105736f2947d51dbee2d1030be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZEReV0plU3DNoZ_JSC2_w.png"/></div></div></figure><p id="defe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从反汇编中不难发现<code class="fe lj lk ll kz b">SetLineEndingType</code>的消息ID、<code class="fe lj lk ll kz b">wParam</code>和<code class="fe lj lk ll kz b">lParam</code>。结果是:报文ID为0x150C，<code class="fe lj lk ll kz b">wParam </code>为行尾类型，不使用<code class="fe lj lk ll kz b">lParam</code>。这意味着我们可以通过调用<code class="fe lj lk ll kz b">SendMessageW(hwndEdit, 0x150C, &lt;type code&gt;, 0);</code>来设置行尾类型</p><p id="e422" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试我目前的发现，我编写了一个小的测试程序。我希望，如果我在Windows 10预览版上运行它，编辑框应该能够识别Unix和Mac行尾，并且我应该能够通过分别发送消息0x150D和0x150C来获取和设置行尾类型。但是结果是编辑控件不理解非Windows行尾，即使我已经调用了<code class="fe lj lk ll kz b">SendMessageW</code>将行尾类型设置为Unix或Mac:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/f196056c117908242ae9a854767b6adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*vPa7fQBb1Euoz7i6mYkdnQ.jpeg"/></div></figure><p id="db18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们知道了如何获取和设置行尾类型。第二部分将讨论我采取的修复错误的步骤，并使编辑控件完全识别所有行尾。</p></div></div>    
</body>
</html>