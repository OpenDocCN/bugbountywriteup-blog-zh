<html>
<head>
<title>The toddler’s introduction to Heap Exploitation, Unsafe Unlink(Part 4.3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学走路的孩子对堆利用的介绍，不安全的解除链接(第4.3部分)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-unsafe-unlink-part-4-3-75e00e1b0c68?source=collection_archive---------1-----------------------#2022-05-07">https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-unsafe-unlink-part-4-3-75e00e1b0c68?source=collection_archive---------1-----------------------#2022-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="43a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">利用堆溢出漏洞并不总是简单的。除此之外，分配器在块分配/释放过程中进行各种检查，这需要额外的步骤来实现可利用的结果。在本帖中，我们假设我们已经发现了这样一个漏洞，我们将探索“下一步”以成功利用它。更具体地说，我们将操作<code class="fe kl km kn ko b"><a class="ae kp" href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344" rel="noopener ugc nofollow" target="_blank">unlink</a></code> <a class="ae kp" href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344" rel="noopener ugc nofollow" target="_blank">宏</a>，以便允许我们控制一个任意指针并修改它所指向的数据。在特定条件下(比如一个指向函数的指针)，我们可能会重定向代码执行，并能够运行任意命令。</p></div><div class="ab cl kq kr hu ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ij ik il im in"><p id="c7b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，请在下面找到我以前关于堆利用的帖子的参考:</p><ul class=""><li id="c373" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><a class="ae kp" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8" rel="noopener">堆剥削的幼儿介绍，介绍(第一部分)</a></li><li id="5240" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated"><a class="ae kp" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-2-d1f325b74286" rel="noopener">堆开发的幼儿入门，简介(第二部分)</a></li><li id="f346" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated"><a class="ae kp" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-overflows-part-3-d3d1aa042d1e" rel="noopener">初学走路的孩子对堆利用的介绍，溢出(第3部分)</a></li><li id="aea8" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated"><a class="ae kp" href="https://valsamaras.medium.com/use-after-free-13544be5a921" rel="noopener">堆剥削幼儿入门，免费后使用&amp;双免费(第四部分)</a></li><li id="0f48" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated"><a class="ae kp" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-to-stack-part-4-1-425592a2870b" rel="noopener">堆利用的幼儿入门，FastBin Dup to Stack(第4.1部分)</a></li><li id="e41e" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated"><a class="ae kp" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8" rel="noopener">堆利用的幼儿入门，FastBin Dup Consolidate(第4.2部分)</a></li></ul></div><div class="ab cl kq kr hu ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ij ik il im in"><h1 id="25dd" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">取消链接宏</h1><p id="203f" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我们从上一篇文章中看到，在块释放过程中，当特定条件发生时，分配器会将相邻的块合并成更大的块，以便更有效地分配内存。简单地说，假设你有块<code class="fe kl km kn ko b">A, B, C</code>和<code class="fe kl km kn ko b">B</code>被释放，那么根据当前的实现，<code class="fe kl km kn ko b">free</code>将检查<code class="fe kl km kn ko b">A</code>或<code class="fe kl km kn ko b">C</code>是否在使用中，如果它们不在使用中，它将试图通过将它们合并到<code class="fe kl km kn ko b">B</code>来创建一个更大的块。下面的代码片段描述了该逻辑的实现:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/4880614e3f5849cf1a6986897225eae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*60I2ODHTDAecpNQ8bVc7UQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated"><a class="ae kp" href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l3972" rel="noopener ugc nofollow" target="_blank">自由合并</a></figcaption></figure><p id="b99a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第<code class="fe kl km kn ko b">3977</code>和<code class="fe kl km kn ko b">3986</code>行的<code class="fe kl km kn ko b">unlink</code>宏之后，我们得出以下定义:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/b2693fa2053c5861f0dea517226c63ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YyOESyJctIWFU-c3zmPDWA.png"/></div></div></figure><p id="ebfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该代码将在双列表重新排列的上下文中修改(见第1350-1351行)块头的<strong class="jp ir"> fd </strong>和<strong class="jp ir"> bk </strong>指针(见下图):</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="ab gu cl nf"><img src="../Images/9a05b6abe8afa2462261717170a401ef.png" data-original-src="https://miro.medium.com/v2/format:webp/1*qFnKe3EL8is3u4GmF4ksVA.png"/></div></figure><p id="0a66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该过程类似于从双列表中删除节点:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ec2101f2a9d92f5f5e98107425eb7cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/1*qGcOcaXi9jPfKlyzcP1jeQ.gif"/></div></figure><p id="1133" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，在任何事情发生之前，执行有效性检查(在第1347行):</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/ad04d6451bbfea4de071f2245e8c2da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*k0n7zWSx86hVtgFr0E8Cog.png"/></div></figure><p id="524f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先注意到<code class="fe kl km kn ko b"><strong class="jp ir">FD = P→fd</strong></code>和<code class="fe kl km kn ko b"><strong class="jp ir">BK = P→bk</strong></code><strong class="jp ir"/>，所以<code class="fe kl km kn ko b"><strong class="jp ir">FD</strong></code> <strong class="jp ir"> </strong>应该指向下一个相邻的块，<code class="fe kl km kn ko b"><strong class="jp ir">BK</strong></code> <strong class="jp ir"> </strong>应该指向上一个相邻的块:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/37ec7b5275207192a13e401508d7f1ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*KKrddxzGzZa5Sj2gd63n1A.png"/></div></figure><p id="57a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，要使双链表<strong class="jp ir">有效</strong> <code class="fe kl km kn ko b"><strong class="jp ir">BK→fd</strong></code> <strong class="jp ir">和</strong> <code class="fe kl km kn ko b"><strong class="jp ir">FD→bk</strong></code> <strong class="jp ir">必须指向</strong> <code class="fe kl km kn ko b"><strong class="jp ir">P</strong></code> <strong class="jp ir"> </strong>:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/f3c1c191b662e4d1aa15564a325b741b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*h3-ZYPLqMmUA5mfvE-M8TA.png"/></div></figure><p id="9ad3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查完这个条件后，我们有了下面的赋值<code class="fe kl km kn ko b"><strong class="jp ir">FD-&gt;bk = BK</strong></code>和<code class="fe kl km kn ko b"><strong class="jp ir">BK-&gt;fd = FD</strong></code>，所以我们的块现在看起来如下:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/b850b2efa32496ca01e96ab5247516fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*0OKWy0y2pAECbvPBvMXkyw.png"/></div></figure><h1 id="5d4a" class="ll lm iq bd ln lo nl lq lr ls nm lu lv lw nn ly lz ma no mc md me np mg mh mi bi translated">开采计划</h1><p id="ba71" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">正如我们在文章开头提到的，我们完全控制块的内容，由于溢出错误，我们可以修改相邻块的元数据。因此，在我们成功利用的过程中，我们必须通过<strong class="jp ir">解除链接检查</strong>:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nq"><img src="../Images/0b1ea640ed74f3cc9f2f51fc091002a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5A6c6Pzl55Ubp2kOQFEVg.png"/></div></div></figure><p id="4894" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了做到这一点，我们将执行以下操作:</p><blockquote class="nr ns nt"><p id="d796" class="jn jo nu jp b jq jr js jt ju jv jw jx nv jz ka kb nw kd ke kf nx kh ki kj kk ij bi translated"><strong class="jp ir">在受控块内创建一个假块</strong></p></blockquote><p id="ca01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将向特定的内存地址插入特定的值，以便在受控块的数据扇区内形成有效的块结构:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ny"><img src="../Images/07b465f6126817756c3c61e3a7fafdfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qPbC_kaa63QRlG8PgtI5lQ.png"/></div></div></figure><p id="9fc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">当我们想要通过解除链接检查时，我们将要在假块中作为</strong> <code class="fe kl km kn ko b"><strong class="jp ir">fd</strong></code> <strong class="jp ir">和</strong> <code class="fe kl km kn ko b"><strong class="jp ir">bk</strong></code> <strong class="jp ir">插入的值必须指向它们各自的</strong> <code class="fe kl km kn ko b"><strong class="jp ir">fd</strong></code> <strong class="jp ir">和</strong> <code class="fe kl km kn ko b"><strong class="jp ir">bk</strong></code> <strong class="jp ir">指针将指向我们的假块的结构！为了形象化这个概念，让我们看几个图:</strong></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nz"><img src="../Images/ec2748dae878e2674b1b649f625966bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eH42FpRs0oKP85061cji7Q.png"/></div></div></figure><p id="bf4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设<code class="fe kl km kn ko b"><strong class="jp ir">Global_Var</strong></code>表形成了一个块结构，那么在内存地址<code class="fe kl km kn ko b">0x6020b0</code>我们会有前一个块的大小，在<code class="fe kl km kn ko b">0x6020b8</code>有当前块的大小，在<code class="fe kl km kn ko b">0x6020c0</code>有fd指针，在<code class="fe kl km kn ko b">0x6020c8</code>有bk指针。所以我们有<code class="fe kl km kn ko b">fake_chunk.fd→bk = 0x1967030</code>和<code class="fe kl km kn ko b"> fake_chunk.bk →fd=0x1967030</code>，它们将通过解除链接验证检查。</p><p id="000f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步:</p><blockquote class="nr ns nt"><p id="b59f" class="jn jo nu jp b jq jr js jt ju jv jw jx nv jz ka kb nw kd ke kf nx kh ki kj kk ij bi translated"><strong class="jp ir">修改下一个数据块的标题，以便显示空闲的假数据块</strong></p></blockquote><p id="faf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住:由于堆溢出，我们可以写超出<strong class="jp ir">控制的块的</strong>边界，因此我们可以修改<strong class="jp ir">下一个块的头:</strong></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/852294e21c186491bfdbf663346d5996.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*WD0oY6NmelBHpDcEm-46HA.png"/></div></figure><p id="d2b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于修改的类型，回想一下，当且仅当前一个块空闲时，分配的块的头部由<strong class="jp ir">当前大小</strong>和<strong class="jp ir">前一个块的大小</strong>组成。我再一次发布块结构，这样你就不用向上滚动了:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="ab gu cl nf"><img src="../Images/9a05b6abe8afa2462261717170a401ef.png" data-original-src="https://miro.medium.com/v2/format:webp/1*qFnKe3EL8is3u4GmF4ksVA.png"/></div></figure><p id="a86b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还要记住，<strong class="jp ir"> mchunk_size </strong>嵌入了由值的最后3位指示的3个标志。因此，如果大小为<code class="fe kl km kn ko b"><strong class="jp ir">0x10</strong></code> <strong class="jp ir"> </strong>并且前一个块正在使用中，则<strong class="jp ir"> mchunk_size </strong>将如下所示:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/6a92561e9e61da2e2aa052f53b3c32a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*zJTZs4Th-_jSjGaYSIsUEQ.png"/></div></figure><p id="7cd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在不关心其余的标志，因为我们只需要翻转最后一位，以便<strong class="jp ir">指示前一个块没有被使用</strong>。<strong class="jp ir">这将触发向后合并过程，反过来将触发unlink宏。</strong></p><p id="d876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后但同样重要的是，<strong class="jp ir"> mchunk_prev_size </strong>还必须对应于假块的大小，以便绕过其余的安全检查。如果一切正常，当<strong class="jp ir">下一个块</strong>时，<strong class="jp ir">假块</strong>将被合并，假块的fd、bk指针将在两个后续步骤中被覆盖:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/f80306ccd3b950b44b6e61083d60981b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*GbhLD416cTHcheBJHdLE6g.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated"><strong class="bd ln">第一步:执行完第1350行后</strong></figcaption></figure><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/032fd55f487c870c25e98fadc1cb7c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*LANmNtz_sSvwOz-Sd5c98Q.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated"><strong class="bd ln">第二步:执行完第1351行后</strong></figcaption></figure><p id="0391" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是下一个棘手的部分，<strong class="jp ir">受控块指向它的数据部分，所以通过修改块[0]就像修改fd指向的内容，因为我们控制fd将指向的位置(通过块[3])，所以我们可以控制块[3]中包含的地址的内容。</strong></p><h1 id="698d" class="ll lm iq bd ln lo nl lq lr ls nm lu lv lw nn ly lz ma no mc md me np mg mh mi bi translated">陈列柜</h1><p id="2ca9" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">假设下面的C程序:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="baf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一行一行来搞清楚这件事。在<code class="fe kl km kn ko b"><strong class="jp ir">Line 6</strong></code> <strong class="jp ir"> </strong>我们定义了一个指针，指向一个返回void且不带任何参数的函数。在<code class="fe kl km kn ko b"><strong class="jp ir">Line 8</strong></code> <strong class="jp ir"> </strong>我们定义了一个指向无符号整数的指针，在<code class="fe kl km kn ko b"><strong class="jp ir">Lines 10 to 17</strong></code> <strong class="jp ir"> </strong>我们定义了两个函数，完全不做任何事情的<strong class="jp ir"> doNothing </strong>和弹出shell的<strong class="jp ir"> shell </strong>。在<code class="fe kl km kn ko b"><strong class="jp ir">Line 26</strong></code> <strong class="jp ir"> </strong>中，我们有<strong class="jp ir"> 0x420 </strong>字节的第一个malloc，所以在这条语句之后，我们将有以下块:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi of"><img src="../Images/104d9adb999568e03f02539e3017b8be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CV_p6D7RlBTN7zVpLLi1qw.png"/></div></div></figure><p id="e338" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此<code class="fe kl km kn ko b">chunk0_ptr</code>指向<code class="fe kl km kn ko b">0x5555555592a0</code>(数据块的数据部分)，而同一数据块的报头在<code class="fe kl km kn ko b">0x555555559290</code>之前开始0x10字节。最后，<code class="fe kl km kn ko b">chunk0_ptr</code>的地址在<code class="fe kl km kn ko b">0x555555558018</code>处，所以，在第一个malloc之后，我们有如下内容:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi og"><img src="../Images/00b6f15e040c23175f245042faa7e821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqRbG3dybQyJ6iv3sdNbXQ.png"/></div></div></figure><p id="5fb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe kl km kn ko b">Line 27</code>中，我们对malloc进行了第二次调用，之后我们的块将如下所示:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oh"><img src="../Images/f52c45ca17cb5839e1119b68a856fcca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7EM49pp3VoIBDSy45ONMA.png"/></div></div></figure></div><div class="ab cl kq kr hu ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ij ik il im in"><h2 id="1411" class="oi lm iq bd ln oj ok dn lr ol om dp lv jy on oo lz kc op oq md kg or os mh ot bi translated">创造一个假的大块</h2><p id="08da" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">现在我们到了这一部分，它对应于假块创建:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ou"><img src="../Images/b8173f1382ac9c7ee7b060c9069e0ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AAhqQQSKe5vfgAYzhOdQmQ.png"/></div></div></figure><p id="f145" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为<code class="fe kl km kn ko b">chunk0_ptr[-1]</code>是<code class="fe kl km kn ko b">0x431</code>，所以<code class="fe kl km kn ko b"><strong class="jp ir">Line 29</strong></code>将把假块的大小设置为<code class="fe kl km kn ko b">0x421</code></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/5675019f45c8a76ad4ed449b201e263a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*kMfcGgoj6skgnTrIS8FtLw.png"/></div></figure><p id="15c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且<code class="fe kl km kn ko b"><strong class="jp ir">Lines 30–31</strong></code>我们设置了假块的fd/bk指针:</p><pre class="mp mq mr ms gt ow ko ox oy aw oz bi"><span id="b11f" class="oi lm iq ko b gy pa pb l pc pd">chunk0_ptr[2] = 0x555555558018 — 3 * 8 = 0x555555558000<br/>chunk0_ptr[2] = 0x555555558018 — 3 * 8 = 0x555555558008</span></pre><p id="12bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们的受控块设置如下:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/bd71d82c124af34a7f443a124c590340.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*TBO3gkwTtTTVGfYKczW7Bg.png"/></div></figure><p id="3a8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将通过取消链接检查，就像您回忆取消链接检查一样，我们将得到以下内容:</p><pre class="mp mq mr ms gt ow ko ox oy aw oz bi"><span id="5729" class="oi lm iq ko b gy pa pb l pc pd">FD = P-&gt;fd =&gt; FD = 0x0000555555558000<br/>BK = P-&gt;bk =&gt; BK = 0x0000555555558008</span></pre><p id="5ca1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随后，<code class="fe kl km kn ko b">FD→bk</code>将向前移动<code class="fe kl km kn ko b">FD</code>指针3的位置(因为这是块标题<code class="fe kl km kn ko b">=&gt; 0x0000555555558000 + 0x18 = 0x0000555555558018)</code>中的<code class="fe kl km kn ko b">bk’s</code>位置),并且<code class="fe kl km kn ko b">FD→fd</code>将向前移动<code class="fe kl km kn ko b">BK</code>指针<code class="fe kl km kn ko b">2</code>的位置(因为这是块标题<code class="fe kl km kn ko b">=&gt; 0x0000555555558008 + 0x10 = 0x0000555555558018)</code>中的<code class="fe kl km kn ko b">fd’s</code>位置)</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi pf"><img src="../Images/e9f1952160b5159030f06c667defbb37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXZ2EKg5-9fy-JLpL91eyQ.png"/></div></div></figure><p id="1d15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总结一下，到目前为止，我们的设置如下:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi pg"><img src="../Images/ed6518a17f721e73643830eb8ad252df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SWQ3Ox8rY_cNl90k-8vzw.png"/></div></div></figure></div><div class="ab cl kq kr hu ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ij ik il im in"><h2 id="2e64" class="oi lm iq bd ln oj ok dn lr ol om dp lv jy on oo lz kc op oq md kg or os mh ot bi translated">“修复”下一个块的头</h2><p id="a128" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">这是容易掌握的部分:因为我们可以在受控块之外写入，所以覆盖相邻的块是微不足道的。这就是<code class="fe kl km kn ko b">Lines 33–35</code>演示的内容:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ph"><img src="../Images/a4befbd67f294cc80de5e0620fc42328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgAg8ShK2dQLhq7wmV30nQ.png"/></div></div></figure><p id="ae83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">chunk1_hdr[0]</code>将指向<code class="fe kl km kn ko b">mchunk_prev_size</code>而<code class="fe kl km kn ko b">chunk1_hdr[1]</code>指向当前尺寸。<code class="fe kl km kn ko b">Line 35</code>将翻转最后一位，使假块显示为未使用:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/544806b0045962305287f993ac7a1b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*qHXWcnp5gekdUCDvNgOHag.png"/></div></figure><p id="1d3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在准备拨打免费电话:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi pj"><img src="../Images/f4ea7133aa3ae95dfa2817cdfdbd5f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdmusTIdI1dKrrb5nYDD2A.png"/></div></div></figure></div><div class="ab cl kq kr hu ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ij ik il im in"><h2 id="a902" class="oi lm iq bd ln oj ok dn lr ol om dp lv jy on oo lz kc op oq md kg or os mh ot bi translated">免费后</h2><p id="2959" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">现在让我们看看自由函数的效果。请注意，在调用它之前，我们有以下内容:<code class="fe kl km kn ko b">*0x555555558018 = 0x00005555555592a0</code></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/2ddbc1822388b475d9d7cf455f247296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*jhK0ncIEbfkgicv-Jz2B8g.png"/></div></figure><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi pl"><img src="../Images/1406c229e6dad28c17563762a75006e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZC_y3cY-fbIideMQ7of9xA.png"/></div></div></figure><p id="2b2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而在<code class="fe kl km kn ko b">free</code>执行期间，将执行以下语句:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/98144c3da0641dbd69cbdeecbba10688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*a1Js2U5pFJ0-MuPrYMXYAA.png"/></div></figure><p id="4ac6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且立即:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/e61ae07ee7ba05d6b46bbbf456bbf5e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*8CTGXo0jE2LOElwePaXiLw.png"/></div></figure><p id="debe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi po"><img src="../Images/eab866d5f41a8c1218039fd63bbf7645.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*5aOv6dcHpMPjHhrs23c5_w.png"/></div></figure><p id="bb75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">最后注意到</strong>T21】</p></div><div class="ab cl kq kr hu ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ij ik il im in"><h2 id="dc54" class="oi lm iq bd ln oj ok dn lr ol om dp lv jy on oo lz kc op oq md kg or os mh ot bi translated">在任何地方写任何东西</h2><p id="859c" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">从我们的C程序中回忆一下免费调用后的下面几行:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi pp"><img src="../Images/fd7b38864ef6a2e8c28593924c0bc7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qu7BAcH7y2bB6uJleKHs2Q.png"/></div></div></figure><p id="be05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b"><strong class="jp ir">d</strong></code> <strong class="jp ir"> </strong>变量指向<code class="fe kl km kn ko b"><strong class="jp ir">doNothing</strong></code>函数<strong class="jp ir"> </strong>，但是由于我们控制了<code class="fe kl km kn ko b"><strong class="jp ir">chunk0_ptr</strong></code>的内容，我们可以修改<code class="fe kl km kn ko b"><strong class="jp ir">chunk0_ptr[3]</strong></code> <strong class="jp ir">、</strong>的值，因此在第41行之后我们将有以下内容:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/26540206af89c15c0110572636bf7d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*mGncvuKTUMkI2MUIrW6PUg.png"/></div></figure><p id="3d7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以它将是<code class="fe kl km kn ko b"><strong class="jp ir"><em class="nu">&amp;chunk0_ptr = 0x00007fffffffe338</em></strong></code> <strong class="jp ir"> </strong>，其中包含了做事情的地址。所以，<code class="fe kl km kn ko b"><strong class="jp ir">chunk0_ptr[0]</strong></code>分在这里:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/81586c5aa9812e3fb682b8bc5149d811.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*ukSCjnWzyk4HkMej-ibwzQ.png"/></div></figure><p id="b465" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此<strong class="jp ir">行42 </strong>将用外壳函数的地址覆盖该存储器地址的内容:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ps"><img src="../Images/87ee75a9484999afc658f73ff9d504a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_79_7Tp6l4oVKXC96JN10Q.png"/></div></div></figure><p id="c4b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这完成了最后一个开发步骤:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/2c7e8b2f426f8fbe9b48b7dfa6f222a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*uSv9F9H86DcK_K_3i34CmQ.png"/></div></figure></div></div>    
</body>
</html>