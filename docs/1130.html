<html>
<head>
<title>Let’s know How I have explored the buried secrets in Xamarin application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们知道我是如何探索Xamarin应用程序中隐藏的秘密的</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/lets-know-how-i-have-explored-the-buried-secrets-in-xamarin-application-d6b8c5609c87?source=collection_archive---------2-----------------------#2021-02-20">https://infosecwriteups.com/lets-know-how-i-have-explored-the-buried-secrets-in-xamarin-application-d6b8c5609c87?source=collection_archive---------2-----------------------#2021-02-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2954" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">移动应用渗透测试指南</h2><div class=""/><div class=""><h2 id="313b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Android逆向工程的新时代(下)</h2></div><blockquote class="kr ks kt"><p id="bd13" class="ku kv kw kx b ky kz kd la lb lc kg ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在<strong class="kx jd"> m </strong> <a class="ae lr" href="https://secureitmania.medium.com/lets-know-how-i-have-explored-the-buried-secrets-in-react-native-application-6236728198f7" rel="noopener"> <strong class="kx jd"> y上一篇文章</strong> </a> <strong class="kx jd"> </strong>中我解释了<strong class="kx jd"> React Native </strong>逆向工程技术。我又一次在基于Xamarin的应用程序中发现了一个bug，这是通过不同的方法而不是旧的逆向工程方法发现的。</p></blockquote><h2 id="66fa" class="ls lt it bd lu lv lw dn lx ly lz dp ma mb mc md me mf mg mh mi mj mk ml mm iz bi translated">简介:</h2><p id="4b0f" class="pw-post-body-paragraph ku kv it kx b ky mn kd la lb mo kg ld mb mp lg lh mf mq lk ll mj mr lo lp lq im bi translated">Xamarin是一个免费的<strong class="kx jd">开源移动应用平台</strong>，用于构建原生和高性能的<strong class="kx jd"> iOS </strong>、<strong class="kx jd"> Android </strong>、tvOS、watchOS、macOS和Windows。</p><h2 id="7e83" class="ls lt it bd lu lv lw dn lx ly lz dp ma mb mc md me mf mg mh mi mj mk ml mm iz bi translated">安卓逆向工程的老套方式</h2><p id="66b6" class="pw-post-body-paragraph ku kv it kx b ky mn kd la lb mo kg ld mb mp lg lh mf mq lk ll mj mr lo lp lq im bi translated">通常，在反转Android应用程序时，会使用<strong class="kx jd"> apktool、dex2jar </strong>进行反编译，然后使用<a class="ae lr" href="https://java-decompiler.github.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx jd"> JD-GUI </strong> </a>进行分析。当处理本机应用程序时，如果应用程序有您想要分析的任何<strong class="kx jd">本机代码</strong>，这可能是有用的。</p><p id="e18e" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld mb lf lg lh mf lj lk ll mj ln lo lp lq im bi translated">但很多时候，应用的核心逻辑在于”。<strong class="kx jd">不需要使用dex2jar就可以获得</strong>的dll”。</p><h1 id="6175" class="ms lt it bd lu mt mu mv lx mw mx my ma ki mz kj me kl na km mi ko nb kp mm nc bi translated">逆向工程过程:Xamarin应用</h1><p id="6fcf" class="pw-post-body-paragraph ku kv it kx b ky mn kd la lb mo kg ld mb mp lg lh mf mq lk ll mj mr lo lp lq im bi translated"><strong class="kx jd">步骤1 </strong>:让我们确认一下应用程序是否构建在Xamarin框架上。</p><p id="7cd6" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld mb lf lg lh mf lj lk ll mj ln lo lp lq im bi translated">要检查这一点，使用zip扩展名重命名APK，然后使用以下命令将APK解压缩到一个新文件夹</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="abd7" class="ls lt it ni b gy nm nn l no np">cp com.example.apk example-apk.zip<br/>unzip -qq example-apk.zip -d unzipped-apk</span></pre><p id="086f" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld mb lf lg lh mf lj lk ll mj ln lo lp lq im bi translated">浏览到新创建的<code class="fe nq nr ns ni b">unzipped-apk</code>文件夹，找到<code class="fe nq nr ns ni b">assemblies</code>文件夹。在这个文件夹中，包含了几个<code class="fe nq nr ns ni b">dll </code>二进制文件。这意味着应用程序是在Xamarin框架上构建的。</p><p id="278e" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld mb lf lg lh mf lj lk ll mj ln lo lp lq im bi translated"><strong class="kx jd">步骤2 </strong>:现在我们必须找到合适的<code class="fe nq nr ns ni b">dll</code>文件，其中包含应用程序的核心逻辑。很容易找到正确的dll文件。通常是以包名或应用程序名命名的<code class="fe nq nr ns ni b">dll</code>文件。</p><figure class="nd ne nf ng gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nt"><img src="../Images/04cc0c9c2ed4e0ea6e82313e7b6f5db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxUlBmLnV5RYKR462QhZOA.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">Xamarin Android应用程序逆向工程</figcaption></figure><p id="53e2" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld mb lf lg lh mf lj lk ll mj ln lo lp lq im bi translated"><strong class="kx jd">步骤3 </strong>:使用<strong class="kx jd"> dnSpy工具</strong>反编译<code class="fe nq nr ns ni b">dll</code>文件。</p><div class="of og gp gr oh oi"><a href="https://github.com/dnSpy/dnSpy" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd jd gy z fp on fr fs oo fu fw jc bi translated">dnSpy/dnSpy</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">dnSpy是一个调试器。NET程序集编辑器。你可以用它来编辑和调试程序集，即使你没有任何…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow nz oi"/></div></div></a></div><p id="4b2d" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld mb lf lg lh mf lj lk ll mj ln lo lp lq im bi translated"><strong class="kx jd">步骤4: </strong>搜索敏感凭据和端点</p><p id="c3df" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld mb lf lg lh mf lj lk ll mj ln lo lp lq im bi translated">在这个阶段，你必须识别出<strong class="kx jd">敏感关键字</strong>来分析反编译的代码。android应用程序流行的一种模式是使用第三方服务，如Firebase、Azure、AWS s3服务端点、私钥等。,</p><p id="67bf" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld mb lf lg lh mf lj lk ll mj ln lo lp lq im bi translated">在对代码审查进行了长时间的深入分析后，我能够在代码的注释部分找到<strong class="kx jd">敏感的硬编码凭证</strong>。</p><figure class="nd ne nf ng gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi ox"><img src="../Images/9fca2fdc365fb24c2b131dc503a5c770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQs6_x8VvLmySJG_2YnA6Q.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">在dnSpy中分析dll代码</figcaption></figure><h2 id="1b18" class="ls lt it bd lu lv lw dn lx ly lz dp ma mb mc md me mf mg mh mi mj mk ml mm iz bi translated">现在是利用公开的密钥的时候了</h2><p id="8380" class="pw-post-body-paragraph ku kv it kx b ky mn kd la lb mo kg ld mb mp lg lh mf mq lk ll mj mr lo lp lq im bi translated">每当我发现任何API密匙，我主要去参考<a class="ae lr" href="https://github.com/streaak/keyhacks" rel="noopener ugc nofollow" target="_blank"> Keyhacks </a> GitHub库。但是没有与公开的密钥相关的有效方法。</p><p id="ff89" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld mb lf lg lh mf lj lk ll mj ln lo lp lq im bi translated">Azure blob存储API文档的未来分析和一些关于Azure CLI的教程。我通过azure CLI了解了如何使用这些凭证。请找到下面的过程来利用公开的密钥</p><p id="5f67" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld mb lf lg lh mf lj lk ll mj ln lo lp lq im bi translated">在您的本地计算机上安装azure CLI，然后通过用公开的密钥替换值来设置以下环境变量</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="9e42" class="ls lt it ni b gy nm nn l no np">C:\Users\admin&gt;set AZURE_STORAGE_ACCOUNT=<strong class="ni jd">&lt;replace this with storageAccountName&gt;</strong><br/>C:\Users\admin&gt;set AZURE_STORAGE_ACCESS_KEY=<strong class="ni jd">&lt;replace this with storageAccessKey&gt;</strong></span><span id="970d" class="ls lt it ni b gy oy nn l no np">C:\Users\admin&gt;set AZURE_STORAGE_CONNECTION_STRING=DefaultEndpointsProtocol=https;EndpointSuffix=core.windows.net;AccountName=<strong class="ni jd">&lt;replace this with storageAccountName&gt;;</strong>AccountKey=<strong class="ni jd">&lt;replace this with storageAccessKey&gt;</strong></span><span id="178e" class="ls lt it ni b gy oy nn l no np">C:\Users\admin&gt;az storage blob list --container-name <strong class="ni jd">&lt;container_name&gt;</strong></span></pre><h1 id="55b4" class="ms lt it bd lu mt mu mv lx mw mx my ma ki mz kj me kl na km mi ko nb kp mm nc bi translated">结论</h1><p id="926b" class="pw-post-body-paragraph ku kv it kx b ky mn kd la lb mo kg ld mb mp lg lh mf mq lk ll mj mr lo lp lq im bi translated">android应用程序的逆向工程过程应该基于构建框架进行。您应该在信息收集的初始阶段就确定应用程序构建技术。</p></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="4ba9" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld mb lf lg lh mf lj lk ll mj ln lo lp lq im bi translated">感谢你花时间阅读这篇博客。如果你想学习android黑客技术，请<strong class="kx jd">关注我</strong>并关注有趣的<strong class="kx jd">黑客技术</strong>并查看<a class="ae lr" href="https://medium.com/@secureITmania" rel="noopener"> <strong class="kx jd">我的简介</strong> </a>阅读有趣的<strong class="kx jd"> BugBounty </strong>报道。</p></div></div>    
</body>
</html>