<html>
<head>
<title>DLL Injection &amp; DLLInjector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DLL注入和DLL注入器</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/dll-injection-dllinjector-d1b30c6760eb?source=collection_archive---------0-----------------------#2021-11-04">https://infosecwriteups.com/dll-injection-dllinjector-d1b30c6760eb?source=collection_archive---------0-----------------------#2021-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="893a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是DLL注入？</h1><p id="7007" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir"> DLL注入</strong>是一种通过强制加载动态链接库，在另一个进程的地址空间内执行代码的技术。</p><p id="6bb7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir"> DLL注入</strong>经常被外部程序用来影响另一个程序的行为，其方式是它的作者没有预料到或打算的。比如注入的代码可以绑定系统函数调用，或者读取密文盒的内容，这些都是正常情况下做不到的。用于将任意代码注入任意进程的程序被称为<strong class="kn ir"> DLL注入器</strong>。</p><h1 id="5d1d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">DLL注入是如何工作的？</h1><ul class=""><li id="dfed" class="lo lp iq kn b ko kp ks kt kw lq la lr le ls li lt lu lv lw bi translated">要注入进程的DLL文件放在目标系统上。</li><li id="a8f4" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">在目标进程的内存上保留空间，以指定DLL文件的路径。</li><li id="8fd8" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">将DLL文件所在的目录路径复制到进程内存中，并确定适当的内存地址。</li><li id="45b3" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">DLL文件运行并开始通过注入的进程执行其进程。</li></ul><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/1e94faba17a3d492e8c2044e79ea369a.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*H-C2Kgdt3H-74lhj6LKusw.jpeg"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">注射0x00 —概述</figcaption></figure><h1 id="fdf4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">将一个DLL </strong>注入一个进程由以下步骤组成:</h1><p id="6b64" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了执行DLL注入，可以访问名为<a class="ae mo" href="https://github.com/raminkarimkhani1996/DLLInjector" rel="noopener ugc nofollow" target="_blank"> DLLInjector </a>的工具，下面给出了DLL注入过程的技术细节。<strong class="kn ir"> <em class="mp"> ( </em>用C#编程语言开发，使用Windows Kernel32库调用该工具中的函数。<em class="mp"> ) </em> </strong>:</p><p id="7c18" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">OpenProcess()函数用于处理要用DLL注入的进程。通过该函数，确定要用DLL注入的进程，并通过该函数用必要的特权处理该进程，以便执行注入操作。图1包含进程访问标志。这些标志决定了应该用什么特权来处理一个进程。用OpenProcess函数给一个进程注入一个DLL，我们选择；必须使用CreateThread、QueryInformation、VMOperation、VMWrite和VMRead标志。DLLInjector工具中的OpenProcess函数被设置为处理具有所有特权的进程。</p><p id="9dbd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">LoadLibraryA函数用于将DLL文件加载到进程内存中。可以从kernel32.dll调用LoadLibraryA。GetProcAddress()函数用于此目的。这个函数用于从指定的库中获取函数或变量的地址。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/09a676783ab3d3c65ad9aa1fd66fc3b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*dxDfJNcR-HfB5nDhBUDl5A.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">0x01 —进程访问授权</figcaption></figure><p id="c17c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">函数的作用是:从目标进程的虚拟内存中分配空间。使用该函数的参数；指定目标进程、要分配的内存区域的起始地址、内存区域长度、内存分配类型以及要分配的页面的内存权限。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/c4db5a84e493290810828cb1af18de92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*07kYMG8L3dnLBnoGPaBLWQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">0x02 —打开进程</figcaption></figure><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mw"><img src="../Images/6c11a133397a330fbd664f618a7b11e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IPYZPZlxzujKjpPg4_VyMA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">0x 03—GetProcAddress-loadlibrary a</figcaption></figure><p id="34d5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">WriteProcessMemory()函数用于写入DLL文件的路径，该文件将被注入到所考虑进程的已分配内存区域中。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mx"><img src="../Images/f76f6bf34e6570b976677aaec5eabc0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28_S-GG0Ge5g9G8iJlZ6Cg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">0x04 — WriteProcessMemory</figcaption></figure><p id="4018" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">CreateRemoteThread函数在进程的虚拟内存空间中创建一个线程。使用这个函数，LoadLibraryA函数作为线程在进程分配的虚拟内存空间中运行。这就完成了DLL注入过程。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi my"><img src="../Images/c772e5d916cf2471811cdf3ddc809217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BnM9oGQ_cImWCpPdlQYtfg@2x.jpeg"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">0x 05–创建远程线程</figcaption></figure></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/38c104847cb4576df8f411bf8b463c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*pSIfHa2iAVqy56-bVnF1EA.gif"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated"><strong class="bd jp"> -知识就是力量- </strong></figcaption></figure></div></div>    
</body>
</html>