<html>
<head>
<title>How to unpack UPX packed malware with a SINGLE breakpoint</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用一个断点解开UPX打包的恶意软件</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/how-to-unpack-upx-packed-malware-with-a-single-breakpoint-4d3a23e21332?source=collection_archive---------0-----------------------#2021-06-27">https://infosecwriteups.com/how-to-unpack-upx-packed-malware-with-a-single-breakpoint-4d3a23e21332?source=collection_archive---------0-----------------------#2021-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="96f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从内存中动态解包UPX有效负载。</p><h1 id="8c0d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是UPX？</h1><p id="c04e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">可执行文件的终极打包程序(UPX)是一个免费的开源可执行打包程序。</p><blockquote class="lo lp lq"><p id="aaa5" class="jn jo lr jp b jq jr js jt ju jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj kk ij bi translated">这通常是“运行时打包程序”的简称，也称为“自解压存档”。执行“打包文件”时在内存中自行解包的软件。有时这种技术也被称为“可执行压缩”。发明这种类型的压缩是为了使文件更小。因此用户不必在执行之前手动解包它们。但是考虑到目前便携式媒体的大小和互联网的速度，对小文件的需求不再那么迫切了。因此，当你看到现在使用的一些打包程序时，几乎都是出于恶意目的。本质上是使逆向工程更加困难，并在被感染的机器上留下更小的足迹。~【blog.malwarebytes.com T2】</p></blockquote><div class="lw lx gp gr ly lz"><a href="https://github.com/upx/upx" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">GITHUB/UPX</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">UPX -可执行文件的终极打包器。在GitHub上创建一个帐户，为upx/upx开发做贡献。</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">github.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn mo lz"/></div></div></a></div><h1 id="d521" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">恶意软件中UPX的出现频率</h1><p id="05a0" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">实际上，这是相当低的，UPX是一个相对非常简单和记录良好的包装，你不希望作为恶意软件作者。但是，我们仍然看到一些低级恶意软件使用UPX作为唯一的打包程序，一些中级恶意软件在其第二阶段或nᵗʰ阶段使用它。</p><p id="d16e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我作为一名网络安全学生的有限经验中，我已经看到了足够多的次数，可以得出这样的结论:这个技巧仍然是相关的。</p><h1 id="0162" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">设置</h1><p id="4c52" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">为了确保这个技巧仍然适用于最新的UPX版本(3.96版)，我用C++创建了一个小应用程序，然后用UPX打包，再用这个技巧解包，并比较结果。</p><h2 id="27db" class="mp km iq bd kn mq mr dn kr ms mt dp kv jy mu mv kz kc mw mx ld kg my mz lh na bi translated">创建简单的有效负载</h2><p id="624a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">一个小程序，要求一个整数<code class="fe nb nc nd ne b"><strong class="jp ir">x</strong></code>并给出<code class="fe nb nc nd ne b"><strong class="jp ir">x*x</strong></code>，</p><figure class="nf ng nh ni gt nj"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2c1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">静态链接，PEBear分析-</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/f7474a85aab9113d0f597212a784a5bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VEdAzOsgYG9miOhJ6Wa65A.png"/></div></div></figure><p id="9bf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来像IDA中任何其他典型的C++代码，</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ns"><img src="../Images/3b3dab123933aa95d6b3f28bb4fca227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15r8OiNLUfg69ry9dTGbYQ.png"/></div></div></figure><h2 id="30a1" class="mp km iq bd kn mq mr dn kr ms mt dp kv jy mu mv kz kc mw mx ld kg my mz lh na bi translated">用UPX包装</h2><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nt"><img src="../Images/827380376692f2a66d2a9a4c2fc6c1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RuGC0Lg3qCQnt9eJJyvqpA.png"/></div></div></figure><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nu"><img src="../Images/0b6d6677c50eb68323ca67c8a068b416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRnTP4FUyiolpEFQoOPmAQ.png"/></div></div></figure><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/34b245550ae033ae0dcc3aacd5e23c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7umyqfmpNgpZXPP_Q994w.png"/></div></div></figure><p id="58ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，这些部分减少到只有3个——upx 0、UPX1和UPX2。此外，文件的大小也减小了(63.34%的压缩比)，让我们看看最终的IDA调用图作为参考。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nv"><img src="../Images/05a50adec12224f279906d615996912f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxkOeHpCnHKKbVSha7Yn-Q.png"/></div></div></figure></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h1 id="d783" class="kl km iq bd kn ko od kq kr ks oe ku kv kw of ky kz la og lc ld le oh lg lh li bi translated">一个断点技巧</h1><p id="d051" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">你可以用任何调试器做到这一点，我打算用<strong class="jp ir"> x32dbg </strong>做这个。</p><p id="3598" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，x32dbg会在PUSHAD的入口点放置一个断点。)</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi oi"><img src="../Images/e8f97117ff8b674fe5e0eb88b608509a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvuaDuSJGi_QmR_kK_ZqcQ.png"/></div></div></figure><div class="lw lx gp gr ly lz"><a href="https://www.felixcloutier.com/x86/pusha:pushad" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">PUSHA/PUSHAD—推送所有通用寄存器</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">将通用寄存器的内容推送到堆栈上。寄存器存储在…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">www.felixcloutier.com</p></div></div></div></a></div><h2 id="7aaa" class="mp km iq bd kn mq mr dn kr ms mt dp kv jy mu mv kz kc mw mx ld kg my mz lh na bi translated">第一步(搜索):</h2><p id="c761" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在调试器中加载二进制文件，并搜索<strong class="jp ir"> POPAD </strong>指令。</p><div class="lw lx gp gr ly lz"><a href="https://www.felixcloutier.com/x86/popa:popad" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">POPA/POPAD - Pop所有通用寄存器</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">将堆栈中的双字(POPAD)或字(POPA)弹出到通用寄存器。寄存器加载在…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">www.felixcloutier.com</p></div></div></div></a></div><h2 id="5e23" class="mp km iq bd kn mq mr dn kr ms mt dp kv jy mu mv kz kc mw mx ld kg my mz lh na bi translated">第二步(设置血压):</h2><p id="44ef" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在<strong class="jp ir"> POPAD </strong>之后立即寻找下一个<strong class="jp ir"> JMP </strong>，并在那里设置你的<strong class="jp ir">断点</strong>。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi oj"><img src="../Images/25db85c606d0cbc9acea21c7a2fa4c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HSYBmKqnQtrOH3FfpaLpeQ.png"/></div></div></figure><h2 id="d98b" class="mp km iq bd kn mq mr dn kr ms mt dp kv jy mu mv kz kc mw mx ld kg my mz lh na bi translated">步骤3(查找OEP):</h2><p id="e318" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">运行程序，直到遇到<strong class="jp ir"> JMP断点</strong></p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ok"><img src="../Images/7bda0db757a649e0d2b79a397460c9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCgTIssTq4wwQAkzX3rCwg.png"/></div></div></figure><p id="2215" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在<strong class="jp ir"> <em class="lr">单步</em> </strong>进入<strong class="jp ir"> JMP，</strong>这将把你带到打包的二进制文件的<strong class="jp ir"> OEP </strong>(原始入口点)。</p><div class="lw lx gp gr ly lz"><a href="https://stackoverflow.com/questions/46108236/whats-the-differences-between-address-of-entry-point-and-original-entry-point" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd ir gy z fp me fr fs mf fu fw ip bi translated">入口点的地址和原始入口点有什么区别？</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">感谢贡献一个堆栈溢出的答案！请务必回答问题。提供详细信息并分享…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">stackoverflow.com</p></div></div><div class="mi l"><div class="ol l mk ml mm mi mn mo lz"/></div></div></a></div><p id="9c91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到<code class="fe nb nc nd ne b"><strong class="jp ir">004014A0</strong></code> <strong class="jp ir"> </strong>作为我们的OEP，现在我们将从这个OEP中提取这个解包的二进制文件。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi om"><img src="../Images/e42ce7d06ada057753e0c1980c50b135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvKAIdIndS0oPvJ_WvB8iA.png"/></div></div></figure><h1 id="90fa" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">转储未包装PE并修复导入表</h1><p id="ad87" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">现在我们将从PE的OEP开始转储PE，为此我使用了x32dbg的<strong class="jp ir"> Scylla </strong>插件，</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi on"><img src="../Images/41821c234157ed56f528b7faa7d16662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*NTucZK5wqMrijMeiTZvW4Q.png"/></div></figure><p id="5f73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您正在使用相同的，请单击工具栏中的“S”按钮。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi oo"><img src="../Images/f4374782ba01afb79152bf1c6af5561d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UCEvhu9sOydEm2cjfRzlrQ.png"/></div></div></figure><p id="50d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在“附加到一个活动进程”中选择您的<strong class="jp ir"> <em class="lr">当前进程</em> </strong>，并且<strong class="jp ir">确保您的OEP是正确的</strong>，让我们在我们的例子中修复它-</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi op"><img src="../Images/493829910de06deda785bad4d56f1466.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*9Yj-7cERwEGshNR28f_gOQ.png"/></div></figure><p id="715b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后点击“IAT自动搜索”来搜索进口商品。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi oq"><img src="../Images/2c79b6136ac433728f3c955af19ee7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HA0OAMsC5wzTCJV7ssyU0w.png"/></div></div></figure><p id="3faf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当询问高级结果时，单击“是”。完成后，单击“获取导入”列出找到的所有导入。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi or"><img src="../Images/929f34ec8364ed164900d77625b19dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*Zy9gjfPOTY_dQz9e3G_ViA.png"/></div></figure><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi os"><img src="../Images/4353c83ad67ffec9768e8d5bffc3bb20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqT3CQFACbUNXFGfdY8XHw.png"/></div></div></figure><p id="6aa8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后单击“转储”转储提取的二进制文件。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ot"><img src="../Images/9df766e0f3bccf7c4099604eb3f1ee3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aaJRUUOCjrApzqy6W-obsg.png"/></div></div></figure><p id="5ab5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后单击“修复转储”并选择最近转储的二进制文件来修复其IAT。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ou"><img src="../Images/8028610b246efe84863ad3da98714b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRsB8J7KhUVRE2tZDPM8yg.png"/></div></div></figure><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ov"><img src="../Images/1bc44832bb7c0023e4a9ff3094ef070e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwZKAoY4iJEj-0Qkdbpf6w.png"/></div></div></figure><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ow"><img src="../Images/cd36080361ad919026d9a7f588043371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nyAK3SXH9SFMe1CRHIlZRg.png"/></div></div></figure><p id="20f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，<code class="fe nb nc nd ne b"><strong class="jp ir">simplenum_packed_dump_SCY.exe</strong></code> <strong class="jp ir"> </strong>是最终解包的二进制文件，为了检查它，让我们在IDA中打开它并比较调用图。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ox"><img src="../Images/90bd8ffbeef6a73b22332c95c7285b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IuB4sgMqN52Kax--vqRYQA.png"/></div></div></figure><p id="08f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到所有的原始字符串和类似的程序结构！我们的方法在这里已经完成了，但是如果你愿意，你可以进一步阅读以了解为什么这个方法有效。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h1 id="bdd4" class="kl km iq bd kn ko od kq kr ks oe ku kv kw of ky kz la og lc ld le oh lg lh li bi translated">为什么会这样？</h1><p id="4e3e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">这是一个众所周知的UPX属性的结果，当你用UPX打包任何可执行文件时，所有现有的部分(文本、数据等)都被压缩。压缩后，它们被命名为<strong class="jp ir"> UPX0、UPX1 </strong>等。然后，它在文件的末尾添加一个新的代码段，该代码段将在执行时解压缩所有打包的代码段。</p><p id="7da8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在执行过程中，它遵循以下步骤</p><ol class=""><li id="b26f" class="oy oz iq jp b jq jr ju jv jy pa kc pb kg pc kk pd pe pf pg bi translated">用<strong class="jp ir">按钮</strong>保存所有寄存器状态</li><li id="51c2" class="oy oz iq jp b jq ph ju pi jy pj kc pk kg pl kk pd pe pf pg bi translated">解压缩内存中的所有部分</li><li id="7dcf" class="oy oz iq jp b jq ph ju pi jy pj kc pk kg pl kk pd pe pf pg bi translated">动态解析IAT</li><li id="3f9a" class="oy oz iq jp b jq ph ju pi jy pj kc pk kg pl kk pd pe pf pg bi translated">使用<strong class="jp ir"> POPAD </strong>恢复寄存器状态</li><li id="8e5b" class="oy oz iq jp b jq ph ju pi jy pj kc pk kg pl kk pd pe pf pg bi translated">跳转到<strong class="jp ir"> OEP </strong>并执行主代码。</li></ol><p id="3f47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的技巧中，我们把断点放在第5步之后，当它跳到OEP时，我们从那里转储PE并修复IAT，而没有完成执行。</p><h1 id="3c18" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="5aa6" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">通过一些实践和经验，您可以很容易地找到这个JMP来在调用图中注册，而不用搜索POPAD，并且您可以快速地解包任何upx二进制文件。</p><h2 id="e924" class="mp km iq bd kn mq mr dn kr ms mt dp kv jy mu mv kz kc mw mx ld kg my mz lh na bi translated">为什么不使用UPX工具本身来解包？</h2><p id="c4ac" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">因为有时你可能会在恶意软件的第二或第三阶段得到UPX打包的二进制文件，大部分是内存注入和“映射的二进制文件”,因此UPX工具将不起作用，但这是另一篇文章的讨论。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="47cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们带你浏览了一个UPX打包的二进制文件，如果你有兴趣学习如何解包其他类型的打包程序，请查看引导黑客的<a class="ae lv" href="https://guidedhacking.com/threads/how-to-unpack-packed-files-tutorial-series.17522/" rel="noopener ugc nofollow" target="_blank">解包教程</a></p></div></div>    
</body>
</html>