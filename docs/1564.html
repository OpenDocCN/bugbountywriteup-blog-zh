<html>
<head>
<title>Beginner Guide To Exploit Server Side Request Forgery (SSRF) Vulnerability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用服务器端请求伪造(SSRF)漏洞的初学者指南</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/exploiting-server-side-request-forgery-ssrf-vulnerability-faeb7ddf5d0e?source=collection_archive---------1-----------------------#2021-09-06">https://infosecwriteups.com/exploiting-server-side-request-forgery-ssrf-vulnerability-faeb7ddf5d0e?source=collection_archive---------1-----------------------#2021-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9420" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated"><span class="l km kn ko bm kp kq kr ks kt di"> S </span>服务器端请求伪造(SSRF)是一种简单的攻击，在这种攻击中，服务器将为攻击者向本地或远程源发出请求(充当代理),然后返回包含请求产生的数据的响应。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/062321ea329e498c136c28574d9b0763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hEXpF7oFw2wgl7qa.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">SSRF插图</figcaption></figure><p id="49fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以说，SSRF的概念与使用代理或VPN是一样的，用户将向某个资源发出请求，然后代理或VPN服务器将向该资源发出请求，然后将结果返回给发出请求的用户。</p><p id="06cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在SSRF，可以做各种事情，例如:</p><ul class=""><li id="3054" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated">本地/远程端口扫描</li><li id="ff5a" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">本地文件读取(使用file://)</li><li id="aaa7" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">与内部应用/服务/网络互动</li><li id="1da9" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">通过链接内部网络上的服务实现RCE</li><li id="740f" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">阅读元数据云(AWS、Azure、谷歌云、数字海洋等)</li><li id="5e17" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">反射XSS/CSRF</li></ul><h1 id="d5c3" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">实验室设置</h1><p id="01ea" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">对于这篇博文中的实验室的使用，只使用下面的简单脚本(当然可能现实世界中的应用程序没有这么简单)并将部署在数字海洋上。</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="0c97" class="ng lz iq nc b gy nh ni l nj nk">&lt;?php<br/>    $url = $_GET['url'];</span><span id="767f" class="ng lz iq nc b gy nl ni l nj nk">$curl = curl_init();<br/>    curl_setopt($curl, CURLOPT_URL, $url);<br/>    curl_setopt($curl, CURLOPT_RETURNTRANSFER,1);<br/>    curl_setopt($curl, CURLOPT_TIMEOUT, 5);<br/>    curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, 5);</span><span id="986d" class="ng lz iq nc b gy nl ni l nj nk">$data = curl_exec ($curl);</span><span id="0479" class="ng lz iq nc b gy nl ni l nj nk">if(curl_error($curl)){<br/>        echo curl_error($curl);<br/>    }else{<br/>        echo "&lt;pre&gt;" . $data . "&lt;/pre&gt;";<br/>    }<br/>    curl_close ($curl);<br/>?&gt;</span></pre><p id="5833" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nm nn no nc b">Curl</code>被选为这篇博文的请求者，因为<code class="fe nm nn no nc b">curl</code>支持各种协议，所以它有利于学习。</p><blockquote class="np nq nr"><p id="a2b2" class="jn jo ns jp b jq jr js jt ju jv jw jx nt jz ka kb nu kd ke kf nv kh ki kj kk ij bi translated"><em class="iq"> requestster </em>是一个函数或库，我们使用它从输入URL获取/请求资源。</p></blockquote><h1 id="fa8f" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">本地/远程端口扫描</h1><p id="164a" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">扫描端口的目的只是为了能够映射该端口背后正在运行的应用程序/服务，以便攻击者能够识别该端口上正在运行的应用程序/服务。如果攻击者想要进行交互，然后对内部应用程序/服务执行查询，这就变得非常重要。</p><p id="2b7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">端口扫描可以使用HTTP、HTTPS、GOPHER或DICT协议来完成。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/b594d1e4e0e8096f15bdf0aa00c980e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/0*g-zcdUF646A15KJR.png"/></div></figure><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/4bfa749014059666281c1d8a3eea7b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/0*arsySB8ab2eZjIyU.png"/></div></figure><p id="e70f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有<em class="ns">盲SSRF </em>来了解端口是打开还是关闭，可以关注<em class="ns">内容-长度</em>、<em class="ns">响应时间</em>，或者<em class="ns"> HTTP状态码</em>。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ny"><img src="../Images/ad09352a12e2bae35a55472f44862524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DMZxc6Xd5lc8g2Z6.png"/></div></div></figure><p id="8c3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，要找出的指标不仅仅是上面提到的三个元素，在端口扫描期间可能会出现“<em class="ns">不寻常的</em>”元素，因为这取决于web应用程序使用的技术和环境。</p><blockquote class="nz"><p id="5de2" class="oa ob iq bd oc od oe of og oh oi kk dk translated">HTTPS协议如果端口是开放的，响应时间将会更长，因为HTTPS将进行握手，因此当面对盲目的SSRF时，使用HTTPS协议可能是端口扫描的合适选择</p></blockquote><h1 id="e88b" class="ly lz iq bd ma mb mc md me mf mg mh mi mj oj ml mm mn ok mp mq mr ol mt mu mv bi translated">本地文件读取</h1><p id="a5c2" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">在SSRF环境中，访问/读取本地文件只能使用<code class="fe nm nn no nc b">file:///</code>协议，但并非所有请求者都支持<code class="fe nm nn no nc b">file:///</code>协议。此外，可能存在不允许使用该协议的硬过滤器/黑名单，但这仍然取决于请求者的行为。</p><p id="8ab8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要访问文件本身，您可以使用<code class="fe nm nn no nc b">file:/PathToFile</code>、<code class="fe nm nn no nc b">file:///PathToFile</code>或<code class="fe nm nn no nc b">file://hostname/PathToFile</code>。这三种访问方式都是<code class="fe nm nn no nc b">file:///</code>的有效URIs。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi om"><img src="../Images/0827c5cc406978b9da6993d1d2baeb4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/0*cTCz6iBm4c6pZ7un.png"/></div></figure><blockquote class="nz"><p id="2932" class="oa ob iq bd oc od on oo op oq or kk dk translated">如果web应用程序部署在Windows Server上，要使用file:///协议访问文件，可以使用file:/// <drive_letter example="" :="" file:=""/></p></blockquote><h1 id="d258" class="ly lz iq bd ma mb mc md me mf mg mh mi mj oj ml mm mn ok mp mq mr ol mt mu mv bi translated">Interacting With Internal Service</h1><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi os"><img src="../Images/7abef606c20d698d8fb39ac82ac01ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ey8ZXRAnTb-caH9F.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">Interactive With Internal Service by SSRF</figcaption></figure><p id="649e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">The real power of SSRF is where the attacker can interact with the internal application/service/network in Local Network, imagine if there is a vulnerable application/service in the internal network where the attacker cannot reach the application/service because it is on a different network, but if there is SSRF vulnerability the Attacker might be able to do that.</p><p id="8b7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">If the requester supports the use of the  【T4】  protocol or there may be a  【T5】  vulnerability, it will allow attackers to interact with various internal services such as  【T6】 ,  【T7】 ,  【T8】 ,  【T9】  and so on. Then querying these services to give the desired command, for example, to read local files or even to get RCE.</p><blockquote class="nz"><p id="126f" class="oa ob iq bd oc od oe of og oh oi kk dk translated">Gopher is classified as a universal protocol, through gopher the attacker can do smuggling to other protocols, besides that gopher also supports the use of newline (\r\n) so that even though the requestster is not vulnerable to CRLF Injection, the attacker can still perform CRLF Injection because Gopher does support multiline requests.</p></blockquote><p id="e1fc" class="pw-post-body-paragraph jn jo iq jp b jq ot js jt ju ou jw jx jy ov ka kb kc ow ke kf kg ox ki kj kk ij bi translated">A blog post on how to interact with internal services can be read in separate material below:</p><ul class=""><li id="f66b" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated"><a class="ae oy" href="https://github.com/rhamaa/Web-Application-Attack/blob/master/other-vulnerability/service-side-request-forgery/ssrf-and-smtp.md" rel="noopener ugc nofollow" target="_blank"> SSRF和SMTP </a></li><li id="c317" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">SSRF和MYSQL(正在进行)</li><li id="aaa9" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><a class="ae oy" href="https://github.com/rhamaa/Web-Application-Attack/blob/master/other-vulnerability/service-side-request-forgery/ssrf-and-redis.md" rel="noopener ugc nofollow" target="_blank"> SSRF和雷迪斯</a></li><li id="36de" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">SSRF和Memcached(正在进行)</li></ul><h1 id="f09d" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">云元数据</h1><p id="4e45" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">有各种各样的供应商提供云计算服务，如AWS、Azure、Google Cloud、Digital Ocean等。其中这些厂商使用REST API提供元数据访问，但是REST API只能通过云网络访问。</p><p id="0b86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果在这些云服务之一中部署了易受攻击的SSRF web应用程序，攻击者就很有可能通过利用SSRF漏洞来访问元数据信息。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/d269668117816fdf2de287762809113a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/0*isNH_QDDzHtCYP3m.JPG"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">数字海洋实例元数据</figcaption></figure><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi pa"><img src="../Images/24d48cbbbe8c8c8370a8ef2cd0ddd3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PjR3AzrrI0Uy_J5M.JPG"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">数字海洋实例元数据</figcaption></figure><p id="f1cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对REST API端点的引用可以参考所使用的云服务提供商的官方文档，或者可以查看BuffaloWill的<a class="ae oy" href="https://gist.github.com/BuffaloWill/fa96693af67e3a3dd3fb" rel="noopener ugc nofollow" target="_blank">云元数据字典对SSRF测试</a>有用。</p><h1 id="4d11" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">反映了XSS</h1><p id="0134" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">如果你没有面对盲目的SSRF，XSS反射就会发生。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi pb"><img src="../Images/d4abfbe7d33b3736cdd552baf79acd16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zK5DVGUaafUFrnAq.JPG"/></div></div></figure><p id="3fc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果请求者支持javascript，例如像<code class="fe nm nn no nc b">PhantomJS</code>和<code class="fe nm nn no nc b">Selenium</code>，盲SSRF上的XSS就会发生，那么攻击者对内部服务/网络进行<code class="fe nm nn no nc b">DNS Rebinding</code>攻击以<em class="ns">玩</em>也不是不可能的。</p><h1 id="7a3d" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">URL模式支持</h1><p id="9f29" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">支持各种协议的请求者列表:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi pc"><img src="../Images/7de5f54fcdb6c3c649f36c7000182023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bYhKEpgcfHlhMmx_57_6Cg.png"/></div></div></figure><p id="ee1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(资料来源:SSRF圣经。Wallarm的备忘单)</p><h1 id="d500" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">SSRF走私议定书</h1><p id="3f02" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">列出一些支持走私到其他协议的协议:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi pd"><img src="../Images/8bdb5522e887c4370b0b85869aee7e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9fTVzJd0DFNDc5Hu-rQLA.png"/></div></div></figure><p id="a049" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(资料来源:SSRF圣经。Wallarm的备忘单)</p><h1 id="715d" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">SSRF提示</h1><ul class=""><li id="32f6" class="lk ll iq jp b jq mw ju mx jy pe kc pf kg pg kk lp lq lr ls bi translated">测试请求者是否执行了下面的重定向，这样有效负载的创建会变得更容易，此外，如果有效负载的某些部分被硬过滤/列入黑名单，它也会绕过。</li><li id="eafb" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">经常测试各种协议比如GOPHER，FTP，SSH等等。</li><li id="ea01" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">对<code class="fe nm nn no nc b">CRLF Injection</code>进行测试，因为如果攻击者想要查询内部服务，这将变得非常重要</li><li id="922e" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated">当面对盲目的SSRF时，如读取本地文件和读取元数据，将没有其他方法来找出响应数据，因此显而易见的解决方案是做其他事情，如端口扫描或与内部网络交互，以便您可以获得RCE。</li></ul><h1 id="3160" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">参考</h1><ul class=""><li id="4e98" class="lk ll iq jp b jq mw ju mx jy pe kc pf kg pg kk lp lq lr ls bi translated">SSRF圣经。Wallarm的Cheatsheet</li><li id="4116" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><a class="ae oy" href="https://en.wikipedia.org/wiki/File_URI_scheme" rel="noopener ugc nofollow" target="_blank">文件URI方案</a></li><li id="091a" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><a class="ae oy" href="https://gist.github.com/BuffaloWill/fa96693af67e3a3dd3fb" rel="noopener ugc nofollow" target="_blank">云元数据字典对SSRF测试有用</a></li><li id="1d14" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><a class="ae oy" href="https://www.acunetix.com/blog/articles/server-side-request-forgery-vulnerability/" rel="noopener ugc nofollow" target="_blank">什么是服务器端请求伪造(SSRF)？</a></li></ul></div></div>    
</body>
</html>