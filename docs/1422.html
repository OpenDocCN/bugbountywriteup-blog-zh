<html>
<head>
<title>Hijacking Kubernetes Resources with Labels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用标签劫持Kubernetes资源</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/hijacking-kubernetes-services-with-labels-ea6b863b5a8e?source=collection_archive---------0-----------------------#2021-06-24">https://infosecwriteups.com/hijacking-kubernetes-services-with-labels-ea6b863b5a8e?source=collection_archive---------0-----------------------#2021-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/e0b5eafde7729e3400dcba107962c1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*wzwBQLc_bTf16hWGQaDKbA.png"/></div></figure><p id="b12e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它所需要的只是一个匹配标签选择器。</p><blockquote class="ks kt ku"><p id="5253" class="ju jv kv jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated">标签旨在用于指定对用户有意义且相关的对象的标识属性，但并不直接暗示核心系统的语义。—<a class="ae kz" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/overview/working-with-objects/labels/</a></p></blockquote><p id="d68d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">根据kubernetes文档，标签只是用来识别用户的属性。但是如果它们被用来授权其他资源如何与它们交互呢？令人震惊的是，向下滚动标签文档页面，我们看到<code class="fe la lb lc ld b">service</code>目标是由一个选择器标签定义的。深入挖掘，您甚至会发现其他资源，如用匹配标签选择器定义的网络策略。所以像所有kubernetes的东西一样，我质疑这是如何被利用的。</p><p id="9165" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，让我们创建一个部署和服务:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="4726" class="lm ln iq ld b gy lo lp l lq lr"><strong class="ld ir">apiVersion</strong>: apps/v1<br/><strong class="ld ir">kind</strong>: Deployment<br/><strong class="ld ir">metadata</strong>:<br/>  <strong class="ld ir">name</strong>: nginx-deployment<br/>  <strong class="ld ir">labels</strong>:<br/>    <strong class="ld ir">app</strong>: nginx<br/><strong class="ld ir">spec</strong>:<br/>  <strong class="ld ir">selector</strong>:<br/>    <strong class="ld ir">matchLabels</strong>:<br/>      <strong class="ld ir">app</strong>: nginx<br/>  <strong class="ld ir">template</strong>:<br/>    <strong class="ld ir">metadata</strong>:<br/>      <strong class="ld ir">labels</strong>:<br/>        <strong class="ld ir">app</strong>: nginx<br/>    <strong class="ld ir">spec</strong>:<br/>      <strong class="ld ir">containers</strong>:<br/>      - <strong class="ld ir">name</strong>: nginx<br/>        <strong class="ld ir">image</strong>: nginx<br/>        <strong class="ld ir">ports</strong>:<br/>        - <strong class="ld ir">containerPort</strong>: 80</span><span id="174d" class="lm ln iq ld b gy ls lp l lq lr"><strong class="ld ir">---<br/>apiVersion</strong>: v1<br/><strong class="ld ir">kind</strong>: Service<br/><strong class="ld ir">metadata</strong>:<br/>  <strong class="ld ir">name</strong>: nginx-service<br/><strong class="ld ir">spec</strong>:<br/>  <strong class="ld ir">selector</strong>:<br/>    <strong class="ld ir">app</strong>: nginx-service<br/>  <strong class="ld ir">selector</strong>:<br/>    <strong class="ld ir">matchLabels</strong>:<br/>      <strong class="ld ir">app</strong>: nginx<br/>  <strong class="ld ir">ports</strong>:<br/>    - <strong class="ld ir">protocol</strong>: TCP<br/>      <strong class="ld ir">port</strong>: 80</span></pre><p id="2764" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将创建一个在端口80上运行nginx的部署。该服务将把任何带有标签<code class="fe la lb lc ld b">app=nginx</code>的pod作为目标，并暴露容器的端口80。从功能角度来看这很好，但是安全性呢？</p><p id="f15b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">默认情况下，对于谁可以创建特定标签没有访问控制。</p><p id="e388" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个流氓部署可以通过创建一个同样标有<code class="fe la lb lc ld b">app=nginx</code>的新部署来轻松劫持这个服务，但实际上运行它想要的任何容器。例如:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="3659" class="lm ln iq ld b gy lo lp l lq lr"><strong class="ld ir">apiVersion</strong>: apps/v1<br/><strong class="ld ir">kind</strong>: Deployment<br/><strong class="ld ir">metadata</strong>:<br/>  <strong class="ld ir">name</strong>: evil-nginx-deployment<br/>  <strong class="ld ir">labels</strong>:<br/>    <strong class="ld ir">app</strong>: evil-nginx<br/><strong class="ld ir">spec</strong>:<br/>  <strong class="ld ir">selector</strong>:<br/>    <strong class="ld ir">matchLabels</strong>:<br/>      <strong class="ld ir">app</strong>: nginx<br/>  <strong class="ld ir">template</strong>:<br/>    <strong class="ld ir">metadata</strong>:<br/>      <strong class="ld ir">labels</strong>:<br/>        <strong class="ld ir">app</strong>: nginx<br/>    <strong class="ld ir">spec</strong>:<br/>      <strong class="ld ir">containers</strong>:<br/>      - <strong class="ld ir">name</strong>: evil-nginx<br/>        <strong class="ld ir">image</strong>: evil-nginx<br/>        <strong class="ld ir">ports</strong>:<br/>        - <strong class="ld ir">containerPort</strong>: 80</span></pre><p id="bb24" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为部署的selector.matchLabels容器<code class="fe la lb lc ld b">app=nginx</code>将被nginx-service作为目标。此时，nginx-service的流量将分布在nginx和evil-nginx部署中。</p><p id="9383" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这很有趣，因为创建流氓部署的用户或服务帐户只需要访问创建新部署的权限。它不需要创建或修改服务的权限，也不需要修改现有部署的权限。</p><p id="fbfd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">同样的概念也适用于网络策略。对您的生产服务和部署的网络访问可能只是一个远离灾难的流氓标签。</p><p id="eb06" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">乐趣并不仅限于kubernetes的本地资源，如服务和网络策略。许多自定义资源定义(CRD)也包括选择器匹配标签的使用。</p><h2 id="967d" class="lm ln iq bd lt lu lv dn lw lx ly dp lz kf ma mb mc kj md me mf kn mg mh mi mj bi translated">结论</h2><p id="5075" class="pw-post-body-paragraph ju jv iq jw b jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr ij bi translated">永远不要相信kubernetes的标签是权威的来源。在任何可能的情况下，坚持使用标签作为用户识别属性的唯一来源，而不是授权资源连接的一种方式。</p></div></div>    
</body>
</html>