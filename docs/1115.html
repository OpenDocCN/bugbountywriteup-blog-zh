<html>
<head>
<title>How to understand and develop a Nmap of your Own — Part 3 — CyberForged</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何理解和开发自己的Nmap第3部分——网络锻造</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/how-to-understand-and-develop-a-nmap-of-your-own-part-3-cyberforged-d757dca0dc72?source=collection_archive---------0-----------------------#2021-02-11">https://infosecwriteups.com/how-to-understand-and-develop-a-nmap-of-your-own-part-3-cyberforged-d757dca0dc72?source=collection_archive---------0-----------------------#2021-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e243" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯……我们继续吗？😀</p><p id="1e03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎回到本教程/指南，学习如何使用Java作为基本语言来复制Nmap。本指南面向那些希望了解如何能够在其软件中包含Nmap的主要功能(如发现开放端口)而无需集成整个系统的人。与此同时，我们正在学习Nmap使用什么样的技术来做它所做的一切。</p><p id="6608" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的前一部分(第2部分，您可以在这里看到<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/how-to-understand-and-develop-a-nmap-of-your-own-part-2-cyberforged-35f4ea6f01cf"/>)中，我们看到了如何用几行代码制作一个软件来检测服务器上开放的TCP端口，这是Nmap最基本的功能。在今天的文章中，我们将看到如何复制这种行为，但尝试检测UDP端口。</p><p id="579f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以开始了吗？</p><h1 id="686e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">UDP和它的小东西</h1><p id="087b" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在开始疯狂编程之前，我们必须知道检测TCP和UDP端口的真正区别是什么，也就是这两种协议的主要区别是什么？</p><p id="0e72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们只看我们对自己的Nmap版本感兴趣的内容，最关键的区别是TCP是面向连接的，也就是说，为了与通过TCP公开的任何端口对话，我们必须首先设置一些参数。我们可以将这种连接建立视为要连接的端口(源和目的地)之间的“聊天”。这个聊天只是试图同步源端口和目的端口，以确保两者都准备好通信。端口之间通信之前的这种对话称为三次握手。</p><p id="88fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦这种“握手”结束，两个端口都知道对方的期望，数据交换就开始了。TCP的好处是它真的很关心数据包和它们的数据，它就像它们的母亲:它检测它们是否有错误，试图纠正它们，试图重新传输那些没有到达的数据包，亲吻它们道晚安……它们得到了最好的照顾。</p><p id="32ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，让我们想象一下UDP也是这样，但是没有任何关系:UDP真正错误对待数据包的唯一方式就是直接用头撞它们。这是一个完全不关心任何事情的协议，它在连接/数据交换之前没有对话，也不关心错误，也不关心重新传输…什么都不关心。这是自私的，非常自我的。但它也有一些优点:正因为它不关心任何事情，所以它非常快，所以它非常适合需要很高速度的应用程序，如果数据包丢失，也不会有太大影响(例如，YouTube上的视频)。</p><p id="887e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这个意义上说，UDP和TCP很像这个模因。TCP干净准确，解渴。UDP就像往自己身上浇一壶冷水，等着什么东西到你嘴里。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/c36a9b3ca93c5c4a24f516fd19ca40fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*57pI-TF53DJgj90T.jpg"/></div></div></figure><h1 id="9bcf" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">现在，我们如何检测UDP中的开放端口？</h1><p id="8ea0" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">可以想象，我们在UDP中检测端口时会遇到一个问题:我们不能像在TCP中那样直接打开连接，因为UDP恰恰是一个没有连接的协议:只有问题和答案，没有其他。</p><p id="e275" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于UDP，应该使用的技术是:发送UDP数据，并尝试查看目的端口是否用另一个特殊的数据包进行响应，在这种情况下使用ICMP协议(ICMP_PORT_UNREACH)。这将为我们提供端口已关闭的信息，通过排除，我们可以知道哪些端口是真正打开或关闭的。这种解决方案的问题是，它需要root权限和对所谓的原始套接字的访问，即在非常低的级别控制套接字发送的数据。</p><p id="d691" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本指南中，我们将首先执行以下检测，而不是上面解释的扫描:如果UDP端口在12秒的最大时间内响应我们，我们认为它是开放的，否则，我们认为它是关闭的。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/c3c018aa4cadc105f319b2ae56951640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/0*wFdFE3LGMGcbJhir.jpg"/></div></figure><p id="69b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果端口关闭，当我们发送随机UDP数据包时，在最长12秒的时间内，它要么不回答我们，要么用ICMP_PORT_UNREACH回答我们(后者我们将无法检测)。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/412e4cdf84963988781501ff05e2ca4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/0*IhQiJQ7THMdP6BRF.png"/></div></figure><p id="a23e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们将遵循这个流程图:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/89b67824653125b01d52168f8c82fb7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/0*yIaasPC0_q3SuRqo.png"/></div></figure><p id="ff79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你相信吗？让我们进入编程部分！</p><h1 id="30f0" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">密码</h1><p id="1b91" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在这种情况下，我们不打算展示上一期文章中的代码，因为已经解释过了。UDP检测的代码如下:</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="0873" class="mi kn iq me b gy mj mk l ml mm">public static void main(String[] args) { <br/>  <br/>int port = 1; <br/>int upperLimit = 14; <br/>  <br/>String dstIP = "192.168.142.128"; <br/>  <br/>int configuredTimeout = 12000; <br/>  <br/>while (port &lt; upperLimit) { <br/>  <br/>  // UDP variables <br/>  DatagramSocket UDPSocket = null; <br/>  InetAddress address; <br/>  <br/>  byte[] buf; <br/>  <br/>  try { <br/>  <br/>    // We open a new UDP socket <br/>    UDPSocket = new DatagramSocket(); <br/>    address = InetAddress.getByName(dstIP); <br/> <br/>    // The message to be sent to the port, <br/>    String msg = "hello world"; <br/>    buf = msg.getBytes(); <br/>    DatagramPacket packet = new DatagramPacket(buf, buf.length, address, port); <br/> <br/>    // We send the packet <br/>    UDPSocket.send(packet); <br/>    packet = new DatagramPacket(buf, buf.length); <br/>  <br/>    // We configure the socket to have a maximun timeout <br/>    UDPSocket.setSoTimeout(configuredTimeout); <br/>    UDPSocket.receive(packet); <br/> <br/>    // Then if we receive something, we know the port is opened <br/>    String received = new String(packet.getData(), 0, packet.getLength()); <br/>    System.out.println("Port " + port + " seems to be opened"); <br/>  <br/>  } catch (SocketTimeoutException e) { <br/>    // The port is closed! <br/>    System.out.println("Port " + port + " seems to be closed"); <br/>  } catch (SocketException e) { <br/>    // TODO Auto-generated catch block <br/>    e.printStackTrace(); <br/>  } catch (UnsupportedEncodingException e) { <br/>    // TODO Auto-generated catch block <br/>    e.printStackTrace(); <br/>  } catch (IOException e) { <br/>    // TODO Auto-generated catch block <br/>    e.printStackTrace(); <br/>  } finally { <br/>    UDPSocket.close(); <br/>  }  <br/> port++; <br/> } <br/>}</span></pre><p id="7450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们使用的是:</p><ul class=""><li id="2dbf" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">接收功能，如果目的端口响应我们，我们将接收数据(因此，它是开放的)。</li><li id="649c" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">socket变量的setSoTimeout函数能够将这12秒作为等待的上限。</li><li id="5f20" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">SocketTimeoutException异常的捕获，当超过12秒而没有收到来自目标端口的响应时，将执行该异常。</li></ul><p id="b930" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这三个工具，我们将能够知道端口是打开的还是关闭的。事实上，我们可以使用上次在本指南的前一部分中使用的kali映像进行测试。</p><p id="0548" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在UDP模式下在端口1上以监听模式启动netcat，使用以下行:</p><pre class="lq lr ls lt gt md me mf mg aw mh bi"><span id="3afc" class="mi kn iq me b gy mj mk l ml mm">echo 'test' | nc -u -l -p 1 -v -s 192.168.142.128 -k</span></pre><p id="56ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令的“echo test”部分是这样的，一旦有人(我们的Nmap)向那个端口(port 1)发送数据，netcat就用那个字符串“test”进行回复。</p><p id="5ef8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只需在Eclipse中启动我们的Nmap版本，获得以下结果:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/7dac9e0691bebd435a7d963eca8eb7ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/0*70npDTlJcVxntpKl.png"/></div></figure><p id="72a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在netcat部分，我们看到我们的字符串“hello world”已经发送。"</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/468f5028c065939d2c33982b9fb915de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/0*Z3eHDAW6pzUkQ_5A.png"/></div></figure><p id="a283" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">瞧啊。我们有一个Nmap可以检测开放的UDP端口。现在我们需要做的是改进它，以包括我们已经讨论过的原始套接字，使它更快，使用某种JNI接口(能够用C编程，在C中原始套接字是真正可访问的)。</p><p id="ce3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你有什么意见吗，你喜欢吗，我能帮你什么吗？请在评论中告诉我！</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="36f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nk">原载于2021年2月11日</em><a class="ae kl" href="https://cyberforged.com/how-to-understand-and-develop-a-nmap-of-your-own-part-3/" rel="noopener ugc nofollow" target="_blank"><em class="nk">【https://cyberforged.com】</em></a><em class="nk">。</em></p></div></div>    
</body>
</html>