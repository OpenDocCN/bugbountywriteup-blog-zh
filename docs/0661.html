<html>
<head>
<title>Are You Sure That You’re Not Leaking User’s Auth Tokens To Third Parties?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您确定您没有向第三方泄露用户的身份验证令牌吗？</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/are-you-sure-that-youre-not-leaking-user-s-access-tokens-to-third-parties-da16d63faaf4?source=collection_archive---------0-----------------------#2020-06-30">https://infosecwriteups.com/are-you-sure-that-youre-not-leaking-user-s-access-tokens-to-third-parties-da16d63faaf4?source=collection_archive---------0-----------------------#2020-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd67" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">OkHttp在重定向期间保留Auth头的行为</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/0d16bd7c2b369b34a2c47ed5153f56d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*aLdqLtDMycwe2zP3JTuXOQ.jpeg"/></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="9f5f" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">你是一个倾向于安全性的Android开发人员，还是一个热衷于将多个点连接起来以识别一个很酷的安全漏洞的应用程序安全人员？你忘了Android开发者的朋友OkHttp在重定向期间保留了auth头吗？如果<strong class="kz iu">是</strong>，那么这个故事对你来说会很有趣。它讨论了OkHttp在重定向到第三方域期间保留auth头的行为。</p><p id="2bef" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了更好地理解这一点，让我们首先回顾一下围绕这个问题的一些基本情况。如果你已经知道OkHttp和应用程序和网络拦截器的概念，你可以跳过下面的章节，直接从<strong class="kz iu">这个问题开始！</strong></p><h1 id="6522" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">OkHttp是什么？</h1><p id="952b" class="pw-post-body-paragraph kx ky it kz b la ml ju lc ld mm jx lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated"><a class="ae mq" href="https://square.github.io/okhttp/" rel="noopener ugc nofollow" target="_blank"> OkHttp </a>是一个Http客户端，它是由<a class="ae mq" href="https://square.github.io/" rel="noopener ugc nofollow" target="_blank"> Square </a>开发的第三方库，用于发送和接收基于HTTP的网络请求。它也是另一个广泛使用的HTTP客户端<a class="ae mq" href="https://square.github.io/retrofit/" rel="noopener ugc nofollow" target="_blank">改进</a>的底层库。</p><h1 id="f091" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">OkHttp拦截器</h1><p id="1c62" class="pw-post-body-paragraph kx ky it kz b la ml ju lc ld mm jx lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">拦截器是一种强大的机制，可以监控、重写和重试网络调用。对于大规模的应用程序，我们有许多API与我们的后端进行通信，编写常见的逻辑(如加密请求体、解密响应体、将访问令牌附加到请求、处理特定的响应(例如HTTP-401-未授权/HTTP-403-禁止)等)可能会非常繁琐和重复。对于每一个API调用，这就是拦截器帮助我们拯救的地方。</p><p id="0720" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们在后端使用API网关作为后端的入口点，我们可以将拦截器视为前端发出的所有请求的网关。</p><h1 id="3563" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">应用程序与网络拦截器</h1><p id="0fe8" class="pw-post-body-paragraph kx ky it kz b la ml ju lc ld mm jx lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">OkHttp拦截器可以注册为一个应用程序或网络拦截器，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/c9501db004d4370dc4827b84b9d649ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HIcRQQxefCE1aImR.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">参考:<a class="ae mq" href="https://square.github.io/okhttp/interceptors/" rel="noopener ugc nofollow" target="_blank">方形</a></figcaption></figure><h2 id="edd3" class="na lu it bd lv nb nc dn lz nd ne dp md lg nf ng mf lk nh ni mh lo nj nk mj nl bi translated">应用拦截器</h2><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="17fc" class="na lu it nn b gy nr ns l nt nu">client = new OkHttpClient.Builder()<br/>        .addInterceptor(new SessionTokenInterceptor())</span></pre><p id="d9c4" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz iu">网络拦截器</strong></p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="9d48" class="na lu it nn b gy nr ns l nt nu">client = new OkHttpClient.Builder()<br/>        .addNetworkInterceptor(new LoggingInterceptor())</span></pre><p id="f4ec" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当我们附加一个拦截器作为网络拦截器时，拦截逻辑也应用于中间请求和响应，例如重定向和重试。然而，在应用程序拦截器的情况下，逻辑只应用于重定向情况下的第一个请求和最后一个响应。</p><p id="9145" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们通过<a class="ae mq" href="https://square.github.io/okhttp/interceptors/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中引用的例子来理解它，其中我们编写了一个<em class="nv">日志拦截器</em>，它记录请求和响应，我们对URL <code class="fe nw nx ny nn b"><a class="ae mq" href="http://www.publicobject.com/helloworld.txtwhich" rel="noopener ugc nofollow" target="_blank">http://www.publicobject.com/helloworld.txt</a></code> <a class="ae mq" href="http://www.publicobject.com/helloworld.txtwhich" rel="noopener ugc nofollow" target="_blank">进行网络调用，然后</a>通过返回一个HTTP-3XX响应重定向到<code class="fe nw nx ny nn b"><a class="ae mq" href="https://publicobject.com/helloworld.txt" rel="noopener ugc nofollow" target="_blank">https://publicobject.com/helloworld.txt</a></code>。</p><p id="21eb" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在将<em class="nv"> LoggingInterceptor </em>作为应用程序拦截器附加的情况下，我们在日志中得到以下内容:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="2bfc" class="na lu it nn b gy nr ns l nt nu">INFO: Sending request http://www.publicobject.com/helloworld.txt on null<br/>User-Agent: OkHttp Example<br/><br/>INFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms<br/>Server: nginx/1.4.6 (Ubuntu)<br/>Content-Type: text/plain<br/>Content-Length: 1759<br/>Connection: keep-alive</span></pre><p id="2ab0" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当它作为网络拦截器附加时，以下内容将被推送到日志中:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="edc1" class="na lu it nn b gy nr ns l nt nu">INFO: Sending request http://www.publicobject.com/helloworld.txt on Connection{www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1}<br/>User-Agent: OkHttp Example<br/>Host: www.publicobject.com<br/>Connection: Keep-Alive<br/>Accept-Encoding: gzip<br/><br/>INFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms<br/>Server: nginx/1.4.6 (Ubuntu)<br/>Content-Type: text/html<br/>Content-Length: 193<br/>Connection: keep-alive<br/>Location: https://publicobject.com/helloworld.txt<br/><br/>INFO: Sending request https://publicobject.com/helloworld.txt on Connection{publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1}<br/>User-Agent: OkHttp Example<br/>Host: publicobject.com<br/>Connection: Keep-Alive<br/>Accept-Encoding: gzip<br/><br/>INFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms<br/>Server: nginx/1.4.6 (Ubuntu)<br/>Content-Type: text/plain<br/>Content-Length: 1759<br/>Connection: keep-alive</span></pre><p id="19f1" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我认为您应该对基础知识有足够的了解，以便正确理解和识别安全问题。</p><h1 id="20b0" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">问题！</h1><p id="fe04" class="pw-post-body-paragraph kx ky it kz b la ml ju lc ld mm jx lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">当我们使用一个拦截器将访问令牌附加到HTTP请求上，并将这个拦截器作为应用程序拦截器添加到OkHttp客户端时，就会出现安全问题。</p><p id="126c" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果满足以下任一条件，则应用程序是安全的:</p><ul class=""><li id="4263" class="nz oa it kz b la lb ld le lg ob lk oc lo od ls oe of og oh bi translated">您没有使用拦截器来添加访问令牌</li><li id="ba49" class="nz oa it kz b la oi ld oj lg ok lk ol lo om ls oe of og oh bi translated">您使用名为<em class="nv"> Authorization </em>的HTTP头将访问令牌传递给后端</li><li id="005b" class="nz oa it kz b la oi ld oj lg ok lk ol lo om ls oe of og oh bi translated">你正在使用拦截器，但是你的后端从来没有重定向用户到任何第三方域</li></ul><p id="b374" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">因为如果使用除了<em class="nv">授权</em>之外的任何名称传递访问令牌，即使重定向到外部域，OkHttp应用程序拦截器也会自动将报头附加到重定向。我在OkHttp v3.5上测试了这种行为</p><h1 id="eb5d" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">演示时间</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi on"><img src="../Images/882b041fca8c4313f5fc706e0695c24b.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*ffk-eYjxHPP4xR1L.png"/></div></div></figure><p id="017b" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">出于演示的目的，我创建了一个示例Android应用程序，它使用OkHttp对后端进行API调用，并获得重定向响应。你可以在这里找到源代码<a class="ae mq" href="https://github.com/shivsahni/WhatTheRedirect" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c91e" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我还使用了两个拦截器，即。<em class="nv">session token interceptor</em>和<em class="nv"> LoggingInterceptor </em>。前者用于将会话令牌附加到HTTP请求，后者用于记录所有请求和响应，以便确定意外的第三方数据泄漏。以下是来自应用程序代码的代码片段</p><p id="ebcf" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz iu">session token interceptor</strong></p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="59d1" class="na lu it nn b gy nr ns l nt nu">public Response intercept(Chain chain) throws IOException {<br/><br/>    Request request = chain.request();<br/>    Request newRequest=request.newBuilder().addHeader("Auth", sessionToken)<br/>            .build();<br/>    return chain.proceed(newRequest);<br/><br/>}</span></pre><p id="d987" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kz iu">日志拦截器</strong></p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="3628" class="na lu it nn b gy nr ns l nt nu">@Override public Response intercept(Interceptor.Chain chain) throws IOException {<br/>    Request request = chain.request();<br/>    long t1 = System.<em class="nv">nanoTime</em>();<br/>    Log.<em class="nv">i</em>("Logging Interceptor",String.<em class="nv">format</em>("Sending request %s on %s%n%s",<br/>            request.url(), chain.connection(), request.headers()));<br/>    Response response = chain.proceed(request);<br/>    long t2 = System.<em class="nv">nanoTime</em>();<br/>    Log.<em class="nv">i</em>("Logging Interceptor",String.<em class="nv">format</em>("Received response for %s in %.1fms%n%s",<br/>            response.request().url(), (t2 - t1) / 1e6d, response.headers()));<br/>    return response;<br/>}</span></pre><p id="82a7" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">由于显而易见的原因，<em class="nv"> SessionTokenInterceptor </em>被添加为应用程序拦截器，<em class="nv"> LoggingInterceptor </em>被添加为网络拦截器。下面提到的代码片段描述了同样的情况。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="f558" class="na lu it nn b gy nr ns l nt nu">client = new OkHttpClient.Builder()<br/>        .addInterceptor(new SessionTokenInterceptor())<br/>        .addNetworkInterceptor(new LoggingInterceptor())<br/>        .build();</span></pre><p id="e013" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">您将观察到通过<em class="nv"> SessionTokenInterceptor </em>(作为应用程序拦截器添加)附加的访问令牌被发送到下面提到的日志中的重定向，这就是您可能将用户的访问令牌泄露给第三方的方式。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="0f59" class="na lu it nn b gy nr ns l nt nu">2020-02-27 16:35:17.143 9877-9953/com.example.okhttpinterceptorissue I/Logging Interceptor: Sending request <a class="ae mq" href="http://192.168.1.70:5000/redirect" rel="noopener ugc nofollow" target="_blank">http://192.168.1.70:5000/redirect</a> on Connection{192.168.1.70:5000, proxy=DIRECT hostAddress=/192.168.1.70:5000 cipherSuite=none protocol=http/1.1}<br/>    User-Agent: OkHttp Example<br/>    <strong class="nn iu">Auth: ThisIsASampleSecretSessionToken</strong><br/>    Host: 192.168.1.70:5000<br/>    Connection: Keep-Alive<br/>    Accept-Encoding: gzip<br/>2020-02-27 16:35:17.152 9877-9953/com.example.okhttpinterceptorissue I/Logging Interceptor: Received response for <a class="ae mq" href="http://192.168.1.70:5000/redirect" rel="noopener ugc nofollow" target="_blank">http://192.168.1.70:5000/redirect</a> in 8.2ms<br/>    Content-Type: text/html; charset=utf-8<br/>    Content-Length: 279<br/>    Location: <a class="ae mq" href="http://goidirectory.nic.in/index.php" rel="noopener ugc nofollow" target="_blank">http://goidirectory.nic.in/index.php</a><br/>    Server: Werkzeug/0.15.6 Python/2.7.16<br/>    Date: Thu, 27 Feb 2020 08:35:18 GMT<br/>2020-02-27 16:35:17.163 9877-9953/com.example.okhttpinterceptorissue I/Logging Interceptor: Sending request <a class="ae mq" href="http://goidirectory.nic.in/index.php" rel="noopener ugc nofollow" target="_blank">http://goidirectory.nic.in/index.php</a> on Connection{goidirectory.nic.in:80, proxy=DIRECT hostAddress=goidirectory.nic.in/164.100.58.217:80 cipherSuite=none protocol=http/1.1}<br/>    User-Agent: OkHttp Example<br/>    <strong class="nn iu">Auth: ThisIsASampleSecretSessionToken</strong><br/>    Host: goidirectory.nic.in<br/>    Connection: Keep-Alive<br/>    Accept-Encoding: gzip<br/>2020-02-27 16:35:17.367 9877-9953/com.example.okhttpinterceptorissue I/Logging Interceptor: Received response for <a class="ae mq" href="http://goidirectory.nic.in/index.php" rel="noopener ugc nofollow" target="_blank">http://goidirectory.nic.in/index.php</a> in 202.6ms<br/>    Date: Thu, 27 Feb 2020 08:34:42 GMT<br/>    Server: Apache<br/>    X-Frame-Options: SAMEORIGIN<br/>    Referrer-Policy: same-origin<br/>    Feature-Policy: microphone 'none'; payment 'none'; sync-xhr 'self'<br/>    Expires: Thu, 19 Nov 1981 08:52:00 GMT<br/>    Pragma: no-cache<br/>    Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0<br/>    Set-Cookie: PHPSESSID=hdddiq459djqfadibfgjmattg6; path=/<br/>    X-XSS-Protection: 1; mode=block<br/>    X-Content-Type-Options: nosniff<br/>    Keep-Alive: timeout=5, max=100<br/>    Connection: Keep-Alive<br/>    Transfer-Encoding: chunked<br/>    Content-Type: text/html; charset=UTF-8</span></pre><blockquote class="oo op oq"><p id="21dd" class="kx ky nv kz b la lb ju lc ld le jx lf or lh li lj os ll lm ln ot lp lq lr ls im bi translated">注意:这听起来好像不能直接利用攻击，因为后端应该将重定向发送到外部域(第三方)，这通常是不期望的。但是，这可能与其他攻击媒介结合在一起，例如HTTP请求走私，其中攻击者已经毒害了请求队列，后端服务器将重定向发送到攻击者的域。</p></blockquote><h1 id="64eb" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">减轻</h1><p id="d1c0" class="pw-post-body-paragraph kx ky it kz b la ml ju lc ld mm jx lf lg mn li lj lk mo lm ln lo mp lq lr ls im bi translated">我一发现这一点，就通知了OkHttp团队，根据OkHttp安全团队的说法，这种行为是有意的，风险很低。</p><blockquote class="oo op oq"><p id="02b7" class="kx ky nv kz b la lb ju lc ld le jx lf or lh li lj os ll lm ln ot lp lq lr ls im bi translated">我认为我们的下一步应该是鼓励开发人员在使用包含秘密的HTTP头时使用Authorization头，防止后端重定向到不受信任的服务器。</p></blockquote><p id="d121" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">因此，我想到写这篇博文，让开发者了解安全团队批准后的当前行为。</p><p id="70a8" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">他们建议开发人员应该使用标准的头(授权和Cookies)来发送会话标识符，而不是非标准的头名称</p><p id="be78" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果很难更改auth header的名称，而重定向是预期的，我建议使用<code class="fe nw nx ny nn b">followRedirects(<strong class="kz iu">false</strong>)</code>禁用自动重定向，并使用一个附加的应用程序拦截器来检查响应是否是重定向响应，当且仅当重定向响应中的域是预期的响应时，才继续重定向。</p></div></div>    
</body>
</html>