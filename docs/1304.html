<html>
<head>
<title>Insecure Deserialization: It’s super hard! Or is it?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不安全的反序列化:超级难！或者是？</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/insecure-deserialization-its-super-hard-or-is-it-94d89e2847?source=collection_archive---------0-----------------------#2021-05-09">https://infosecwriteups.com/insecure-deserialization-its-super-hard-or-is-it-94d89e2847?source=collection_archive---------0-----------------------#2021-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="42f1" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="7fd5" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">不安全的去军事化通常被视为一种非常严重的漏洞类型，但也不尽然。这确实需要对所讨论的编程语言有相当的了解，但是如果你对编程语言有所了解的话，这种情况也会发生。</p><p id="25cc" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在本模块中，我们将通过portswigger实验室中的实际例子来了解PHP和Ruby的反序列化过程。这将让我们更好地理解这个概念。</p><p id="fdf3" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">Java序列化和反序列化使用二进制格式，这种格式很难阅读，超出了本文的范围。</p><h1 id="957e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">序列化</h1><p id="0de6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果我们想了解去序列化过程，我们首先需要了解什么是序列化。当我们谈到序列化时，我们指的是将复杂的结构(如对象，例如一个人的年龄、性别和姓名)处理成一种更简单的格式，这样它就可以在一个连续的字节流中发送和接收。这使得我们可以将复杂的数据结构写入内存、文件或数据库，还可以通过网络将数据发送给不同的API。</p><p id="23cd" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">当我们序列化数据时，我们保存它的属性和它们的值，记住这一点非常重要。例如名为“Sophie Kent”的16岁女性将变成类似{female|16|Sophie|kent}的东西</p><p id="01c4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">例如，考虑一个具有PHP属性的用户对象:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="b2bb" class="ma jr it lw b gy mb mc l md me">$user-&gt;name = "carlos";<br/>$user-&gt;isLoggedIn = true;</span></pre><p id="77b9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">序列化时，该对象可能如下所示:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="d352" class="ma jr it lw b gy mb mc l md me">O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}</span></pre><p id="40fd" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这可以解释如下:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="6091" class="ma jr it lw b gy mb mc l md me">O:4:"User" - An object with the 4-character class name "User"<br/>2 - the object has 2 attributes<br/>s:4:"name" - The key of the first attribute is the 4-character string "name"<br/>s:6:"carlos" - The value of the first attribute is the 6-character string "carlos"<br/>s:10:"isLoggedIn" - The key of the second attribute is the 10-character string "isLoggedIn"<br/>b:1 - The value of the second attribute is the boolean value true</span></pre><p id="137f" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu"> Python将序列化称为酸洗</strong></p><p id="ab7d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu"> Ruby将序列化称为编组</strong></p><h1 id="4023" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">反序列化</h1><p id="04cd" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我们反序列化我们相反，我们使用创建的字节流，并把它变成一个对象。狂热的黑客应该已经发现了哪里会出错。</p><figure class="lr ls lt lu gt mg gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/2d835c6abc7ed987837e369d445e5d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*nHqA2bLN2ejzu1Jo_kWlpg.png"/></div></figure><p id="4800" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">序列化具体如何发生在很大程度上取决于编程语言，有些语言可能将对象转换成二进制格式，而其他语言可能使用不同的字符串格式。有些很容易读，有些很难读。</p><h1 id="08b8" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">不安全的去军事化</h1><h1 id="208f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">它是如何发生的？</h1><p id="241c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">无论哪里涉及到用户输入，我们现在或以后都有可能出现问题。在非军事化的情况下，现在正是时候。很难安全地正确序列化或反序列化用户输入，因为开发人员必须创建自己的过滤和黑名单。想想看，现代网站有如此多的依赖项和库，以至于无法预测攻击者可以调用哪些方法。如果攻击者真的下定决心，他们甚至会在通过接收器传递数据时链接不同的方法。</p><p id="669a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">不安全的反序列化令人担忧的是，攻击甚至在反序列化完成之前就发生了。人们普遍缺乏对整个反序列化过程的理解，也不知道反序列化用户输入有多危险。</p><p id="c7c1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">即使在反序列化数据上增加额外的检查也是无效的，因为缺陷发生在反序列化过程之前。</p><p id="26c7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">理想情况下，你永远不应该忽视用户输入！</p><p id="7109" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">由于这个过程的工作方式，我们可以用web应用程序可以访问的任何对象替换序列化对象。这也是为什么不安全的反序列化有时被称为对象注入的原因。</p><h1 id="9ba5" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">如何鉴别？</h1><p id="89aa" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">识别不安全的反序列化通常非常简单。不同的语言都使用特定的格式，如果你知道它看起来像什么，就很容易识别。</p><h1 id="8229" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">服务器端编程语言（Professional Hypertext Preprocessor的缩写）</h1><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="5660" class="ma jr it lw b gy mb mc l md me">O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}</span></pre><p id="cc46" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们之前已经看过这个例子了，PHP将以人类可读的格式序列化数据。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="7493" class="ma jr it lw b gy mb mc l md me">O:4:"User" - An object with the 4-character class name "User"<br/>2 - the object has 2 attributes<br/>s:4:"name" - The key of the first attribute is the 4-character string "name"<br/>s:6:"carlos" - The value of the first attribute is the 6-character string "carlos"<br/>s:10:"isLoggedIn" - The key of the second attribute is the 10-character string "isLoggedIn"<br/>b:1 - The value of the second attribute is the boolean value true</span></pre><h1 id="78ce" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">红宝石</h1><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="243f" class="ma jr it lw b gy mb mc l md me">marshalled = Marshal.dump([1, 2, 'string', Object.new])<br/>This dump method will create a seriliazed object. Our input contains numbers, a string and even an object. We can easily seriliaze those into one and then later deserialize it when we need it. <br/>Result =&gt; "\\x04\\b[\\ti\\x06i\\aI\\"\\vstring\\x06:\\x06ETo:\\vObject\\x00"</span></pre><p id="15d0" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">正如您所看到的，ruby似乎用十六进制表示法(\x04)来表示它的“编组”数据(记住编组是Ruby的序列化术语)。</p><p id="341f" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果我们遇到这种情况，最重要的是我们可以创建一个非常简单的ruby脚本来反序列化这个对象。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="99e2" class="ma jr it lw b gy mb mc l md me">Marshal.load("\\x04\\b[\\ti\\x06i\\aI\\"\\vstring\\x06:\\x06ETo:\\vObject\\x00")<br/># =&gt; [1, 2, "string", #&lt;Object:0x00000002643000&gt;]</span></pre><p id="9186" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然后，我们可以进行任何需要的更改，并用我们前面看到的封送转储方法对其重新编码。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="6c4d" class="ma jr it lw b gy mb mc l md me">marshalled = Marshal.dump([2, 2, 'string', Object.new])</span></pre><h1 id="1e8f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">那么我该如何利用这一点呢？</h1><p id="80c6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以用两种方式来利用这个缺陷，在本文中我将主要介绍函数方式，因为这是我的工作方式，而对象注入通常需要访问源代码。我还将在一定程度上介绍对象注入方法，以便您可以习惯它，如果您对它感兴趣，我希望您能进一步研究它。</p><h1 id="aa24" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">功能测试</h1><p id="aca3" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当我们测试纯粹的功能时，我们依赖于这样一个事实，即我们可能在某个地方找到这些序列化对象中的一个，我们可以操纵它的值。Portswigger labs使用cookies作为示例，但它也可以出现在其他位置，例如可能发送序列化对象的表单中的隐藏字段。我们可以找到serliliazed对象的另一个地方是在javascript代码中，因为它可能需要将其中一个值传递给后端。</p><p id="7309" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果我们看一看portswigger实验室，我们可以看到一些简单的PHP示例。所有这些都依赖于被设置为序列化PHP对象的cookie。如果您检查cookies，您应该会发现与我们的示例类似的内容。你可以简单地编辑这个cookie来做你不应该做的事情。这方面的一个基本示例是，通过更改以下实验中可以找到的布尔值来使自己成为管理员:</p><p id="e09d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><a class="ae mj" href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects" rel="noopener ugc nofollow" target="_blank">https://ports wigger . net/we B- security/deserialization/exploining/la B- deserialization-modificing-serialized-objects</a></p><p id="981a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">像PHP这样的编程语言有一种叫做松散比较运算符的东西。在PHP中这是一个例子。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="1a8e" class="ma jr it lw b gy mb mc l md me">if("a"=="b")</span></pre><p id="d014" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这个==被称为操作符，在这种情况下，两个=符号意味着PHP将检查提供的变量的值，而不是类型。这意味着，如果真正的密码不是以数字开头，并且我们能够将密码设置为0，则以下条件成立。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="87cd" class="ma jr it lw b gy mb mc l md me">$login = unserialize($_COOKIE)<br/>if ($login['password'] == $password)</span></pre><p id="4ee9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><a class="ae mj" href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-data-types" rel="noopener ugc nofollow" target="_blank">https://ports wigger . net/we B- security/deserialization/exploining/la B- deserialization-modificing-serialized-data-types</a></p><p id="9ccc" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">最后一个实验实际上非常聪明，因为它试图让您将几个漏洞链接在一起。你必须在服务器上删除一个文件，这可能是非常具有破坏性的，但删除该文件并不那么容易。毕竟，你怎么能删除一个不属于你的网络服务器上的文件呢？</p><p id="2d31" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这个实验室的cookies中也有序列化的数据，这次它允许您通过提供链接来设置用户头像。这看起来影响不大，因为简单的设定一个头像不会造成太大的伤害，所以让我们继续。</p><p id="7824" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然而，一个聪明的黑客正在思考他们的可能性，他们发现每当他们删除他们的帐户时，通过创建一个新帐户并尝试浏览他的旧头像，头像图片也会被删除，在那里他们会收到404-not found消息。这种行为给了黑客一个主意，他会把头像的位置设置到他想删除的文件上，然后删除账户。突然，他们不能再在网站上冲浪了，他们笑着知道他们刚刚删除了所有的配置文件</p><p id="48b2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><a class="ae mj" href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-using-application-functionality-to-exploit-insecure-deserialization" rel="noopener ugc nofollow" target="_blank">https://ports wigger . net/we B- security/deserialization/exploining/la B- deserialization-using-application-functional-to-exploi-unsecured-deserialization</a></p><p id="9cf2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">所有这些实验都讨论PHP序列化和反序列化，但是当然所有这些攻击在任何其他语言上都是可能的，因为它们都围绕着简单地反序列化这些对象，同时我们进行一些更改并再次序列化有效负载(通过在语言手册中查找要使用的命令并编写一个简单的脚本)。</p><h1 id="2e2c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">对象注入</h1><p id="eced" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae mj" href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-arbitrary-object-injection-in-php" rel="noopener ugc nofollow" target="_blank">https://ports wigger . net/we B- security/deserialization/exploining/la B- deserialization-arbitrary-object-injection-in-PHP</a></p><p id="4de0" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在本实验中，您将学习如何通过在文件名后输入波浪号(~)来查看文件的源代码。这是因为一些编辑器和ide创建了备份文件，并用波形符进行标记。有时候开发人员忘记了他们不应该上传这些文件。</p><p id="1bbf" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在浏览源代码时，我们可以找到__destruct()方法，它将调用lock_file_path属性上的unlink()方法，这将根据PHP手册删除该路径上的文件。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="cb56" class="ma jr it lw b gy mb mc l md me">unlink ( string $filename , resource $context = ? ) : bool<br/>==&gt; Deletes filename. Similar to the Unix C unlink() function. An E_WARNING level error will be generated on failure.</span></pre><p id="b9c0" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">该网站不断引用一些自定义模板PHP站点，所以让我们在这里应用我们的波浪号技巧。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="843d" class="ma jr it lw b gy mb mc l md me"><a class="ae mj" href="https://[[YOUR-LAB-ID]].web-security-academy.net/libs/CustomTemplate.php~" rel="noopener ugc nofollow" target="_blank">https://[[YOUR-LAB-ID]].web-security-academy.net/libs/CustomTemplate.php~</a></span></pre><p id="9cb3" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这给了我们一个很酷的源代码文件，里面有我们讨论过的所有方法。销毁方法是一个所谓的魔法方法，当我们删除一个序列化的对象时，这个方法会被激活。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="5cd9" class="ma jr it lw b gy mb mc l md me">&lt;?php</span><span id="e15b" class="ma jr it lw b gy mk mc l md me">class CustomTemplate {<br/>    private $template_file_path;<br/>    private $lock_file_path;</span><span id="f7f8" class="ma jr it lw b gy mk mc l md me">    public function __construct($template_file_path) {<br/>        $this-&gt;template_file_path = $template_file_path;<br/>        $this-&gt;lock_file_path = $template_file_path . ".lock";<br/>    }</span><span id="449c" class="ma jr it lw b gy mk mc l md me">    private function isTemplateLocked() {<br/>        return file_exists($this-&gt;lock_file_path);<br/>    }</span><span id="706e" class="ma jr it lw b gy mk mc l md me">    public function getTemplate() {<br/>        return file_get_contents($this-&gt;template_file_path);<br/>    }</span><span id="d28c" class="ma jr it lw b gy mk mc l md me">    public function saveTemplate($template) {<br/>        if (!isTemplateLocked()) {<br/>            if (file_put_contents($this-&gt;lock_file_path, "") === false) {<br/>                throw new Exception("Could not write to " . $this-&gt;lock_file_path);<br/>            }<br/>            if (file_put_contents($this-&gt;template_file_path, $template) === false) {<br/>                throw new Exception("Could not write to " . $this-&gt;template_file_path);<br/>            }<br/>        }<br/>    }</span><span id="5771" class="ma jr it lw b gy mk mc l md me">    **function __destruct() {**<br/>        // Carlos thought this would be a good idea<br/>        if (file_exists($this-&gt;lock_file_path)) {<br/>            unlink($this-&gt;lock_file_path);<br/>        }<br/>    }<br/>}</span><span id="9dbe" class="ma jr it lw b gy mk mc l md me">?&gt;</span></pre><p id="abe7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">有了这些信息，我们就能解决实验室的问题。因为在我们的cookies中有一个序列化的对象，我们可以用它来构造一个序列化的对象，它包含指向我们想要删除的文件的lock_file_path。如果我们现在用修改后的会话cookie替换我们的会话cookie，服务器将自动调用__destruct方法并销毁我们的目标文件。</p><p id="aaf1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">不要在BUG奖励或PENTESTING中删除重要或随机的文件！</p><h1 id="71c6" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">下一步是什么？</h1><p id="40c7" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当然，对象注入和功能测试并不是我们在这里唯一能做的两件事。您还可以进一步了解:</p><ul class=""><li id="2476" class="ml mm it kq b kr lm kv ln kz mn ld mo lh mp ll mq mr ms mt bi translated">二元不安全反序列化</li><li id="3a16" class="ml mm it kq b kr mu kv mv kz mw ld mx lh my ll mq mr ms mt bi translated">小工具链</li><li id="aa52" class="ml mm it kq b kr mu kv mv kz mw ld mx lh my ll mq mr ms mt bi translated">创建您自己的漏洞</li><li id="f48a" class="ml mm it kq b kr mu kv mv kz mw ld mx lh my ll mq mr ms mt bi translated">PHAR反序列化</li><li id="dfad" class="ml mm it kq b kr mu kv mv kz mw ld mx lh my ll mq mr ms mt bi translated">使用内存损坏的去串行化</li></ul><h1 id="1fe1" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">资源</h1><p id="9ec0" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae mj" href="https://stackoverflow.com/questions/410186/how-does-ruby-serialization-marshaling-work" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/410186/how-do-ruby-serialization-marshaling-work</a></p><p id="227b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><a class="ae mj" href="https://portswigger.net/web-security/deserialization/exploiting" rel="noopener ugc nofollow" target="_blank">https://ports wigger . net/we B- security/deserialization/exploining</a></p><p id="f758" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">【https://docs.python.org/3/library/pickle.html T4】</p></div></div>    
</body>
</html>