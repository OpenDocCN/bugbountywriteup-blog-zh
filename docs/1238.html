<html>
<head>
<title>RET2LIBC ATTACK IN LINUX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LINUX中的RET2LIBC攻击</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/ret2libc-attack-in-lin-3dfc827c90c3?source=collection_archive---------2-----------------------#2021-04-16">https://infosecwriteups.com/ret2libc-attack-in-lin-3dfc827c90c3?source=collection_archive---------2-----------------------#2021-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="efc7" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Ret2Libc — -&gt;返回Libc</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/98eb8134fa6fef7a15e733f7728a088d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S0gumJcSTcwp4C7l.png"/></div></div></figure><h1 id="b63e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">LIBC</h1><p id="4540" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">术语“libc”通常用作“标准C库”的简写，这是一个标准函数库，可由所有C程序使用(有时也可由其他语言的程序使用)。</p><p id="86d3" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">更多关于<a class="ae ma" href="https://man7.org/linux/man-pages/man7/libc.7.html" rel="noopener ugc nofollow" target="_blank"> LIBC </a></p><h1 id="8ba7" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">方法学</h1><p id="d627" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">每当程序调用一个函数时，该函数所需的参数就被加载到堆栈中，以便基指针(BP)可以很容易地指向它来处理指令。</p><p id="8cff" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">我们不能将一个仲裁地址指向指令指针(IP)来从那个地址运行我们的外壳代码。</p><p id="d7a9" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这将会失败，因为当NX位启用时，不会执行外壳代码。</p><h2 id="6f4f" class="mb jo iq bd jp mc md dn jt me mf dp jx li mg mh kb lm mi mj kf lq mk ml kj mm bi translated">绕过NX位保护的常用方法是尝试ret2libc攻击</h2><p id="41d7" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在这种攻击中，我们会将函数参数直接加载到堆栈中，以便我们需要的其他函数可以调用它。</p><h2 id="0712" class="mb jo iq bd jp mc md dn jt me mf dp jx li mg mh kb lm mi mj kf lq mk ml kj mm bi translated">工作机制</h2><p id="01a4" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">所以为了实现这个目标，</p><ol class=""><li id="1375" class="mn mo iq kz b la lv le lw li mp lm mq lq mr lu ms mt mu mv bi translated">我们可以通过将函数加载到缓冲区来将函数的参数传递到堆栈中</li><li id="a4b3" class="mn mo iq kz b la mw le mx li my lm mz lq na lu ms mt mu mv bi translated">将我们的指令指针(IP)指向另一个使用我们传递的输入作为参数的函数</li><li id="e232" class="mn mo iq kz b la mw le mx li my lm mz lq na lu ms mt mu mv bi translated">当程序从指定的函数中出来时，返回要执行的函数</li></ol><h2 id="7d0b" class="mb jo iq bd jp mc md dn jt me mf dp jx li mg mh kb lm mi mj kf lq mk ml kj mm bi translated">需要指向什么类型的函数</h2><p id="9e7a" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">可重用函数需要在指令指针(IP)中指向</p><p id="b269" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这些函数可以内置在程序中，也可以从库中调用</p><p id="aa25" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">对于ret2libc，函数应该来自libc</p><h1 id="ccd3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">剥削</h1><p id="fb17" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在Ret2Libc攻击中，我们将指向Libc库中的函数</p><p id="c19d" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这就是这种攻击得名“ret2libc”的原因</p><p id="26fa" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">就LIBC而言，这个库中的每个函数都存在于离库底的固定偏移量处</p><p id="c6d1" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">如果已知库版本和库基值地址，我们可以很容易地从中计算出任何函数的地址</p><p id="ffcc" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">要计算LIBC的功能地址，<a class="ae ma" href="https://libc.blukat.me/" rel="noopener ugc nofollow" target="_blank">点击这里</a></p><h1 id="7c44" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用RET2LIBC生成SHELL</h1><p id="07e6" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们考虑一个易受攻击的程序作为这种攻击的例子</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/f2e7617c29d0cf0359fb1b0d18d8948e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GasogSmTFBxIdvfT.png"/></div></div></figure><p id="279f" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">让我们以32位模式编译这个二进制文件</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/53ad8dc3e4fd2a7577c3f4f4d5c666e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m_xPZA__y81nTJGa.png"/></div></div></figure><p id="523b" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">我们没有使用<code class="fe nd ne nf ng b"> -z execstack</code>来使堆栈可执行</p><p id="3c27" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">让我们运行“checksec”来检查这个二进制文件的安全保护</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/afaabc6467e1fb4a82bc46c84e38aace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8QFGwjPIShgQCcmY.png"/></div></div></figure><p id="9052" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">所以应该启用我们的NX位，以避免在堆栈中执行</p><h2 id="6295" class="mb jo iq bd jp mc md dn jt me mf dp jx li mg mh kb lm mi mj kf lq mk ml kj mm bi translated">破坏我们的计划</h2><p id="a9f1" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们检查一下这个程序是否会崩溃</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/82d975da68a2dbc8972537e45969f7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K6_HoFGp1uuYhDku.png"/></div></div></figure><p id="32ae" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">当我们传递大于缓冲区大小的输入时，这个程序会崩溃</p><h2 id="f832" class="mb jo iq bd jp mc md dn jt me mf dp jx li mg mh kb lm mi mj kf lq mk ml kj mm bi translated">寻找偏移</h2><p id="5d16" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在确认程序崩溃后</p><p id="b0bb" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">我们需要找到指令指针的偏移量(IP)</p><p id="bb04" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这样我们就可以将有效载荷精确地传递到缓冲区中</p><p id="7eff" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">让我们在GDB-PEDA中创建一个随机模式，将其作为输入来传递，以找到偏移值</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/f615d0449e704cf3c1c21ec1978ccef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RaQNP7L_Zhigpnqt.png"/></div></div></figure><p id="248e" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">将这个模式传递到缓冲区中，我们的程序会再次崩溃</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nk"><img src="../Images/d4c0e259235dd3f7aa29ac89c9ba9efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k4aBQyXjIx_iID9c.png"/></div></div></figure><p id="dea0" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">我们可以看到，我们的基本指针(BP)、指令指针(IP)被生成的模式中的值覆盖了</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/eb36c779a1a22b5f44127460a197da8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/0*_OcOx_puq2nXCNdt.png"/></div></figure><p id="6f62" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">现在我们从模式值中找到了指令指针(IP)的偏移值</p><h2 id="8004" class="mb jo iq bd jp mc md dn jt me mf dp jx li mg mh kb lm mi mj kf lq mk ml kj mm bi translated">控制指令指针</h2><p id="1059" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们用python编写一个输入数据来测试我们是否能正确地覆盖指令指针(IP)</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/667e4273ad8e89c785fad16ad5c069cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oAZgubrwdGTwJ3oZ.png"/></div></div></figure><p id="22a2" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">在程序崩溃后，通过检查寄存器，我们可以说我们的输入数据成功地覆盖了寄存器</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nn"><img src="../Images/17a2ae232783f8474341f33e90f525fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SLxhhXhxZnFPi3wR.png"/></div></div></figure><p id="161a" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">我们的指令指针(IP)由0x42424242填充</p><p id="0ee3" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">所以我们现在控制指令指针(IP)</p><h2 id="927f" class="mb jo iq bd jp mc md dn jt me mf dp jx li mg mh kb lm mi mj kf lq mk ml kj mm bi translated">形成RET2LIBC</h2><p id="11d2" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">为了成功执行ret2libc，我们需要一个可用且可执行的带参数的函数</p><p id="c735" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">如果我们需要在不崩溃的情况下退出函数(如果需要的话),要执行的返回函数</p><p id="467f" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">在此之前，让我们检查堆栈中的数据</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi no"><img src="../Images/ba432851f76c74eedb47011bfe12745a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I6sMZMyF4ubFhfIS.png"/></div></div></figure><p id="9518" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">程序再次崩溃</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi np"><img src="../Images/013b3d80386cf29cdf5702a53a904f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9PVIwQ5IlKPhxkL9.png"/></div></div></figure><p id="634f" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">因此，我们的数据“XXXXYYYYZZZZ”正确地存储在堆栈指针(SP)中</p><p id="269c" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">代替“XXXXYYYYZZZZ ”,我们将传递参数，这些参数将由函数在被调用时执行</p><p id="6d6f" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">因此，执行ret2libc的关键取决于以下顺序中的值</p><ol class=""><li id="c35e" class="mn mo iq kz b la lv le lw li mp lm mq lq mr lu ms mt mu mv bi translated">需要从指令指针调用函数(函数存在于LIBC)</li><li id="1227" class="mn mo iq kz b la mw le mx li my lm mz lq na lu ms mt mu mv bi translated">退出第一个函数时将执行的返回函数</li><li id="ea33" class="mn mo iq kz b la mw le mx li my lm mz lq na lu ms mt mu mv bi translated">要传递的参数</li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/1ff9c2ceffae471139875a1e78671941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eCD2b7SjSk0IoXtT.jpg"/></div></div></figure><p id="8054" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">为了生成shell，我们将从LIBC调用“system()”</p><p id="dff1" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">并将“/bin/sh”作为参数传递，它将生成$</p><p id="5ca8" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这类似于，</p><p id="cbd9" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated"><code class="fe nd ne nf ng b">system('/bin/sh')</code></p><p id="9301" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">值“/bin/sh”不应作为字符串传递</p><p id="cfbf" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">应该是从一个地址指向的</p><p id="a0a2" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">当shell生成成功时，我们需要一个退出函数，否则程序会崩溃</p><p id="ef8b" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">为此，我们使用“exit()”，这是一个简单的退出函数</p><p id="17ff" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">要得到这些函数的地址，我们可以用GDB-PEDA法很容易地搜索到它</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/b8a3b8685ee445e585248235585e2d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n0fMEICGCoQMl1T6.png"/></div></div></figure><p id="7128" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这里我们从LIBC得到了“system()”和“exit()”的地址</p><p id="d185" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">我们还可以看到，这些地址位于LIBC的可执行内存区域，这样的函数只能用于ret2libc攻击</p><p id="4675" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">查找“/bin/sh”指针</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/2e342b6d1b76af35186a75952e1e8e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/0*g_GqMB3oOUC1Giz_.png"/></div></figure><p id="80d3" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">我们还可以为我们想要的参数导出一个环境变量，并调用它作为执行ret2libc的指针</p><h2 id="02e5" class="mb jo iq bd jp mc md dn jt me mf dp jx li mg mh kb lm mi mj kf lq mk ml kj mm bi translated">生成漏洞</h2><p id="1ebd" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在有了这些地址值，让我们用python来制作我们的漏洞</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/13c61124f82399bf0a5a0c358fcacdab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oTDnR-iLP2lbczW4.png"/></div></div></figure><p id="2ed9" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">不要忘记将这些地址转换成小端(如果处理器是小端)</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nu"><img src="../Images/4ea9f4fabb3d6a670f5c43ed160d6f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*87fYELn_pYbnkFhb.png"/></div></div></figure><p id="b709" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">通过GDB调试器中的这个漏洞，我们可以看到PID</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nv"><img src="../Images/595c8f8ee953a61b08bd2d3b6d0462e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vvf4YlklEL_RiyJy.png"/></div></div></figure><p id="b9c1" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">所以shell正在生成，它还打印了命令的输出</p><p id="dbc4" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">让我们在调试器中尝试一下</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nw"><img src="../Images/4a2cc416002291616e0175466b1540ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ioye0aSMU7TINlJB.png"/></div></div></figure><p id="adbf" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">或者我们也可以从脚本中运行它</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nx"><img src="../Images/94f747edb16e405886e65a6a4fde7713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4jNnZH-euRk5N7-P.png"/></div></div></figure><p id="5097" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">有时，由于不正确的STDIN处理，您的利用可能会失败</p><p id="e430" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">要克服这一点，您可以使用<code class="fe nd ne nf ng b"> (cat payload;cat) | ./ret2libc</code></p><h2 id="95ae" class="mb jo iq bd jp mc md dn jt me mf dp jx li mg mh kb lm mi mj kf lq mk ml kj mm bi translated">剥削结束了</h2><h2 id="431b" class="mb jo iq bd jp mc md dn jt me mf dp jx li mg mh kb lm mi mj kf lq mk ml kj mm bi translated">执行RET2LIBC</h2><h2 id="049b" class="mb jo iq bd jp mc md dn jt me mf dp jx li mg mh kb lm mi mj kf lq mk ml kj mm bi translated">GitHub Repo中提供了漏洞利用示例</h2><h2 id="17b1" class="mb jo iq bd jp mc md dn jt me mf dp jx li mg mh kb lm mi mj kf lq mk ml kj mm bi translated"><a class="ae ma" href="https://github.com/AidenPearce369/ExploitDev" rel="noopener ugc nofollow" target="_blank">aiden peace 369</a></h2></div></div>    
</body>
</html>