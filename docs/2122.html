<html>
<head>
<title>[BugBounty] Tips to Find Stored XSS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[BugBounty]找到储存的XSS的提示</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/bugbounty-tips-to-find-stored-xss-9995814d353f?source=collection_archive---------0-----------------------#2022-06-08">https://infosecwriteups.com/bugbounty-tips-to-find-stored-xss-9995814d353f?source=collection_archive---------0-----------------------#2022-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/56c3bef53ce57b65ba96b835e968f62c.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*Q4FqFV_y2V7Ue3CDEnU13A.png"/></div></figure><h1 id="74fc" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">介绍</h1><p id="5117" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">今天，我想分享一些简单快捷的方法来找到存储的XSS(跨站点脚本)漏洞，以及我在<a class="ae lt" href="https://hackerone.com/" rel="noopener ugc nofollow" target="_blank"> HackerOne </a>私人程序中报告的2个存储的XSS漏洞。</p><p id="4d96" class="pw-post-body-paragraph kv kw it kx b ky lu la lb lc lv le lf lg lw li lj lk lx lm ln lo ly lq lr ls im bi translated">对于任何不熟悉AppSec或Bug Bounty的人来说，当应用程序接收到用户输入的数据，并将该数据保存在应用程序后来的HTTP响应中，并以不安全的方式呈现该数据时，就会发生存储XSS(也称为持久XSS)。例如，如果允许用户在web应用程序的注释部分输入任何数据，她可以在易受攻击的注释部分插入一个XSS负载，比如<code class="fe lz ma mb mc b">&lt;script&gt;alert('XSS')&lt;/script&gt;</code>。如果web应用程序按原样保存不受信任的用户提供的XSS有效负载，并且不进行任何清理就呈现它，则该有效负载将在访问受影响页面的任何其他用户的浏览器上执行。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="1e3a" class="jx jy it bd jz ka mk kc kd ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku bi translated">1.寻找不同的渲染区域</h1><p id="9a0c" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">很多时候，我试图使用手动方法来寻找XSS或HTML注入漏洞。例如，如果有一个用户输入字段，比如profile页面的用户名字段，我注入一个简单的有效负载，比如<code class="fe lz ma mb mc b">&lt;h1&gt;test&lt;/h1&gt;</code>，并检查应用程序中不同的呈现页面。如果幸运的话，你可以通过这种方式找到一个储存的XSS。这是因为对于一个复杂的应用程序，开发人员很难对每个呈现页面强制执行相同的数据清理。</p><p id="bf58" class="pw-post-body-paragraph kv kw it kx b ky lu la lb lc lv le lf lg lw li lj lk lx lm ln lo ly lq lr ls im bi translated">对于我的第一个存储的XSS例子，我用这个简单的方法获得了1000美元的奖金。目标应用程序是一个复杂的网络设备监控工具。在测试应用程序时，我发现用户输入字段“Device Name”在呈现时没有对JavaScript有效载荷(<code class="fe lz ma mb mc b">&lt;p onmouseover="alert(document.cookie)"&gt;payload&lt;/p&gt;</code>)进行编码。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mp"><img src="../Images/2544ada0bda52055fc03489360f4af93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*37-h-FqEBaLmf-TWLdCR2g.png"/></div></div></figure><p id="764f" class="pw-post-body-paragraph kv kw it kx b ky lu la lb lc lv le lf lg lw li lj lk lx lm ln lo ly lq lr ls im bi translated">接下来，我开始寻找不同的渲染页面，这些页面将显示更新的设备名称，以查看它们如何显示注入的有效载荷。大多数页面都得到了适当的开发，它们仍然将注入的有效负载呈现为字符串值；然而，我发现一个显示<strong class="kx iu">用户活动日志的区域</strong>没有清理有效载荷，而是执行了XSS有效载荷。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi my"><img src="../Images/579220a7f9d07ceb4d1d3baaed17474d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kBWCzF4lFZvGx_THTGmZww.png"/></div></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="9aa6" class="jx jy it bd jz ka mk kc kd ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku bi translated">2.通过API请求绕过数据清理</h1><p id="3ede" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我找到的下一个存储的XSS是通过使用一个API请求发现的，该请求绕过GUI环境中的数据清理来注入XSS有效负载。受影响的应用程序是一个网站，用户可以在那里分享他们的食物食谱，并与其他用户进行评论。用户可以在注册过程中设置她的名字和姓氏，输入字段也只允许名字和姓氏使用字母数字字符。一旦设置了名称，用户就不能在个人资料页面中修改它们了(但是如果需要，用户可以更新电子邮件)。</p><p id="3019" class="pw-post-body-paragraph kv kw it kx b ky lu la lb lc lv le lf lg lw li lj lk lx lm ln lo ly lq lr ls im bi translated">当我进一步枚举用户配置文件信息的API端点时，我能够找到一个在<code class="fe lz ma mb mc b">/api/customers/&lt;Customer ID&gt;</code>端点更新电子邮件的<code class="fe lz ma mb mc b">PUT</code>请求:</p><pre class="mq mr ms mt gt mz mc na nb aw nc bi"><span id="4eec" class="nd jy it mc b gy ne nf l ng nh">PUT /api/customers/11119999/ HTTP/2 <br/>Host: &lt;REDACTED&gt; </span><span id="301b" class="nd jy it mc b gy ni nf l ng nh">...snip... </span><span id="fec0" class="nd jy it mc b gy ni nf l ng nh">{ <br/>    "email":"newEmail@email.com" <br/>}</span></pre><p id="6247" class="pw-post-body-paragraph kv kw it kx b ky lu la lb lc lv le lf lg lw li lj lk lx lm ln lo ly lq lr ls im bi translated">所以我在想，如果我试图使用这个API来更改用户的名字或姓氏，我可能已经注入了一个XSS有效载荷，会怎么样呢？原来是我可以:)所以我注入了下面的API请求，将<code class="fe lz ma mb mc b">email</code>改为<code class="fe lz ma mb mc b">firstName</code>，应用程序用<code class="fe lz ma mb mc b">204 No Content</code>响应:</p><pre class="mq mr ms mt gt mz mc na nb aw nc bi"><span id="47ae" class="nd jy it mc b gy ne nf l ng nh">PUT /api/customers/11119999/ HTTP/2 <br/>Host: &lt;REDACTED&gt;</span><span id="2061" class="nd jy it mc b gy ni nf l ng nh">...snip...</span><span id="6baf" class="nd jy it mc b gy ni nf l ng nh">{ <br/>    "firstName":"&lt;img src='x' onerror='alert(1)'&gt;" <br/>}</span></pre><blockquote class="nj nk nl"><p id="b5f0" class="kv kw nm kx b ky lu la lb lc lv le lf nn lw li lj no lx lm ln np ly lq lr ls im bi translated"><strong class="kx iu"> 204无内容</strong> —服务器已经完成请求，但是不需要返回实体主体，并且可能想要返回更新的元信息。</p></blockquote><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nq"><img src="../Images/5398eb15d04ef410e5f3136a3a4b746a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DsNKDQw7Q7JjeE1RdQ0tQ.png"/></div></div></figure><p id="d170" class="pw-post-body-paragraph kv kw it kx b ky lu la lb lc lv le lf lg lw li lj lk lx lm ln lo ly lq lr ls im bi translated">当我转到主页时，我可以看到我的名字现在已经成功地更改为XSS有效载荷，但是在那里它被视为一个字符串值。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nq"><img src="../Images/6eab91f1fdb0e85a704936742d8788c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZpudULCOHHj0Qq0p6aynUA.png"/></div></div></figure><p id="7b1a" class="pw-post-body-paragraph kv kw it kx b ky lu la lb lc lv le lf lg lw li lj lk lx lm ln lo ly lq lr ls im bi translated">但是你还记得我们第一个寻找不同渲染区域的方法吗？:)对，所以我的下一步是寻找显示用户名字的不同呈现页面。我发现用户可以对一个食谱发表评论，它会显示用户名字的评论。所以，我认为这可能是一个很好的地点来检查储存的XSS。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nr"><img src="../Images/e3a8cbebaaa929d51289d23da144642f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYS1C9PlWNiTdf2k9ci45A.png"/></div></div></figure><p id="c92d" class="pw-post-body-paragraph kv kw it kx b ky lu la lb lc lv le lf lg lw li lj lk lx lm ln lo ly lq lr ls im bi translated">一旦我把评论留给了评论，并重新访问了同一个菜谱，XSS的有效负载就被执行了。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ns"><img src="../Images/dc6558ffaace6a193cc29f180ed0d45f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wd-1OCBnFaFAGd8HG0eFOw.png"/></div></div></figure><p id="4b3a" class="pw-post-body-paragraph kv kw it kx b ky lu la lb lc lv le lf lg lw li lj lk lx lm ln lo ly lq lr ls im bi translated">这个有效负载是为任何访问过这个菜谱的用户执行的，这个发现被程序归类为关键。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="22ae" class="jx jy it bd jz ka mk kc kd ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku bi translated">最终想法！</h1><p id="cbc6" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当做一个Bug赏金的时候，自动脚本或者扫描器不会永远是你的朋友。有时候，做一些手工测试来发现一些简单的问题会更好。感谢阅读！</p></div></div>    
</body>
</html>