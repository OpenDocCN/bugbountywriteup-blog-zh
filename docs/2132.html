<html>
<head>
<title>The terrifying world of Cross-Site Scripting (XSS) (Part 2) — StackZero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跨站脚本的可怕世界(XSS)(第二部分)——stack zero</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-terrifying-world-of-cross-site-scripting-xss-part-2-stackzero-cc7fa7e8dcbb?source=collection_archive---------1-----------------------#2022-06-14">https://infosecwriteups.com/the-terrifying-world-of-cross-site-scripting-xss-part-2-stackzero-cc7fa7e8dcbb?source=collection_archive---------1-----------------------#2022-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a2c6348be0b43669ffe8e6c6cc70227e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55mfYgdaxF8YQrh2hCPilQ.jpeg"/></div></div></figure><h1 id="27df" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="6188" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我已经在文章第1部分的<a class="ae lx" href="https://www.stackzero.net/xss/" rel="noopener ugc nofollow" target="_blank"> XSS简介</a>中讨论了这个漏洞。无论如何，只是为了快速刷新，XSS是一个漏洞，使攻击者能够将恶意代码注入其他用户浏览的网页。【types有三种类型:</p><p id="6ca3" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在文章的第二部分，我要做的只是构建一个简单的易受攻击的应用程序，然后尝试利用它们。即使它只包含理解所必需的内容，我也会尝试实现所有类型的漏洞。</p><p id="56d8" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">让我们一起努力实现目标，更好地了解XSS。</p><p id="d004" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在开始之前，这里有一个快速导航的相关文章列表:</p><ul class=""><li id="630d" class="md me it lb b lc ly lg lz lk mf lo mg ls mh lw mi mj mk ml bi translated"><a class="ae lx" href="https://medium.com/codex/the-terrifying-world-of-cross-site-scripting-xss-part-1-stackzero-54be9cdc011a" rel="noopener">跨站脚本的恐怖世界(XSS)(第一部分)</a></li><li id="a3f4" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" href="https://medium.com/@stackzero/the-terrifying-world-of-cross-site-scripting-xss-part-2-stackzero-cc7fa7e8dcbb" rel="noopener">跨站脚本的恐怖世界(XSS)(第二部分)</a></li><li id="b263" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" href="https://medium.com/codex/xss-in-practice-how-to-exploit-xss-in-web-applications-walktrought-into-google-xss-game-c939f30005ea" rel="noopener">实践中的XSS:如何在web应用程序中利用XSS</a></li><li id="3d3e" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/reflected-xss-dvwa-an-exploit-with-real-world-consequences-stackzero-171cfb2d87d2">反映了XSS DVWA——一个具有真实世界后果的漏洞</a></li><li id="5e37" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/how-to-exploit-a-stored-xss-vulnerability-on-dvwa-stackzero-1de6cc9545b9">如何利用DVWA上存储的XSS漏洞</a></li><li id="9ff6" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/how-to-exploit-dom-xss-on-dvwa-stackzero-c83a682ed7b7">如何在DVWA上利用多姆XSS</a></li></ul><h1 id="c255" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">要求</h1><p id="eae9" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我认为为了让一切更具可读性，Python将是正确的选择，我们将用<a class="ae lx" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a> / <a class="ae lx" href="https://flask.palletsprojects.com/en/2.1.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a>编写整个应用程序，并用<a class="ae lx" href="https://www.javascript.com/" rel="noopener ugc nofollow" target="_blank"> Javascript </a>编写最后一部分。</p><p id="5a5e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我们只需要:</p><p id="d34f" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">为了安装<a class="ae lx" href="https://flask.palletsprojects.com/en/2.1.x/" rel="noopener ugc nofollow" target="_blank">烧瓶</a>，我们必须打开一个新的终端并键入:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c40a" class="na kc it mw b gy nb nc l nd ne">pip3 install flask</span></pre><p id="478a" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">如果有什么问题，你可以在这里找到官方指南。</p><p id="e923" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在满足所有要求之后，我们可以构建我们的应用程序结构:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="7459" class="na kc it mw b gy nb nc l nd ne">from flask import Flask, request<br/>from pathlib import Path</span><span id="caa2" class="na kc it mw b gy nf nc l nd ne">app = Flask("__name__")</span><span id="0eb8" class="na kc it mw b gy nf nc l nd ne"># Code Here</span><span id="350f" class="na kc it mw b gy nf nc l nd ne">app.run(host="0.0.0.0", port=5000)</span></pre><p id="3a5e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这是一个空的应用程序，此时，我们只需要定义端点。</p><h1 id="1e45" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">反射式跨站点脚本</h1><p id="3586" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是最容易理解的，我们将通过从查询字符串中取出未排序的变量，并将其放入服务器的页面中来实现漏洞。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c199" class="na kc it mw b gy nb nc l nd ne"><a class="ae lx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/reflected-xss")<br/>def reflected_xss():<br/>    name = request.args.get("name")<br/>    page = f"""<br/>            &lt;html&gt;<br/>                &lt;head&gt; &lt;/head&gt;<br/>                &lt;body&gt;<br/>                    &lt;h1&gt;Hello {name}! &lt;/h1&gt;<br/>                &lt;/body&gt;<br/>            &lt;/html&gt;<br/>    """<br/>    return page</span></pre><p id="4428" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">正如我们所看到的，服务器将我们传递给变量<em class="ng">“name”</em>的内容放入HTML。</p><p id="6cbb" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">如果我们想利用，让我们运行服务器:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="bc34" class="na kc it mw b gy nb nc l nd ne">python3 main.py</span></pre><p id="4a93" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在我们想运行以下恶意脚本作为概念证明:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a8b6" class="na kc it mw b gy nb nc l nd ne">&lt;script&gt; alert("You have been hacked"); &lt;/script&gt;</span></pre><p id="dd12" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">为此，让我们打开浏览器并连接到以下地址:</p><p id="fd93" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu">http://127 . 0 . 0 . 1:5000/reflected-XSS？name= &lt; script &gt; alert("你被黑了！");&lt;/脚本&gt; </strong></p><p id="7af9" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">它将显示一个包含字符串“你已经被黑客攻击！”<br/>显然，这是无害的，但它让我们明白黑客是如何在我们的浏览器中运行任意代码的。</p><p id="82d9" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">容易吗？现在我想更进一步。</p><h1 id="1c72" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">存储的跨站点脚本</h1><p id="b4e6" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在这种情况下，服务器必须存储脚本，这只是为了创建一个简单的持久性机制。</p><p id="d6d8" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">所以实际结果是实现了一个非常基本的留言簿，但是为了避免无用的复杂性，我们将所有消息保存在一个简单的文本文件中。这很好地满足了我们的目的，可以让我们专注于主题。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="15ff" class="na kc it mw b gy nb nc l nd ne"><a class="ae lx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/stored-xss", methods=["POST", "GET"])<br/>def stored_xss():</span><span id="2f3b" class="na kc it mw b gy nf nc l nd ne">db_file = "comments.txt"</span><span id="9c0f" class="na kc it mw b gy nf nc l nd ne">file = Path(db_file)<br/>    file.touch(exist_ok=True)</span><span id="40a8" class="na kc it mw b gy nf nc l nd ne">if request.method == "POST":<br/>        comment = request.form["comment"]</span><span id="f2bf" class="na kc it mw b gy nf nc l nd ne">with open(db_file, "a") as f:<br/>            f.write(comment + "\n")</span><span id="f7b0" class="na kc it mw b gy nf nc l nd ne">comments = ""<br/>    with open(db_file, "r+") as f:<br/>        for line in f.readlines():<br/>            comments += f"&lt;div&gt;{line}&lt;/div&gt;"</span><span id="592e" class="na kc it mw b gy nf nc l nd ne">page = f"""<br/>        &lt;html&gt;<br/>        &lt;head&gt;&lt;/head&gt;<br/>        &lt;body&gt;<br/>            &lt;form action="#" method="POST"&gt;<br/>                &lt;input type="text" id="comment" name="comment"&gt;&lt;br&gt;&lt;br&gt;<br/>                &lt;input type="submit" value="Submit"&gt;<br/>            &lt;/form&gt;<br/>            {comments}<br/>        &lt;/body&gt;<br/>        &lt;/html&gt; <br/>    """<br/>    return page</span></pre><p id="d96c" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">代码是不言自明的，为了清楚起见，我想列出它的流程。</p><p id="2562" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这些是此代码执行的操作:</p><ul class=""><li id="8288" class="md me it lb b lc ly lg lz lk mf lo mg ls mh lw mi mj mk ml bi translated">定义一个名为stored_xss的路由，允许使用POST或GET方法进行访问。</li><li id="f75f" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">如果不存在名为【T6 " comments . txt "的数据库文件，则创建该文件。</li><li id="0b43" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">如果请求方法是POST，它会将表单中的注释添加到数据库文件中。</li><li id="6556" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">最后，它读取数据库文件并在页面上显示注释。</li></ul><p id="f71b" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">正如我们之前所做的那样，现在是时候测试利用漏洞了，让我们打开浏览器，查看地址:</p><p id="6197" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><a class="ae lx" href="http://localhost:5000/stored-xss" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">http://localhost:5000/stored-XSS</strong></a></p><p id="1306" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在这种情况下，输入来自POST方法，因此我们必须将漏洞放入“name”表单，然后单击submit按钮。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/c6e2594259ba9e08e6603ad1342f55c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FoqtrH-DxP1G923F0wrhVw.jpeg"/></div></div></figure><p id="39a2" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">然后，在提交之后，服务器将给定的脚本存储在我们的数据库中，每次我们打开页面时弹出窗口都会出现。</p><p id="454e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">显而易见，这种类型的跨站点脚本有多危险，每次用户打开易受攻击的页面时，都会受到攻击。</p><h1 id="f426" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">基于DOM的跨站点脚本</h1><p id="07d9" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是涉及客户端处理的漏洞。所以我们要做的是处理Url并将其写入DOM。<br/>显然，它与第一个示例非常相似，但更深入地看，这次遗漏的清理发生在客户端，而在前一个示例中，易受攻击的输入由服务器反映。</p><p id="63cf" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">但是看一下代码:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="1441" class="na kc it mw b gy nb nc l nd ne"><a class="ae lx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/dom-based-xss")<br/>def dom_based_xss():<br/>    page = """<br/>        &lt;html&gt;<br/>        &lt;head&gt;&lt;/head&gt;<br/>        &lt;body&gt;<br/>            &lt;h1&gt;Hello <br/>                &lt;script&gt;<br/>                var name_start = document.location.href.indexOf("name=");<br/>                var name_end = document.location.href.substring(name_start).indexOf("&amp;");<br/>                <!-- -->if(name_start == -1)<br/>                    var name= "Anonymous";<br/>                else if(name_end != -1)<br/>                    var name = document.location.href.substring(name_start+5, name_start+name_end);<br/>                else<br/>                    var name = document.location.href.substring(name_start+5);<br/>                document.write(decodeURIComponent(name));  <br/>                &lt;/script&gt;<br/>            <br/>            &lt;/h1&gt;<br/>   <br/>        &lt;/body&gt;<br/>        &lt;/html&gt;<br/>    """</span><span id="e28b" class="na kc it mw b gy nf nc l nd ne">return page</span></pre><p id="fcf7" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">很明显没有服务器端处理，但它只是返回一个HTML/Javascript页面。</p><p id="38dd" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">“script”标记中的代码从URL中检索“name”参数的值，并将其写入文档。</p><p id="6cc6" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">具体来说，它从变量分隔符<em class="ng"> " &amp; " </em>中获取<em class="ng"> "name=" </em>的索引。</p><p id="62e2" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">例如，看看我们连接到这个地址的情况(localhost是127.0.0.1的别名):</p><p id="52fc" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><a class="ae lx" href="http://localhost:5000/dom-based-xss?name=stackzero&amp;othervariable=othervalue" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">http://localhost:5000/DOM-based-XSS？name = stack zero&amp;other variable = other value</strong></a></p><p id="6bc8" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">页面内的脚本将解析URL，并将值“stackzero”放入name变量，该值是index of<em class="ng">(“name= "</em>)+5(5是字符串“name = ")和indexOf( <em class="ng"> " &amp; " </em>)之间的子字符串。</p><p id="30f5" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">即使在这种情况下，字符串也不会被清理，所以为了利用这个漏洞，我们可以像在反射XSS案例中那样，将恶意脚本放入URL中。</p><p id="8c11" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu">http://localhost:5000/DOM-based-XSS？name= &lt; script &gt; alert("你被黑了！");&lt;/脚本&gt;/T13】</strong></p><h1 id="27e0" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">一些快速缓解</h1><p id="1841" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">正如我们在XSS介绍文章中看到的，防止攻击的方法是净化输入，让我们看看如何在我们的应用程序中做到这一点。</p><p id="c961" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">前两种情况非常相似，我们需要将输出转义到服务器，我们可以很容易地做到。使用Flask中的“escape”模块。</p><p id="4b7a" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">这些是新进口的:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d1f3" class="na kc it mw b gy nb nc l nd ne">from flask import Flask, request, escape <br/>from pathlib import Path</span></pre><p id="8eb5" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在反射和存储的XSS被净化:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9298" class="na kc it mw b gy nb nc l nd ne"><a class="ae lx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/reflected-xss-sanitized")<br/>def reflected_xss_sanitized():<br/>    name = request.args.get("name")<br/>    page = f"""<br/>            &lt;html&gt;<br/>                &lt;head&gt; &lt;/head&gt;<br/>                &lt;body&gt;<br/>                    &lt;h1&gt;Hello {escape(name)}! &lt;/h1&gt;<br/>                &lt;/body&gt;<br/>            &lt;/html&gt;<br/>    """<br/>    return page</span><span id="8406" class="na kc it mw b gy nf nc l nd ne"><a class="ae lx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/stored-xss-sanitized", methods=["POST", "GET"])<br/>def stored_xss_sanitized():</span><span id="8d5e" class="na kc it mw b gy nf nc l nd ne">db_file = "comments.txt"</span><span id="55f2" class="na kc it mw b gy nf nc l nd ne">file = Path(db_file)<br/>    file.touch(exist_ok=True)</span><span id="540e" class="na kc it mw b gy nf nc l nd ne">if request.method == "POST":<br/>        comment = request.form["comment"]</span><span id="d621" class="na kc it mw b gy nf nc l nd ne">with open(db_file, "a") as f:<br/>            f.write(comment + "\n")</span><span id="652d" class="na kc it mw b gy nf nc l nd ne">comments = ""<br/>    with open(db_file, "r+") as f:<br/>        for line in f.readlines():<br/>            comments += f"&lt;div&gt;{line}&lt;/div&gt;"</span><span id="8f6c" class="na kc it mw b gy nf nc l nd ne">page = f"""<br/>        &lt;html&gt;<br/>        &lt;head&gt;&lt;/head&gt;<br/>        &lt;body&gt;<br/>            &lt;form action="#" method="POST"&gt;<br/>                &lt;input size="100" type="text" id="comment" name="comment"&gt;&lt;br&gt;&lt;br&gt;<br/>                &lt;input type="submit" value="Submit"&gt;<br/>            &lt;/form&gt;<br/>            {escape(comments)}<br/>        &lt;/body&gt;<br/>        &lt;/html&gt; <br/>    """<br/>    return page</span></pre><p id="c063" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在基于DOM的跨站点脚本攻击中，错误出现在URI组件的解码中，</p><p id="f173" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我们可以通过用encodeURIComponent函数对组件进行编码来解决这个问题。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a4f9" class="na kc it mw b gy nb nc l nd ne"><a class="ae lx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/dom-based-xss-sanitized")<br/>def dom_based_xss_sanitized():<br/>    page = """<br/>        &lt;html&gt;<br/>        &lt;head&gt;&lt;/head&gt;<br/>        &lt;body&gt;<br/>            &lt;h1&gt;Hello <br/>                &lt;script&gt;<br/>                var name_start = document.location.href.indexOf("name=");<br/>                var name_end = document.location.href.substring(name_start).indexOf("&amp;");<br/>                <!-- -->if(name_start == -1)<br/>                    var name= "Anonymous";<br/>                else if(name_end != -1)<br/>                    var name = document.location.href.substring(name_start+5, name_start+name_end);<br/>                else<br/>                    var name = document.location.href.substring(name_start+5);<br/>                document.write(encodeURIComponent(name));  <br/>                &lt;/script&gt;<br/>            <br/>            &lt;/h1&gt;<br/>   <br/>        &lt;/body&gt;<br/>        &lt;/html&gt;<br/>    """</span><span id="d084" class="na kc it mw b gy nf nc l nd ne">return page</span></pre><h1 id="d79e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">完整的代码</h1><p id="ded1" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在，让我们看看完整的应用程序，以便更好地了解一切，或者如果您有点懒，您可以复制粘贴并测试漏洞:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="81b6" class="na kc it mw b gy nb nc l nd ne">from flask import Flask, request, escape<br/>from pathlib import Path</span><span id="ff59" class="na kc it mw b gy nf nc l nd ne">app = Flask("__name__")</span><span id="2bd4" class="na kc it mw b gy nf nc l nd ne"><a class="ae lx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/reflected-xss")<br/>def reflected_xss():<br/>    name = request.args.get("name")<br/>    page = f"""<br/>            &lt;html&gt;<br/>                &lt;head&gt; &lt;/head&gt;<br/>                &lt;body&gt;<br/>                    &lt;h1&gt;Hello {name}! &lt;/h1&gt;<br/>                &lt;/body&gt;<br/>            &lt;/html&gt;<br/>    """<br/>    return page</span><span id="0f05" class="na kc it mw b gy nf nc l nd ne"><a class="ae lx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/reflected-xss-sanitized")<br/>def reflected_xss_sanitized():<br/>    name = request.args.get("name")<br/>    page = f"""<br/>            &lt;html&gt;<br/>                &lt;head&gt; &lt;/head&gt;<br/>                &lt;body&gt;<br/>                    &lt;h1&gt;Hello {escape(name)}! &lt;/h1&gt;<br/>                &lt;/body&gt;<br/>            &lt;/html&gt;<br/>    """<br/>    return page</span><span id="8ef5" class="na kc it mw b gy nf nc l nd ne"><a class="ae lx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/stored-xss", methods=["POST", "GET"])<br/>def stored_xss():</span><span id="5c22" class="na kc it mw b gy nf nc l nd ne">db_file = "comments.txt"</span><span id="74e2" class="na kc it mw b gy nf nc l nd ne">file = Path(db_file)<br/>    file.touch(exist_ok=True)</span><span id="fbf6" class="na kc it mw b gy nf nc l nd ne">if request.method == "POST":<br/>        comment = request.form["comment"]</span><span id="7509" class="na kc it mw b gy nf nc l nd ne">with open(db_file, "a") as f:<br/>            f.write(comment + "\n")</span><span id="ce96" class="na kc it mw b gy nf nc l nd ne">comments = ""<br/>    with open(db_file, "r+") as f:<br/>        for line in f.readlines():<br/>            comments += f"&lt;div&gt;{line}&lt;/div&gt;"</span><span id="8f31" class="na kc it mw b gy nf nc l nd ne">page = f"""<br/>        &lt;html&gt;<br/>        &lt;head&gt;&lt;/head&gt;<br/>        &lt;body&gt;<br/>            &lt;form action="#" method="POST"&gt;<br/>                &lt;input size="100" type="text" id="comment" name="comment"&gt;&lt;br&gt;&lt;br&gt;<br/>                &lt;input type="submit" value="Submit"&gt;<br/>            &lt;/form&gt;<br/>            {comments}<br/>        &lt;/body&gt;<br/>        &lt;/html&gt; <br/>    """<br/>    return page</span><span id="8679" class="na kc it mw b gy nf nc l nd ne"><a class="ae lx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/stored-xss-sanitized", methods=["POST", "GET"])<br/>def stored_xss_sanitized():</span><span id="7756" class="na kc it mw b gy nf nc l nd ne">db_file = "comments.txt"</span><span id="dc39" class="na kc it mw b gy nf nc l nd ne">file = Path(db_file)<br/>    file.touch(exist_ok=True)</span><span id="527c" class="na kc it mw b gy nf nc l nd ne">if request.method == "POST":<br/>        comment = request.form["comment"]</span><span id="946c" class="na kc it mw b gy nf nc l nd ne">with open(db_file, "a") as f:<br/>            f.write(comment + "\n")</span><span id="4305" class="na kc it mw b gy nf nc l nd ne">comments = ""<br/>    with open(db_file, "r+") as f:<br/>        for line in f.readlines():<br/>            comments += f"&lt;div&gt;{line}&lt;/div&gt;"</span><span id="b2c2" class="na kc it mw b gy nf nc l nd ne">page = f"""<br/>        &lt;html&gt;<br/>        &lt;head&gt;&lt;/head&gt;<br/>        &lt;body&gt;<br/>            &lt;form action="#" method="POST"&gt;<br/>                &lt;input size="100" type="text" id="comment" name="comment"&gt;&lt;br&gt;&lt;br&gt;<br/>                &lt;input type="submit" value="Submit"&gt;<br/>            &lt;/form&gt;<br/>            {escape(comments)}<br/>        &lt;/body&gt;<br/>        &lt;/html&gt; <br/>    """<br/>    return page</span><span id="ef74" class="na kc it mw b gy nf nc l nd ne"><a class="ae lx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/dom-based-xss")<br/>def dom_based_xss():<br/>    page = """<br/>        &lt;html&gt;<br/>        &lt;head&gt;&lt;/head&gt;<br/>        &lt;body&gt;<br/>            &lt;h1&gt;Hello <br/>                &lt;script&gt;<br/>                var name_start = document.location.href.indexOf("name=");<br/>                var name_end = document.location.href.substring(name_start).indexOf("&amp;");<br/>                if(name_end != -1)<br/>                    var name = document.location.href.substring(name_start+5, name_start+name_end);<br/>                else<br/>                    var name = document.location.href.substring(name_start+5);<br/>                document.write(decodeURIComponent(name));  <br/>                &lt;/script&gt;<br/>            <br/>            &lt;/h1&gt;<br/>   <br/>        &lt;/body&gt;<br/>        &lt;/html&gt;<br/>    """</span><span id="6c70" class="na kc it mw b gy nf nc l nd ne">return page</span><span id="6dcb" class="na kc it mw b gy nf nc l nd ne"><a class="ae lx" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/dom-based-xss-sanitized")<br/>def dom_based_xss_sanitized():<br/>    page = """<br/>        &lt;html&gt;<br/>        &lt;head&gt;&lt;/head&gt;<br/>        &lt;body&gt;<br/>            &lt;h1&gt;Hello <br/>                &lt;script&gt;<br/>                var name_start = document.location.href.indexOf("name=");<br/>                var name_end = document.location.href.substring(name_start).indexOf("&amp;");<br/>                <!-- -->if(name_start == -1)<br/>                    var name= "Anonymous";<br/>                else if(name_end != -1)<br/>                    var name = document.location.href.substring(name_start+5, name_start+name_end);<br/>                else<br/>                    var name = document.location.href.substring(name_start+5);<br/>                document.write(encodeURIComponent(name));  <br/>                &lt;/script&gt;<br/>            <br/>            &lt;/h1&gt;<br/>   <br/>        &lt;/body&gt;<br/>        &lt;/html&gt;<br/>    """</span><span id="64d5" class="na kc it mw b gy nf nc l nd ne">return page</span><span id="fe25" class="na kc it mw b gy nf nc l nd ne">app.run(host="0.0.0.0", port=5000)</span></pre><h1 id="8ebc" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="66bd" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在本文中，我们在实践中分析了该漏洞，并看到了一些简单的缓解措施，无论如何，这只是一个概念证明，以更好地理解，远离现实世界的情况。<br/>为了完整起见，XSS是一个非常危险且广泛存在的漏洞(即使它没有出现在<a class="ae lx" href="https://www.stackzero.net/top-10-owasp-2021/" rel="noopener ugc nofollow" target="_blank">OWASP 2021年10大漏洞</a>中)，因此我们在构建web应用程序时必须注意输入。</p><p id="3422" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我们的XSS世界之旅还没有结束，下一步将是在一个更现实的应用程序中进行演练，该应用程序包含相同类型的漏洞。</p><p id="832e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">我希望你喜欢这篇文章。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="1add" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><em class="ng">原载于2022年6月14日</em><a class="ae lx" href="https://www.stackzero.net/the-terrifying-world-of-cross-site-scripting-xss-part-2/" rel="noopener ugc nofollow" target="_blank"><em class="ng">https://www.stackzero.net</em></a><em class="ng">。</em></p><h2 id="b0d3" class="na kc it bd kd np nq dn kh nr ns dp kl lk nt nu kp lo nv nw kt ls nx ny kx nz bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae lx" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4条线索、3个视频、2个Github Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>