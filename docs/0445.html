<html>
<head>
<title>Breaking Down : SHA-3 Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解:SHA-3算法</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/breaking-down-sha-3-algorithm-70fe25e125b6?source=collection_archive---------0-----------------------#2019-12-09">https://infosecwriteups.com/breaking-down-sha-3-algorithm-70fe25e125b6?source=collection_archive---------0-----------------------#2019-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0817a6b7c469ff439ecaa68434984452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nbI8mYn0SivLvjpBE7Aoxg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">SHA-3算法概述</figcaption></figure><div class=""/><div class=""><h2 id="6c23" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">看看引擎盖下面，了解它是如何工作的？</h2></div><p id="8e6b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在过去的一个月里，我一直在写关于哈希算法的文章，这是“崩溃”系列的一个结尾。在我们当前场景中，有许多著名的散列算法。尤其是那些上来就争SHA-3头衔的。所以，为了让大家更好地了解最新最棒的哈希算法SHA-3，让我回到过去，向大家解释一下它为什么会出现。</p><figure class="lr ls lt lu gt is gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/28bc47d5ae60030f66217981d26698d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*PSMjToG-xUgqVMkPYRY91A.png"/></div></figure><h1 id="f65e" class="lv lw jf bd lx ly lz ma mb mc md me mf kl mg km mh ko mi kp mj kr mk ks ml mm bi translated">历史</h1><p id="b4d5" class="pw-post-body-paragraph ku kv jf kw b kx mn kg kz la mo kj lc ld mp lf lg lh mq lj lk ll mr ln lo lp ij bi translated">大约在21ˢᵗ世纪初，SHA-2算法出现，SHA-1算法已经受到理论上的挑战。很明显，在容易发现碰撞之前，这种情况不会持续很长时间。因此，在这一切之中，NIST开始了一场寻找SHA-2更好继任者的竞赛，尽管它是安全的，现在也是。</p><p id="4b53" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">寻找最佳和最有效的哈希算法的比赛开始了，从64份提交的申请中，[ *根据维基百科，51份]。Keccak通过了所有轮次，最终在2015年被选为SHA-3算法。它是由吉多·贝尔托尼、琼·代蒙、迈克尔·彼得斯和T4的吉勒·范·阿舍设计的。你应该读一读它的历史和它是如何形成的，这很有趣。</p><h1 id="64dc" class="lv lw jf bd lx ly lz ma mb mc md me mf kl mg km mh ko mi kp mj kr mk ks ml mm bi translated">我们开始吧！</h1><p id="1295" class="pw-post-body-paragraph ku kv jf kw b kx mn kg kz la mo kj lc ld mp lf lg lh mq lj lk ll mr ln lo lp ij bi translated">所以，那些不经常阅读我的文章的人，这篇文章是我的系列文章的继续，在我的系列文章中，我描述了散列算法以及它们是如何工作的。你可以看看我的其他文章，我在下面已经提到了。</p><blockquote class="mt mu mv"><p id="1e49" class="ku kv mw kw b kx ky kg kz la lb kj lc mx le lf lg my li lj lk mz lm ln lo lp ij bi translated"><strong class="kw jg">分解:系列</strong></p><p id="8420" class="ku kv mw kw b kx ky kg kz la lb kj lc mx le lf lg my li lj lk mz lm ln lo lp ij bi translated"><a class="ae ms" href="https://medium.com/bugbountywriteup/breaking-down-md5-algorithm-92803c485d25" rel="noopener"> <em class="jf"> 1。分解:MD5算法</em> </a></p><p id="c8e1" class="ku kv mw kw b kx ky kg kz la lb kj lc mx le lf lg my li lj lk mz lm ln lo lp ij bi translated"><a class="ae ms" href="https://medium.com/bugbountywriteup/breaking-down-sha-1-algorithm-c152ed353de2" rel="noopener">②<em class="jf">。分解:SHA-1算法</em> </a></p><p id="0554" class="ku kv mw kw b kx ky kg kz la lb kj lc mx le lf lg my li lj lk mz lm ln lo lp ij bi translated"><a class="ae ms" href="https://medium.com/@aditya12anand/breaking-down-sha-512-algorithm-1fdb9cc9413a" rel="noopener"> <em class="jf"> 3。分解:SHA-512算法</em> </a></p><p id="5989" class="ku kv mw kw b kx ky kg kz la lb kj lc mx le lf lg my li lj lk mz lm ln lo lp ij bi translated"><a class="ae ms" href="https://medium.com/bugbountywriteup/breaking-down-sha-256-algorithm-2ce61d86f7a3" rel="noopener"> <em class="jf"> 4。分解:SHA-256算法</em> </a></p></blockquote><p id="e765" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在我们知道了为什么需要SHA-3以及它的历史。让我们看看它是如何工作的。</p><p id="a71a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">首先，我需要声明，Keccak与之前的算法完全不同，所以我们需要以开放的态度来看待它，否则它可能会被证明有点难以理解。向上滚动，看看文章开头的图像，这将有助于我们了解整个算法的流程及其工作原理。</p><h2 id="af26" class="na lw jf bd lx nb nc dn mb nd ne dp mf ld nf ng mh lh nh ni mj ll nj nk ml nl bi translated">1.填料</h2><p id="45ee" class="pw-post-body-paragraph ku kv jf kw b kx mn kg kz la mo kj lc ld mp lf lg lh mq lj lk ll mr ln lo lp ij bi translated">这是一个与之前的哈希算法类似的过程。在我们开始散列我们的消息之前，我们需要确保它们是标准长度，为此我们执行填充过程。</p><p id="fb3b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在我们继续之前，我们需要知道我们需要满足的标准大小是什么，为此我们将看看Keccak如何计算状态大小。</p><pre class="lr ls lt lu gt nm nn no np aw nq bi"><span id="cf38" class="na lw jf nn b gy nr ns l nt nu">b = 25 x 2ˡ ; b = state size</span><span id="962c" class="na lw jf nn b gy nv ns l nt nu">value of l = {0, 1, 2, 3, 4, 5, 6}<br/>value of b = {25, 50, 100, 200, 400, 800, 1600}</span></pre><p id="5d50" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">对于SHA-3，“l”的值被确定为6。国家规模越大，它提供的安全性就越好。现在，基于‘l’的值，我们还决定对于填充消息的每个部分需要执行多少轮计算。</p><pre class="lr ls lt lu gt nm nn no np aw nq bi"><span id="10b2" class="na lw jf nn b gy nr ns l nt nu">rounds = 12 + 2 x l<br/>       = 12 + 12    ; as l = 6<br/>       = 24         ; 24 rounds in total</span></pre><p id="3c66" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在，我们知道对于SHA-3，我们将具有1600比特的状态大小，并且计算的回合数将是24。</p><p id="168f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">回到填充，我们需要根据我们要计算的散列长度将位附加到消息中。这些值应该是我将在下面提到的数字的倍数。现在只要记住这些值，我稍后会解释它们。</p><pre class="lr ls lt lu gt nm nn no np aw nq bi"><span id="b8ab" class="na lw jf nn b gy nr ns l nt nu">  Type        Output Length     Rate (r)         Capacity (c)<br/>SHA3-224           224            1152              448<br/>SHA3-256           256            1088              512<br/>SHA3-384           384             832              768<br/>SHA3-512           512             576             1024</span></pre><p id="f743" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">填充需要以这样的方式完成，即在填充过程之后，对于相应的散列函数，填充消息的长度正好是“r”的倍数。</p><p id="aa6c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">填充的第一个和最后一个比特将是“1 ”,而中间的所有比特将是“0”。在填充之后，它们被分成“n”个部分，例如n乘以r等于填充消息的长度。数学上它可以这样表示。</p><pre class="lr ls lt lu gt nm nn no np aw nq bi"><span id="5721" class="na lw jf nn b gy nr ns l nt nu">p = n x r</span><span id="d5d7" class="na lw jf nn b gy nv ns l nt nu">p = length of message after padding<br/>n = number of parts in which we divide 'p'<br/>r = length of the rate</span></pre><blockquote class="mt mu mv"><p id="f239" class="ku kv mw kw b kx ky kg kz la lb kj lc mx le lf lg my li lj lk mz lm ln lo lp ij bi translated"><strong class="kw jg">注意:</strong>“r”和“c”的值之和总是等于1600，即状态大小</p></blockquote><h2 id="3b57" class="na lw jf bd lx nb nc dn mb nd ne dp mf ld nf ng mh lh nh ni mj ll nj nk ml nl bi translated">2.国家规模</h2><figure class="lr ls lt lu gt is gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/3c959102f25062d70777ab2f1ffa4ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*8G9S8mbx9Poeqgz6bni9qw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">国家规模</figcaption></figure><p id="c33e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们现在知道，对于相应的散列长度，填充消息的长度正好是“r”的倍数，但是为了进一步理解，请看你左边的图像。图像中的“r”和“c”代表各自哈希算法的速率和容量。</p><p id="c35e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">因为填充的消息是“r”的精确倍数，并且我们需要执行模运算。所以，r和P₀的长度是一样的。</p><p id="5a70" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">状态大小是“r”和“c”的总和，对于不同的哈希长度，它们具有不同的值。</p><h2 id="9472" class="na lw jf bd lx nb nc dn mb nd ne dp mf ld nf ng mh lh nh ni mj ll nj nk ml nl bi translated">3.吸收功能</h2><figure class="lr ls lt lu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/4200b0be905ca74db4d45c1579cf44c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gk85iF3ScJ5lP3yzqGN0ow.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">吸收功能</figcaption></figure><p id="5b82" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">SHA-3算法可以大致分为两个不同的部分，吸收部分和压缩部分。吸收功能是SHA-3功能的两个主要步骤的第一部分。</p><p id="968a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们称之为吸收函数的原因是，在Keccak算法的第一部分中，我们获取填充消息的所有值，我们已经将这些值分解为“n”个部分，并逐个消耗它们，以在最后给出输出。</p><p id="1a13" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们执行此操作的方式是，在吸收函数中输入“r”长度的填充消息。我们从P₀和“r”之间的模运算开始，“r”的初始值都是“0”位。一旦模运算完成，我们就把值传递给实际的吸收函数开始的函数。</p><p id="fcc3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在函数内部，我们反复执行相同的一组五个操作24次。一旦所有回合结束，我们就分离“r”和“c”位，然后再次执行模运算，函数再次开始。</p><p id="6bde" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们看看这五个函数的伪代码:-</p><p id="ddd7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg"><em class="mw">θ</em>(θ):伪码</strong></p><pre class="lr ls lt lu gt nm nn no np aw nq bi"><span id="c917" class="na lw jf nn b gy nr ns l nt nu">for x in 0…4<br/>C[x] = A[x,0] xor A[x,1] xor A[x,2] xor A[x,3] xor A[x,4],    </span><span id="d081" class="na lw jf nn b gy nv ns l nt nu">for x in 0…4<br/>D[x] = C[x-1] xor rot(C[x+1],1),<!-- --> </span><span id="7199" class="na lw jf nn b gy nv ns l nt nu">for (x,y) in (0…4,0…4)<br/>A[x,y] = A[x,y] xor D[x]</span></pre><p id="5158" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg"><em class="mw">ρ</em>(rho)&amp;<em class="mw">π</em>(pi):伪码</strong></p><pre class="lr ls lt lu gt nm nn no np aw nq bi"><span id="e0ca" class="na lw jf nn b gy nr ns l nt nu">for (x,y) in (0…4,0…4)<br/>B[y,2*x+3*y] = rot(A[x,y], r[x,y]),</span></pre><p id="b692" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg"> <em class="mw"> χ </em> (chi):伪码</strong></p><pre class="lr ls lt lu gt nm nn no np aw nq bi"><span id="a705" class="na lw jf nn b gy nr ns l nt nu">for (x,y) in (0…4,0…4)<br/>A[x,y] = B[x,y] xor ((not B[x+1,y]) and B[x+2,y])</span></pre><p id="4aef" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg"> <em class="mw"> ι </em> (iota):伪代码</strong></p><pre class="lr ls lt lu gt nm nn no np aw nq bi"><span id="fb3f" class="na lw jf nn b gy nr ns l nt nu">A[0,0] = A[0,0] xor RC</span></pre><p id="62fd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我很难用语言解释这些功能，所以我展示了Keccak团队的<a class="ae ms" href="https://keccak.team/keccak_specs_summary.html" rel="noopener ugc nofollow" target="_blank">网站</a>上的伪代码。阅读他们的论文以更好地理解整个概念。</p><p id="b320" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这五个功能反复进行24次。24轮计算结束后，我们得到1600位，然后根据“r”和“c”位的长度将其分离，该过程继续进行。</p><h2 id="38c9" class="na lw jf bd lx nb nc dn mb nd ne dp mf ld nf ng mh lh nh ni mj ll nj nk ml nl bi translated">4.挤压功能</h2><p id="3c59" class="pw-post-body-paragraph ku kv jf kw b kx mn kg kz la mo kj lc ld mp lf lg lh mq lj lk ll mr ln lo lp ij bi translated">在我们到达吸收函数的末尾之后，挤压函数立即开始。我们称之为挤压函数，因为这是我们提取散列消息的步骤。我们提取它的方法非常简单，容易理解。</p><figure class="lr ls lt lu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/b84bd83b603330907a0dd6f84e867c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNxOdnHDCfSuPDmRGkWjYQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">挤压函数</figcaption></figure><p id="82ce" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">计算哈希值时，我们已经知道哈希值的输出长度，可能是224、256、384或512。完成吸收功能后，我们得到一个最终的1600位长度的输出。我们根据“r”和“c”位的长度来分离输出，这取决于我们试图计算的哈希值，这导致了我们的输出。</p><h1 id="36fc" class="lv lw jf bd lx ly lz ma mb mc md me mf kl mg km mh ko mi kp mj kr mk ks ml mm bi translated">输出</h1><p id="3b2d" class="pw-post-body-paragraph ku kv jf kw b kx mn kg kz la mo kj lc ld mp lf lg lh mq lj lk ll mr ln lo lp ij bi translated">现在，我们有了“r”和“c”的值，然后我们根据哈希算法从“r”中提取前几位，因此对于SHA3–256算法，我们将从“r”的1088位中提取前256位，对于SHA3–512，我们将从“r”的576位中提取前512位。从“r”的第一位提取的值是整个消息的散列。</p><h1 id="cd43" class="lv lw jf bd lx ly lz ma mb mc md me mf kl mg km mh ko mi kp mj kr mk ks ml mm bi translated">结论</h1><p id="b151" class="pw-post-body-paragraph ku kv jf kw b kx mn kg kz la mo kj lc ld mp lf lg lh mq lj lk ll mr ln lo lp ij bi translated">SHA-3 / Keccak算法是最安全和有效的散列算法之一，一些人声称它在未来20 - 30年内不会被破解。量子计算世界的发展可能会缩短这个时间框架，但它仍然是我们目前得到的最好的哈希算法之一。</p><p id="00f0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">那么，让我们再来看一下SHA-3算法的整个功能，并允许我用一个很长的段落来解释整个事情。</p><blockquote class="mt mu mv"><p id="dd6b" class="ku kv mw kw b kx ky kg kz la lb kj lc mx le lf lg my li lj lk mz lm ln lo lp ij bi translated">像往常一样，我们的第一步是计算消息的长度，然后根据我们选择的散列长度进行填充。我们添加到消息中的填充位以“1”开始和结束，中间的所有位都是“0”。填充完成后，我们将它分成“n”个块，每个块的长度为“r ”,值“r”将再次取决于哈希长度。填充位从P₀开始，然后是P₁，直到Pₙ-₁.我们从P₀开始，首先用最初全为“0”的“r”进行模运算。一旦模运算完成，我们就开始24轮，每轮由这五个函数组成<strong class="kw jg"> θ </strong>、<strong class="kw jg"> ρ </strong>、<strong class="kw jg"> π </strong>、<strong class="kw jg"> χ </strong>和<strong class="kw jg"> ι </strong>。在所有这些轮次之后，我们得到接下来的1600位，然后我们根据散列长度将其分成“r”和“c”位。这种24轮的计算在吸收函数中发生“n”次，然后我们到达挤压函数。从一开始，我们就知道执行哈希运算时输出的长度，因此我们从“r”中提取这些精确的位数，这就是我们完整的哈希值。</p></blockquote><p id="1e32" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这就是发生在SHA-3算法中的整个操作的简短版本。</p><p id="dbae" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果你喜欢，请鼓掌让我们合作。获取、设置、破解！</p><p id="34f8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">网站</strong>:<a class="ae ms" href="https://www.aditya12anand.com/" rel="noopener ugc nofollow" target="_blank">aditya12anand.com</a>|<strong class="kw jg">捐款</strong>:<a class="ae ms" href="https://paypal.me/aditya12anand" rel="noopener ugc nofollow" target="_blank">paypal.me/aditya12anand</a><br/><strong class="kw jg">电报</strong>:<a class="ae ms" href="https://t.me/aditya12anand" rel="noopener ugc nofollow" target="_blank">https://t.me/aditya12anand</a><br/><strong class="kw jg">推特</strong>:<a class="ae ms" href="https://twitter.com/aditya12anand?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">twitter.com/aditya12anand</a><br/><strong class="kw jg">LinkedIn</strong>:<a class="ae ms" href="https://www.linkedin.com/in/aditya12anand/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/aditya12anand/</a><br/><strong class="kw jg">电子邮箱</strong>:aditya12anand@protonmail.com</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="723f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="mw">关注</em> <a class="ae ms" href="https://medium.com/bugbountywriteup" rel="noopener"> <em class="mw"> Infosec报道</em> </a> <em class="mw">获取更多此类精彩报道。</em></p><div class="ip iq gp gr ir og"><a href="https://medium.com/bugbountywriteup" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jg gy z fp ol fr fs om fu fw je bi translated">信息安全报道</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">收集了世界上最好的黑客的文章，主题从bug奖金和CTF到vulnhub…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ix og"/></div></div></a></div></div></div>    
</body>
</html>