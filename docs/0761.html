<html>
<head>
<title>Hacker101 CTF: Android Challenge Writeups</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">黑客101 CTF:安卓挑战报道</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/hacker101-ctf-android-challenge-writeups-f830a382c3ce?source=collection_archive---------0-----------------------#2020-08-14">https://infosecwriteups.com/hacker101-ctf-android-challenge-writeups-f830a382c3ce?source=collection_archive---------0-----------------------#2020-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="17d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我将展示如何解决Android类别的<em class="ko">黑客101</em><em class="ko"/>(捕捉旗帜)挑战。<a class="ae kp" href="https://www.hacker101.com/" rel="noopener ugc nofollow" target="_blank"> Hacker101 </a>是一个免费的黑客教育网站，由<a class="ae kp" href="https://www.hackerone.com/" rel="noopener ugc nofollow" target="_blank"> HackerOne </a>运营。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/c7553fbebf1bd89b895554eada677747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yyyvHnbCM2zBj8Sb4GPeCw.png"/></div></div></figure></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="d509" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">放弃</h1><p id="c27b" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">我写这篇文章的动机是想了解更多关于Android移动应用程序安全性的知识。这篇文章显然会包含剧透，我鼓励读者在阅读这篇文章之前尝试这个CTF。试着尽可能多地解决这些挑战，如果你遇到困难或者想看看解决挑战的不同方法，稍后再来阅读这篇文章。不要再拖延了，让我们开始吧😃！</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="9ba0" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">H1恒温器(简易，双旗)</h1><p id="2149" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">我通过下载应用程序APK文件，并使用<strong class="js iu"> Android调试桥</strong> ( <strong class="js iu"> ADB </strong>)将其安装在我的仿真器设备上，开始了这个挑战</p><pre class="kr ks kt ku gt mm mn mo mp aw mq bi"><span id="3c60" class="mr lk it mn b gy ms mt l mu mv">adb install thermostat.apk</span></pre><p id="2be9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开应用程序显示，它只有一个带有恒温器和温度计的活动，允许用户提高或降低温度设置。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/bbfce290c356a3d7ff0b0cf2e0cbf33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*CGF40SEYPFpUuR22xqJ93Q.png"/></div></figure><p id="8af9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我使用<strong class="js iu">移动安全框架</strong> ( <strong class="js iu"> MobSF </strong>)工具为APK文件生成了一个静态分析报告。我通过检查<em class="ko"> AndroidManifest.xml </em>文件开始审查报告。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi mx"><img src="../Images/0221be9fe7297bce0486a9a0d2ff0cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vk-VumJxEX9Wk0OeqVA0Ug.png"/></div></div></figure><p id="a3c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看清单文件，我可以看到应用程序只请求了<strong class="js iu">Android . permission . internet</strong>权限，该权限允许应用程序创建网络套接字。开发人员已经将属性<strong class="js iu">Android:usesCleartextTraffic</strong>和<strong class="js iu"> android:allowBackup </strong>设置为<strong class="js iu"> true </strong>，这意味着应用程序打算使用明文流量，并且可以让用户备份其内容。</p><p id="14c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该应用程序似乎也只有两个组件。一个名为<em class="ko">com . hacker 101 . level 11 . thermoseactivity</em>的<strong class="js iu">活动</strong>已经用意图过滤器声明。名为<em class="ko">ProcessLifecycleOwnerInitializer</em>的<strong class="js iu">内容提供者</strong>也已声明，但未导出。我决定检查一下<em class="ko">com . hacker 101 . level 11 . thermoseactivity .</em>的java源代码</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi my"><img src="../Images/7b1a4244fceecdcc55df5bc80f23435e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2k6NOYEZHyCdEcSiktnSVw.png"/></div></div></figure><p id="0baa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在查看活动的源代码时，我注意到正在发出一个网络请求。这个网络请求中使用了一个名为<em class="ko"> PayloadRequest </em>的类，用绿色突出显示。检查<em class="ko"> PayloadRequest </em>类的源代码，我发现了挑战的两个标志。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi mz"><img src="../Images/6a559e34c852451439c5b4a37abb41e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zuniQtvgWhO0a1n79eOlpQ.png"/></div></div></figure><p id="00eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来一个标志使用<strong class="js iu"> MD5 </strong>散列，然后<strong class="js iu"> base64 </strong>编码，然后作为一个值添加到名为<em class="ko"> X-MAC </em>的头中。另一个标志只是作为明文值添加到报头<em class="ko"> X标志</em>中。在与应用程序交互时，我可以使用工具<strong class="js iu"> BurpSuite </strong>来拦截这个网络请求。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi na"><img src="../Images/f7d5b509a19d8fb6860a7ae029220f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*oI6NDZtbq7J90LhZpQQeGA.png"/></div></figure><p id="1ece" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上图所示，截取的网络请求显示了<em class="ko"> X-MAC </em>和<em class="ko"> X-Flag </em>报头及其等值。第一次挑战很简单😃！</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="c5c2" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">有意锻炼(中度，1面旗)</h1><p id="1fbf" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">按照前面挑战中看到的类似方法，我使用ADB安装了应用程序，并使用MobSF生成了APK文件的静态分析报告。打开应用程序会显示一个带有欢迎消息和一个名为<strong class="js iu">【Flag】</strong><em class="ko">的链接的活动。</em></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/a13f4562bac24a46a21abf80d9861c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*vWWNnIcD6qSOm2ftwRg_Ew.png"/></div></figure><p id="7ae9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点击链接导致<strong class="js iu">“无效请求”</strong>错误。我猜不会那么容易😏。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/51b8a24f54c067f473c3d86a3762b335.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*TsmXscAkZ90eam8V0E6Myw.png"/></div></figure><p id="82b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如在前面的挑战中看到的，我从查看应用程序的清单文件开始。清单文件中只声明了一个<strong class="js iu">活动</strong>。该活动的突出之处在于，它已经通过三个<strong class="js iu">意图过滤器</strong>进行了声明。下图中被绿色包围的两个意图过滤器展示了你如何为你的应用程序内容创建一个<strong class="js iu">深度链接</strong>(<strong class="js iu">参见参考文献</strong>)。</p><blockquote class="nd ne nf"><p id="236c" class="jq jr ko js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated">注意:深度链接是一个帮助用户在网络和应用之间导航的概念。它们基本上是将用户直接导航到<strong class="js iu">应用程序中特定内容的URL。</strong></p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/64a972bc98e2198dc8fcd76a87140a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*SGh0Zlg1qqJhgD-AucYiNg.png"/></div></figure><p id="e7b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了测试第一个深度链接(即http)，我可以使用<strong class="js iu"> ADB </strong>和活动管理器(am)工具来测试为深度链接指定的意图过滤器URI是否解析到正确的应用活动。下面的命令成功地启动了应用程序的主活动。</p><pre class="kr ks kt ku gt mm mn mo mp aw mq bi"><span id="a9e2" class="mr lk it mn b gy ms mt l mu mv">adb shell am start -W -a "android.intent.action.VIEW" -d "http://level13.hacker101.com" com.hacker101.level13</span></pre><p id="a2ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我决定看看<em class="ko"> MainActivity的源代码。浏览java代码，我可以看到应用程序创建了一个<strong class="js iu"> WebView </strong>。还声明了两个字符串变量，变量<strong class="js iu"> <em class="ko"> str </em> </strong>包含一个硬编码的URL。</em></p><blockquote class="nd ne nf"><p id="dec1" class="jq jr ko js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated">注意:您的应用程序的URL会有所不同。</p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/dd3a0abaaa598aa5510f596c2f6e3242.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*Py3zPNNY89AyBsN8bSOPGw.png"/></div></figure><p id="1c2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将这个URL输入到浏览器中，会调出之前在应用程序主活动中看到的相同页面。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/479dc9d7e7898d5848201a070a4d7ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*MdyVgyfYiolfRtm3E867ZQ.png"/></div></figure><p id="1f12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">单击标志链接仍会返回无效请求。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/3901bed31ee0c527aa3e2ec851fa3856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*dNnl_OzNCyrJR6iwFuQc2A.png"/></div></figure><p id="bb3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次查看源代码，我看到应用程序检索了用于启动主活动的i <strong class="js iu"> ntent </strong>中存储的数据。检查前面的清单文件，我知道这个数据是http://level13.hacker101.com的<strong class="js iu"/><em class="ko"/>URL。然后，应用程序继续使用java <strong class="js iu"> subString(28) </strong>方法来忽略从intent检索的数据字符串中的前28个字符(即<strong class="js iu"><em class="ko">【http://level13.hacker101.com】</em></strong>URL)，并将剩余的字符串值附加到<strong class="js iu"> str2 </strong>变量中，并在<strong class="js iu"> str </strong>变量中添加硬编码的URL链接字符串。然后，应用程序检查字符串是否包含“<strong class="js iu">？</strong> <em class="ko"> " </em>如果不存在，则将其添加到字符串的末尾。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3fab96d014b492caf346a4c5f6415f7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*JOYqNu--xFMULWTWeHG-zg.png"/></div></figure><p id="d9ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据我目前的静态分析，我还不知道<strong class="js iu"> str2 </strong> <em class="ko"> </em>的值是多少。到目前为止，<strong class="js iu"> str </strong>的最终值是由<strong class="js iu">硬编码的URL链接</strong>、<strong class="js iu"> str2 <em class="ko">、T30】值</em></strong>(此时它只是一个空字符串)和<strong class="js iu">“？”</strong>在字符串的末尾。</p><pre class="kr ks kt ku gt mm mn mo mp aw mq bi"><span id="debf" class="mr lk it mn b gy ms mt l mu mv">http://34.74.105.127/398abac4c8/appRoot<strong class="mn iu">'empty str2 value'</strong>?</span></pre><p id="588a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一个代码块包括使用SHA-256哈希算法创建一个消息摘要。散列被更新两次。第一个是用名为<strong class="js iu">s 00 p 3s 3c 3r tk3 y</strong><em class="ko"/>的键，第二个是用<em class="ko"> </em> <strong class="js iu"> str2 <em class="ko"> </em>值</strong> <em class="ko">。</em>WebView随后将加载一个新构建的URL，其中包括<strong class="js iu"> str </strong> <em class="ko"> </em>值(即<strong class="js iu"> URL </strong>)、字符串“<strong class="js iu">&amp;hash”</strong>和<strong class="js iu"> SHA-256 hash </strong>值。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi no"><img src="../Images/9f68a36b68a86d50e4ab50b225758dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZHhyGj7G9HvtJUX5NhdiA.png"/></div></div></figure><p id="b371" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，最终构建的URL如下所示:</p><pre class="kr ks kt ku gt mm mn mo mp aw mq bi"><span id="ec6e" class="mr lk it mn b gy ms mt l mu mv">http://34.94.3.143/<!-- -->398abac4c8<!-- -->/appRoot'<strong class="mn iu">empty</strong> <strong class="mn iu">str2 value</strong>'?&amp;hash="<strong class="mn iu">hash value</strong>"</span></pre><p id="9aaa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用一个名为<strong class="js iu"> BurpSuite </strong>的工具，我可以在应用程序启动时拦截它发出的请求，并观察由<em class="ko"> MainActivity </em>源代码构建的URL。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi np"><img src="../Images/52d426c2b5be4d09e79bb09e582757a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcUjKViJ2MnIvrg-QJkO5Q.png"/></div></div></figure><p id="6f5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看应用程序发出的主机值和GET请求，我可以看到完整的URL。</p><pre class="kr ks kt ku gt mm mn mo mp aw mq bi"><span id="3eba" class="mr lk it mn b gy ms mt l mu mv">http://35.227.24.107/3ef212b832/appRoot?&amp;hash=61f4518d...etc</span></pre><blockquote class="nd ne nf"><p id="13eb" class="jq jr ko js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated">注意:由于我下载了新版本的应用程序，URL中的数值(即3ef212b832)已发生变化。</p></blockquote><p id="b532" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在URL中输入这个值仍然会把我带到默认的WebView，并带有一个获取标志的链接。我知道这个链接以某种方式用于获取标志，通过查看链接的页面源代码，我可以看到它使用<strong class="js iu"> /flagBearer </strong>作为URL地址的一部分。该值位于<strong class="js iu">逼近</strong>之后，可能是缺失的<strong class="js iu"> str2 </strong>值。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/97b60b8dd2672f18b9730f0fc0125230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*xVLz3Qhc-mDBak3YjpsX5A.png"/></div></figure><p id="40d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我将<strong class="js iu"> /flagBearer </strong>添加到缺少的<strong class="js iu"> str2 </strong>值所在的位置，我会得到下面的URL路径。</p><pre class="kr ks kt ku gt mm mn mo mp aw mq bi"><span id="2263" class="mr lk it mn b gy ms mt l mu mv">http://35.227.24.107/3ef212b832/appRoot/flagBearer?&amp;hash=61f4518d...etc</span></pre><p id="662b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的浏览器中输入这个URL路径会出现一个新的错误信息，上面写着“<strong class="js iu">无效哈希</strong> <em class="ko">”。</em></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/8ef9c1fe7a187d7c2cc451fb0bbc5753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*LChk7y3by2AANrp5KEuw8w.png"/></div></figure><p id="40b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着<strong class="js iu"> /flagBearer </strong>是未知的<strong class="js iu"> str2 </strong>值，可以通过在其位置键入其他值来确认，这将导致一个未找到的错误。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ns"><img src="../Images/4ac54f179e868a6ac5cbe73fce26eda1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctledjc_Ho6h5JzhaI5wYg.png"/></div></div></figure><p id="30a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管有了正确的URL路径，我仍然看到一个散列错误。如前所述，在静态分析<em class="ko"> MainActivity </em>源代码时，使用<strong class="js iu"> str2 </strong>值(即<em class="ko"> /flagBearer </em>)和键<strong class="js iu">s 00 p 3s 3c r tk3 y</strong><em class="ko"/>来组成完整的SHA-256散列。然而，由于意图过滤器中指定的数据URL路径(即<em class="ko">http://level13.hacker101.com</em>)不包含字符串<strong class="js iu"> /flagBearer </strong>，并且被java <strong class="js iu"> subString(28) </strong>方法完全忽略，因此<strong class="js iu"> str2 </strong> <em class="ko"> </em>值为空。这意味着哈希不正确，因为在<strong class="js iu"> str2 </strong>中没有值(即<em class="ko"> /flagBearer </em>)。</p><p id="5c6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是<strong class="js iu">深层链接</strong>发挥作用的地方。看了一篇名为《<em class="ko">安卓深度链接的Zaheck！</em> " ( <strong class="js iu">参见参考文献</strong>)，我了解到，如果正在进行的<strong class="js iu">URL验证</strong>不充分，那么我可以加载自己的<strong class="js iu">任意URL </strong>。<strong class="js iu"> </strong>我知道没有对用于触发意图过滤器和启动应用程序主活动的URL执行URL验证。这意味着我可以提供自己的URL，并附上<strong class="js iu"> /flagBearer </strong> <em class="ko"> </em>路径，这将启动主活动并导致<strong class="js iu"> str2 </strong>值等于<strong class="js iu"> /flagBearer </strong> <em class="ko">。</em>我可以通过使用<strong class="js iu"> ADB </strong>来实现这一点，就像之前在测试URI意图过滤器时看到的那样。</p><pre class="kr ks kt ku gt mm mn mo mp aw mq bi"><span id="2918" class="mr lk it mn b gy ms mt l mu mv">adb shell am start -W -a "android.intent.action.VIEW" -d "http://level13.hacker101.com/flagBearer" com.hacker101.level13</span></pre><p id="2a40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这导致该标志被呈现😄。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/a7b49fbd154ab88c7f2a238cc0b9678f.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*tDcizXdNnt6msMFqvkXOhg.png"/></div></figure><p id="3b08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种不使用深层链接来解决这一挑战的方法是，通过组合密钥<strong class="js iu">s 00 p 3s 3c r tk3 y</strong><em class="ko"/>和<strong class="js iu"> /flagBearer </strong>字符串，简单地<strong class="js iu">自己创建散列</strong><strong class="js iu"/>。我使用了一个名为<strong class="js iu"> CyberChef </strong>的在线工具来创建SHA-256散列。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nu"><img src="../Images/f944d5718658cc01e3aad8e9ed77928c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WElzu39XaDT6qSWdVzjXag.png"/></div></div></figure><p id="f573" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我将这个新散列添加到我的URL路径中，给我一个标志。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nv"><img src="../Images/f4c44ddf4f1314e14c466444099722fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVF_IHMJrIls4FBl2_OlmQ.png"/></div></div></figure></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="b1be" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">Oauthbreaker(中等，2个标志)</h1><p id="dcf4" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">使用ADB和MobSF，我再次安装了应用程序并生成了一个静态分析报告。打开应用程序，我看到一个活动，上面有一个按钮，写着authenticate。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/d6fc5b82ad7b8b3d9e6e7946ef0d86aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*LSFgSzqln1YThXUJn3cR5Q.png"/></div></figure><p id="a51b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点击此按钮，我的仿真器上的WebView浏览器打开，在URL栏中有一个地址和一个授权我的移动应用程序的链接。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/6b414dc618b85598fc555f5255b31d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*Wydv7w8Df2b4qy7_sAaVtg.png"/></div></figure><p id="5425" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">URL栏中的完整地址可以在下面看到。</p><pre class="kr ks kt ku gt mm mn mo mp aw mq bi"><span id="a26f" class="mr lk it mn b gy ms mt l mu mv"><a class="ae kp" href="http://34.74.105.127/81857ddddb/oauth?redirect_url=oauth%3A%2F%2Ffinal%2Flogin&amp;response_type=token&amp;scope=all" rel="noopener ugc nofollow" target="_blank">http://34.74.105.127/81857ddddb/oauth?redirect_url=oauth%3A%2F%2Ffinal%2Flogin&amp;response_type=token&amp;scope=all</a></span></pre><p id="7ccb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点击<em class="ko">授权移动应用</em>链接，我会进入一个新的活动，消息显示我已经通过OAuth成功认证了“<strong class="js iu">”!</strong>”。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/2bf1345ce125e158bb74382ea124f4ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*mc4jm5-CjZfORZp6hJOqhA.png"/></div></figure><p id="d632" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在探索应用程序的功能时，我决定在我的模拟器上打开WebView浏览器中显示的URL。在查看这个页面的源代码时，我发现了<strong class="js iu">的第一个标志</strong>。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ny"><img src="../Images/f01ddc7de4bec2d164dcfdc400b708d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISxLPcFNqCfy9JPx0tROTA.png"/></div></div></figure><p id="0afd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查Android清单文件显示，<strong class="js iu">两个名为“<em class="ko">com . hacker 101 . oauth . browser</em>”和“<em class="ko">com . hacker 101 . oauth . main activity</em>”的活动</strong>是用<strong class="js iu">意图过滤器</strong>声明的。正如前面的挑战所看到的，这些意图过滤器用于创建深层链接。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nz"><img src="../Images/c6d1e497b69e54e20dbeeaf8ade4d506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oKWtRXJKiYHSgQfVUDBbNQ.png"/></div></div></figure><p id="1a88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看完清单文件后，我开始查看<em class="ko"> MainActivity的源代码。</em>创建主活动时，名为<strong class="js iu"> authRedirectUri </strong>的变量等于值“<strong class="js iu"><em class="ko">oauth://final/</em></strong>”。这是用于将用户带到<em class="ko">浏览器</em>活动的深层链接URL。检索并检查包含在用于启动主活动的意图中的数据，以查看它是否有任何数据或者查询参数<strong class="js iu"> <em class="ko"> redirect_uri </em> </strong>是否为空。如果intent参数<strong class="js iu"> <em class="ko"> redirect_uri </em> </strong>不为空，则将该参数的值赋给<strong class="js iu"> authRedirectUri </strong>。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/75cabfa93a418f5f1d6a0c7d0a2be3d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*1KIBnntcoX1VbtkXU9a94w.png"/></div></figure><p id="89d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再往下，我可以看到，当我单击按钮"<strong class="js iu"> Authenticate </strong> <em class="ko">"，</em>时，一个URL被构建，其中包括URL编码的<strong class="js iu"> authRedirectUri </strong>值。然后创建一个新的意向，并将URL作为数据添加到该意向中。这个意图然后被用来触发<strong class="js iu">浏览器活动</strong>。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/7f526bc2cd277fffa9a8f25550176da3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*rUPo7RL533Iw1iOmXpltgA.png"/></div></figure><p id="ebab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从这段源代码中，我可以看到无论<strong class="js iu"> <em class="ko"> redirect_uri </em> </strong>参数值是什么，用户都会被<strong class="js iu">重定向</strong>到。为了测试这一点，我可以给<strong class="js iu"><em class="ko">redirect _ uri</em></strong>intent参数赋值，并观察它是否成功地重定向了我。</p><pre class="kr ks kt ku gt mm mn mo mp aw mq bi"><span id="0c6c" class="mr lk it mn b gy ms mt l mu mv">adb shell am start -W -a "android.intent.action.VIEW" -d "oauth://final/redirect_uri=https://ctftime.org/" com.hacker101.oauth</span></pre><p id="39f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这很管用，我成功地被重定向到了<em class="ko">ctftime.org</em>网站。第一个标志也显示在URL中。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/5dba096c3ab6c4b75a4555b46095e8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*nHugvWxHbff9Ugiwj9365w.png"/></div></figure><p id="b8de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我仍然不确定如何利用这个漏洞，所以我决定开始查看<strong class="js iu">浏览器活动</strong>。我看到创建了一个名为<em class="ko"> SSLTolerentWebViewClient </em>的私有类。在这个类中，声明了<em class="ko">shouldoverrideulroading()</em>方法，该方法允许主机应用程序有机会在URL将要被加载到当前WebView中时进行控制(<strong class="js iu">参见参考文献</strong>)。这解释了为什么WebView浏览器在我的模拟器上打开。方法<em class="ko"> SslErrorHandler() </em>也被声明，用于简单地忽略SSL错误。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi oc"><img src="../Images/e3025a8c2f59c0b1a7d27622db883484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2sRfS1z1YLPog4YMiL2Kw.png"/></div></div></figure><p id="b83a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在源代码中继续往下，我可以看到一个名为<strong class="js iu"> str </strong> <em class="ko"> </em>的变量被声明为一个URL地址。这个URL地址就是我之前看到的成功消息，它告诉我我通过了身份验证。检查用于启动活动的来自intent的数据和名为<strong class="js iu"> uri </strong>的intent参数，看它是否为空。然后，使<strong class="js iu"> str </strong>值等于包含在<strong class="js iu"> uri </strong> intent参数中的数据。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/a3fa3fa740bf84f6377ea995e854d6b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*QS8mcMmEhKIG4npyUHlXvg.png"/></div></figure><p id="c2ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这下面，我可以看到创建了一个新的WebView。创建WebView时，需要注意两条重要的信息。首先是WebView已经使用<em class="ko"> setJavascriptEnabled() </em>启用了<strong class="js iu"> JavaScript执行</strong>。第二个是声明了方法<em class="ko">addJavascriptInterface()</em>。这将提供的Java对象注入到WebView中，并且<strong class="js iu">允许从JavaScript </strong>访问Java对象的方法。这个方法有两个参数:</p><ol class=""><li id="8161" class="oe of it js b jt ju jx jy kb og kf oh kj oi kn oj ok ol om bi translated">要绑定到JavaScript的类实例(即<em class="ko"> WebAppInterface </em>)</li><li id="874a" class="oe of it js b jt on jx oo kb op kf oq kj or kn oj ok ol om bi translated">用于在JavaScript中公开实例的名称(即<em class="ko"> iface </em>)。</li></ol><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi os"><img src="../Images/3ead02a0f167cfa77c1f7cabbe8bb2b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_E4KSKzYSMI-NYcypZOe9A.png"/></div></div></figure><p id="dc58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这允许我控制<strong class="js iu"> WebAppInterface </strong>类中的任何方法。看这个类，可以看到一个有趣的方法叫做<strong class="js iu"> getFlagPath() </strong>。这个方法包含了一个大的int值数组，如下所示。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nz"><img src="../Images/7730f5d02cb0678e7564d78ac22b7533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6aLrYb5HyAe4PDcGTgewsw.png"/></div></div></figure><p id="d4a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的代码似乎执行了各种操作，这些操作会导致创建一个html文件的路径。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/93f0a838d8f25ef1ef86696c300e884b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*2XsNe-1okHhn3oPoPaWzzA.png"/></div></figure><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/fee6701372cf62bf82dea86ded21d396.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*D5NUk9XfIZiZdgiH-eMYHA.png"/></div></figure><p id="6709" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了调用这个方法，我可以使用<strong class="js iu"> Github Pages </strong>创建一个简单的网页。然后，我可以将下面的JavaScript添加到网页中，它将使用暴露类实例的"<strong class="js iu"> iface </strong>"名称调用<strong class="js iu"> getFlagPath() </strong>方法。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/e054f175cce284c5ef3ea02054c44132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*NTrQXXzCocZZoNmW4kGYfA.png"/></div></figure><p id="7d58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我可以重定向到我的Github Pages网站，如前所述，方法是在调用<strong class="js iu">浏览器活动</strong>时，为<strong class="js iu"> uri </strong>参数分配站点URL地址作为其值。</p><pre class="kr ks kt ku gt mm mn mo mp aw mq bi"><span id="5fd3" class="mr lk it mn b gy ms mt l mu mv">adb shell am start -W -a "android.intent.action.VIEW" -d "oauth://final/uri=https://<strong class="mn iu">github.website.url"</strong> com.hacker101.oauth</span></pre><p id="47bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将产生一个HTML页面的路径。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/2e8416a9715974a6aae5255eb987857c.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*XPm1Yo5hygDmCOWDXYekVQ.png"/></div></figure><p id="3239" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我可以简单地将HTML文件的路径添加到如下所示的地址的末尾。</p><pre class="kr ks kt ku gt mm mn mo mp aw mq bi"><span id="93f4" class="mr lk it mn b gy ms mt l mu mv">http://34.94.3.143/cb1f155695/<strong class="mn iu">path-to-flag.html</strong></span></pre><p id="e7dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这给了我第二面旗帜😃。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/eb458587762e0ee4bf67335f93502a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*CC8DVLhsesOp65gFoCWgGA.png"/></div></figure></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="1631" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">移动网站开发(中等，双标志)</h1><p id="aca5" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">再次使用ADB和MobSF，我安装了应用程序并生成了一个静态分析报告。打开应用程序，我看到一个允许我刷新页面和编辑页面内容的活动。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/b9a75520ed3a513f2b219cac682faaff.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*JJCMfjhU9BHNOXNh6pZXtg.png"/></div></figure><p id="3fdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">单击“编辑”按钮会显示一个新页面，其中显示了我可以编辑的文件。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/22e3992dcc7acc107dce0ed3c7d40132.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*t9aOBUZ8XxFyFP4KCxfP9w.png"/></div></figure><p id="20da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点击文件可以让我编辑它。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi oz"><img src="../Images/dff3de5938178556e0be899a0a4fbc9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*v4nUYqtZ-KOByBkUHx0GgA.png"/></div></div></figure><p id="6bab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我单击保存并返回视图，我可以看到我的编辑已被应用。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/2dfbee526bf8c6807e1c4666d7ed7e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*cu7fkgrsjRgkY1YW80lv-w.png"/></div></figure><p id="43d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在查看了应用程序的功能之后，我继续检查应用程序的Android清单文件。只有<strong class="js iu">一个名为<em class="ko">主活动</em>的活动</strong>被声明。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/6a5c20452af4001fb2db647b1818e394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*wxd0PcsFNg4iwnjjboc9Mg.png"/></div></figure><p id="8087" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我决定看看<em class="ko"> MainActivity的源代码。</em>阅读源代码时，我首先注意到一个名为<strong class="js iu"> HmacKey </strong>的变量，它有一个字符串值，似乎是一个私钥。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi pc"><img src="../Images/2575567d74c2fa232dc848bfdd965385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0lVcmV_N-0-gjpF4eXInlg.png"/></div></div></figure><p id="4c8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再往下，我看到一个名为<em class="ko"> Hmac() </em>的方法，这个方法还没有实现，正如异常消息所暗示的。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/dd8f6cca2d44f47e61c7b9a4a34e0d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*__uj23IpjblPk_y8D3ZPxA.png"/></div></figure><p id="8dc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在此之下，我找到了源代码的其余部分，如前所述，它们促进了应用程序的功能。我可以看到用于查看和编辑内容的不同URL。我还看到显示内容的WebView启用了JavaScript。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/c2bc01da69843173df21668b1ed6cbb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*Y_vrbbkKOBi0Fh0kOXccOQ.png"/></div></figure><p id="ff47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">起初，我真的不确定如何使用HMAC键，所以我最终尝试了一些不同的方法。例如，我最初的直觉是看看我是否可以执行XSS攻击，因为我可以编辑页面的内容，并且在WebView中启用了JavaScript执行。我认为如果我能执行一些JavaScript，一个标志可能会自己出现。我给index.html页面添加了一些JavaScript，如下图所示。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/a821d0bc3bcefc5afb274c5cb3be07eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*INAU8aPvL5uvFoWjTeWfHA.png"/></div></figure><p id="9490" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">保存文件并在浏览器中查看内容页面后，我可以看到XSS攻击起作用了，但没有显示任何标志。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/e55aaf756c110cb4f1f8199a16cac17f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*EjqAy-vZaHDvmlYkvJZ-jA.png"/></div></figure><p id="bc73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在四处寻找之后，我终于在edit.php的页面上找到了线索。开发者留下的评论提到了一个名为<em class="ko">upload.php</em>的页面。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/d9c72b470bad494a4e84885a820ead2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*bfME8yp2rwhH6JN2UHAL2w.png"/></div></figure><p id="2973" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顾名思义，当我访问这个页面时，我可以上传一个文件。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/5f5364fea490b756e22eead7d3c2a921.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*uLtCJmI-Z90ECJrVgsGaJg.png"/></div></figure><p id="c47a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看页面源代码，我可以看到上传表单接受zip文件。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/97eb3769f4328b1b47fe44a9959fa6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*Bwv064l5EOYGqWkNcR5S8w.png"/></div></figure><p id="797f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，当我试图上传一个zip文件时，出现了以下错误。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/d78148a1e7aad9957f2488b77fc8983b.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*cTIBE-OyfYNoFqj7XMSctg.png"/></div></figure><p id="61b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上传zip文件时，我似乎需要提供HMAC签名。</p><blockquote class="nd ne nf"><p id="768b" class="jq jr ko js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated">注意:<strong class="js iu"> HMAC算法</strong>可用于验证在应用程序之间传递或存储在潜在易受攻击位置的信息的<strong class="js iu">完整性</strong>。基本思想是<strong class="js iu">生成实际<strong class="js iu">数据</strong>与共享<strong class="js iu">秘密密钥</strong>的加密散列</strong>。<strong class="js iu">产生的散列</strong>然后可用于检查传输或存储的消息以确定信任级别，而无需传输密钥。</p></blockquote><p id="c6df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我知道了HMAC私钥的用途，我可以继续创建HMAC签名了。为了实现这一点，我使用了一个简单的在线python脚本(<strong class="js iu">参见参考文献</strong>)来计算HMAC签名。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi pj"><img src="../Images/ef63c50ee0ab2945109c56b26e3d80a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XfcRJX7KJw57WU6WJKSPhA.png"/></div></div></figure><p id="4493" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">执行这个脚本会生成我的<strong class="js iu"> HMAC签名</strong>，如下所示。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi pk"><img src="../Images/c1771375b11508f06dff4151550e5257.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*sJVrAJGqC9nUG4cetp54tw.png"/></div></div></figure><p id="878f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Burpsuite，我可以再次上传我的zip文件，这次将我的HMAC签名添加到POST请求中，作为请求正文的另一部分。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/d42d721d4bffb3fc1e02da50507fba24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*F7Rcatz8J2SCWo8zkTIaaw.png"/></div></figure><p id="37c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是成功的，并导致第一个标志<strong class="js iu">被显示。</strong></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi pm"><img src="../Images/f6bfb16f267f6945489717c6ad8e3d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G5K89JNn2yMU0VUZGPOarg.png"/></div></div></figure><p id="c48f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">成功上传zip文件后，会显示一条信息，说明zip文件已经解压到一个名为/ <em class="ko"> temp </em>的文件夹中，但需要<strong class="js iu">复制</strong>到<em class="ko"> /content </em>文件夹中。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/9cc3b9569ad8cda425f4da72bf9a903b.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*eOdzmKplhs48S77xzzAwqA.png"/></div></figure><p id="4eea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在网上搜索了一些zip文件上传目录遍历漏洞后，我发现了一个叫做<strong class="js iu"> Zip Slip漏洞</strong>的漏洞。</p><blockquote class="nd ne nf"><p id="5df5" class="jq jr ko js b jt ju jv jw jx jy jz ka ng kc kd ke nh kg kh ki ni kk kl km kn im bi translated">注意:Zip Slip漏洞允许攻击者创建Zip存档，使用<strong class="js iu">路径遍历</strong>来覆盖受影响系统上的重要文件，或者破坏它们，或者用恶意替代文件替换它们。</p></blockquote><p id="ee1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了测试这个漏洞是否存在，我使用了Github上的<strong class="js iu"> Snyk </strong>提供的zip slip文件(<strong class="js iu">参见参考文献</strong>)。我用我的python脚本再次创建了一个HMAC签名，但这次是用<em class="ko"> zip-slip.zip </em>文件。然后，我使用BurpSuite拦截POST请求，并像前面看到的那样添加HMAC签名。成功上传zip文件后，我收到了<strong class="js iu">第二个标志</strong>！</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi po"><img src="../Images/865f7ac256ac4bca1103252b531ec829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3KfLu6vYlCZCsAcmPlABXQ.png"/></div></div></figure></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="7e4b" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结束语</h1><p id="54c5" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">我真的很喜欢解决这些挑战，并发现它们对于教授如何利用Android应用程序中的漏洞非常有用。我希望HackerOne将来会继续发布更多基于Android的CTF挑战赛，感谢您阅读到最后😄！</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="eb33" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">参考</h1><ul class=""><li id="cfc0" class="oe of it js b jt mh jx mi kb pp kf pq kj pr kn ps ok ol om bi translated"><a class="ae kp" href="https://developer.android.com/training/app-links/deep-linking" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/training/app-links/深层链接</a></li><li id="0e45" class="oe of it js b jt on jx oo kb op kf oq kj or kn ps ok ol om bi translated"><a class="ae kp" href="https://medium.com/bugbountywriteup/the-zaheck-of-android-deep-links-a5f57dc4ae4c" rel="noopener">https://medium . com/bugbountywriteup/the-za heck-of-Android-deep-links-a5f 57 DC 4 AE 4c</a></li><li id="5bfc" class="oe of it js b jt on jx oo kb op kf oq kj or kn ps ok ol om bi translated"><a class="ae kp" href="https://developer.android.com/reference/android/webkit/WebViewClient#shouldOverrideUrlLoading(android.webkit.WebView,%20android.webkit.WebResourceRequest)" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/reference/Android/WebKit/webview client # shouldoverrideulroading(Android . WebKit . webview，% 20 Android . WebKit . webresourcerequest)</a></li><li id="4ef0" class="oe of it js b jt on jx oo kb op kf oq kj or kn ps ok ol om bi translated"><a class="ae kp" href="https://developer.android.com/reference/android/webkit/SslErrorHandler#proceed()" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/reference/Android/WebKit/SslErrorHandler # proceed()</a></li><li id="d79e" class="oe of it js b jt on jx oo kb op kf oq kj or kn ps ok ol om bi translated"><a class="ae kp" href="https://developer.android.com/reference/android/webkit/WebSettings#setJavaScriptEnabled(boolean)" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/reference/Android/WebKit/web settings # set JavaScript enabled(boolean)</a></li><li id="9c0f" class="oe of it js b jt on jx oo kb op kf oq kj or kn ps ok ol om bi translated"><a class="ae kp" href="https://www.codeproject.com/Articles/392603/Android-addJavaScriptInterface" rel="noopener ugc nofollow" target="_blank">https://www . code project . com/Articles/392603/Android-addJavaScriptInterface</a></li><li id="4dcb" class="oe of it js b jt on jx oo kb op kf oq kj or kn ps ok ol om bi translated"><a class="ae kp" href="https://pymotw.com/2/hmac/" rel="noopener ugc nofollow" target="_blank">https://pymotw.com/2/hmac/</a></li><li id="dd40" class="oe of it js b jt on jx oo kb op kf oq kj or kn ps ok ol om bi translated"><a class="ae kp" href="https://stackoverflow.com/questions/8659808/how-does-http-file-upload-work" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/8659808/how-do-http-file-upload-work</a></li><li id="941f" class="oe of it js b jt on jx oo kb op kf oq kj or kn ps ok ol om bi translated"><a class="ae kp" href="https://github.com/snyk/zip-slip-vulnerability/blob/master/archives/zip-slip.zip" rel="noopener ugc nofollow" target="_blank">https://github . com/snyk/zip-slip-vulnerability/blob/master/archives/zip-slip . zip</a></li></ul></div></div>    
</body>
</html>