<html>
<head>
<title>The toddler’s introduction to Heap exploitation, Use After Free &amp; Double free (Part 4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学走路的孩子对堆利用的介绍，在免费和双免费之后使用(第4部分)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/use-after-free-13544be5a921?source=collection_archive---------1-----------------------#2022-03-31">https://infosecwriteups.com/use-after-free-13544be5a921?source=collection_archive---------1-----------------------#2022-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3f3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章是与x64 Linux二进制开发技术相关的系列文章的一部分。总结我以前的帖子，我们从探索简单的堆栈损坏错误及其缓解技术开始，并逐渐发展到更复杂的主题。在本文中，我将深入研究使用先前已经释放的内存的概念，在堆内存利用的上下文中，这种错误被称为<strong class="jp ir">释放后使用</strong> (UAF)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/a81d4aa00463519d940c4b57cf17baab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rx-GnJvIXOepyxky7iCYpw.png"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="28c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些刚刚“加入”的人，这里是我到目前为止所介绍的内容:</p><p id="86d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">堆栈溢出:</strong></p><ul class=""><li id="69a6" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated"><a class="ae ln" href="https://valsamaras.medium.com/introduction-to-x64-linux-binary-exploitation-part-1-14ad4a27aeef" rel="noopener">基本缓冲区溢出(没有ASLR，DEP/NX，堆栈加那利)</a></li><li id="79c8" class="le lf iq jp b jq lo ju lp jy lq kc lr kg ls kk lj lk ll lm bi translated"><a class="ae ln" href="https://valsamaras.medium.com/introduction-to-x64-binary-exploitation-part-2-return-into-libc-c325017f465" rel="noopener">返回libc </a></li><li id="e727" class="le lf iq jp b jq lo ju lp jy lq kc lr kg ls kk lj lk ll lm bi translated"><a class="ae ln" href="https://valsamaras.medium.com/introduction-to-x64-linux-binary-exploitation-part-3-rop-chains-3cdcf17e8826" rel="noopener">旋转链条</a></li><li id="e16b" class="le lf iq jp b jq lo ju lp jy lq kc lr kg ls kk lj lk ll lm bi translated"><a class="ae ln" href="https://valsamaras.medium.com/introduction-to-x64-linux-binary-exploitation-part-4-stack-canaries-e9b6dd2c3127" rel="noopener">堆叠鸭翼</a></li><li id="b500" class="le lf iq jp b jq lo ju lp jy lq kc lr kg ls kk lj lk ll lm bi translated"><a class="ae ln" href="https://valsamaras.medium.com/introduction-to-x64-linux-binary-exploitation-part-5-aslr-394d0dc8e4fb" rel="noopener">绕过地址空间布局随机化</a></li></ul><p id="077c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">堆利用:</strong></p><ul class=""><li id="6b49" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated"><a class="ae ln" href="https://valsamaras.medium.com/the-toddlers-introduction-to-dynamic-memory-allocation-300f312cd2db" rel="noopener">动态内存分配</a></li><li id="0f12" class="le lf iq jp b jq lo ju lp jy lq kc lr kg ls kk lj lk ll lm bi translated"><a class="ae ln" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8" rel="noopener">探索堆(竞技场、块、箱)</a></li><li id="5ee7" class="le lf iq jp b jq lo ju lp jy lq kc lr kg ls kk lj lk ll lm bi translated"><a class="ae ln" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-2-d1f325b74286" rel="noopener"> Ptmalloc内部构件</a></li><li id="72a8" class="le lf iq jp b jq lo ju lp jy lq kc lr kg ls kk lj lk ll lm bi translated"><a class="ae ln" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-overflows-part-3-d3d1aa042d1e" rel="noopener">堆溢出</a></li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="08c4" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">定义</h1><p id="e939" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">回想一下我的<a class="ae ln" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-overflows-part-3-d3d1aa042d1e" rel="noopener">堆溢出</a>帖子，一大块内存可以存在<strong class="jp ir">两种状态:</strong> <strong class="jp ir">在用</strong>或者<strong class="jp ir">空闲</strong>。<strong class="jp ir">当<em class="mw">使用中(分配)</em> </strong> <em class="mw">，</em>时，块连同<strong class="jp ir">用户数据</strong>一起携带关于其<strong class="jp ir">大小的元数据</strong>，<strong class="jp ir">标志</strong>(指示块是否属于主竞技场，它是否使用mmap分配，以及前一个块是否正在使用)以及关于前一个块的大小的信息(如果后一个块是空闲的)。这样，在需要新分配的过程之后，可以很容易地跟踪和重用它。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/4708edf919e3016b2210f2fdaff65322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yk4wN8hL2yxDWi-cHUg0OA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">空闲块携带着关于它们的大小和其他块的内存地址的信息</figcaption></figure><p id="be77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当程序试图访问空闲块时，结果是不可预测的，主要取决于以下两个因素:</p><ul class=""><li id="e616" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">此事件之前和之后的程序状态，因为它定义了使用非法引用所依据的逻辑。</li><li id="df82" class="le lf iq jp b jq lo ju lp jy lq kc lr kg ls kk lj lk ll lm bi translated">区块的当前内容。</li></ul><p id="c5d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">试图使用先前已被释放的块被称为“<em class="mw">释放后使用”</em> (UAF)，这是最常见的错误之一，其影响从简单的程序崩溃到任意代码执行不等。</p><blockquote class="nc nd ne"><p id="bcf8" class="jn jo mw jp b jq jr js jt ju jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj kk ij bi translated">u<strong class="jp ir"><em class="iq">se After Free</em></strong>是一类当程序试图解引用指向已释放块的指针时发生的漏洞。</p></blockquote><p id="5070" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们以指针<strong class="jp ir"> p </strong>为例，它指向包含函数<strong class="jp ir"> f1地址的块<strong class="jp ir"> A </strong>。</strong>让我们假设由于某种原因<strong class="jp ir"> A </strong>已经被释放并被添加到空闲块列表中。现在，想象在某个时刻，<strong class="jp ir"> A </strong>再次被分配，这次包含了函数<strong class="jp ir"> f2的地址。</strong>当<strong class="jp ir"> p仍然</strong>指向<strong class="jp ir"> A，</strong>再次被访问时，将触发<strong class="jp ir"> f2 </strong>的执行:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/2dd69f8055ea26f9f5319eea8e93ff58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QElXLTYeRxc-T_XptVlAzA.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">在第二次访问期间，p仍然指向块A，块A现在包含函数f2的地址</figcaption></figure><p id="aabd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有各种各样的技术可以利用这类错误，我将在这篇文章以及我的下一篇文章中描述这些技术。</p><h1 id="3424" class="lt lu iq bd lv lw nj ly lz ma nk mc md me nl mg mh mi nm mk ml mm nn mo mp mq bi translated">第一次适合</h1><p id="a600" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">释放后使用漏洞类利用了ptmalloc分配器的行为，根据该行为，malloc将返回第一个匹配内存需求的块的地址。下面的例子展示了这种行为，这个例子摘自<a class="ae ln" href="https://github.com/shellphish" rel="noopener ugc nofollow" target="_blank">shellphish</a>/<a class="ae ln" href="https://github.com/shellphish/how2heap" rel="noopener ugc nofollow" target="_blank">how 2 heap</a>回购:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="422a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们编译并运行该程序，我们会观察到以下输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/90d9135c35a4531d4b081ec2004ea3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hR0o2xguseLI_SbwUR9oQw.png"/></div></div></figure><p id="5747" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图中(<strong class="jp ir"> 1)和(2) </strong>反映了变量<code class="fe nr ns nt nu b">a</code>指向包含字符串<code class="fe nr ns nt nu b"><strong class="jp ir">this is A</strong></code> <strong class="jp ir">的<code class="fe nr ns nt nu b">0x5558007bf010 </code>。</strong>于(<strong class="jp ir"> 3) </strong> <code class="fe nr ns nt nu b">a</code>获得自由。然后程序请求一个大小类似于分配给<code class="fe nr ns nt nu b">a</code>的块(见第32行)。它使用<code class="fe nr ns nt nu b">c</code>指向这个块，并将<code class="fe nr ns nt nu b"><strong class="jp ir">this is C!</strong></code>写入这个新分配的内存空间。在(<strong class="jp ir"> 5)中，</strong>作为指针<code class="fe nr ns nt nu b">a</code>被再次访问(在空闲后使用)，它将打印<code class="fe nr ns nt nu b"><strong class="jp ir">this is C!</strong></code> <strong class="jp ir"> </strong>作为块的数据被覆盖。</p><h2 id="3985" class="nv lu iq bd lv nw nx dn lz ny nz dp md jy oa ob mh kc oc od ml kg oe of mp og bi translated">第一次拟合UAF示例(1)</h2><p id="a659" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">让我们看一个更有趣的例子，摘自<a class="ae ln" href="https://googleprojectzero.blogspot.com/2015/06/what-is-good-memory-corruption.html" rel="noopener ugc nofollow" target="_blank">这篇</a>帖子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3146" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行这段代码只会弹出一个shell:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oh"><img src="../Images/5ffd78db6414baabfc6a1fed700043fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*beHooJGaM6HXvEuuvUlPdg.png"/></div></div></figure><p id="dd26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">但为什么是</strong>？毕竟<code class="fe nr ns nt nu b">*run_calc</code>已经被设置为<strong class="jp ir"> 0，</strong>因此第13行的条件<em class="mw"> </em>将为假，并且<code class="fe nr ns nt nu b">execl</code>将永远不会运行。让我们在<code class="fe nr ns nt nu b">gdb</code>加载程序，并在第一次malloc后设置一个断点，并将零值分配给<code class="fe nr ns nt nu b">*run_calc</code>:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oi"><img src="../Images/28b323ab91314a2d9e154de2b85c161a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iX_kodQsxL7w93OCsii7aQ.png"/></div></div></figure><p id="55f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不出所料<code class="fe nr ns nt nu b">run_calc</code> <strong class="jp ir"> </strong>指向包含零值的<code class="fe nr ns nt nu b">0x00005555555592a0</code>:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oj"><img src="../Images/47254ea96d31e764c7996a0068af13d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLWetCuf3F68hq6usMi8IQ.png"/></div></div></figure><p id="37b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nr ns nt nu b">p_unicorn_counter</code> <strong class="jp ir"> </strong>将指向与<code class="fe nr ns nt nu b">run_calc</code>相同的块，由于在<strong class="jp ir">、</strong>之前描述的<em class="mw">首次拟合逻辑</em>，因此在<code class="fe nr ns nt nu b">Line 12</code>之后，块看起来如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ok"><img src="../Images/b9794f078779836bf6a9985d462142c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-k_GDNZfCDsMxp1RZd4vzg.png"/></div></div></figure><p id="4d85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当再次访问<code class="fe nr ns nt nu b">run_calc</code> <strong class="jp ir"> </strong>时，它包含值0x2a，因此<em class="mw"> if </em> <strong class="jp ir"> </strong>将允许调用<code class="fe nr ns nt nu b">execl</code>。</p><h2 id="6680" class="nv lu iq bd lv nw nx dn lz ny nz dp md jy oa ob mh kc oc od ml kg oe of mp og bi translated">第一次拟合UAF示例(2)</h2><p id="4517" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">考虑下面描述的代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3ca9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">第4行</strong>中，我们将<code class="fe nr ns nt nu b">fp</code>定义为一个指向函数的指针，该函数不获取任何参数并返回void。在<strong class="jp ir">行15 </strong>中，我们定义了一个<code class="fe nr ns nt nu b">fp</code>类型的指针，它指向<code class="fe nr ns nt nu b">func1</code> ( <strong class="jp ir">行16 </strong>)。在<strong class="jp ir">第21行</strong>中，我们为<code class="fe nr ns nt nu b">pointer1</code>调用函数<code class="fe nr ns nt nu b">free</code>，并为<code class="fe nr ns nt nu b">func2</code>和<code class="fe nr ns nt nu b">pointer2</code>重复相同的过程。问题出现在<strong class="jp ir">第33行</strong>，因为我们正在重用一个之前释放的指针。如果我们编译并运行该程序，我们会得到以下输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/ecf770bed0e0e80f354e9086039ecf5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*nI0yXnyqqnIIacQ1xrIg4A.png"/></div></figure><p id="1bba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然在状态[4]之前一切都如预期的那样进行，但是我们注意到在调用<code class="fe nr ns nt nu b">func2</code>之后，即使我们从未将<code class="fe nr ns nt nu b">func2</code>的地址分配给指针<code class="fe nr ns nt nu b">pointer1</code>。为了理解发生了什么，让我们将程序加载到gdb，并在<code class="fe nr ns nt nu b">malloc</code>和<code class="fe nr ns nt nu b">free</code>调用后设置一些断点:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi om"><img src="../Images/4fc0b6db1c995cd901be985fb4408de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCY8HlXJsUrGtCZqghCpJA.png"/></div></div></figure><p id="8b07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一个<code class="fe nr ns nt nu b">malloc</code>和将<code class="fe nr ns nt nu b">func1</code>地址分配给<code class="fe nr ns nt nu b">pointer1</code>之后，我们有以下分配:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi on"><img src="../Images/b75a4b4c700d287c172b7587ac65ddac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPeQpQCbesIpWnm5MpcCAA.png"/></div></div></figure><p id="c59c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如所料，<code class="fe nr ns nt nu b">pointer1</code>指向<code class="fe nr ns nt nu b">0x00005555555592a0</code>，其中包含与<code class="fe nr ns nt nu b">func1</code>地址相对应的内存地址<code class="fe nr ns nt nu b">0x00005555555551c9</code>:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/8ce7a841e9a7bdec36c640a04bda268c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*54BLzZVpIzZWiv9bHgOH9w.png"/></div></figure><p id="1f5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随后在<code class="fe nr ns nt nu b">free</code>调用之后，<code class="fe nr ns nt nu b">pointer1</code>指向的块被添加到<code class="fe nr ns nt nu b">tcache</code>列表中:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi op"><img src="../Images/b95e7bfb677426266aaeeb9ec1a5dd96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GGo-peg2gKGsuRyxuHeUzA.png"/></div></div></figure><p id="3d3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在第二次malloc之后，<code class="fe nr ns nt nu b">tcache</code>为空，因为<code class="fe nr ns nt nu b">pointer2</code>的内存大小要求与<code class="fe nr ns nt nu b">pointer1</code>相同，因此分配器将空闲块分配给<code class="fe nr ns nt nu b">pointer2</code>:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oq"><img src="../Images/6d658197a8b215e71c11e9e0f38f7bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PjfR9wA_65Y-VYAYDYC6Jg.png"/></div></div></figure><p id="a834" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于<code class="fe nr ns nt nu b">pointer1</code>仍然指向<code class="fe nr ns nt nu b">0x00005555555592a0</code>，我们程序中第33行的<code class="fe nr ns nt nu b">(*pointer1)();</code>调用将调用函数<code class="fe nr ns nt nu b">func2</code>。</p><h2 id="f4b1" class="nv lu iq bd lv nw nx dn lz ny nz dp md jy oa ob mh kc oc od ml kg oe of mp og bi translated">第一次拟合UAF示例(3)</h2><p id="d004" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">让我们看看另一个取自(现已死亡)https://exploit-exersises.com/protostar/heap2网站的例子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="569d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该程序包含一个<code class="fe nr ns nt nu b">while</code>循环(第19-44行),并根据从第22行获得的用户输入进行操作。发出一个<code class="fe nr ns nt nu b"><strong class="jp ir">auth</strong></code> <strong class="jp ir"> </strong>命令，后跟一个字符串，将触发第25行的早午餐。这将根据auth struct大小分配空间，并将分配的字节设置为零(第26行)。如果在<code class="fe nr ns nt nu b">auth</code>之后给出的字符串小于31字节(第27行),内容将被复制到由<code class="fe nr ns nt nu b">authVar-&gt;name</code>变量指向的内存空间。</p><p id="b56c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nr ns nt nu b"><strong class="jp ir">service</strong></code> <strong class="jp ir"> </strong>命令将使用<code class="fe nr ns nt nu b"><a class="ae ln" href="https://man7.org/linux/man-pages/man3/strdup.3.html#:~:text=The%20strdup()%20function%20returns,copies%20at%20most%20n%20bytes." rel="noopener ugc nofollow" target="_blank">strdup</a></code>通过malloc函数复制给定的字符串:</p><pre class="km kn ko kp gt or nu os ot aw ou bi"><span id="de2c" class="nv lu iq nu b gy ov ow l ox oy">The <strong class="nu ir">strdup</strong>() function returns a pointer to a new string which is<br/>a duplicate of the string <em class="mw">s</em>.  Memory for the new string is<br/>obtained with <a class="ae ln" href="https://man7.org/linux/man-pages/man3/malloc.3.html" rel="noopener ugc nofollow" target="_blank">malloc(3)</a>, and can be freed with <a class="ae ln" href="https://man7.org/linux/man-pages/man3/free.3.html" rel="noopener ugc nofollow" target="_blank">free(3)</a>.</span></pre><p id="5164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nr ns nt nu b"><strong class="jp ir">login</strong></code> <strong class="jp ir"> </strong>命令检查<code class="fe nr ns nt nu b">authVar-&gt;auth</code>并将始终打印“请输入您的密码”，因为没有办法根据用户输入修改auth变量(或者也许有？).因此，这里的利用场景是让程序相信我们已经登录。最后，如果用户输入<code class="fe nr ns nt nu b"><strong class="jp ir">reset</strong></code>、<strong class="jp ir">、</strong>，程序将调用<code class="fe nr ns nt nu b">free</code>函数获取<code class="fe nr ns nt nu b">authVar</code>指针。该bug的出现是因为在对<code class="fe nr ns nt nu b">free</code>的潜在调用之后，在第38行再次访问了<code class="fe nr ns nt nu b">authVar</code>。</p><p id="4f53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们在gdb中运行程序来看看发生了什么之前，让我们先做一下数学计算:</p><blockquote class="nc nd ne"><p id="00b5" class="jn jo mw jp b jq jr js jt ju jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj kk ij bi translated"><strong class="jp ir"> auth </strong> <strong class="jp ir"> struct </strong>总共需要<strong class="jp ir"> 36个字节</strong>，其中32个字节用于名称，另外4个字节用于auth整数。分配器需要再添加<strong class="jp ir"> 8个字节</strong>来跟踪块的大小，这产生了对<strong class="jp ir"> 0x24 </strong>字节的需求，由于16字节对齐，这将最终导致<strong class="jp ir"> 0x30 </strong>字节<strong class="jp ir"> </strong>分配。当程序调用<code class="fe nr ns nt nu b">free</code>函数时，块将被添加到<code class="fe nr ns nt nu b">tcache</code>中，以满足下一个(类似大小的)分配需求。这里是<code class="fe nr ns nt nu b"><strong class="jp ir">service</strong></code> <strong class="jp ir"> </strong>命令进入框架的地方。如果我们创建一个0x30字节的分配需求，释放的块将被分配给<code class="fe nr ns nt nu b"><em class="iq">char *service </em></code>指针。既然控制了输入，根据第35行，我们可以用任意一个值覆盖<em class="iq"> </em> <code class="fe nr ns nt nu b"><em class="iq">auth</em></code> <em class="iq">整数</em> <em class="iq">值并通过登录检查。</em></p></blockquote><p id="8486" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先试试这个假设:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/810125b8df6c76a6ab8c105c7b5d08fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*a7LwoePsWKK4TUCPRyf1cQ.png"/></div></figure><p id="372f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如所料，123456789012345678901234567890 ab值覆盖了允许我们以管理员身份登录的整数<code class="fe nr ns nt nu b">authVar-&gt;auth</code>。让我们将程序加载到gdb，以便更好地了解情况。让我们在strcpy函数后设置一个断点并运行程序:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pa"><img src="../Images/eabff3b9a09d0c19c54b85bf2ea74a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ue08i8TzRuDwuZvQlP2Zjg.png"/></div></div></figure><p id="5e00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在“auth admin”输入之后，我们有以下块:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pb"><img src="../Images/03b417485e2d542551cc2aa1176d6e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_GPm1dTCtviFSCL-nz_vw.png"/></div></div></figure><p id="511a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nr ns nt nu b">authVar</code>指向<code class="fe nr ns nt nu b">0x555555559ac0</code>，分配的块大小为0x30字节:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/3ae8c9e97dc556eaa55301bb963f9439.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*3tEhavuXVzyw6t60OAjV-A.png"/></div></figure><p id="6412" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">键入<code class="fe nr ns nt nu b">reset</code>将触发分配块的free函数，因此它将被添加到tcache:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pd"><img src="../Images/6198970eece40bc9122b4b7905dcf7d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rpivPbkWRrV-LtAg_WaAuA.png"/></div></div></figure><p id="ddf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">键入<code class="fe nr ns nt nu b">service 123456789012345678901234567890AB</code>将创建一个34字节的需求(包括服务后的空间和新行)，因此<code class="fe nr ns nt nu b">service</code>指针将指向与authVar:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/21aeb72c923bce8fbbaa8b4922fb57e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*lZF_rCj8VVN1XSAnDKysiw.png"/></div></figure><p id="d478" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们键入<code class="fe nr ns nt nu b"><strong class="jp ir">login</strong></code> <strong class="jp ir"> </strong>并检查<code class="fe nr ns nt nu b">0x555555559ac0</code>处的块</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/16c6623e5b8189a1579e31809bc6a985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*TaGTRh3psG9ouYgQyXR5qg.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pc"><img src="../Images/35a6f2d1b4e63b21faffe8650b5dd5d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*lkhEzsv4Mi-G1XJsf-Lx_Q.png"/></div></div></figure><p id="d82b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nr ns nt nu b">0x0a42</code>值已经覆盖了int auth，因此<code class="fe nr ns nt nu b">if(authVal-&gt;auth</code>将被评估为true并允许我们登录。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/cffd9d286c89067b5b86b568f89f138d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*y7GgEizfC6dqryPJrD5r5w.png"/></div></figure><h1 id="5cda" class="lt lu iq bd lv lw nj ly lz ma nk mc md me nl mg mh mi nm mk ml mm nn mo mp mq bi translated">双倍免费</h1><p id="d2fe" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">当对同一个指针多次调用free时，就会出现Double free。让我们看一个来自https://github.com/shellphish/how2heap的例子</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2635" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">第11–18行，</strong>程序正在填充tcache列表。</p><blockquote class="nc nd ne"><p id="80bc" class="jn jo mw jp b jq jr js jt ju jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj kk ij bi translated"><strong class="jp ir">记住</strong>:多达七个相同大小的块将会出现在同一个tcache子列表中。</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ph"><img src="../Images/5a0c7ff7bcb7b0c39335a26216b39138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvlRmTMyJpOPSArEwIJNIQ.png"/></div></div></figure><p id="dc9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">第20-23行，</strong>程序再分配三个大小为<code class="fe nr ns nt nu b"><strong class="jp ir">0x8</strong></code> <strong class="jp ir"> </strong>的块，而在<strong class="jp ir">第30行</strong>我们第一次调用释放指针<code class="fe nr ns nt nu b"><strong class="jp ir">a</strong></code>。在<strong class="jp ir">行</strong>行<strong class="jp ir"> 39 </strong>处，我们第二次调用<code class="fe nr ns nt nu b"><strong class="jp ir">free</strong></code>来获取<strong class="jp ir">的一个</strong>指针。在第39行之前，fastbins列表将如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pi"><img src="../Images/7bc54e72d2e53c4866e76d01dd841722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ch60maotYYxJ0WhSgjBPmw.png"/></div></div></figure><p id="e843" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第39行之后(注意列表顶端和末端的地址):</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pj"><img src="../Images/8086668051179e58f15abc68afcd1f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EszWPyXgWOxZ3JejDwQN2A.png"/></div></div></figure><p id="ca1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">第42到44行</strong>处，我们有三个分配需求，它们将从快速箱中得到满足，但是由于第一个和最后一个块是相同的，<code class="fe nr ns nt nu b"><strong class="jp ir">a</strong></code> <strong class="jp ir"> </strong>和<code class="fe nr ns nt nu b"><strong class="jp ir">c</strong></code> <strong class="jp ir"> </strong>将指向相同的位置<code class="fe nr ns nt nu b"><strong class="jp ir">0x5555555593a0</strong></code>。错误的分配可以通过简单地运行程序来验证:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pk"><img src="../Images/8d3a023a58766309b4a6a4de6d047345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-BJxoOeaHYETn9awsxOOg.png"/></div></div></figure><p id="0dab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意最后3行中的<strong class="jp ir"> a </strong>和<strong class="jp ir"> c </strong>指向<code class="fe nr ns nt nu b"><strong class="jp ir">0x55b275b703a0</strong></code></p></div></div>    
</body>
</html>