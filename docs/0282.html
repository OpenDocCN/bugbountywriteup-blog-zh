<html>
<head>
<title>Cross-Site Content and Status Types Leakage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跨网站内容和状态类型泄漏</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/cross-site-content-and-status-types-leakage-ef2dab0a492?source=collection_archive---------0-----------------------#2019-03-19">https://infosecwriteups.com/cross-site-content-and-status-types-leakage-ef2dab0a492?source=collection_archive---------0-----------------------#2019-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="78aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在做我通常的Bug Bounty研究程序时，我发现一个有趣的行为发生在一个流行的网站上，比如说censored.com<em class="kl"/>。根据用户是否被授权显示网站，会显示两个完全不同的页面。一个是带有<code class="fe km kn ko kp b"><em class="kl">content-type:text/html;charset=utf-8</em></code> <a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> HTTP头</em> </a>的，第二个是完全没有<a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type" rel="noopener ugc nofollow" target="_blank"> <em class="kl">内容类型</em> </a> <em class="kl">头</em>的，在这种情况下默认为<code class="fe km kn ko kp b"><em class="kl">text/plain</em></code>。所以我问自己:<em class="kl">有没有一种聪明的方法来区分这两种反应？如果是的话，这能推广到所有的网站吗？它会带来什么威胁？</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ce85e7133324d90f61cf67791f7d8230.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*M_ITUtOapoOVCjMkfmKM8Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">内容类型:文本/html</figcaption></figure><p id="2ccd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从区分前面提到的响应所带来的威胁开始。这可能不明显，但这是一个严重的信息泄露，可能会在不同的网站上发生。在这个具体的例子中，恶意第三方可以获得关于访问者是否被授权在另一个网站，例如<em class="kl">Facebook.com</em>上显示给定的一组资源的信息，并且因此基于结果暴露他们的身份。</p><p id="dd9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在某些情况下，这种影响可能比用户去匿名化更严重，因此尝试一下这个想法似乎是值得的。当时，我预感这是可能实现的，所以我开始研究<a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/HTML" rel="noopener ugc nofollow" target="_blank"> MDN Web文档</a>，希望能找到任何有帮助的有趣属性。没花太长时间，因为我很快就发现了值得的那个。</p><blockquote class="lh li lj"><p id="e0ed" class="jn jo kl jp b jq jr js jt ju jv jw jx lk jz ka kb ll kd ke kf lm kh ki kj kk ij bi translated"><code class="fe km kn ko kp b"><strong class="jp ir"><em class="iq">HTMLObjectElement.typeMustMatch</em></strong></code>属性是一个<code class="fe km kn ko kp b"><a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean" rel="noopener ugc nofollow" target="_blank"><em class="iq">Boolean</em></a></code>，它反映了<code class="fe km kn ko kp b"><a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object" rel="noopener ugc nofollow" target="_blank"><em class="iq">&lt;object&gt;</em></a></code>元素的<code class="fe km kn ko kp b"><a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object#attr-typemustmatch" rel="noopener ugc nofollow" target="_blank"><em class="iq">typemustmatch</em></a></code>属性。它指示它所链接的资源是否必须匹配由<code class="fe km kn ko kp b"><a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLObjectElement/type" rel="noopener ugc nofollow" target="_blank"><em class="iq">HTMLObjectElement.type</em></a></code>给出的MIME类型，以便使用这个资源。<a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLObjectElement/typeMustMatch" rel="noopener ugc nofollow" target="_blank">【1】</a></p></blockquote><p id="8fc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个属性，我开始在Chrome上进行实验。然而，试了几次之后，我还是没有成功。浏览器似乎完全忽略了这个属性。事实上，我忽略了<a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLObjectElement/typeMustMatch#Browser_compatibility" rel="noopener ugc nofollow" target="_blank">浏览器兼容性</a>部分。幸运的是，<a class="ae kq" href="https://twitter.com/sirdarckcat" rel="noopener ugc nofollow" target="_blank">爱德华多</a>启发了我，它应该可以在Firefox中工作。的确如此，就像一个魔咒。</p><p id="8c4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更详细地说，如果<code class="fe km kn ko kp b"><em class="kl">content-type</em></code>头与<code class="fe km kn ko kp b"><em class="kl">HTML &lt;object&gt;</em></code>的<code class="fe km kn ko kp b"><em class="kl">type</em></code>属性不匹配，资源将不会被加载。不幸的是，<code class="fe km kn ko kp b"><em class="kl">&lt;object&gt;</em></code>元素既不触发<code class="fe km kn ko kp b"><em class="kl">onload</em></code>也不触发<code class="fe km kn ko kp b"><em class="kl">onerror</em></code>事件，所以检测对象是否已经加载是另一个难题。</p><p id="93c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kq" href="https://twitter.com/sirdarckcat" rel="noopener ugc nofollow" target="_blank"> Eduardo </a>提出了一个有趣的想法，通过使用<code class="fe km kn ko kp b"><em class="kl">&lt;object&gt;</em></code>中的内联元素来检测状态。</p><pre class="ks kt ku kv gt ln kp lo lp aw lq bi"><span id="70f4" class="lr ls iq kp b gy lt lu l lv lw">&lt;object type= data= typemustmatch&gt; not_loaded &lt;/object&gt;</span></pre><p id="835e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，这个想法是，如果呈现了<code class="fe km kn ko kp b"><em class="kl">not_loaded</em></code>文本，要么是<code class="fe km kn ko kp b"><em class="kl">type</em></code>属性与<code class="fe km kn ko kp b"><em class="kl">content-type</em></code>头不匹配，要么是服务器以不同于<code class="fe km kn ko kp b"><em class="kl">HTTP 200 OK</em></code>的状态响应。这看起来不太容易，所以我一直在调查。</p><p id="9ac1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在仔细查看了<code class="fe km kn ko kp b"><em class="kl">&lt;object&gt;</em></code>属性之后，我注意到<code class="fe km kn ko kp b"><em class="kl">&lt;object&gt;.clientHeight</em></code>和<code class="fe km kn ko kp b"><em class="kl">&lt;object&gt;.clientWidth</em></code>在某些场景中会有所不同。这些属性不亚于渲染对象的<code class="fe km kn ko kp b"><em class="kl">width</em></code>和<code class="fe km kn ko kp b"><em class="kl">height</em></code>。如果对象还没有被渲染，那么它的尺寸是<code class="fe km kn ko kp b"><em class="kl">0</em></code>，否则，很可能大于这个尺寸。像上一段一样，这里也一样，只有当服务器用<code class="fe km kn ko kp b"><em class="kl">HTTP 200 OK</em></code>状态响应时，对象才会被呈现。我不确定这是对攻击的阻碍还是<strong class="jp ir">通向另一个的桥梁，</strong>非常有效的<strong class="jp ir">，错误页面检测技术？</strong><a class="ae kq" href="https://portswigger.net/blog/exposing-intranets-with-reliable-browser-based-port-scanning" rel="noopener ugc nofollow" target="_blank"><em class="kl">【2】</em></a></p><p id="f1ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">攻击的最后一个缺失部分是检测<code class="fe km kn ko kp b"><em class="kl">&lt;object&gt;</em></code>何时加载。<em class="kl">因为，</em> <em class="kl">如果我们不知道</em> <code class="fe km kn ko kp b"><em class="kl">&lt;object&gt;</em></code> <em class="kl">什么时候已经加载了</em>，我们怎么知道什么时候应该读取它的 <code class="fe km kn ko kp b"><em class="kl">height</em></code> <em class="kl">属性？一个简单的解决方案是在读取<code class="fe km kn ko kp b"><em class="kl">object.clientHeight</em></code>之后使用计时。但是没有人喜欢计时，计时非常不稳定，对掉线非常敏感。</em></p><p id="f80b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，也许<code class="fe km kn ko kp b"><em class="kl">&lt;object&gt;</em></code>本身不会触发<code class="fe km kn ko kp b"><em class="kl">onload</em></code>事件，但是<code class="fe km kn ko kp b"><em class="kl">window</em></code>物体肯定会。只有当包括<code class="fe km kn ko kp b"><em class="kl">iframes</em></code>在内的所有组件都被加载时，才会触发<em class="kl">窗口</em>中的事件。因此，通过创建一个新的独立文档(例如<em class="kl"> iframe </em>)，很容易监听它的<code class="fe km kn ko kp b"><em class="kl">onload</em></code>事件，然后读取放在那里的<code class="fe km kn ko kp b"><em class="kl">&lt;object&gt;</em></code>的<code class="fe km kn ko kp b"><em class="kl">height</em></code>。</p><p id="09d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至于结合模拟的<code class="fe km kn ko kp b"><em class="kl">&lt;object&gt;.onload</em></code>事件和检测的<code class="fe km kn ko kp b"><em class="kl">&lt;object&gt;</em></code>渲染的结果，我们得到了一个全新的<strong class="jp ir">跨源</strong> <strong class="jp ir">内容和状态类型</strong>检测的技术。有鉴于此，可以很有把握地说，这种方法自豪地加入了<a class="ae kq" href="https://github.com/xsleaks/xsleaks/wiki/Browser-Side-Channels" rel="noopener ugc nofollow" target="_blank"> XS泄漏</a>家族。</p><p id="7e34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我嵌入了一个奇特的概念证明，成功地泄露了资源的<code class="fe km kn ko kp b"><em class="kl">content-type</em></code>。享受旅程吧！</p><h2 id="074f" class="lr ls iq bd lx ly lz dn ma mb mc dp md jy me mf mg kc mh mi mj kg mk ml mm mn bi translated">更新:</h2><p id="40c1" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">火狐团队已经修复了这个问题，所以这项技术不再有效。</p><blockquote class="mt"><p id="06c9" class="mu mv iq bd mw mx my mz na nb nc kk dk translated">对HTML <code class="fe km kn ko kp b">&lt;object&gt;</code>元素上的<code class="fe km kn ko kp b">typemustmatch</code>属性和<code class="fe km kn ko kp b">HTMLObjectElement</code> DOM接口上对应的<code class="fe km kn ko kp b"><a class="ae kq" href="https://developer.mozilla.org/docs/Web/API/HTMLObjectElement/typeMustMatch" rel="noopener ugc nofollow" target="_blank">typeMustMatch</a></code>属性的支持已经从最新的HTML live Standard和Firefox 68中移除。没有其他浏览器支持该属性，因此兼容性风险应该很低。</p></blockquote><p id="1eaa" class="pw-post-body-paragraph jn jo iq jp b jq nd js jt ju ne jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated"><a class="ae kq" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1548773" rel="noopener ugc nofollow" target="_blank">https://bugzilla.mozilla.org/show_bug.cgi?id=1548773</a></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ni nj l"/></div></figure></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="b86b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">关注</em> <a class="ae kq" href="https://medium.com/bugbountywriteup" rel="noopener"> <em class="kl"> Infosec报道</em> </a> <em class="kl">获取更多此类精彩报道。</em></p><div class="nr ns gp gr nt nu"><a href="https://medium.com/bugbountywriteup" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">信息安全报道</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">收集了世界上最好的黑客的文章，主题从bug奖金和CTF到vulnhub…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="oe l of og oh od oi lb nu"/></div></div></a></div></div></div>    
</body>
</html>