<html>
<head>
<title>0-day bug breaks multi-million dollar system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">零日漏洞打破数百万美元的系统</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/0-day-bug-breaks-multi-million-dollar-system-38c9e31b27e9?source=collection_archive---------1-----------------------#2020-12-30">https://infosecwriteups.com/0-day-bug-breaks-multi-million-dollar-system-38c9e31b27e9?source=collection_archive---------1-----------------------#2020-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b1d1ef80e243ba92de1e9e190e0e86ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJGouk1_c9K-tpFi3gI6yA.png"/></div></div></figure><p id="a18e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前几天，我们从一个全国性组织那里得到了一份黑盒测试的订单。该组织在全国范围内提供数十甚至数百种服务，其用户数以百万计。老实说，从影响的角度来看，这是迄今为止我们做过的最大的黑客攻击之一。但这不是我决定发表这篇文章的主要原因..</p><p id="1855" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">真正的原因是黑客本身，在我看来，<strong class="ka ir">真的很有趣</strong>！这是你可以引以为豪的黑客类型。它花了令人难以置信的时间和许多不同的方法才获得成功。由于我的固执，我没有太快放弃，最后，我发现了四个新的漏洞，它们共同导致了组织内部的未授权、远程和任意代码执行<strong class="ka ir">。</strong></p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="041b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">说到细节。简而言之，目标是一组专门构建的web应用程序，用于填充、处理和发送许多不同类型的表单。由于测试是黑盒测试，我们没有得到任何关于系统的信息，除了最终用户能看到的，什么也没有。这很重要，因为在专门构建的后端中找到并充分利用漏洞显然不太容易。</p><p id="f959" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与pentests一样，我们从列出所有服务器和端点开始，查看流程流和前端代码。在黑盒测试中，这是一个非常重要的阶段，因为您可能会了解到系统正在使用的一些<strong class="ka ir">库或组件</strong>，它们是典型的现成产品。这可以告诉您有关架构和技术的更多信息，还可以让您识别系统是否包含众所周知的易受攻击的组件版本。不幸的是，通过查看收集的列表，我们没有发现任何易受攻击的产品版本，但是有一个组件——尤其是它的使用方式——在其他组件中非常突出。</p><p id="4636" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个可疑的组件从浏览器接收html文件<strong class="ka ir">(用户输入),并将html文件转换成PDF。从pentester的角度来看，这种服务似乎非常有趣，因为(1)有一些文件上传；(2)一些处理(解析器等。)并且我们也(3)取回一些结果。所有的步骤都可能是脆弱的，事实上，情况就是如此。</strong></p><p id="2f6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一个信息——组件通过它在url路径中的名字被公开<strong class="ka ir">。路径以:<em class="ld"> https://……结尾../API/</em><strong class="ka ir"><em class="ld">gotenberg</em></strong>。我本人并不知道这个组件，但它的名字非常容易辨认，以至于快速搜索“gotenberg pdf”会出现一个github页面，其中有一个开源的pdf转换组件— <a class="ae le" href="https://github.com/thecodingmachine/gotenberg/" rel="noopener ugc nofollow" target="_blank"> Gotenberg，</a>作者称之为:</strong></p><blockquote class="lf lg lh"><p id="341e" class="jy jz ld ka b kb kc kd ke kf kg kh ki li kk kl km lj ko kp kq lk ks kt ku kv ij bi translated">Docker支持的无状态API，用于将HTML、Markdown和Office文档转换为PDF。</p></blockquote><p id="bf2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">附注</strong>:本文中描述的漏洞(CVE-2020–13449、CVE-2020–13450、CVE-2020–13451和CVE-2020–1345)已报告给作者，并很快被修复。我要感谢朱利安·纽哈特的快速反应和修复。作者同意并声明，Gotenberg在这个主要版本(6)中应该只由不对外公开的可信应用程序在内部使用。</p><p id="2efe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，整个系统都是使用微服务架构构建的，其中有一个Gotenberg组件完全暴露在外部世界中。</p><p id="9233" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，该系统仅使用HTML转换API，但其公开的方式允许所有未经认证的互联网用户使用<strong class="ka ir">整体API </strong> — HTML、markdown和office，包括<em class="ld"> /url </em> /端点，该端点允许将组件指向互联网上的外部web url以生成PDF文件。这本身就是一个漏洞，因为允许匿名代理web流量，甚至使用它来执行使用我们的客户端基础设施的DoS攻击。</p><p id="ba06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为该组件是开源的，可以在Docker hub中获得，所以很容易对其进行非常基本的攻击测试。因此，在使用以下命令启动Docker容器后(我特意在这里启动易受攻击的版本6.2.0，因为这个问题已经在6.3.0中得到解决):</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="79fc" class="lu lv iq lq b gy lw lx l ly lz">$ docker run --rm -p 3000:3000 --name gotenberg thecodingmachine/gotenberg:6.2.0</span></pre><p id="159f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以玩玩，试着找一些有趣的攻击。</p><p id="d3d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前两个漏洞<strong class="ka ir">是<strong class="ka ir">微不足道的</strong>，并且很快被发现。但是开发它们的方式更具挑战性。</strong></p><h1 id="5f03" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">第一个漏洞—上传任意文件</h1><p id="5a19" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">如果组件接受文件(上传),那么pentester首先进行的测试之一就是尝试路径遍历攻击。因此查看<a class="ae le" href="https://thecodingmachine.github.io/gotenberg/" rel="noopener ugc nofollow" target="_blank">文档</a>我们可以这样调用<em class="ld"> /markdown/ </em>端点(注意<strong class="ka ir">加粗的</strong>部分):</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="d63f" class="lu lv iq lq b gy lw lx l ly lz">$ curl 'http://$URL_GOTENBERG/convert/markdown' --form files=@index.html --form "files=@test;filename=<strong class="lq ir">../../../tmp/test</strong>" -o res.pdf --header 'Content-Type: multipart/form-data'</span></pre><p id="edbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">令人惊讶的是——因为在大多数web框架中，这种攻击不会起作用，因为文件名参数输入在框架级别被转义——Gotenberg<strong class="ka ir">实际上</strong>易受攻击,因为它是用Go lang编写的，并且使用net/http包来处理http请求，它在将文件名传递给应用程序之前不会对文件名进行转义，后者也不会对其进行转义。因此，上面的curl将文件<em class="ld"> test </em>写入Docker容器的路径<em class="ld"> /tmp/test </em>中。这可以通过运行以下命令来验证:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="11c4" class="lu lv iq lq b gy lw lx l ly lz">$ docker exec -it gotenberg bash -c "ls -la /tmp/"<br/>total 16<br/>drwxrwxrwt 1 root      root      4096 Dec 29 19:10 .<br/>drwxr-xr-x 1 root      root      4096 Dec 29 19:10 ..<br/>drwxr-xr-x 2 root      root      4096 May  1  2020 hsperfdata_root<br/><strong class="lq ir">-rw------- 1 gotenberg gotenberg   60 Dec 29 19:10 test</strong></span></pre><h1 id="74bd" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">第二个漏洞—任意文件下载</h1><p id="0941" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">更棘手的是第二个漏洞。根据Gotenberg的文档，Gotenberg允许转换markdown文件——但是转换的方式是通过一个呈现模板的HTML文件。模板可以调用一个助手函数<em class="ld"> toHTML </em>，该函数实际上读取文件系统中的任何文件，并将markdown呈现为HTML。</p><p id="10df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您可能猜到的那样，这可能导致容器内的任意文件泄漏。就其本身而言，这并不是一个非常严重的漏洞，因为没有多少东西可以利用它，但是正如您稍后将看到的，这个漏洞可以用来造成更多的破坏！</p><p id="d643" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，为了了解它是如何工作的，让我们创建一个HTML(让我们命名为index.html)文件:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="0569" class="lu lv iq lq b gy lw lx l ly lz">&lt;!doctype html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;title&gt;My PDF&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;pre style="white-space: pre-wrap;"&gt;<br/>      Path:<br/>      {{ .DirPath }}  <br/>      PASSWD:<br/>      {{ toHTML .DirPath "../../../../etc/passwd" }}<br/>      IP:<br/>      {{ toHTML .DirPath "../../../../proc/net/fib_trie" }}<br/>      TCP:<br/>      {{ toHTML .DirPath "../../../../proc/net/tcp" }}<br/>      env:<br/>      {{ toHTML .DirPath "../../../../proc/self/environ" }}<br/>    &lt;/pre&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="6cf8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样称呼戈登堡:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="03e2" class="lu lv iq lq b gy lw lx l ly lz">$ curl '<a class="ae le" href="http://$URL_GOTENBERG/convert/markdown'" rel="noopener ugc nofollow" target="_blank">http://$URL_GOTENBERG/convert/markdown'</a> --form files=<a class="ae le" href="http://twitter.com/index" rel="noopener ugc nofollow" target="_blank">@index</a>.html -o result.pdf --header 'Content-Type: multipart/form-data'</span></pre><p id="41ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在result.pdf中，您会得到一个漂亮的pdf文件，其中包含一些有用的信息，如容器的passwd文件、IP地址、TCP连接和环境变量。这可能很有趣，但不是很关键(现在还不是！).</p><h1 id="5aa0" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">有趣的部分—代码执行</h1><p id="bdc3" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">好吧，我们有上传和下载漏洞，但我们需要更多..首先，让我们谈一点关于Gotenberg内部。它是一个Go lang http服务器，运行在Docker容器中，使用不同的现成组件将不同的格式转换为PDF。</p><p id="af04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于转换HTML，markdown和外部网址，它使用谷歌浏览器运行在无头模式。这个引擎是由Gotenberg进程使用<a class="ae le" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank"> Chrome DevTools协议</a>控制的(与在一些自动化测试框架中所做的一样)，该进程将无头Chrome浏览器重定向到适当的文件/URL，并最终将呈现的HTML打印为PDF。</p><p id="1f71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">重要提示:</strong>由于有可能将内置Chrome重定向到任何URL，攻击者从一开始就可以轻微访问容器的本地主机(以及DevTools侦听的端口9222)以及内部网络中的其他机器(docker容器或客户端系统的内部IP)。这证明了Gotenberg是一个内部接口，应该隐藏在系统的内部，如果它的API应该向外界公开，它应该被剥离成非常有限的功能。</p><p id="1822" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于office文档，它使用的是<a class="ae le" href="https://github.com/unoconv/unoconv" rel="noopener ugc nofollow" target="_blank"> unoconv Linux包</a>，它在下面运行libreoffice，呈现office文档，并像以前一样将其打印为PDF。</p><h2 id="708b" class="lu lv iq bd mb nc nd dn mf ne nf dp mj kj ng nh mn kn ni nj mr kr nk nl mv nm bi translated">尝试# 1—不成功</h2><p id="49f5" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">有了文件上传漏洞，我首先想到的是容器中是否有一个文件可以被覆盖，从而导致代码执行。</p><p id="85cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">跳到容器中并在文件系统中查找可写文件后:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="4c90" class="lu lv iq lq b gy lw lx l ly lz">$ docker exec -it gotenberg find / -writable<br/>/dev/core<br/>/dev/stderr<br/>/dev/stdout<br/>/dev/stdin<br/>..<br/>/gotenberg/.bash_history<br/>/gotenberg/tmp<br/>/<strong class="lq ir">tini</strong></span></pre><p id="b84e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在根目录下看到一个可写的文件，名为/tini，仔细查看后发现它是一个可执行文件，它是Docker容器在开始时主要调用的文件(所谓的<em class="ld"> entrypoint — </em>见<a class="ae le" href="https://github.com/thecodingmachine/gotenberg/blob/4e7f5401eca18970df840429563a569f5298c627/build/package/Dockerfile#L43-L47" rel="noopener ugc nofollow" target="_blank">来源</a>)。<a class="ae le" href="https://github.com/krallin/tini/" rel="noopener ugc nofollow" target="_blank"> tini </a>是一个微小的程序，可以在Docker容器中使用，通过处理信号、僵尸进程等来正确处理实际运行的进程。由于发生在gotenberg中，该文件可由用户“Gotenberg”写入。对于最终的代码执行人员来说，这似乎是一个可行的方法。</p><p id="2a15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">想法</strong>:我们可以利用文件上传漏洞覆盖<em class="ld"> /tini </em>可执行文件，下次启动容器时，它将运行我们的可执行文件。</p><p id="1404" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即便如此，还有一个相当重要的问题:Gotenberg作者建议以“临时运行”方式运行容器(注意上面的<em class="ld"> docker run </em>命令中的<em class="ld"> - rm </em>开关)。如果容器以这种方式启动，这意味着它将永远不会停止和重新启动，所以不幸的是，这种攻击的应用非常有限。</p><p id="d2ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在尝试了上述想法后，Gotenberg在上传文件时将其权限更改为644，这使得<em class="ld"> /tini </em>可执行文件缺少+x权限，因此即使容器停止并重新启动，它也不会运行，因为缺少执行权限。</p><p id="e008" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不错的尝试，但运气不好..</p><h2 id="9ec6" class="lu lv iq bd mb nc nd dn mf ne nf dp mj kj ng nh mn kn ni nj mr kr nk nl mv nm bi translated">尝试2——不成功</h2><p id="a95c" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">在列出可写文件时，我发现有两个用户配置文件也可以被覆盖，而且看起来非常有趣，它们是:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="6a8b" class="lu lv iq lq b gy lw lx l ly lz">/gotenberg/.local/share/applications<br/>/gotenberg/.local/share/applications/mimeapps.list</span></pre><p id="b2ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还记得戈滕伯格运行谷歌Chrome吗？如果您正在使用Linux，您可能知道上面的applications文件夹和mimeapps.list文件负责处理不同内容的默认应用程序。</p><p id="b3b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">想法</strong>:如果我们在applications文件夹中创建一个应用程序x.desktop文件来运行我们的有效负载，例如:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="351e" class="lu lv iq lq b gy lw lx l ly lz">[Desktop Entry]<br/>TryExec=bash<br/>Exec=bash -c "echo asd&gt;/tmp/hacked"</span></pre><p id="ea75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们使用mimeapps.list将该应用程序挂钩，以处理自定义URL方案:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="18c5" class="lu lv iq lq b gy lw lx l ly lz">..<br/>x-scheme-handler/mailto=x.desktop<br/>..</span></pre><p id="c743" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">mimeapps.list中的上面一行用<em class="ld"> mailto: </em> URL方案注册了我们的x.desktop应用程序，因此每次浏览器调用<em class="ld"> mailto: </em>链接时，它都会启动我们的x.desktop应用程序。</p><p id="cf7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的非headless chrome上尝试这个想法效果很好，进入mailto:test链接实际上会执行适当的x.desktop，它甚至可以通过远程DevTools协议调试工作。</p><p id="c230" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，这种攻击在Gotenberg运行时不起作用。看起来这可能是因为chrome在无头模式下初始化的方式，自定义URI方案(使用Linux xdg)没有被正确调用。事实上，在我的本地机器上用headless参数访问mailto: scheme也不能调用正确的应用程序。</p><p id="285a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">又一次，没有运气..</p><h2 id="4b4e" class="lu lv iq bd mb nc nd dn mf ne nf dp mj kj ng nh mn kn ni nj mr kr nk nl mv nm bi translated">尝试3——成功！</h2><p id="4287" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">离放弃只有一步之遥，我决定再试最后一次。我开始关注拼图的最后一块——即unoconv和LibreOffice。首先，我查看了unoconv被调用的方式，以及是否有任何注入代码的方式等等。不幸的是，我在那里找不到任何有用的东西。</p><p id="8ca8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我想到了以前的好宏。也许我们可以在文件中注入一个宏，然后神奇地让它运行起来。不幸的是，所有的快速尝试都失败了(不出所料)，因为LibreOffice不允许运行宏，除非它们是从一个可信的位置运行的，而这个位置当然不是。</p><p id="76cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是等等..LibreOffice将可信位置保存在哪里？它在用户主目录的某个地方吗？我快速检查了一下我的本地机器，确实可信的宏路径被添加到了<em class="ld"> ~/中。config/libre office/4/user/registry modifications . xcu</em>文件作为类似于以下内容的行:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="4766" class="lu lv iq lq b gy lw lx l ly lz">&lt;item oor:path="/org.openoffice.Office.Common/Security/Scripting"&gt;&lt;prop oor:name="SecureURL" oor:op="fuse"&gt;&lt;value&gt;&lt;it&gt;<strong class="lq ir">PATH</strong>&lt;/it&gt;&lt;/value&gt;&lt;/prop&gt;&lt;/item&gt;</span></pre><p id="aa3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，在戈登堡的家里我没有看到。配置目录..但后来我提醒自己，在查看Gotenberg调用unoconv的参数时，我看到了一些关于用户目录的东西。</p><p id="749f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">又看了一遍之后，我意识到Gotenberg使用一个新的临时用户目录(在<em class="ld"> /tmp/ </em>路径中)运行每个转换；用<em class="ld"> -用户目录</em>参数)。真有趣..</p><p id="2a23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更重要的是，在运行Gotenberg一段时间并尝试不同的office转换后，我意识到这些临时文件夹的名字都很短，并且在请求后它们<strong class="ka ir">不会被删除</strong> <strong class="ka ir">！</strong></p><p id="2870" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看临时文件夹名称，所有名称都在标准TCP临时端口范围(~30000到~65000)之间，这似乎很容易预测。</p><p id="7b6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，查看代码，我们看到Gotenberg调用freeport golang包，这是进一步调用net包，它创建一个新的套接字并使用<a class="ae le" href="https://man7.org/linux/man-pages/man2/bind.2.html" rel="noopener ugc nofollow" target="_blank"> bind </a> syscall绑定它，而没有指定端口号——根据<a class="ae le" href="https://man7.org/linux/man-pages/man7/ip.7.html" rel="noopener ugc nofollow" target="_blank"> Linux文档</a>的说法，这导致Linux内核从在<em class="ld">/proc/sys/net/IP v4/IP _ local _ port _ range</em>中定义的短暂端口范围中选择一个随机端口。这是内核在创建新套接字时随机选择的临时端口。分析<a class="ae le" href="https://github.com/torvalds/linux/blob/master/net/ipv4/inet_connection_sock.c#L182" rel="noopener ugc nofollow" target="_blank">内核代码</a>我们可以看到函数<em class="ld"> inet_csk_find_open_port </em>负责从短暂范围中选择一个端口。默认的Linux内核范围是32768 — 60999，syscall绑定只接受奇数。因此，我们只有大约14115个可能的端口号。</p><p id="592c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我们知道文件夹的名字是可以预测的，最重要的部分不会在最后被删除。</p><p id="fe81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">想法</strong>:想法是在不运行宏的情况下首先创建一个配置文件(我们不知道配置文件编号是多少，所以我们必须“泛洪”并检查，直到我们找到一个具有我们想要的编号的配置文件..这可能需要一些时间)。然后上传一个新的LibreOffice配置文件，该文件以某种方式运行宏，同时加载一个带有该配置文件的文件。最后，请求再次“淹没”服务器，直到它再次重用同一个端口号，导致准备好的概要文件被重用。</p><p id="e5d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发现我们可以很容易地设置全局宏，在LibreOffice打开文档后运行，而不是使用可信路径。这是一个更好的方法，因为它不依赖于上传的文件。例如，我们可以让普通用户为我们“淹没”服务器。</p><p id="c572" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">的确这个想法<strong class="ka ir">奏效了</strong>！该漏洞执行相当长的时间之前，但它相当稳定。</p><h1 id="ae98" class="ma lv iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">下一步是什么？</h1><p id="7134" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">最后，有了code exec，我们可以开始将攻击转移到客户的内部基础设施，这使我们能够连接到内部重要服务，如orchestrators和其他关键管理服务(如配置服务器)以及数据库引擎和其他微服务。</p><p id="f6a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在内部，客户端<strong class="ka ir">在服务之间没有防火墙</strong>,此外，监控<strong class="ka ir">在大约两周的时间里没有注意到我们的反向抄表会话</strong>,直到我们关闭了它！</p><p id="fb7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使我们得出一个结论:</p><ol class=""><li id="6933" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated">不要向外界暴露太多的端点。</li><li id="9689" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated">根据需求分离服务(例如使用防火墙)。</li><li id="7dfd" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated">仅允许批准的入站和出站连接到您的基础架构。</li><li id="2b5b" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated">监控流量中一些不寻常的长期连接。</li></ol></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="e993" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">跑分视频</strong>:</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="425a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">原漏洞报告及披露</strong>:<br/>T5】https://sploit.tech/2020/12/29/Gotenberg.html</p><p id="a1ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">漏洞利用代码</strong>:<br/><a class="ae le" href="https://github.com/br0xpl/gotenberg_hack" rel="noopener ugc nofollow" target="_blank">https://github.com/br0xpl/gotenberg_hack</a></p></div></div>    
</body>
</html>