<html>
<head>
<title>RoCET — Remote Code Execution Tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RoCET —远程代码执行工具</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/rocet-remote-code-execution-tool-11efa54654d5?source=collection_archive---------1-----------------------#2018-04-19">https://infosecwriteups.com/rocet-remote-code-execution-tool-11efa54654d5?source=collection_archive---------1-----------------------#2018-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6035" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这整个项目始于vulnhub.com的ctf。最初，我是为红队做的，他们决定每周我们都需要一个新的vulnhub完成。到目前为止没什么大不了的，已经有两个了。不过这一次不同。我阅读了几个演练，并收集了有关本地文件包含漏洞如何工作的信息。我记得几个月前，我偶然看到一篇关于某人的文章，他写了一个shell，能够与网站上的文件列表脚本进行交互。这给了我创建一个shell的想法，它将与文件包含接口，有效地提供一个完整的shell，脱离了您可以读取某个文件并运行将打印到该文件的命令的基础。</p><p id="5998" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在上面开发LFInT的虚拟机叫做evilscience，可以在这里下载<a class="ae kl" href="https://www.vulnhub.com/entry/the-ether-evilscience-v101,212/" rel="noopener ugc nofollow" target="_blank">。你打开虚拟机，发现它是无头的。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/0bb01eace2ae89085d80492c94bb74f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*ZP8L1-3Wk82Dv7KKVkNPvw.jpeg"/></div></figure><p id="2e1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您对此运行简单的nmap扫描，并发现一些有趣的开放端口:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/9a143795046301c65922f56cea415653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*GqABexaZY5lzjTaOO3lfGw.jpeg"/></div></figure><p id="b066" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，有一些不错的端口开放，但是在探索这个之前，因为它是在端口80上的<br/>主机，让我们立即对它进行一次漏洞扫描。<br/>事实证明，存在本地文件包含的可能性，正如该扫描结果所暗示的<br/>:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kv"><img src="../Images/ccc5f1ecb7d85a61e4a0f2c98cd5bc41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*482q6pG9yYqgUau2nZg-qQ.jpeg"/></div></div></figure><p id="5c7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一件事，知道它可能会让我看到文件，是试图找到其他文件包括在内。在浏览常用文件时，一些东西吸引了我的注意。/var/log/auth.log是一个常用的包含文件，我们的目标是运行ssh。所以试着把这个文件卷起来:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi la"><img src="../Images/4f404622417ffd95db558e7aed00cb42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yK8VNHiN2Tqlnh5br0u6IQ.jpeg"/></div></div></figure><p id="e91e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，酷。现在我可以知道ssh上的认证日志放在哪里了。但是事情是这样的:多亏了curl，它变成了HTML。根据以往的经验，我知道用一些简单的一行php，你可以插入一行，例如<br/> <br/> <code class="fe lb lc ld le b">&lt;?php echo system($_GET['cmd']); ?&gt;</code> <br/> <br/>并在服务器上执行命令。那么，为什么我不试着用这个作为我的ssh用户名，并卷曲页面给它一个命令呢？</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lf"><img src="../Images/f9aca356558487dbf495a98affff767d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-42YBuYvKNRGRk7QgoVxA.jpeg"/></div></div></figure><p id="320d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在卷曲:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lg"><img src="../Images/b6c8e43e6f5c47ba6c4163855c61a586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kX8HfdFQFsZkxUS2uxqjLQ.jpeg"/></div></div></figure><p id="06c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们成功了！这是我在CTF挑战赛中停下来的地方。原因是我立即开始考虑写一个脚本，让我可以对这个远程代码执行漏洞做很多事情。在挑战的这一点之后，您通常会运行某种逆向shell，并让标志完成。老实说，在这一点上，我还没有完成挑战。但是，从中产生了这个剧本。</p><p id="218a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我从python的简单执行开始，特别是使用os.system。在你笑着说我不知道如何使用os.system编写python之前，只需知道这整个旅程让我找到了更好的方法。这里有一个我最初是如何通过python来卷曲网站的例子:<br/> <br/> <code class="fe lb lc ld le b">os.system("curl '192.168.150.128/index.php?file=/var/log/auth.log&amp;" + cmd)</code></p><p id="44ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我使用一些非常糟糕的文件读/写操作来解析文件。使用sed和awk，它写入文件，使用sed清理特定于该虚拟机的内容，然后使用awk清理重复的行。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/36843890346d9fd04566402cf202fd89.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*JORQVOfVZ9GwEAzFQCIkxA.jpeg"/></div></figure><p id="28bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着时间的推移，我决定让它更像一个脚本，并实现库。第一个方便使用的库是pycurl库。从逻辑上讲，这是在这种情况下使用的最佳库，因为它执行与curl相同的操作。当然，导入StringIO来读写curl的字节。这使得我的卷曲操作做得非常干净。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi li"><img src="../Images/ada17242fec49a6333b8de8b65e25472.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*P2jTReLTJC6Yf36ZDIKaWg.jpeg"/></div></figure><p id="b1f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的步骤相当简单，创建一些方法来获得一个工作目录，在main方法中包括目录遍历，并执行。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/eb99f3b323a99410ab8de36e29d22879.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*WS_HQ9DclxgY7KWjN8gHiw.jpeg"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/69c04e3dccba44569cb93ef3b37bc16d.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*Nx0kv7IgkqV_oXSMY6mJtg.jpeg"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/6c42cb74a29cb12354a54202befe941a.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*Nulh2C60kYHUgZB8PNU8CQ.jpeg"/></div></figure><p id="8848" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">剩下的唯一一步是解析给我们的信息，并把它打印到终端上作为一个基本的shell。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/44250b42ec6749798802c1ef95e8fb68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*nfwbfwzAkZW_aGOtpCJ10Q.jpeg"/></div></figure><p id="86ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我已经将该项目重命名为RoCET，代表远程命令执行工具。如果您能够执行命令并将其打印到html，该工具可以通过web远程执行任何代码。这个shell还在开发中，但是在我的github上。</p></div></div>    
</body>
</html>