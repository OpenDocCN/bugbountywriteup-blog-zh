<html>
<head>
<title>Understand the Powerful ROP Attack from Zero!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始了解强大的ROP攻击！</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/understand-the-powerful-rop-attack-from-zero-f68631af0c6d?source=collection_archive---------1-----------------------#2021-02-01">https://infosecwriteups.com/understand-the-powerful-rop-attack-from-zero-f68631af0c6d?source=collection_archive---------1-----------------------#2021-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4268f9c414d53a913756383e7dd7d7e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRKyz6gatgNecg6gzmJeMw.png"/></div></div></figure><h1 id="25b2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1.内容</h1><ul class=""><li id="95f3" class="kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/en/2021/01/29/understand-the-powerful-rop-attack-from-zero/#what-is-rop" rel="noopener ugc nofollow" target="_blank">什么是ROP？</a></li><li id="9c7a" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/en/2021/01/29/understand-the-powerful-rop-attack-from-zero/#implement" rel="noopener ugc nofollow" target="_blank">实施真正的ROP攻击！</a></li><li id="0dde" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/en/2021/01/29/understand-the-powerful-rop-attack-from-zero/#environment" rel="noopener ugc nofollow" target="_blank">环境</a></li><li id="0332" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/en/2021/01/29/understand-the-powerful-rop-attack-from-zero/#steps" rel="noopener ugc nofollow" target="_blank">生成外壳的步骤</a></li><li id="4d76" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://pwnbykenny.com/en/2021/01/29/understand-the-powerful-rop-attack-from-zero/#summary" rel="noopener ugc nofollow" target="_blank">总结</a></li></ul><h1 id="a11d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.ROP是什么？</h1><p id="955f" class="pw-post-body-paragraph lu lv iq ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">小工具是以跳转指令结尾的汇编代码序列，例如，“pop raxret。跳转指令包括“ret”、“jmp”、“call”等。如果使用每个小工具的最后一个跳转指令来逐个执行多个小工具，那就是面向返回的编程(ROP):gadget 1-(jump)&gt; gadget 2-(jump)&gt; gadget 3-(jump)&gt;…小工具广泛存在于易受攻击的二进制可执行文件中。您需要扫描二进制可执行文件，找到它的小工具，利用漏洞执行一些有用的小工具，并最终完成您的攻击。</p><h1 id="3e7b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.实现真正的ROP攻击！</h1><h1 id="d3ac" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.1环境</h1><p id="f91d" class="pw-post-body-paragraph lu lv iq ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">从<a class="ae lo" href="https://drive.google.com/drive/folders/11yJKHWwEG2pJ0A2ofU_IFwA_ILwGTd7f?usp=sharing" rel="noopener ugc nofollow" target="_blank">下载必要的文件。bug是易受攻击的二进制可执行文件。exploit_gen.c生成一个名为“exploit”的二进制数据文件。数据文件是bug的输入。exploit_gen.c可能无法利用您机器上的漏洞。遵循下一节中的步骤。做你的实验，修改exploit_gen.c。</a></p><p id="a343" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld ml mb mc lf mm me mf lh mn mh mi lj ij bi translated">以下是bug的源代码:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="22b9" class="mx jz iq mt b gy my mz l na nb">include &lt;stdio.h&gt;<br/>int fun(FILE* f) {<br/>	char buf[2];<br/>	char i = 0;<br/>	char c;<br/>	while (1) {<br/>		c = fgetc(f);<br/>		if (c != EOF) buf[i] = c;<br/>		else break;<br/>		i++;<br/>	}<br/>	return 0;<br/>}<br/>int main(int argc, char* argv[]) {<br/>	FILE* f =  fopen("exploit", "rb");<br/>	printf("Address of printf: %p\n", printf);<br/>	printf("Address of fun: %p\n", fun);<br/>	fun(f);<br/>	fclose(f);<br/>	return 0;<br/>}</span></pre><p id="cce7" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld ml mb mc lf mm me mf lh mn mh mi lj ij bi translated">在fun函数中，我们将文件f中的任何内容写入缓冲区buf，直到文件结束。这绝对是堆栈溢出bug。</p><p id="b517" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld ml mb mc lf mm me mf lh mn mh mi lj ij bi translated">下面是我们如何利用bug:首先，我们在bug中搜索小工具。其次，我们在它使用的libc文件中搜索<a class="ae lo" href="https://pwnbykenny.com/en/2020/12/31/one-gadget-easy-powerful-tool-example/" rel="noopener ugc nofollow" target="_blank"> one gadgets </a>。第三，我们用bug来覆盖fun的回邮地址。程序将被重定向以执行小工具。小工具将准备内存并满足一个小工具的约束。最后，最后一个小工具将指导程序执行一个小工具。我们会有一个壳。上面的利用过程可以用这个工作流来概括:bug -(overwrite) &gt;返回地址-(跳转)&gt;小工具-(跳转)&gt;一个小工具。</p><h1 id="af61" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.2生成壳的步骤</h1><ul class=""><li id="e798" class="kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ky ir">通过运行“ROPgadget二进制bug”找到bug </strong>内的小工具。ROPgadget是一个在二进制可执行文件中发现小工具的工具。从互联网安装。下图显示了部分输出。每一行都是一个小工具。它们都以跳转指令结束。</li></ul><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/139095b17d5c4a781446d13773916a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/0*6_B5JlaVmN6B37D3"/></div></figure><ul class=""><li id="6358" class="kw kx iq ky b kz mj lb mk ld nd lf ne lh nf lj lk ll lm ln bi translated"><strong class="ky ir">找到bug程序使用的libc文件名。</strong>使用以下命令，你会发现它使用的libc文件名:1)“gdb bug”。2)“r”。这个命令应该在gdb中运行。3)“ctrl+c”。同时按下键盘上的两个键。4)“vmmap”。要使用这个命令，您需要安装一个插件，比如gef to gdb。您将从该命令的输出中找到libc名称:</li></ul><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/e2966777d5a2ad2812d8692655c74d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/0*nWc4E5pgnp2JtgIH"/></div></figure><ul class=""><li id="28e0" class="kw kx iq ky b kz mj lb mk ld nd lf ne lh nf lj lk ll lm ln bi translated"><strong class="ky ir">在libc文件中找到一个小工具。</strong>打开你的终端，运行“one _ gadget/usr/lib/x86 _ 64-Linux-GNU/libc-2.31 . so”。记住用您的文件名替换libc文件名。您将得到如下所示的输出。这是一个小玩意。其偏移量为0xcbcda。</li></ul><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/525713a5f502594bb94f744218783eca.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/0*Qt16O34Fvzucboef"/></div></figure><ul class=""><li id="3644" class="kw kx iq ky b kz mj lb mk ld nd lf ne lh nf lj lk ll lm ln bi translated"><strong class="ky ir">选择满足一个小工具约束的小工具。</strong>很明显，上面一个小工具要求r12和r13为0。所以你需要在调用一个小工具之前选择一些小工具来设置它们的值。看看我们现在都有什么小玩意。你会发现第一个小工具设置r12和r13很完美:pop rbppop r12pop r13pop r14pop r15ret。它在bug程序中的偏移量是0x1273。</li><li id="c2dc" class="kw kx iq ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><strong class="ky ir">检查堆栈。在gdb内部运行bug。在fun函数处放一个断点。观察堆栈:</strong></li></ul><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/dca741cdc818ee16d00de7d784cb7809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SIXCMQFOSwgLxPKl"/></div></div></figure><p id="87bd" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld ml mb mc lf mm me mf lh mn mh mi lj ij bi translated">fun函数有3个变量。他们的地址如下。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/a1c9e1044ff2e9b4fb18dd4bfc84acbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/0*BTwWVwr6YB9SE_88"/></div></figure><p id="f056" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld ml mb mc lf mm me mf lh mn mh mi lj ij bi translated">从上面两张图中，你可以清楚地看出堆栈的结构:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="be65" class="mx jz iq mt b gy my mz l na nb">0x7fffffffdf5c   buf[0]<br/>0x7fffffffdf5e   c<br/>0x7fffffffdf5f   i<br/>0x7fffffffdf60   rbp<br/>0x7fffffffdf68   return address</span></pre><ul class=""><li id="8023" class="kw kx iq ky b kz mj lb mk ld nd lf ne lh nf lj lk ll lm ln bi translated"><strong class="ky ir">准备堆栈。</strong>我们要覆盖返回地址，并跳转执行所选的小工具，最终跳转执行所选的一个小工具。这就是我们覆盖堆栈的方式:</li></ul><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/66befd7c02df1120d089c73196963c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/0*bIr9AiS3C4VAttwX"/></div></figure><p id="dcce" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld ml mb mc lf mm me mf lh mn mh mi lj ij bi translated">漏洞阵列中的数据结构与我们观察到的堆栈结构相同。我们会用buf覆盖c，I，rbp，返回地址等等。在数组的第一行，我们使用三个字符来覆盖buf和c。这些字符是什么并不重要，因为我们不会在利用中使用它们。它们只是占位符。接下来我们用0x03覆盖I，这个很关键。我们使用I来访问buf，并逐字节覆盖堆栈。所以我们不想改变I，当我们用buf覆盖I时，I正好是0x03。在第二行，数据将覆盖地址0x7fffffffdf60的8个字节。我们不关心数据是什么，因为我们在开发中不使用它。</p><p id="aaf5" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld ml mb mc lf mm me mf lh mn mh mi lj ij bi translated">第三行覆盖了返回地址，这样程序将跳转到执行我们选择的小工具。我们需要计算这个小装置的地址。它等于“bug的代码段基址+小工具偏移量”。基址等于“乐趣的地址—乐趣的偏移量”。让我们看看我们是如何得到这些值的。如果你看bug的源代码，你会看到fun的地址是程序给的。对我来说是0x555555555155。我们已经获得了所选小工具的偏移量。是0x1273。fun是bug中的一个函数符号。它的偏移量记录在bug的符号表中。运行“objdump -t bug | grep fun”你会在输出中找到fun的偏移量:0x1155。所以小工具的地址= fun的地址— fun的偏移量+小工具的偏移量= 0x 55555555155–0x 1155+0x 1273 = 0x 55555555273。这正是我们的第三条线。</p><p id="4199" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld ml mb mc lf mm me mf lh mn mh mi lj ij bi translated">函数fun中的ret指令会返回0x555555555273，执行我们的小工具:pop rbppop r12pop r13pop r14pop r15ret。这个小工具从堆栈中获取数据。所以我们需要相应地准备堆栈。从漏洞数组的第四行开始，每一行都为小工具中的一条指令提供一个值。您会看到这些值将r12和r13设置为0。它满足了我们一个小玩意的要求。最后，我们使用小工具中的最后一个ret指令来跳转执行我们的小工具。所以我们需要给ret指令一个小工具的地址。</p><p id="d09e" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld ml mb mc lf mm me mf lh mn mh mi lj ij bi translated">一个小工具的地址= libc基址+一个小工具的偏移量= printf的地址-printf的偏移量+一个小工具的偏移量。printf的地址是bug程序给的:0x7ffff7e3bcb0。one gadget的偏移量是在上面的步骤中获得的:0xcbcda。printf是libc符号表中存在的函数符号。用这个命令观察libc的符号表:objdump-T/usr/lib/x86 _ 64-Linux-GNU/libc-2.31 . so | grep " printf "，你会发现printf的偏移量是0x56cb0。记住用您的路径替换libc的路径。所以one gadget的地址= 0x 7 ffff 7 E3 BCB 0–0x 56 CB 0+0x CBC da = 0x 7 ffff 7 EB 0 CDA。这个值正好是漏洞数组的最后一行。小工具中的最后一个ret指令将使用这个值并返回来执行我们的小工具。</p><ul class=""><li id="e178" class="kw kx iq ky b kz mj lb mk ld nd lf ne lh nf lj lk ll lm ln bi translated"><strong class="ky ir">观察剥削。</strong>在exploit_gen.c中正确设置exploit数组后，编译运行。将生成一个名为“exploit”的数据文件。在gdb中运行bug。在第14行放一个断点(fun的返回指令)。运行程序。现在堆栈变成这样:</li></ul><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="235a" class="mx jz iq mt b gy my mz l na nb">0x7fffffffdf5c    0x41    buf[0]<br/>0x7fffffffdf5e    0xff    c<br/>0x7fffffffdf5f    0x40    i<br/>0x7fffffffdf60    0x00    rbp<br/>0x7fffffffdf68    0x555555555273    ret -&gt; gadget<br/>0x7fffffffdf70    0x00    pop rbp<br/>0x7fffffffdf78    0x00    pop r12<br/>0x7fffffffdf80    0x00    pop r13<br/>0x7fffffffdf88    0x00    pop r14<br/>0x7fffffffdf90    0x00    pop r15<br/>0x7fffffffdf98    0x7ffff7eb0cda    ret -&gt; one gadget</span></pre><p id="38ce" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld ml mb mc lf mm me mf lh mn mh mi lj ij bi translated">第一列是地址。第二个是地址的值。第三个是使用该值的变量或指令。现在，如果我们使用命令“n”一行一行地运行程序，我们将看到指令和值是如何引导我们到shell的。fun的ret指令执行后，程序转到地址0x555555555273执行:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/76632c397c6c35f7d58c89ba6da78894.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/0*muwTPfX10sLMEJLX"/></div></figure><p id="9fb4" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld ml mb mc lf mm me mf lh mn mh mi lj ij bi translated">这是我们的小玩意！这个小工具从堆栈中获取数据，并将它们放入寄存器中。如果我们执行到最后一条ret指令，我们会看到从rbp到r15都变成0。在我们执行ret指令之后，程序开始执行我们的小工具:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/9bfcecd2c28ec4f95d997de7231ac523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/0*8M7YHvXr5ppu5jEO"/></div></figure><p id="134b" class="pw-post-body-paragraph lu lv iq ky b kz mj lw lx lb mk ly lz ld ml mb mc lf mm me mf lh mn mh mi lj ij bi translated">r12和r13是execve的自变量。现在它们被正确地设置为0。运行4指令，我们将得到一个shell:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/138239f96b00367a3e47b0fda07afca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/0*eBUn6LgoVLSGjrBk"/></div></figure><ul class=""><li id="8b20" class="kw kx iq ky b kz mj lb mk ld nd lf ne lh nf lj lk ll lm ln bi translated"><strong class="ky ir">生一个没有gdb的壳。</strong>我们的漏洞无法绕过ASLR。所以你需要关闭ASLR。首先，使用“su”进入root模式。第二，用“echo 0&gt;/proc/sys/kernel/randomize _ va _ space”关闭ASLR。现在，如果您执行bug，您将看到一个shell被生成:</li></ul><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/12a938819960fa3fc0ec10008619508e.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/0*WEQXh0fMH1V4fRs-"/></div></figure><h1 id="ebeb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4.摘要</h1><p id="c779" class="pw-post-body-paragraph lu lv iq ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">这篇文章使用了一个具体的例子来展示如何实现ROP攻击。实现一个ROP攻击，就是把分散在目标程序代码空间里的小工具一个一个执行。从一个小工具到另一个小工具的执行由每个小工具的最后一个跳转指令连接。跳转指令包括jmp、ret、call等。亲爱的读者，如果你觉得这篇文章有帮助，请帮我分享到你的社交媒体上。非常感谢！</p></div></div>    
</body>
</html>