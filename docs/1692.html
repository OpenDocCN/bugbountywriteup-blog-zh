<html>
<head>
<title>My mindset while hunting on Yandex and my SSRF</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在Yandex和我的SSRF上打猎时的心态</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/how-i-hacked-yandex-with-ssrf-vulnerability-e19af20ed4d?source=collection_archive---------0-----------------------#2021-12-03">https://infosecwriteups.com/how-i-hacked-yandex-with-ssrf-vulnerability-e19af20ed4d?source=collection_archive---------0-----------------------#2021-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c1adc42f74449d3c45f97aaf1341baee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qfNf2ZVjY-B_oEWH.jpg"/></div></div></figure><p id="0f16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嘿猎人们！</p><p id="6369" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一篇关于我在另一个大程序中寻找一个有新漏洞的程序时的心态的文章。在我们开始之前，让我们看看我们将在这篇文章中讨论什么:</p><ul class=""><li id="bb2f" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">我在Yandex打猎时的心态</li><li id="ab54" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">动态思考</li><li id="d6a1" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">一些谷歌呆子</li><li id="f429" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">SSRF介绍</li><li id="6de0" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">代码审查</li><li id="f1dc" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">基于HTTP头的SSRF</li><li id="e63b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">HTTP交互</li></ul><blockquote class="lk ll lm"><p id="119e" class="jy jz ln ka b kb kc kd ke kf kg kh ki lo kk kl km lp ko kp kq lq ks kt ku kv ij bi translated">注意:我得到了Yandex团队的许可来写这篇文章，所以它是完全合法的:</p></blockquote><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/78c70f44c43396c08e9f26f82510f2e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*VvBK05y_nkQEVkxXUddqtw.png"/></div></figure><p id="190c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们开始…</p><p id="1fbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">渗透测试领域的固定思维让你思考得更少，因为你总是需要创新，例如每个目标都应该有自己的侦察、测试等方法。因为每个目标都有自己的功能、服务和工作流程。我的目标是Yandex，首先我开始收集相关信息，根据我的研究，我发现Yandex提供以下服务:</p><ul class=""><li id="6ea8" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">搜索引擎</li><li id="9322" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">云服务</li><li id="5a6b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">邮件服务</li><li id="8048" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">电子商务</li><li id="9ba9" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">广告</li><li id="b8f2" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">以及其他与互联网相关的产品和服务</li></ul><p id="c61d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这不是一个普通的目标，这是一个非常大的目标，现在在执行我的侦察后——我在以前的文章和我的<a class="ae lw" href="https://github.com/Cyber-Guy1/theCyberGuy_Recon_V1.0" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>中提到过它——所以我从GHDB开始，以便找到一些秘密，但因为这个目标提供的巨大服务，如果我键入一些像这样的呆子:</p><pre class="ls lt lu lv gt lx ly lz ma aw mb bi"><span id="072b" class="mc md iq ly b gy me mf l mg mh">site:*.yandex.* intext:"access_token"</span></pre><p id="2177" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先这个呆子做什么？这个傻瓜会给我Yandex的所有子域和Tob级域(TLD)的完整结果，以便使我的搜索范围更广，所以在键入这个傻瓜后，你会得到以下结果:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/833f84cddc30a99fde5c53181be7b920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tsMZk4vZUqWzBjenYKGcjQ.png"/></div></div></figure><p id="50c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一次，你会非常高兴，因为你认为你找到了一个访问令牌，但请记住，这只是一个文档，因为正如我所说，Yandex提供云服务。</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/3a32f35b675d9a485abd4396eeddb2ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*LKWcMmznvQ85W3xP.gif"/></div></figure><p id="286a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，如果你面对这样的事情，如果你有一个固定的想法，你应该搜索另一个秘密，但这是错误的，你应该制作一个呆子，以便从搜索结果中排除云子域，所以我制作了以下呆子:</p><pre class="ls lt lu lv gt lx ly lz ma aw mb bi"><span id="8908" class="mc md iq ly b gy me mf l mg mh">site:*.yandex.* intext:"access_token" -site:cloud.*</span></pre><p id="cbb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个呆子将排除云服务的任何子域，所以你不会在任何地方看到任何云服务子域:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/561475652e13faf663be4df001abcf22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kaZY9VTgyILFTUkjUbTlQ.png"/></div></div></figure><p id="3854" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以只从URL中排除<code class="fe ml mm mn ly b">cloud</code>短语，方法是使用我编写的dork:</p><pre class="ls lt lu lv gt lx ly lz ma aw mb bi"><span id="2163" class="mc md iq ly b gy me mf l mg mh">site:*.yandex.* intext:"access_token" -inurl:cloud</span></pre><p id="7e6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我认为这也很好，但是你可以看到另一个文档和文档！所以我现在能做什么？</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/3343d8509917a87932bbd60cdc435c95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5qBVxqvVKXxz4ULax17ULQ.png"/></div></div></figure><p id="7c62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我有一个想法，如果我开始搜索一个暴露的服务器索引，这样我就可以开始挖掘任何新的秘密，所以我制作了这个呆子:</p><pre class="ls lt lu lv gt lx ly lz ma aw mb bi"><span id="a9ca" class="mc md iq ly b gy me mf l mg mh">site:*.yandex.* intitle:"index of"</span></pre><p id="7f56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我得到的结果是:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/6e1b9b8f61a1592dd2cac69fc9c6452d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MXiB1McY04EorvZyrlPYhQ.png"/></div></div></figure><p id="06ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以在谈论这个之前，如果你熟悉像脸书这样的一些bug公司，那么你知道每个公司都有它的镜像来存储它的软件，他们使用的操作系统和其他文件可能不敏感，但有时我们可以收集一些关于这家公司内部基础设施的信息，所以在我的情况下，所有的结果都像一个镜像，所以我试图使用dork搜索更高级的内容:</p><pre class="ls lt lu lv gt lx ly lz ma aw mb bi"><span id="b3f8" class="mc md iq ly b gy me mf l mg mh">site:*.yandex.* intitle:"index of" intext:"passwd"</span></pre><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/51eddd184720fae522850ace14a629b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUTUMcAVrkpODwp9jrh9Xw.png"/></div></div></figure><p id="3350" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我解释一下，在输入结果之前分析结果是非常重要的，因为您可以了解他们托管了什么句柄的背景，所以在这里您可以看到所有的扩展是这样的:</p><ul class=""><li id="cf67" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><code class="fe ml mm mn ly b">tar.xz</code> =压缩文件</li><li id="fdf9" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><code class="fe ml mm mn ly b">deb</code> = Debian包</li><li id="2721" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><code class="fe ml mm mn ly b">apk</code> =安卓包</li></ul><p id="718b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，如果你看一下这些路径，它们会是这样的:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/763ab293a24e2c837e3b4bb9d3d007a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMHIxH9HHkSS5eLSZS6Irw.png"/></div></div></figure><p id="b041" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有这些路径都存储了发行版或Linux库的基本文件，但是让我们输入这些目标中的任何一个:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/de527af8ef98ed519cf088e2657e8e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DNNxRDZa7JDPbajMS57lvw.png"/></div></div></figure><p id="e525" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们试着下载任何文件，比如说文件:</p><pre class="ls lt lu lv gt lx ly lz ma aw mb bi"><span id="1108" class="mc md iq ly b gy me mf l mg mh"><a class="ae lw" href="https://mirror.yandex.ru/debian/pool/main/liba/libauthen-simple-passwd-perl/libauthen-simple-passwd-perl_0.6-4.1.dsc" rel="noopener ugc nofollow" target="_blank">libauthen-simple-passwd-perl_0.6-4.1.dsc</a></span></pre><p id="f3fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开始我们的分析:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/3d76116eaf2fdd76a9596047b3704c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lLy8iiTicfR8RrThMK59UQ.png"/></div></div></figure><p id="bd56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，这只是一个用于验证每个lib文件签名的文件，在我们的例子中，我们得到了lib: <code class="fe ml mm mn ly b">libauthen</code>，正如我们可以看到的，他们的web应用程序是:</p><pre class="ls lt lu lv gt lx ly lz ma aw mb bi"><span id="e834" class="mc md iq ly b gy me mf l mg mh"><a class="ae lw" href="https://metacpan.org/dist/Authen-Simple-Passwd" rel="noopener ugc nofollow" target="_blank">https://metacpan.org/dist/Authen-Simple-Passwd</a></span></pre><p id="f8d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看这个库之后，它只是一个用于验证passwd文件的库:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/a1824d28f5f4d60a0f89bcac327672fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aDZV6SVO4CioptGaLkmYSQ.png"/></div></div></figure><p id="dfdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为这对我们没什么好处，因为这些只是镜像，只是存储一些库和Linux发行版供公众使用，现在让我们跳回来，开始通过制作一个新的呆子来指定我们的结果:</p><pre class="ls lt lu lv gt lx ly lz ma aw mb bi"><span id="ca9d" class="mc md iq ly b gy me mf l mg mh">site:*.yandex.* intext:"id_rsa" -inurl:cloud|mirror AND intitle:"index of"</span></pre><p id="0025" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将搜索任何<code class="fe ml mm mn ly b">id_rsa</code>文件，并从URL中排除和<code class="fe ml mm mn ly b">cloud</code>或<code class="fe ml mm mn ly b">mirror</code>，最后搜索任何HTTP标题，得到单词<code class="fe ml mm mn ly b">index of</code>，有人会问为什么我在搜索<code class="fe ml mm mn ly b">id_rsa</code>时将云排除在外？原因很简单，因为这将出现在每个云域/服务中，因为当您要创建一个主机，例如使用SSH连接以控制服务器时，您应该有两个文件:</p><ul class=""><li id="ac36" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><code class="fe ml mm mn ly b">id_rsa.pub</code> = &gt;用于加密的公钥</li><li id="a042" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><code class="fe ml mm mn ly b">id_rsa</code> = &gt;用于解密的私钥</li></ul><p id="c9ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在大多数情况下，这在文档中会出现很多，注意:<code class="fe ml mm mn ly b">id_rsa</code>可能不存在，但是你可以根据你的目标使用的加密来搜索<code class="fe ml mm mn ly b">id_dsa</code>，所以在创建我的呆子之后，我得到了结果:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/ecf4bea24874fb631bf5d02f6e455570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DME8544qMjI9ULFzg1J2g.png"/></div></div></figure><p id="b595" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我决定现在停止欺骗，并在我知道这个目标的基础设施是什么之后，自动进行欺骗过程，这样我就知道我应该制作什么样的欺骗，并进入下一步，在开始下一步之前，即利用和发现，让我们来谈谈SSRF，即服务器端请求伪造，看看下面的代码:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/41eaac18a7711462c3b73ce25abdbe14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*05t20RbGva-ww9WFSAHtOQ.png"/></div></div></figure><p id="91ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，为了解释SSRF是如何发生的，我已经编写了这个简单的网页，现在让我们来看看每个代码块:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/3551e26660950ccbf04e3fe2fedc4270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cPVd1bJ3tOQugy8okjmWg.png"/></div></div></figure><p id="e73f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，这是一个简单的PHP代码，在后端系统中执行以下操作:</p><ul class=""><li id="cadf" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">它将GET参数<code class="fe ml mm mn ly b">Proxy-Host</code>存储在变量名<code class="fe ml mm mn ly b">host</code>中</li><li id="1942" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">然后它检查参数:<code class="fe ml mm mn ly b">Proxy-Host</code>是否存在于请求中，以及这个参数是否没有一个<code class="fe ml mm mn ly b">False</code>值。</li><li id="0695" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在这之后，它读取一个远程主机，并开始使用<code class="fe ml mm mn ly b">While</code>循环抓取它的内容，以便继续抓取它的内容，直到传输结束。</li><li id="c04e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">最后，fopen会议结束。</li></ul><p id="5a80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在第二部分:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/b011e2ad84313847a3634903dd5ece11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zx9HmxSC9y_bP_XgHKTGJg.png"/></div></div></figure><p id="28db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，因为我的全局变量在我的PHP代码中，现在这个HTML代码将从远程主机导入CSS表和JS脚本，请求主机的响应将显示在<code class="fe ml mm mn ly b">innerContent</code> div中。</p><p id="7a36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看服务器将如何执行此操作:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/6da513759b0fec3fadea189669874bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pd949mStQw17KbzoKqtMEw.png"/></div></div></figure><p id="94a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，当客户端访问类似于:<code class="fe ml mm mn ly b"><a class="ae lw" href="https://vulnerable" rel="noopener ugc nofollow" target="_blank">https://vulnerable</a>.com/File.php?Proxy-Host=https://example.com</code>的URL时，服务器将接受此请求，后端编码将使服务器向<code class="fe ml mm mn ly b">Proxy-Host</code>参数中指定的主机发送请求，因此现在易受攻击的服务器向另一个请求发送请求。</p><p id="38ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看攻击者如何攻击该功能:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/aebbf320ca570d3c720b0a986a11e335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Txnzkc7JkSDcUBGzlDANoQ.png"/></div></div></figure><p id="8ae6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，攻击者知道服务器用它自己进行请求操作，所以他想到请求内部资源，如:<code class="fe ml mm mn ly b">http://localhost</code>如果服务器易受攻击，它会用内部服务器内容给你一个响应。</p><blockquote class="lk ll lm"><p id="a219" class="jy jz ln ka b kb kc kd ke kf kg kh ki lo kk kl km lp ko kp kq lq ks kt ku kv ij bi translated">提示:有些时候当你输入一些常见的东西，比如:<a class="ae lw" href="http://localhost," rel="noopener ugc nofollow" target="_blank"> http://localhost，</a>服务器会阻止它，因为它在服务器黑名单中，所以你可以在搜索的时候寻找任何一个指向localhost或endpoint的主机。例如，在我的一次狩猎之旅中，我在本地设备中打开了apache2服务器，所以当我要访问远程目标URL时，例如:<a class="ae lw" href="http://target.com," rel="noopener ugc nofollow" target="_blank">http://target.com，</a>我看到我的本地主机正在被查看。这意味着这个主机是指本地主机，然后保存它，以便在这个目标或另一个目标中查找SSRF时使用。</p></blockquote><p id="1a3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在还有SSRF，因为注入了HTTP头，比如:<code class="fe ml mm mn ly b">X-Forwarded-Host</code>和<code class="fe ml mm mn ly b">X-Forwarded-Host</code>，所以在我的例子中，SSRF在HTTP头中，那么我怎么能找到它呢？有两种自动化方式来执行此操作:</p><ol class=""><li id="ee2b" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv nb lc ld le bi translated">使用带有良好的HTTP头列表的burp入侵者，并通过Burp Collaborator或服务器为该头赋予一个值，以获得检查SSRF的请求。</li><li id="5a44" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nb lc ld le bi translated">使用<code class="fe ml mm mn ly b">Nuclei</code>模板扫描仪来执行此操作，使用模板:<code class="fe ml mm mn ly b">~/nuclei-templates/extra_templates/header-blind-ssrf.yaml</code>，如您所见，模板显示这个SSRF是一个<code class="fe ml mm mn ly b">blind</code> SSRF，但这并不总是如此，因为在我的例子中，它是一个基本的SSRF，在使用此模板之前，让我们确定它是如何工作的:</li></ol><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/c1ef47448db41bd707a950ff88181e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*aGoEmnhwtR_fmjBG-_q8uQ.png"/></div></figure><p id="a2d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们试着分析一下:</p><ol class=""><li id="d4eb" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv nb lc ld le bi translated">有效载荷部分:</li></ol><ul class=""><li id="33d4" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><code class="fe ml mm mn ly b">header:</code>这里是HTTP头单词表，它被用于强制HTTP请求。</li></ul><p id="0d9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.原始部分:</p><ul class=""><li id="c05d" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><code class="fe ml mm mn ly b">/?&amp;header&amp;</code>它在GET请求中设置HTTP头，以便让用户知道现在使用的是什么HTTP头。</li><li id="6617" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><code class="fe ml mm mn ly b">&amp;header&amp;</code>它设置了请求中正在使用的报头</li><li id="2943" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><code class="fe ml mm mn ly b">{{interactsh-url}}</code>用于标识交互的URL</li></ul><p id="5992" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在使用nuclei完成自动化后，我能够使用以下请求在Yandex中找到SSRF:</p><pre class="ls lt lu lv gt lx ly lz ma aw mb bi"><span id="ef51" class="mc md iq ly b gy me mf l mg mh">GET / HTTP/1.1<br/>Host: example.vulnYandex.tld<br/>User-Agent: someDevice<br/>Accept: text/html<br/>Accept-Encoding: gzip, deflate<br/>Proxy-Host: burpcollaporator-url.net<br/>Connection: close</span></pre><p id="3be1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，漏洞在标题:<code class="fe ml mm mn ly b">Proxy-Host</code>中，我得到一个HTTP交互，如下所示:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/c67582b36cba296c02a145fd3254f68c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1sGaRw95wMOYTykKxYs17g.png"/></div></div></figure><p id="9bcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我想确保这种交互发生在Yandex服务器上，所以我使用命令做了一个<code class="fe ml mm mn ly b">Reverse DNS</code>:</p><pre class="ls lt lu lv gt lx ly lz ma aw mb bi"><span id="f4f1" class="mc md iq ly b gy me mf l mg mh">host -t PTR 1.1.1.1</span></pre><p id="880d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代替<code class="fe ml mm mn ly b">1.1.1.1</code>放置由合作者识别的IP，然后我设置结果:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/5de5282e5c9e4b3d2f1c6b2fbdf6946d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*BNgiSz71hJIL2Ml_3dHm_Q.png"/></div></figure><p id="6266" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我考虑过利用内部资源来扩大影响，但当我查看Yandex的政策时，我发现:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/bcdf331f757ac69582a68fc0cbef12b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WkK2cDBkXhk_VZ-zrtlxDw.png"/></div></div></figure><blockquote class="lk ll lm"><p id="8b51" class="jy jz ln ka b kb kc kd ke kf kg kh ki lo kk kl km lp ko kp kq lq ks kt ku kv ij bi translated">注意:我能够执行内部端口扫描，但由于Yandex政策，我应该在访问内部数据之前询问他们，所以我发送了报告，然后要求他们让我升级影响，但他们确认了SSRF，并将在内部这样做:</p></blockquote><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/2e8ee2dd57c603e1dca4a4261cc0d385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yl004f5W7g4zxLu-FvRVNQ.png"/></div></div></figure><p id="5aa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我报告了这个漏洞，并等待团队，等待他们是否希望我继续利用它，或者他们将在内部审查它，他们确实在内部继续。</p><p id="58ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/b76c254e7406a1726eba2dfd4d965c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KIdRkI9aBhPxsl81ml4EfA.png"/></div></div></figure></div></div>    
</body>
</html>