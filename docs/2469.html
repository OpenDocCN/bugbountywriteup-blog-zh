<html>
<head>
<title>Write-up: HTTP request smuggling, basic CL.TE vulnerability @ PortSwigger Academy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">上书:HTTP请求走私，基本CL。TE漏洞@ PortSwigger学院</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/write-up-http-request-smuggling-basic-cl-te-vulnerability-portswigger-academy-5acbbc040c74?source=collection_archive---------0-----------------------#2022-10-23">https://infosecwriteups.com/write-up-http-request-smuggling-basic-cl-te-vulnerability-portswigger-academy-5acbbc040c74?source=collection_archive---------0-----------------------#2022-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3d3ea4cecd30514943f7c1450b9e045f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VN1aPoF07s8bjCxm.png"/></div></div></figure><p id="edec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文为lab <em class="kw"> HTTP请求走私，基础CL。TE漏洞</em>是我为<a class="ae kx" href="https://portswigger.net/web-security" rel="noopener ugc nofollow" target="_blank"> PortSwigger的Web安全学院</a>所做的演练系列的一部分。</p><p id="1430" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">学习路径</strong>:高级主题→ HTTP请求走私</p><div class="ky kz gp gr la lb"><a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd ir gy z fp lg fr fs lh fu fw ip bi translated">实验室:HTTP请求走私，基本CL。TE漏洞|网络安全学院</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">练习利用现实目标的弱点。记录你从学徒到专家的进步。看哪里…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">portswigger.net</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp jw lb"/></div></div></a></div><h1 id="853d" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">实验室描述</h1><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/9e75cc3242cfa1ea80b39514c2363464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*retM9gbbr_V13HVp.png"/></div></div></figure><h1 id="7329" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">步伐</h1><p id="f160" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">通常，第一步是分析实验室应用程序的功能，这是一个博客应用程序。然而，在这种情况下，漏洞存在于服务器本身。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="1e3d" class="lq lr iq bd ls lt nf lv lw lx ng lz ma mb nh md me mf ni mh mi mj nj ml mm mn bi translated">该理论</h1><p id="0bf6" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">根据实验室的描述，该实验室包含多台服务器，它们在HTTP请求的解析方式上存在分歧。</p><p id="7f01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然前端服务器只允许<code class="fe nk nl nm nn b">GET</code>和<code class="fe nk nl nm nn b">POST</code>请求，后端服务器支持自定义的<code class="fe nk nl nm nn b">GPOST</code>动词。</p><p id="efe3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个尝试是找出两个服务器是否在头<code class="fe nk nl nm nn b">Content-Length</code>和<code class="fe nk nl nm nn b">Transfer-Encoding</code>的解释上达成一致。根据定义，如果两个接头都存在，则<code class="fe nk nl nm nn b">Transfer-Encoding</code>应优先。</p><p id="a5fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我可以创建一个请求，前端服务器将其解释为两个不同的请求，那么它将向后端服务器发送两个不同的请求。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="59bd" class="lq lr iq bd ls lt nf lv lw lx ng lz ma mb nh md me mf ni mh mi mj nj ml mm mn bi translated">尝试新事物</h1><p id="5adc" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我向打嗝中继器发送了一个请求。一个<code class="fe nk nl nm nn b">GET</code>请求不能包含主体数据，所以我将动词改为<code class="fe nk nl nm nn b">POST</code>。</p><p id="2069" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个测试是检查前端服务器是否使用<code class="fe nk nl nm nn b">Content-Length</code>，而后端服务器是否使用<code class="fe nk nl nm nn b">Transfer-Encoding</code>。</p><p id="f695" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我需要防止打嗝自动为我更新<code class="fe nk nl nm nn b">Content-Length</code>标题:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e2be325d5ba64507d578d23183eed94e.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*8fEQqiO6XWV9bdQp.png"/></div></figure><p id="d0c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我现在可以创建一个包含不一致信息的请求。如果服务器容易受到这种类型的攻击，那么前端服务器将基于<code class="fe nk nl nm nn b">Content-Length</code>的值在<code class="fe nk nl nm nn b">A</code>之后终止请求。</p><p id="2da0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后端服务器收到请求后，将等待更多的块，从而导致延迟。果然，我在发送请求后收到一个超时消息:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/9606dc6a1d1c1193ec1509a47ed58ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*x2QoqPA7gx06BoCo.png"/></div></div></figure><p id="6162" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个测试中，当后端服务器等待剩余的内容时，前端服务器将消息剪短。</p><p id="b7a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以通过使前端服务器发送比后端服务器期望的更多的内容来逆转这一点。额外的字符将被添加到下一个请求的前面。</p><p id="f6fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于下一个请求，我重新激活自动重新计算<code class="fe nk nl nm nn b">Content-Length</code>。我需要发送请求两次，第一次将产生正常的响应，而第二次可能会显示后端服务器最终接收到的内容:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/122b81fcac8fa377b8f6f3b479dc3a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g-KgwLF7IM-H5puu.png"/></div></div></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/dc81ae1982028e8d7a410f5ebf902953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P-rtfqsCw4cQ9Kwy.png"/></div></div></figure><p id="94e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个响应证明嵌入在第一个请求中的<code class="fe nk nl nm nn b">X</code>被添加到了第二个请求的前面，形成了一个无效的<code class="fe nk nl nm nn b">XPOST</code>请求:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/cec5464b0df712ca6ff35a5cc3e5bf45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/0*ZrPAmfzrTrT8BxLn.png"/></div></figure></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="70cc" class="lq lr iq bd ls lt nf lv lw lx ng lz ma mb nh md me mf ni mh mi mj nj ml mm mn bi translated">恶意负载</h1><p id="9b28" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">现在我知道我可以发送请求，在下一个请求的开头添加任意字符。对于这个实验，我需要发送一个<code class="fe nk nl nm nn b">GPOST</code>请求，所以我必须对我的测试请求做一个小小的修改。同样，我必须发送两次请求:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/7f7153023b3b9d8f967be2fb6fce5764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IrqR8tBCLHlyvbCj.png"/></div></div></figure><p id="6813" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，实验室更新为</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/4b9ecd26aaf0aceaa158600d62ac3907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-v1yP3TS8Yl8l31p.png"/></div></div></figure></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="b576" class="lq lr iq bd ls lt nf lv lw lx ng lz ma mb nh md me mf ni mh mi mj nj ml mm mn bi translated">另一途径</h1><p id="8822" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我也可以偷偷提出第二个完整的请求。在正文中，我用一个长度为零的块终止消息，然后用一个<code class="fe nk nl nm nn b">GPOST</code>请求跟进。发送两次后，我再次收到<code class="fe nk nl nm nn b">GPOST</code>方法错误:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/3c6b36bba5cd51cc29f9620d33751de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uY8HEsWVRPgHV22r.png"/></div></div></figure><p id="3311" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法的缺点是请求和响应不同步，每个后续请求都可能收到前一个请求的响应。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="3e70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">最初发表于</em><a class="ae kx" href="https://github.com/frank-leitner/portswigger-websecurity-academy/tree/main/21_HTTP_request_smuggling/HTTP_request_smuggling%2C_basic_CL.TE_vulnerability" rel="noopener ugc nofollow" target="_blank"><em class="kw">https://github.com</em></a><em class="kw">。</em></p><p id="f211" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nk nl nm nn b"><a class="ae kx" href="https://medium.com/@frank.leitner/membership" rel="noopener">New to Medium? Become a Medium member to access all stories and support me!</a></code></p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h2 id="bddd" class="nw lr iq bd ls nx ny dn lw nz oa dp ma kj ob oc me kn od oe mi kr of og mm oh bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae kx" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4个线程、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>