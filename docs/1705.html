<html>
<head>
<title>Heap Exploitation for Homo Sapiens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对智人的堆积剥削</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/heap-exploitation-for-homo-sapiens-f166cd6a59fe?source=collection_archive---------0-----------------------#2021-12-09">https://infosecwriteups.com/heap-exploitation-for-homo-sapiens-f166cd6a59fe?source=collection_archive---------0-----------------------#2021-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4be4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好黑客们，</p><p id="09f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，我们将开始一个关于ARM上堆利用的新系列。与堆栈利用相比，堆利用相当复杂且难以理解。资源不多，尤其是堆利用本身。大多数教程对我们这些<strong class="jp ir">人类</strong>生物来说是非常痛苦和难以理解的。我也是堆利用方面的新手，所以我认为写这些文章将有助于像我这样的人轻松理解这一点，而无需太多努力。</p><p id="cc94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想让这件事尽可能简单。我不会过多地深入堆内部。我只会触及表面。即使这些教程基于ARM，也可以在x86等其他平台上完成。</p><p id="048d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将介绍一些常见的堆错误，如堆溢出、免费后使用、双免费、风水等。所以先说一下学习这个的前提条件。</p><ul class=""><li id="665d" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">ARM x32指令的基础知识</li><li id="34a4" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">应该对堆栈溢出有所了解</li><li id="cd5f" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">c编程基础</li><li id="e9b9" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">耐心</li><li id="dea5" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">应熟悉广发银行和全球环境基金</li></ul><p id="94b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说得够多了，让我们开始吧。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><h1 id="ecc8" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">堆简介</h1><p id="8c48" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">注意，我们将重点关注在Linux上实现的<strong class="jp ir"> glibc堆分配器</strong>。这和windows不一样。</p><p id="b7d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那堆是什么？</p><p id="65dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地说，堆是一个动态分配的树状结构，可用于存储数据(变量、指针等)。在堆上分配的变量在运行时分配内存。我们可以在任何时候分配一个特定的块，也可以在任何时候释放它。这使得在任何给定时间跟踪堆的哪些部分被分配或空闲变得更加复杂。与操作系统管理的堆栈不同，堆应该由用户自己管理，因为它是动态的。使用完堆内存后，应该由用户自己删除(释放)。</p><p id="4ffd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在C语言中，我们将使用malloc()从堆中分配内存。它返回一个指向已分配内存的空指针，该内存应该根据需要存储的数据类型进行类型转换。让我们看一个例子。</p><pre class="kz la lb lc gt mj mk ml mm aw mn bi"><span id="b136" class="mo lh iq mk b gy mp mq l mr ms">pt = (cast-type*) malloc(byte-size)</span></pre><blockquote class="mt mu mv"><p id="9ed1" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><strong class="jp ir">pt =(int *)malloc(5 * sizeof(int))；</strong></p></blockquote><p id="9c1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当malloc返回一个地址时，它应该存储在一个指针中，对吗？</p><ul class=""><li id="7e65" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">pt:存储地址的指针</li><li id="0810" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">(int *):类型转换为整数</li><li id="271e" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">sizeof(int):返回整数的大小(4字节)</li></ul><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/b043da5b00849593e8f28352c108136a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4Ym0N9IfAbkNxo3V.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated"><a class="ae nl" href="https://www.geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc/</a></figcaption></figure><p id="3cb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将返回大约5×4字节= 20字节，并且pt将指向该存储块的开始。</p><p id="730a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我说大约，对吗？你知道为什么吗？</p><p id="d36c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会想，这怎么可能，因为整数的大小是4字节，所以5 * 4 = 20字节。</p><p id="b004" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这将分配超过20个字节。这就是堆内部机制发挥作用的地方。我不会深究，因为我想保持简单，但让我解释一下为什么有超过20个字节。</p><p id="7d49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">长话短说，堆管理器确保分配在32位系统上是8字节对齐，在64位系统上是16字节对齐。</p><p id="ee92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，内存分配的对齐并不重要，但是应该正确地进行对齐，因为堆管理器不知道用户/程序员将在分配的空间中存储什么，这也是为了提高<strong class="jp ir">性能</strong>而实现的。</p><p id="467a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还要注意，malloc()返回的最小内存块在32位系统中是<strong class="jp ir"> 16字节</strong>，在64位系统中是<strong class="jp ir"> 32字节</strong>。</p><p id="4479" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们使用的是32位系统，所以返回的内存块的最小大小是16字节。这意味着如果我们试图通过malloc从堆中分配小于或等于16字节大小的内存，它将总是返回16字节。如果你尝试分配超过16字节的内存，它将返回16+8字节，也就是24字节。在最小大小的内存块之后，它将增加8个字节，因为在32位系统中，内存块是按8个字节对齐的</p><p id="196a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更好地理解这一点，让我们在调试器中看看。我将用这个程序来说明malloc的行为。</p><blockquote class="mt mu mv"><p id="026e" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"># include<stdlib.h>T11】# include&lt;stdio . h&gt;T12】void main(){</stdlib.h></p><p id="bd02" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">char * m1 =(char *)malloc(2)；<br/>char * m2 =(char *)malloc(4)；<br/>char * m3 =(char *)malloc(10)；<br/>char * M4 =(char *)malloc(20)；</p><p id="dfc1" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi">}</p></blockquote><p id="0f44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用gcc编译它</p><blockquote class="mt mu mv"><p id="061c" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">海合会马洛克</p></blockquote><p id="0ab4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们把这个加载到gdb里面，对主函数进行反汇编。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nm"><img src="../Images/9e417279a7cfd07db28df5c003c302ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P0tIe_1TotqQrij39bmegw.png"/></div></div></figure><p id="5cd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在来看一下拆解。</p><p id="0f89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有四个打给malloc的电话。因此，我们可以假设“bl 0x102c8”是malloc的分支，类似地，看看这个分支上面的mov指令，它每次都向r0移动一些值。你能猜出这个值是什么吗？</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nn"><img src="../Images/e9e0eeee251c21ab383f86eaa9ed802f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dqiLIhBUJrzLjJzvNR94uA.png"/></div></div></figure><p id="1a2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据ARM调用约定，第一个参数应该在r0寄存器中传递。malloc()中唯一的参数是用户/程序员给定的要分配的大小。所以它将用户/程序员提供的大小复制到r0，作为malloc()的参数。</p><p id="ce40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单来说，</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/f8140d13f25396b4a268f03821a64c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XsV2annJg3a3vhEbEt3gvQ.png"/></div></div></figure><p id="9174" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在地址为0x00010430的第一个malloc处设置一个断点，然后运行程序。</p><blockquote class="mt mu mv"><p id="01dd" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">bp *0x00010430</p></blockquote><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi no"><img src="../Images/5e472301ba19465c90139f7c013ff79f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5fWP4PhAmWcN60TfXQK2w.png"/></div></div></figure><p id="7fbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的断点已被命中。如果你现在看r0，它包含2(malloc(size)的参数)。现在让我们跳过ni</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi np"><img src="../Images/0de5776df9429def3d5f929be4fdfe39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gs5ow8-nJdAMOgD9eNr2AQ.png"/></div></div></figure><p id="2d6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在调试器执行了malloc()调用，并返回到下一条指令。如你所知，r0包含了一个函数的返回值，所以在调用malloc()之后，它将返回一个指向零的地址。它是指向由malloc()返回的已分配内存的第一个字节的地址。</p><p id="5476" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以地址“0x00021008”指向分配内存的开始，是这样吗？让我们使用examine命令对此进行检查。</p><blockquote class="mt mu mv"><p id="875c" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">全球环境基金&gt; x/6x 0x 00021008–8</p></blockquote><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nq"><img src="../Images/411a8d177428d79f31830bafcb8d30ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRpI013ukUZYtjhuifig4Q.png"/></div></div></figure><p id="567a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个输出可能看起来有点混乱，但是让我解释一下。我们分配的空间从“0x 00021008”(r0中的返回地址)开始。所以空间从下图的阴影空间开始</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nq"><img src="../Images/cbd5fa0cda6060ee679a30e3081c4777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s_BEeI3itJL4_DqDp8N3vQ.png"/></div></div></figure><p id="4c76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会奇怪，我们只要求2个字节，但其他空间有零。啊，是的，记得我说过在32位系统中，最小分配内存块是16字节。所以这些零也被我们的第一个malloc(2)分配了空间。</p><p id="d2bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这个怎么加起来是16个字节，我们的0x021008之前这个诡异的0x11是什么？</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nq"><img src="../Images/07f4f55dbdb0336c7075a11b51a1aee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mp2T3xJgGdXsSmSC9_bQcA.png"/></div></div></figure><p id="a9b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，将这4个字节相加将得到3 * 4 = 12个字节。但是我们的最小16字节对齐在哪里呢？</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="nr lf l"/></div></figure><p id="caf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以事实是奇怪的0x11也是我们分配的块的一部分。现在如果你计算4 * 4 = 16字节。一切都会解决的，对吧？</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nq"><img src="../Images/55fa47521c594f6fc38534785a310287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UXnODVzRKE4Uj9ovLoIf0Q.png"/></div></div></figure><p id="5671" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们从malloc(2)中分配的内存块。即使我们请求2个字节，它也返回一个16字节的对齐块。</p><p id="3d9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，下一个问题是，如果包含“0x00000011”的前四个字节是我们分配的块的一部分，那么为什么r0不指向那个内存地址(0x21004)以及包含值0x11的是什么？</p><p id="3cf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了回答这个问题，让我们来看看分配内存的结构。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/601d11cd9ca186aa819e885f6d7c7834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*izBEpRX-xBBxDJGLOGgIsA.png"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">SOS:Azerialabs.com</figcaption></figure><p id="42b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Chunk只是malloc()为我们分配的内存块调用的另一个词。(上面的整个黄色阴影块)。从现在开始，我将使用这个词，而不是每次都键入分配的内存块。</p><p id="1b19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分配的块有一个称为“块大小”的字段。这包含我们分配的块的总大小，也包括这个字段本身。正如我们在上面看到的，字段(上面的黄色阴影图片)是4字节长，所以4 * 4 = 16。</p><p id="770b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们分配的块是16字节(包括大小字段)长。因此大小字段将包含值16。我们可以忽略“<strong class="jp ir"> PREV SIZE </strong>”字段，因为当一个块被<em class="mw">分配</em>时它不被使用。</p><p id="1f29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">十六进制的16是0x10，但是我们的字段包含0x11。额外的一位来自标志“<strong class="jp ir"> PREV: IN USE </strong>”(看上面的图片)，这意味着从堆中分配的块正在使用中。这将在我们使用当前块时进行设置。大小就是这样变成0x11的。</p><p id="ac60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">malloc总是将地址返回到块的“用户数据”部分，这就是为什么r0没有指向“元数据”(大小字段)的地址，该地址位于0x21004。“用户数据”从0x21008开始，这就是r0包含该地址的原因。</p><p id="ff50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想现在一切都清楚了。让我们继续我们的节目到下一个malloc(4)。它也将分配相同的16个字节。下面是我们的前两个malloc()</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nt"><img src="../Images/daad8268817c8de9679f4a4f100b85cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dY5CQ_xeEjaeOoeKxu6L0Q.png"/></div></div></figure><p id="07ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对于所有请求的16字节或更小的块都是一样的。让我们看看当我们分配超过16个字节时会发生什么。让我们继续我们的程序，直到最后一个malloc(20)超过16个字节。因此，让我们在那里设置一个断点并进行检查。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nu"><img src="../Images/5c09bddeefbe9e2a9a7474aa214b1586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FRgsuL4DcHWHQVv6IPSX2A.png"/></div></div></figure><p id="b4d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用inspect命令检查r0处的地址</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nv"><img src="../Images/14c0bbbd16e806f5537e029a28ce2a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JETxCtPX9kv_Wp3rOe9xPg.png"/></div></div></figure><p id="86da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，它返回了一个24字节大小的块。十进制的0x19(十六进制)是24。</p><p id="d84d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种分配在24字节以内是相同的。但是如果你尝试内存分配超过24字节，它将返回一个24+8 = 32字节的块。这就是8字节对齐理论的由来。所以接下来的块将是8的倍数。所以大概是16，24，32等等。我希望你明白我的意思。</p><p id="d964" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们退出调试器，继续前进。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="1943" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们在使用后释放块。要释放这个块，我们可以使用c中的free函数。(我不会展示这个例子)</p><p id="69ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自由(指针)</p><blockquote class="mt mu mv"><p id="7131" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">免费(pt)；</p></blockquote><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/61da5b37beb42c431fa80e38a50e6b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V6Q9ZUtxmSkFRPMC.png"/></div></div></figure><p id="27c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使在释放它之后，它也会指向同一个内存位置，所以我们应该让指针(pt)指向空值。这样它就不会指向任何内存位置。如果处理不当，可能会导致其他安全隐患，比如在free()之后使用。我们稍后会谈到这一点。让我们开始吧</p><blockquote class="mt mu mv"><p id="d89d" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">pt = NULL</p></blockquote><p id="e358" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我想这是足够的理论。这里不需要的东西，我不想过度解释和添加不必要的东西。我们可以在需要的时候通过其他东西，就像我们通过其他开发技术一样。如果你还想阅读更多，请浏览这个</p><div class="od oe gp gr of og"><a href="https://www.geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">使用malloc()、calloc()、free()和realloc() - GeeksforGeeks在C中动态分配内存</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">由于C是一种结构化语言，它有一些固定的编程规则。其中一个包括改变一个…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="op l"><div class="oq l or os ot op ou nf og"/></div></div></a></div><h1 id="6624" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">溢出堆</h1><p id="e0ee" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">与堆栈不同，我们不能直接控制PC(程序计数器)。堆不像堆栈那样包含任何返回地址。所以覆盖并不是一直都有帮助。但是，如果有任何这样的指针，那么你是幸运的。您可以覆盖指针并控制程序流程</p><p id="5c54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了理解这一点，我们将开发一个非常简单的程序。所以让我们来看看这个程序。</p><blockquote class="mt mu mv"><p id="6986" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"># include<stdio.h><br/># include&lt;string . h&gt;<br/># include&lt;stdlib . h&gt;</stdio.h></p><p id="e15e" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">void main(int argc，char *argv[]){</p><p id="bfe8" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">if(argc&lt;= 1){</p><p id="ad70" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">printf(“Provide an argument as the username :)\n”);</p><p id="afea" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">exit(0);</p><p id="cddd" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi">}</p><p id="b95d" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">printf(“Basic ARM Heap overflow challenge \n”);</p><p id="16e1" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">char *name = malloc(64);<br/>char * cmd = malloc(64)；</p><p id="5967" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">strcpy(cmd，“whoami”)；</p><p id="bfa2" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">strcpy(name，argv[1])；</p><p id="b3f6" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">printf("%s正在执行命令%s "，name，cmd)；<br/>printf(" \ n \ n ")；</p><p id="50ef" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">系统(cmd)；</p><p id="d29d" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi">}</p></blockquote><p id="db39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这是一个简单的程序。它从命令行接受一个参数，并沿着输入的参数打印命令“whoami”的输出。</p><blockquote class="mt mu mv"><p id="80d7" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">char * name = malloc(64)；<br/>char * cmd = malloc(64)；</p></blockquote><p id="6ce3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类型为<strong class="jp ir">字符</strong>的指针变量name和cmd将指向所分配内存的起点。</p><p id="bcca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，第一个<strong class="jp ir"> malloc </strong>将从堆中分配大约60个字节，并返回指向该内存的第一个字节的地址。它存储在变量名中。这个<em class="mw">名</em>变量用于存储使用strcpy()的命令行输入。请注意，这是我们可以控制程序输入的唯一地方。</p><p id="fb2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个malloc的大小与第一个malloc相同，它也这样做，并将地址存储在“cmd”变量中。它用于在分配的内存中复制命令“whoami”。</p><p id="3354" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“whoami”命令在调用时显示当前用户的用户名。这里的用户是“pi”。</p><p id="737e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一个演示。</p><p id="c2b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先使用GCC编译它。</p><blockquote class="mt mu mv"><p id="e190" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">gcc堆挑战. c -o堆挑战</p></blockquote><p id="2245" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们运行这个。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ov"><img src="../Images/98efe23871fbaf761b896a334254f8a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eak2O5KcX-Zt1pDHAIKJfA.png"/></div></div></figure><p id="f46c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你在这里看到的，它需要一个参数。它通过使用系统函数来执行命令。</p><p id="28d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你明白这个程序是如何工作的。</p><p id="1c08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我问你。你发现这里的漏洞了吗？</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ow lf l"/></div></figure><p id="7ff5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有，恭喜你。如果没有，请再次查看代码并检查代码中使用的函数。</p><p id="a42e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想起什么了吗？</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ox lf l"/></div></figure><p id="10b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想你现在明白了，对吧？</p><p id="5d51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该漏洞存在于<strong class="jp ir"> <em class="mw"> strcpy </em> </strong>函数中。众所周知<strong class="jp ir"><em class="mw">strcpy</em></strong><em class="mw"/>是一个没有绑定检查的易受攻击的函数。就像在堆栈中一样，我们可以利用这个函数来溢出我们的堆。</p><blockquote class="mt mu mv"><p id="d7ec" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">strcpy(cmd，“whoami”)；</p><p id="9341" class="jn jo mw jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">strcpy(name，argv[1])；//漏洞</p></blockquote><p id="9cc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个malloc()用于为username分配空间，第二个用于复制命令。因为它们的大小相同，所以返回的块将彼此相邻。</p><p id="9e20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用调试器来确认这个论点。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oy"><img src="../Images/b5709c48ed504ba43477843d6b88952b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQQPjypWd7nbG4SbuW2T9A.png"/></div></div></figure><p id="b19c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">黄色阴影部分表示用于复制命令的块。命令“whoami”已经被复制到其中。如果查看第二个块的大小字段，DWORD的值为“0x616f6877 ”,其后的下一个DWORD包含“0x0000696d ”,表示“whoami”命令。第一个块中的41表示发送到命令行输入的“A”。</p><p id="1622" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说得够多了……现在让我们直奔主题吧。如何利用这一点？</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="ea23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你看看这个程序，主要的缺陷不是使用strcpy()，而是使用程序块的顺序。命令块在用户名块之后，并且用户的输入也仅在第二次复制命令之后才被复制。因此，这给了我们一个溢出用户块并覆盖命令块的机会，因为如果我们溢出用户块，溢出的数据将转到相邻的命令块。因此，我们可以用自己的任意命令覆盖“whoami”命令，并执行它。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="c5cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们运行程序，提供一个大的“A”输入，并尝试溢出我们的第一个块。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oz"><img src="../Images/ec8ccf19546e3b32a885af9f8688fd0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpyPhmAItEbikrodZfUmuQ.png"/></div></div></figure><p id="55a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不出所料，程序块溢出了，结果，我们的“whoami”命令没有执行。“whoami”命令被“A”覆盖。</p><p id="b354" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那现在怎么办？</p><p id="3c34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们尝试执行任意命令。为此，我们可以通过调整“A”的数量并猜测在第二个块中覆盖“whoami”命令所需的“A”的数量，或者您可以使用与我们在基本堆栈溢出中使用的模式类似的模式。</p><p id="d27f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将只使用第一个命令，并尝试执行“ls”命令</p><p id="57a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ls命令:列出目录中的所有文件。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi pa"><img src="../Images/040787297cf0b27bab34d45bd7a623c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJJ5a5gshN3Ez4znT6YYUg.png"/></div></div></figure><p id="0b2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">试了几次后，我做对了。:)</p><p id="067d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试着用这个得到一个壳。这很简单，我们只需要传递“/bin/sh”而不是“ls ”,因为它使用system()函数，它将生成一个shell。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi pb"><img src="../Images/d73e8edcf01cbf687e6ba38dfe390efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5YSSQ3Ym_fT3ukkPk4TVQ.png"/></div></div></figure><p id="00fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们得到了贝壳。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="pc lf l"/></div></figure><p id="c6de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想今天就这些了，我们把这个包起来吧。</p><p id="9acd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管我想让这变得简单，但同时我也想让你明白这些事情是如何运作的。这里我跳过了很多东西。但是一旦我们转移到其他话题，我会把它说出来。我希望你喜欢这个，有一个美好的一天:)</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="7fb9" class="mo lh iq bd li pd pe dn lm pf pg dp lq jy ph pi lu kc pj pk ly kg pl pm mc pn bi translated">参考</h2><div class="od oe gp gr of og"><a href="https://www.geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">使用malloc()、calloc()、free()和realloc() - GeeksforGeeks在C中动态分配内存</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">由于C是一种结构化语言，它有一些固定的编程规则。其中一个包括改变一个…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="op l"><div class="po l or os ot op ou nf og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">堆利用第1部分:理解Glibc堆实现</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">C和C++程序员使用在程序执行期间手动分配新的进程内存区域…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">azeria-labs.com</p></div></div><div class="op l"><div class="pp l or os ot op ou nf og"/></div></div></a></div></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="a76e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如有任何疑问，您可以联系我</p><p id="6cd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">https://www.facebook.com/i.am.ultralegend<a class="ae nl" href="https://www.facebook.com/i.am.ultralegend" rel="noopener ugc nofollow" target="_blank">脸书</a></p><p id="6563" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">insta gram:【https://www.instagram.com/hagane_no_rekinjutsushi/ T4】</p><p id="ae3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想支持我或者学习<strong class="jp ir"> ARM开发</strong>请查看我的课程:<a class="ae nl" href="https://www.udemy.com/course/reverse-engineering-and-binary-exploitation-in-arm/?referralCode=8C725D513E77420A0CBF" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/course/reverse-engineering-and-binary-exploitation-in-ARM/？referral code = 8c 725d 513 e 77420 a0cb</a></p></div></div>    
</body>
</html>