<html>
<head>
<title>The toddler’s introduction to Heap Exploitation, FastBin Dup Consolidate (Part 4.2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆利用的幼儿入门，FastBin Dup Consolidate(第4.2部分)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8?source=collection_archive---------1-----------------------#2022-04-13">https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8?source=collection_archive---------1-----------------------#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8660" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将触发一个<strong class="jp ir"> FastBin合并</strong>，我们将结合一个双自由漏洞(dup)来返回一个指向已经分配的块的指针。所谓的<strong class="jp ir">合并</strong>指的是合并相邻的空闲块并将它们放入未排序的容器中以备将来分配的过程。</p><p id="3be3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，请在下面找到我以前关于堆利用的帖子的参考:</p><ul class=""><li id="2c4f" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><a class="ae ku" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8" rel="noopener">堆利用入门(第1部分)</a></li><li id="b589" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-2-d1f325b74286" rel="noopener">堆利用入门(第二部分)</a></li><li id="1811" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-overflows-part-3-d3d1aa042d1e" rel="noopener">堆利用入门——溢出(第3部分)</a></li><li id="0e1c" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://valsamaras.medium.com/use-after-free-13544be5a921" rel="noopener">堆利用的幼儿入门——免费后使用&amp;双免费(第四部分)</a></li><li id="4acd" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-to-stack-part-4-1-425592a2870b" rel="noopener">堆利用的幼儿入门，FastBin Dup to Stack(第4.1部分)</a></li></ul></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="ea06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到我们的主题，<code class="fe lh li lj lk b"><strong class="jp ir">malloc_consolidate</strong></code>执行合并，它是free()函数的特殊版本[1]:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="fbfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数将迭代FastBin列表，将一个空闲块合并到它的下一个<strong class="jp ir">和/或前一个</strong>(<strong class="jp ir">4766–4783</strong>)中，结果块将被添加到未排序的Bin列表中(<strong class="jp ir"> 4784 </strong>)。当出现特殊情况时，可以通过<code class="fe lh li lj lk b"><strong class="jp ir">malloc</strong></code>功能触发合并:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ls"><img src="../Images/ba9121314c7ab3f1ab0e36b8400664ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N7AcBxus7yP_DoUFX-6UaA.png"/></div></div></figure><p id="a6aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果释放块的大小≥ <strong class="jp ir"> 64KB </strong>,它也由<code class="fe lh li lj lk b"><strong class="jp ir">malloc_init_state, malloc_trim, __libc_mallopt</strong></code>和<code class="fe lh li lj lk b"><strong class="jp ir">free</strong></code>函数触发:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/035bb2f063a69f907276ac2391a9ad28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*iCfj10VR0wQjXSfBro1QCg.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><a class="ae ku" href="https://sourceware.org/" rel="noopener ugc nofollow" target="_blank">https://sourceware.org/</a></figcaption></figure><p id="8cc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将坚持使用<strong class="jp ir"> malloc </strong>，因为这是触发Fastbins合并<strong class="jp ir">的最直接的方式。</strong></p><h1 id="3dda" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">FastBin Dup合并</h1><p id="d165" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">我们将使用以下程序:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="ee47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然上面的代码很容易理解，但是让我们花点时间来强调几点:</p><ul class=""><li id="a19e" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">在<code class="fe lh li lj lk b"><strong class="jp ir">Lines 11–14</strong></code>处，我们填充tcache列表，以便强制使用FastBin。</li><li id="4cf4" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">在<code class="fe lh li lj lk b"><strong class="jp ir">Lines 16–20</strong></code> <strong class="jp ir"> </strong>处，释放p1会将相应的块添加到FastBin列表，因为tcache列表对于该大小(0x40)已经满了。</li><li id="da9c" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">下一次分配(<code class="fe lh li lj lk b"><strong class="jp ir">Line 22</strong></code>)将触发FastBin列表中块的合并。然而，由于p1块已经被合并，p3指针将指向与p1相同的地址。</li><li id="45cb" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">释放<strong class="jp ir"> p1 </strong>(再次在<code class="fe lh li lj lk b"><strong class="jp ir">Line 22</strong></code>)将把块添加到tcache，即使它仍然被<strong class="jp ir"> p3引用。</strong></li><li id="da2d" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">在<code class="fe lh li lj lk b"><strong class="jp ir">Line 33</strong></code>，我们请求一个可以被tcache最后一次添加(<code class="fe lh li lj lk b"><strong class="jp ir">0x400</strong></code>)所满足的大小。因此<strong class="jp ir"> p4 </strong>现在将指向与<strong class="jp ir"> p3 </strong>相同的地址。</li></ul><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/2641ada66e330deff3783baa49328a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*VqRzLBndqM1Mr2YCpa_6aQ.png"/></div></figure><p id="6ea1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将程序加载到gdb中，看看运行中的一切:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ni"><img src="../Images/c9d7ccb111a1fc6ef099a061082b0701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8rYGlcHrSzVLdC7VSrskhw.png"/></div></div></figure><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nj"><img src="../Images/55d2bba8518559af26aab6c57d9169a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jyCEyqrIuB4kojvspnNNw.png"/></div></div></figure><p id="8074" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe lh li lj lk b">free(p1)</code>后设置一个断点，点击后检查堆箱:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nk"><img src="../Images/cd20ec2acc40e8aab979da149f977281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65Re3KK7KJsXCCynm2Ynbw.png"/></div></div></figure><p id="7129" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在进入<code class="fe lh li lj lk b"><strong class="jp ir">malloc</strong></code>直到<code class="fe lh li lj lk b"><strong class="jp ir">_int_malloc</strong></code> <strong class="jp ir"> </strong>函数，这里我们注意到一个对<code class="fe lh li lj lk b"><strong class="jp ir">checked_request2size</strong></code> <strong class="jp ir"> : </strong>的调用</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3935613a06394a9f50acd0eda28d3897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*MkDg0aabRBMk0nnoPcL4vA.png"/></div></figure><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nm"><img src="../Images/e0d52ac5574edfc96c4cba81cfa0aac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M7NXDs3j-pE45DkG_WfP8g.png"/></div></div></figure><p id="3c3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在随后的分支上，_int_malloc将检查快速箱是否能满足要求(使用<code class="fe lh li lj lk b"><strong class="jp ir">get_max_fast()</strong></code>):</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/63a17453b8d2b03e928c99ab9af092c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*oumYQVQTkUXUeJna5PrBfA.png"/></div></figure><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi no"><img src="../Images/7b8dbc4c850b8f9cbf97cb75e160df8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*klNLftdb1srDZO7ykkzEzA.png"/></div></figure><p id="dec0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们请求的大小为0x400字节，该检查将失败，因此我们将结束于<code class="fe lh li lj lk b"><strong class="jp ir">malloc_consolidate</strong></code>调用:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi np"><img src="../Images/853b5428e7d8ca36031ee6483a3dd56e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mhnhRDkYQF9PgvIQIUkW-w.png"/></div></div></figure><p id="0cce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个调用之后，<code class="fe lh li lj lk b"><strong class="jp ir">0x5555555598e0</strong></code>处的块已经被合并:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/e67b1e38d1e3b5f589bfe59545f4f9cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*w1GZFzEJCZ18essTBsO90A.png"/></div></figure><p id="0766" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在malloc将返回<code class="fe lh li lj lk b"><strong class="jp ir">0x5555555598e0</strong></code> <strong class="jp ir"> </strong>作为新的块地址引用来满足分配(见下面顶部块之前的最后一个):</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nr"><img src="../Images/f702a7a16de16e0538a763e03661e7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SxW3GwCS_JTaqpl4XKlc2Q.png"/></div></div></figure><p id="8cbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">p1的双释放将块移动到tcache:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nk"><img src="../Images/4c3703070594680949414fd4e7c86b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIAVqECzqWTSNJCGKiAvEw.png"/></div></div></figure><p id="c7ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，对malloc的最后一次调用会将已经分配的块分配给p4(参见下面的$rax ),这就完成了我们的概念验证:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ns"><img src="../Images/cebd32d49dae0031f476f8153d2fc2e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hflYZdrBX-y2p_UtAXs9HQ.png"/></div></div></figure><p id="290f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[1]<a class="ae ku" href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;hb=45a8e05785a617683bbaf83f756cada7a4a425b9" rel="noopener ugc nofollow" target="_blank">https://sourceware.org/git/?p = glibc.gita = blobf = malloc/malloc . c；HB = 45 A8 e 05785 a 617683 bbaf 83 f 756 CAD a7 a 425 b 9</a></p><p id="4b02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2]<a class="ae ku" href="https://sourceware.org/glibc/wiki/MallocInternals#Thread_Local_Cache_.28tcache.29" rel="noopener ugc nofollow" target="_blank">https://sourceware . org/glibc/wiki/malloc internals # Thread _ Local _ Cache _ . 28 tcache . 29</a></p></div></div>    
</body>
</html>