<html>
<head>
<title>The toddler’s introduction to Heap Exploitation, House of Lore(Part 4.5)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">《堆开发的幼儿入门》,知识之家(第4.5部分)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-house-of-lore-part-4-5-1b5865297057?source=collection_archive---------1-----------------------#2022-06-06">https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-house-of-lore-part-4-5-1b5865297057?source=collection_archive---------1-----------------------#2022-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0581" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与我们到目前为止看到的其他堆利用攻击类似，<strong class="jp ir">知识之家</strong> ( <strong class="jp ir"> HoL </strong>)背后的想法是<strong class="jp ir">欺骗malloc返回一个指针，指向攻击者</strong>控制的内存位置。<strong class="jp ir"> HoL </strong> (ab)使用ptmalloc处理<code class="fe kl km kn ko b">small bin</code>条目的方式，尽管<a class="ae kp" href="https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt" rel="noopener ugc nofollow" target="_blank">初始post </a>也包含了<code class="fe kl km kn ko b">large bin</code>条目。除了知识之家周围的条件非常独特这一事实[1]，malloc实现的变化(<code class="fe kl km kn ko b">fd_nextsize</code>和<code class="fe kl km kn ko b">bk_nextsize</code>的引入)[2]使得这种攻击对于大型bin滥用来说不切实际，而在<code class="fe kl km kn ko b">tcache</code>的引入和最新glibc版本的额外强化之后，这种攻击需要更多的条件才能成功。</p><p id="87ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了它的(不)实用性，理解这种攻击是如何工作的，将有助于我们理解malloc是如何工作的，毕竟…这才是真正重要的。</p><p id="6b68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始之前，这里是目前为止的故事:</p><ul class=""><li id="bce7" class="kq kr iq jp b jq jr ju jv jy ks kc kt kg ku kk kv kw kx ky bi translated"><a class="ae kp" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8" rel="noopener">蹒跚学步，堆剥削，<strong class="jp ir">简介</strong>(上篇)</a></li><li id="8d38" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><a class="ae kp" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-2-d1f325b74286" rel="noopener">蹒跚学步，堆剥削，<strong class="jp ir">简介</strong>(下篇)</a></li><li id="61e2" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><a class="ae kp" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-overflows-part-3-d3d1aa042d1e" rel="noopener">学步的，堆剥削的，<strong class="jp ir">溢出的</strong>(第三部分)</a></li><li id="664c" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><a class="ae kp" href="https://valsamaras.medium.com/use-after-free-13544be5a921" rel="noopener">学步的，<strong class="jp ir">使用后免费&amp;双免费</strong>(第四部分)</a></li><li id="135d" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><a class="ae kp" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-to-stack-part-4-1-425592a2870b" rel="noopener">学步的，<strong class="jp ir"> FastBin Dup to Stack </strong>(第4.1部分)</a></li><li id="3d45" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><a class="ae kp" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8" rel="noopener">学步的，<strong class="jp ir"> FastBin Dup巩固</strong>(第4.2部分)</a></li><li id="d32b" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><a class="ae kp" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-unsafe-unlink-part-4-3-75e00e1b0c68" rel="noopener">蹒跚学步的孩子，<strong class="jp ir">不安全的解除链接</strong>(第4.3部分)</a></li><li id="8f3a" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated"><a class="ae kp" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-house-of-spirit-part-4-4-252cd8928f84" rel="noopener">幼儿的<strong class="jp ir">精神之家</strong>(第4.4部分)</a></li></ul></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="e564" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">知识之家</h1><p id="1cd2" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">坚持攻击的主要思想，我们将强制malloc返回一个指向我们控制的堆栈内存区域的指针。这将帮助我们覆盖发生漏洞的函数的返回地址，并通过跳过<a class="ae kp" href="https://valsamaras.medium.com/introduction-to-x64-linux-binary-exploitation-part-4-stack-canaries-e9b6dd2c3127" rel="noopener">金丝雀</a>值绕过堆栈粉碎检测。我们将在glibc 2.23版本的背景下研究HoL，以避免<code class="fe kl km kn ko b">tcache</code>的发生，并逐渐添加缺失的条件，以便为最新的glibc版本实现这种攻击。</p><p id="92ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始之前，您需要了解以下内容:</p><ul class=""><li id="3693" class="kq kr iq jp b jq jr ju jv jy ks kc kt kg ku kk kv kw kx ky bi translated">当一个块被传递给free()时，它首先被添加到未排序的bin中。</li><li id="574e" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">在下一次调用malloc时，如果smallbin或未排序的块不能满足内存需求，那么将未排序的块放到适当的列表中。</li><li id="f186" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">当一个块被插入到(双重链接的)<a class="ae kp" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-2-d1f325b74286" rel="noopener">小容器</a>中时，更新<strong class="jp ir"> fd </strong>和<strong class="jp ir"> bk </strong>指针，以便指向适当的节点。</li><li id="b636" class="kq kr iq jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">由于分配器遵循这个bin的FIFO规则，对<code class="fe kl km kn ko b">free</code>的调用将把新的块发送到列表的头部，对malloc的调用将从尾部解除块的链接并删除块:</li></ul><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mo"><img src="../Images/8b51e2ade75e6f91d6232033ac6a40c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8XmgO04x_dnQtQNtCeb1ag.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">在小垃圾箱中插入和移除块</figcaption></figure><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ne"><img src="../Images/5d7c1d3211019d993828c26754afe7eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWJ6AIeMSaSmuoAjHaMCRg.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">组块结构</figcaption></figure><h2 id="e260" class="nf lm iq bd ln ng nh dn lr ni nj dp lv jy nk nl lz kc nm nn md kg no np mh nq bi translated">袭击</h2><p id="c94e" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">假设您有一个溢出，允许您覆盖一个N大小块的<code class="fe kl km kn ko b"><strong class="jp ir">bk</strong></code> <strong class="jp ir"> </strong>条目，因此它指向一个任意的内存位置:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nr"><img src="../Images/d38b96e53fbe8cc605da9989626d9e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-HfZn70GLp2env52eFOdzg.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">覆盖bk以指向假块</figcaption></figure><p id="c999" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么为了让攻击发生，分配器需要对一个N大小的malloc执行N次调用，这样就可以到达被覆盖的bk。让我们来看看shellphish的<a class="ae kp" href="https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_lore.c" rel="noopener ugc nofollow" target="_blank"> how2heap </a> repo中的一个例子:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f596" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第6  <strong class="jp ir">和7 </strong>行的<code class="fe kl km kn ko b"><strong class="jp ir">stack_buffer_1</strong></code>和<code class="fe kl km kn ko b"><strong class="jp ir">stack_buffer_2</strong></code>代表两个将被分配到堆栈中的假块。在<strong class="jp ir">第9行</strong>中，我们分配了<code class="fe kl km kn ko b"><strong class="jp ir">victim</strong></code>块，我们假设它通过溢出来控制它的头数据。在<strong class="jp ir">行11 </strong>处，<code class="fe kl km kn ko b"><strong class="jp ir">victim_chunk</strong></code>将指向牺牲块的头部。第14行到第19行处理<code class="fe kl km kn ko b"><strong class="jp ir">stack_buffer_1</strong></code>和<code class="fe kl km kn ko b"><strong class="jp ir">stack_buffer_2</strong></code> <strong class="jp ir"> </strong>看起来像与受害者块链接的有效块。更具体地说，<strong class="jp ir">线16 </strong>将绕过<strong class="jp ir">线3388 </strong>处的malloc检查:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nu"><img src="../Images/fce573a051ecef1c90c2abe225d97dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E78M6di9NvXL8baCmua-qg.png"/></div></div></figure><p id="6e9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第17、19行的代码将在一个双向链表中链接假块，因此我们将得到如下结果:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nv"><img src="../Images/40d5b14dcd1bc7c84c1b60b75f73cd36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThTRMM9FLzEXIPZU8bdfMA.png"/></div></div></figure><p id="4094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">添加第21行</strong>以避免受害者块与顶部块合并。在<strong class="jp ir">行23 </strong>对free的调用将首先把牺牲块移动到未排序的bin，因此未排序的bin不能满足的下一个malloc将把牺牲块移动到smallbin。<strong class="jp ir">线28 </strong>表示脆弱性，其结果为以下排列:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nw"><img src="../Images/6657b9f2d28a77a29143bd9517fabfa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VqnWXLghe4IvHRDto6Sz_Q.png"/></div></div></figure><p id="3721" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于<code class="fe kl km kn ko b"><strong class="jp ir">victim_chunk</strong></code>是smallbin中唯一的节点，第一次调用第31行的malloc将返回它的地址以满足分配，所以随后调用第33行的malloc将返回一个指向<code class="fe kl km kn ko b"><strong class="jp ir">stack_buffer_1</strong></code>的(假)数据部分的指针。由于我们控制了<code class="fe kl km kn ko b"><strong class="jp ir">p4</strong></code>指向的内存位置，我们可以覆盖<strong class="jp ir">主</strong>函数的返回地址(第37行)以指向<code class="fe kl km kn ko b">jackpot()</code>函数的入口，这样通过运行程序我们将在输出中得到一个<code class="fe kl km kn ko b">Nice jump d00d</code>，然后程序将退出。</p><h2 id="76e2" class="nf lm iq bd ln ng nh dn lr ni nj dp lv jy nk nl lz kc nm nn md kg no np mh nq bi translated">#if USE_TCACHE</h2><p id="47fb" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">tcache的引入为smallbin处理流增加了几个额外的分支，攻击要成功必须绕过这些分支。更具体地说，malloc将尝试把剩余的相同大小的smallbin块存储到tcache中</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nx"><img src="../Images/6f2a27870dd88c9ac314a7d277918016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3IVLa3-cZZrOBMrZ7e6Y6w.png"/></div></div></figure><p id="e71d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了克服这些检查，shellphish的repo中的代码创建了一个假的空闲列表，并通过一个假的<code class="fe kl km kn ko b">bk</code>指针链接每个节点:</p><p id="7d9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">void * fake _ freelist[7][4]；</strong></p><p id="b3de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">for(int I = 0；I&lt;6；i++){ fake _ freelist[I][3]= fake _ freelist[I+1]；} </strong></p><p id="3395" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将创建以下设置:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ny"><img src="../Images/339b3f873b3c95c94f502f686b20667d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eha1cLgLwaSLjuJ303YgQw.png"/></div></div></figure><p id="6bdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将填充tcache列表并在<strong class="jp ir">行3927 </strong>处退出循环。最后，代码通过一个伪需求耗尽tcache列表，如下所示:</p><p id="f4d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">虚空*假人【7】；for(int I = 0；我&lt;7；i++)dummies[I]= malloc(0x 100)；</strong></p><p id="49f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">…</p><p id="c007" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">…</p><p id="a072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">for(int I = 0；我&lt;7；i++)free(dummies[I])；</strong></p><p id="06de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个代码如下:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9cae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[1]<a class="ae kp" href="https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt" rel="noopener ugc nofollow" target="_blank">https://dl . packets storm security . net/papers/attack/mallocmaleficarum . txt</a></p><p id="817d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2]<a class="ae kp" href="https://heap-exploitation.dhavalkapil.com/attacks/house_of_lore" rel="noopener ugc nofollow" target="_blank">https://heap-exploitation . dhavalkapil . com/attacks/house _ of _ lore</a></p></div></div>    
</body>
</html>