<html>
<head>
<title>TryHackMe — Basic Malware RE Walkthrough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TryHackMe —基本恶意软件演练</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/tryhackme-basic-malware-re-walkthrough-61b24cf79a30?source=collection_archive---------0-----------------------#2021-05-16">https://infosecwriteups.com/tryhackme-basic-malware-re-walkthrough-61b24cf79a30?source=collection_archive---------0-----------------------#2021-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/17e6168a80a9372f1dc0ae8161a09911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sVju-xZEYr3F7nCgRNj6PA.png"/></div></div></figure><h2 id="ffb0" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">为什么要对恶意软件进行逆向工程？</h2><p id="99a9" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">安全专业人员使用逆向工程进行<strong class="kw ir">静态恶意软件分析</strong>，以便在创建恶意软件时提取有用的信息，如元数据、嵌入资源、加密密钥、标题等。许多工具用于对恶意软件进行反向工程，如反汇编程序、调试器、PE查看器和网络分析器。</p><p id="47e5" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">这篇文章是对TryHackMe的<strong class="kw ir">基本恶意软件RE</strong>room(<a class="ae lu" href="https://tryhackme.com/room/basicmalwarere" rel="noopener ugc nofollow" target="_blank">https://tryhackme.com/room/basicmalwarere</a>)的一个补充，在这里你必须对一些样本恶意软件进行逆向工程并捕获标记。</p><h2 id="3a33" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">关于吉德拉</h2><p id="f0f3" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">为了完成这个挑战，我使用了由美国国家安全局开发的免费开源逆向工程工具。许多安全研究人员认为Ghidra是IDA Pro等商业级逆向工程工具的竞争对手。你可以从https://ghidra-sre.org下载。它是独立于平台的，所以你可以在Linux，Windows和Mac上运行它。如果你不熟悉这个工具，先完成TryHackMe的Ghidra room(<a class="ae lu" href="https://tryhackme.com/room/ccghidra" rel="noopener ugc nofollow" target="_blank">https://tryhackme.com/room/ccghidra</a>)，或者你可以阅读写得很好的文档。</p><h2 id="a63f" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">先决条件</h2><ul class=""><li id="bf3a" class="lv lw iq kw b kx ky lb lc kh lx kl ly kp lz lo ma mb mc md bi translated">熟悉<strong class="kw ir">汇编</strong>和c等编程语言。</li><li id="fc00" class="lv lw iq kw b kx me lb mf kh mg kl mh kp mi lo ma mb mc md bi translated">逆向工程的基础知识。</li><li id="75d6" class="lv lw iq kw b kx me lb mf kh mg kl mh kp mi lo ma mb mc md bi translated">工具的熟悉程度<strong class="kw ir"> Ghidra。</strong></li></ul><p id="aa5c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">让我们进入正题。</p><h2 id="a9ee" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">挑战1 </strong></h2><p id="a002" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">该可执行文件在执行时会在屏幕上打印一个MD5散列。你能拿到准确的旗子吗？</p><p id="12c8" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir"> <em class="mj">解</em> </strong></p><p id="2c30" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">首先你需要下载任务文件并用Ghidra启动它。在任何情况下，你都不必运行可执行文件，因为它是恶意的。</p><p id="3510" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir">提示</strong> —由于任务文件是一个可执行文件，所以不要使用Windows来解决这个问题。使用你最喜欢的Kali/Parrot操作系统，因为有可能你会不小心打开可执行文件。我们是人类，人类也会犯错。对吗？Windows恶意软件没有Linux强大！！！</p><p id="036f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">启动可执行文件后，Ghidra界面将如下所示。我们更需要关注的是<strong class="kw ir">符号树</strong>部分，因为它包含了代码的所有功能、导入和导出。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/85898d78037e555a233b13ce98d3b39f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMpUE9snabUFf6Z0Ww36Uw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">启动任务文件后的Ghidra界面</figcaption></figure><p id="6d14" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们更需要关注的是<strong class="kw ir">函数</strong>部分。我展开它，寻找一个主函数。但是，没有主要功能。但是有一个<strong class="kw ir">录入功能。</strong></p><p id="f1bd" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在计算机编程中，入口点是程序开始执行指令的地方，也是程序可以访问命令行参数的地方。为了开始一个程序的执行，加载程序或操作系统将控制权传递给它的入口点。这标志着从加载时间到运行时间的转变。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/fbddae79c24fa0796c9b224c5ee59cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*GmS3eDyuJ2j8m5jVNYuf9A.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">功能部分显示入口功能</figcaption></figure><p id="a38e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">为了查看源代码，我双击了入口函数。在观察源代码时，我遇到了一个被MD5散列的字符串，我可以很容易地从解编译的源代码中获取第一个标志，如下所示。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/85342071f826ca1646f1815750d53721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pe4Dyauo4h4EdXh_UvijXQ.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">标志1</figcaption></figure><p id="a15b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">提示—Flag以单词“<strong class="kw ir"> FLAG </strong>开始，并且<strong class="kw ir">没有</strong>数字出现在Flag中！！！</p><p id="9df1" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">这就像从婴儿手里拿走糖果一样容易。不是吗？让我们开始第二个挑战。但是，并没有上面那么容易。你需要知道stack是如何工作的，还要有一些编程知识。</p><h2 id="2b4d" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">挑战2 </strong></h2><p id="950c" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">该可执行文件在执行时会在屏幕上打印一个MD5散列。你能拿到准确的旗子吗？</p><p id="4911" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir"> <em class="mj">解</em> </strong></p><p id="d0bf" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">为了解决这一挑战，也遵循了相同的程序。</p><p id="3a2e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在分析函数时，我得出了与前面相同的结构。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/968662687df5cff170add6410d81c189.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*MbERC3rsR6BHkfBZ8S_PCQ.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">挑战2的功能部分</figcaption></figure><p id="db06" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">所以，我从入口函数开始，因为它是flag在之前挑战中所在的函数。入口函数的反编译源代码如下。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/eff5dcb904e16b688b9adda0641e6a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I07MaQbZLKkUJnojBfgRbw.png"/></div></div></figure><p id="678f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">它以一个<strong class="kw ir"> char </strong>变量开始，然后是一堆<strong class="kw ir">未定义的</strong>变量。最后一个是<strong class="kw ir">字符指针</strong>变量。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/95a2fca7172f0bc8bb87f3d8d4877144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bg1rJrtYe9w6Ppy8mH18Hw.png"/></div></div></figure><p id="e8ae" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">如果我们看一下反汇编部分，我们可以了解这些变量是如何添加到堆栈中的。我们可以清楚地看到一个相反的顺序。</p><p id="8920" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">最后一个字符指针<strong class="kw ir"> local_8 </strong>是第一个加入堆栈的指针，如下所示。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/0f77a123f213b30968a52f4cff55d9c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y3tU8Y2Ne3PUwpSfrS0KDQ.png"/></div></div></figure><p id="4885" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">让我们记住这一点，并进一步观察反编译器。</p><p id="e2f0" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们可以看到每个变量都被赋值如下。第一个字符变量<strong class="kw ir"> local_2c </strong>被分配给'<strong class="kw ir"> F </strong>'，所有未定义的变量被分配十六进制值。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/83e2e42de2a0b2b642fd3209b087eb5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*d9-ECH3GX59ITrv9LKBZlg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">变量被赋值</figcaption></figure><p id="4a6e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">提示—这些十六进制值应该是ASCII字符，因为每个值正好是一个字节。</p><p id="04e0" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">如果你还记得，我们发现最后定义的变量是local_8，是一个字符指针。现在，它被赋值为从变量<strong class="kw ir"> char local_2c </strong>的内存地址开始的字符串的<strong class="kw ir">散列，如下所示。</strong></p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/067b37cfc1652eaaf59aa51d2d13572d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*9Ox1eWuvkShvUnc-rLcieQ.png"/></div></figure><p id="0083" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">这意味着它将散列从栈底到栈顶<strong class="kw ir">的整个字符串。因此，我们需要<strong class="kw ir">将在<strong class="kw ir"> local_2c </strong>之后分配给变量的每个十六进制字符转化为ASCII字符，以便获得被散列的字符串。</strong></strong></p><p id="f950" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">为此，您可以使用<a class="ae lu" href="https://www.rapidtables.com/convert/number/hex-to-ascii.html" rel="noopener ugc nofollow" target="_blank">https://www . rapid tables . com/convert/number/hex-to-ascii . html</a>。您将获得如下ASCII标志。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/9414e604988f4d60377872986c791b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*f0-vxBAtvcC0FiAT3g5OQA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">标志2</figcaption></figure><p id="0b0f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">提示—提交前需要在标志的开头加上<strong class="kw ir"> local_2c </strong>的值，即<strong class="kw ir">“F”</strong>。</p><h2 id="95c1" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">挑战3</h2><p id="9c48" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">该可执行文件在执行时会在屏幕上打印一个MD5散列。你能拿到准确的旗子吗？</p><p id="0149" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><strong class="kw ir"> <em class="mj">解</em> </strong></p><p id="762e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">和前面的例子一样，从分析函数部分开始，如下所示。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/425a6fba64728ee4521efc7a5f8d210c.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*XpYEQihqV97hDvTWSmVJEg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">挑战3的功能部分</figcaption></figure><p id="1739" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">它包含入口函数。然而，在以前的挑战中可以找到的一些功能却不见了。让我们分析一下入口函数。这次你会遇到一个更复杂的入口函数。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/86d6ad75e4f195d10c10f93994147343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ameTpU6IV0O2Yndw1IaKg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">挑战3的入口功能</figcaption></figure><p id="1b47" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">如你所见，有一些外部函数被调用，如<strong class="kw ir"> FindResourceA() </strong>和<strong class="kw ir"> LoadStringsA() </strong>。当我们查看汇编代码时，我们会发现FindResourceA()来自Kernel32库，而LoadStringsA()来自User32库。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/0a3f9b619e140514f434e5dd49a39a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*RyO8p8nivWGavsPOCYLhiA.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">FindResourceA()来自Kernel32库</figcaption></figure><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/d60fcbec86c617dc2c5eeeda361276b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*jQYzVpzcj-t2M2XO3TQwrg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">LoadStringsA()来自User32库</figcaption></figure><p id="4262" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">LoadStringsA()所做的是从其引用中加载字符串，并存储在变量<strong class="kw ir"> local_4a4中。</strong>那么，让我们找到参照物。</p><p id="fa68" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">如上面的入口函数所示，我们知道<strong class="kw ir"> 0x110 </strong>十六进制值参数是LoadStringsA()函数调用中字符串的标识符。</p><p id="df81" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">十六进制0x110 =十进制<strong class="kw ir"> 272 </strong></p><p id="6816" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">从Ghidra功能区打开<strong class="kw ir">定义的字符串</strong>(窗口→定义的字符串)。向下滚动，你会看到一个包含许多旗帜的旗帜表。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/6123afabfbc528fd4153f8eba29193b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oM80GMzLnG4GrwHJIaz5UA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">标志表</figcaption></figure><p id="f8d6" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">看一看反汇编程序上的等价代码，你会在右上角找到十进制的<strong class="kw ir">字符串ID </strong>。因此，向下滚动直到找到string-ID 272。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/95d0e16d255f6a8a1777736519532709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ltShMsV3YuoNcePV7VB8Gg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">最终旗帜</figcaption></figure><p id="b78f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">这将是CTF挑战赛的最后一面旗帜。</p><p id="3f79" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">当涉及到现实世界的静态恶意软件分析时，可能会变得比这更具挑战性，原因有很多，例如，</p><ul class=""><li id="8d79" class="lv lw iq kw b kx lp lb lq kh nh kl ni kp nj lo ma mb mc md bi translated">反汇编程序失败。</li><li id="e4b7" class="lv lw iq kw b kx me lb mf kh mg kl mh kp mi lo ma mb mc md bi translated">反编译器产生混淆的代码。</li></ul><p id="4106" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">这主要是因为恶意软件代码的复杂性。因此，动态恶意软件分析应运而生。动态分析是在一个封闭的系统(称为<strong class="kw ir">沙箱</strong>)上进行的，目的是在一个安全的环境中启动恶意程序，并简单地观察它做了什么。</p><p id="6f7b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我希望你学到了一些东西，并享受这个挑战。通过LinkedIn联系我，【https://www.linkedin.com/in/ravishanka-silva-a632351a0/ T2】</p><p id="cd46" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">祝你在前方捕捉旗帜时好运！！！</p></div></div>    
</body>
</html>