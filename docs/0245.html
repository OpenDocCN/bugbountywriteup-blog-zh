<html>
<head>
<title>What is a Second-Order SQL Injection and how can you exploit it successfully?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是二阶SQL注入，如何成功利用它？</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-wrath-of-second-order-sql-injection-c9338a51c6d?source=collection_archive---------0-----------------------#2019-01-24">https://infosecwriteups.com/the-wrath-of-second-order-sql-injection-c9338a51c6d?source=collection_archive---------0-----------------------#2019-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dd35" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">带演示的二阶SQL注入</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d7088ac4816077eefe7fcc7c0def208a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yVWZzOfqD65Lo_v0.jpg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">信用:pixabay.com</figcaption></figure><h1 id="eef2" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">什么是SQL注入</h1><p id="e794" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">SQL注入—在数据请求中注入SQL语言代码的过程，会导致应用程序后端数据库服务器泄露机密数据或在数据库上执行恶意脚本内容，从而导致主机完全受损。</p><h1 id="9eb2" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">了解二阶代码注入</h1><p id="da5b" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">想象一个场景，其中由攻击者注入到应用程序中的恶意代码不会立即在应用程序中执行。是的，你没看错。这是一个熟悉的故事，通常是这样的，当用户提供的数据被应用程序或任何其他应用程序利用时，攻击者提供的注入代码就会被激活，从而导致成功利用。</p><p id="8611" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">一阶和二阶SQL注入的主要区别在于，攻击者可以简单地输入一个恶意字符串，并导致修改后的代码立即执行。</p><p id="1459" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">看出区别了吗？</p><p id="8613" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">攻击者向被视为可信来源的持久存储(如表行)中注入。攻击随后由另一个活动执行。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mv"><img src="../Images/2d011ab6ced8902e30fb7bbec80825c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vJH6jdi24DmjTElSUmcDLA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">信用:portswigger.net</figcaption></figure><h1 id="4c7f" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">测试挑战</h1><p id="5f36" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">常见代码注入的攻击性质允许攻击者通过观察应用程序响应来发现漏洞。</p><p id="8a4d" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">测试二阶SQL注入有点困难，因为它要求攻击者了解应用程序的后端操作。</p><p id="7486" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">你怎么能打败它呢？</p><p id="694f" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">自动化web应用程序评估工具不足以识别这些漏洞。自动化工具不够智能，无法识别任何后续响应中的应用程序行为变化，这些响应是由先前查询之一中的恶意注入引起的。</p><h1 id="bdb3" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">是什么使应用程序容易受到二阶SQL注入的攻击</h1><p id="6df0" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">之所以会出现这种漏洞，是因为一个优秀的程序员可能会在用户可以输入内容的表单中修补他的代码以防止SQL注入，但在用户与应用程序数据库没有任何交互的情况下，他不会做同样的事情。</p><h1 id="dd09" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">利用场景</h1><p id="8fae" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">另一方面，二阶SQL注入是一种可通过两个不同步骤利用的漏洞:</p><ol class=""><li id="f27e" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp nb nc nd ne bi translated">首先，我们在数据库中存储一个特定的用户提供的输入值</li><li id="3ba9" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp nb nc nd ne bi translated">其次，我们使用存储的值来利用构建web应用程序的动态查询的源代码中易受攻击的函数中的漏洞。</li></ol><p id="6e4c" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">因此，让我们言归正传，在一个假设场景的帮助下，更详细地了解如何利用易受攻击的应用程序:</p><h2 id="5dbd" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">示例1</h2><pre class="kn ko kp kq gt nw nx ny nz aw oa bi"><span id="2a90" class="nk ld iq nx b gy ob oc l od oe"><em class="of">CREATE TABLE USERS ( userId serial PRIMARY KEY, firstName TEXT )</em></span></pre><p id="a6e4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">假设您有这样一些安全代码，从一个表单接收<strong class="lw ir"> <em class="of">的名字</em> </strong>:</p><pre class="kn ko kp kq gt nw nx ny nz aw oa bi"><span id="54fc" class="nk ld iq nx b gy ob oc l od oe"><em class="of">$firstname = someEscapeFunction($_POST[“firstName”]);</em></span><span id="1980" class="nk ld iq nx b gy og oc l od oe"><em class="of">$SQL = “INSERT INTO USERS (firstname) VALUES (‘{$firstName }’);”;</em></span><span id="0f99" class="nk ld iq nx b gy og oc l od oe"><em class="of">someConnection-&gt;execute($SQL);</em></span></pre><p id="0dd2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">到目前为止还不错，假设someEscapeFunction()做得很好。注入SQL是不可能的。如果我现在将我的有效负载作为firstname的值发送，您不会介意:</p><p id="9621" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><em class="of">有效载荷:bla’)；从用户中删除；// </em></p><p id="7234" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">现在，假设同一个系统中的某个人想要将名字从用户传输到其他用户，这样做:</p><pre class="kn ko kp kq gt nw nx ny nz aw oa bi"><span id="ab45" class="nk ld iq nx b gy ob oc l od oe"><em class="of">$userid = 42; $SQL = “SELECT firstname FROM USERS WHERE (userId={$userid})”; $RS = con-&gt;fetchAll($SQL); $firstName = $RS[0][“firstName”];</em></span></pre><p id="c9e0" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">然后不转义地将其插入某个表中:</p><pre class="kn ko kp kq gt nw nx ny nz aw oa bi"><span id="23ab" class="nk ld iq nx b gy ob oc l od oe"><em class="of">$SQL = “INSERT INTO SOME VALUES (‘{$firstName}’);”;</em></span></pre><p id="b6b4" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">恶意查询变成这样:</p><pre class="kn ko kp kq gt nw nx ny nz aw oa bi"><span id="2457" class="nk ld iq nx b gy ob oc l od oe"><em class="of">INSERT INTO SOME VALUES (‘ bla’); DELETE FROM USERS; //</em></span></pre><p id="06d2" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">此时，您意识到如果名字包含一些删除命令，它仍然会被执行。</p><h2 id="68fe" class="nk ld iq bd le nl nm dn li nn no dp lm md np nq lo mh nr ns lq ml nt nu ls nv bi translated">示例2</h2><p id="a1b1" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">有可能利用一些不需要用户输入的函数，并使用已经保存在数据库中的数据，在需要时进行检索。密码重置功能！</p><p id="07c7" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">受害者用户“用户123”可以用一个非常强且安全的密码在网站上注册，但我们仍然很想得到他的帐户。在二阶SQL注入中，我们应该能够完成类似于以下的工作:</p><p id="32d8" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">注册一个新账户。我们想将这个新用户命名为“user 123”—“user pass @ 123”</p><p id="4781" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><em class="of">有效载荷:“用户123”——“</em></p><p id="d362" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">然后，我们可以重置我们的密码，并以适当的形式设置一个新密码。</p><p id="9026" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">合法的查询将是:</p><pre class="kn ko kp kq gt nw nx ny nz aw oa bi"><span id="70dc" class="nk ld iq nx b gy ob oc l od oe"><em class="of">$pwdreset = mysql_query(“UPDATE users SET password=’getrekt’ WHERE username=’User123' — ‘ and password=’UserPass@123'”);</em></span></pre><p id="44c8" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">但是，由于—是用于在SQL中进行注释的字符，查询结果将是这样的:</p><pre class="kn ko kp kq gt nw nx ny nz aw oa bi"><span id="21bc" class="nk ld iq nx b gy ob oc l od oe"><em class="of">$pwdreset = mysql_query(“UPDATE users SET password=’getrekt’ WHERE username=’User123'”);</em></span></pre><p id="737e" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">然后嘣！你在那里。这将为受害者用户帐户设置一个我们选择的新密码！</p><h1 id="69bb" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">示范</h1><p id="d712" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">我在HTB的SecNotes机器上工作，遇到了如图1所示的登录表单。必须尝试SQL注入，对吗？咄！我尝试在登录参数中插入SQL注入查询，但是没有显示任何内容。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/41fffd91278b587b01d6ee10a2439f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/0*oxGrdTw3tv3JmKCB"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">图1</figcaption></figure><p id="acf6" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我创建了一个用户user123，并登录到该帐户，在其中我可以看到一些注释，如图2和图3所示。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/b4828af5d408a94937eaa0514da0b8c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/0*eSjnracdKAU2DsNI"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">图2</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oj"><img src="../Images/b0ce412d93a7caf395bec5ae430c17e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HNpJ-QwJm_K_X4a7"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">图3</figcaption></figure><p id="1f92" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">如果我们回忆一下SQL注入漏洞利用是如何工作的，我们将一个特定的值存储在数据库中，存储的值将成为web应用程序源代码中未过滤或已调试函数的查询的一部分。</p><p id="f974" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">如果应用程序使用该应用程序的用户名从数据库中获取笔记会怎样。让我们创建一个用户名包含'的用户，并希望我们可能会遇到SQL错误</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/463f2bfa4140268ee791fe07b7abb140.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*dRVoSY-5s5cVr4Mg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">图4</figcaption></figure><p id="55ac" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">哇哦。服务器响应500内部服务器错误，如图5所示。一旦我能够让服务器响应一个错误(主要是HTTP 500状态)，我必须确认是SQL命令导致了错误，而不是其他原因。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/9e52e0dc6cfcc6caca486b012eb6bd70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*Nuq5lzw6pcze7dD6nmN1tg.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">图5</figcaption></figure><p id="5d40" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">我用用户名<em class="of">或‘ASD’=‘ASD</em>创建了一个账户，如图6所示。因此，用户名<em class="of">或‘ASD’=‘ASD</em>被存储在数据库中。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/76037672391fa05c62fadbf31e88ec30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*VwgQRErm7w7ZwYcDg7zkug.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">图6</figcaption></figure><p id="4047" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">然后，我使用如图7所示的相同用户名登录帐户。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/369ab0826a4883e513443161eaef1067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/0*ZrieX9cPsvNqaRuO"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">图7</figcaption></figure><p id="0f36" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">答对了。现在，我可以看到数据库中的三个注释，如图8所示。已经证实，航向导致了这种二阶SQL注入漏洞。构建的动态查询看起来会像这样，</p><pre class="kn ko kp kq gt nw nx ny nz aw oa bi"><span id="05e4" class="nk ld iq nx b gy ob oc l od oe"><em class="of">SELECT * from notes WHERE username = ‘’ or ‘asd’ = ‘asd’;</em></span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi on"><img src="../Images/3b379f637b12f7b749affc7d910458cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PCK6I6Qg4WZAAj8R"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">图8</figcaption></figure><h1 id="63e8" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">攻击概率</h1><p id="4f8c" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">与二阶SQL注入相比，识别经典(一阶)SQL注入的成功率是常见的。一阶注入通常被称为“低挂果实”，可以直接观察到，而二阶SQL注入的相对概率较低。</p><p id="2e68" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">在大多数情况下，二阶SQL注入攻击必须“盲目”执行，因为攻击者在没有任何系统知识的情况下对后端功能执行攻击。</p><h1 id="79ac" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">防止二阶SQL注入</h1><p id="b807" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">使用白名单方法来净化数据(即默认情况下禁止所有内容，并明确列举允许或被认为“安全”的数据字符)。</p><p id="ca9c" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">请注意，对于一个应用程序标记为“安全”的数据对于另一个应用程序/组件可能并不安全。</p><ul class=""><li id="fb04" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp oo nc nd ne bi translated">每个检索存储数据的应用程序(特别是如果数据可能是由用户提供的)在进一步处理数据之前，必须应用自己的数据清理过程。在进一步处理任何用户提供的数据之前，应对其进行净化处理</li><li id="9ebe" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp oo nc nd ne bi translated">应用程序组件内部和之间处理的所有数据都应该经过验证。</li></ul><p id="9396" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">针对特定语言的建议:</p><ul class=""><li id="40c8" class="mw mx iq lw b lx mq ma mr md my mh mz ml na mp oo nc nd ne bi translated">Java EE —使用PreparedStatement()</li><li id="54cd" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp oo nc nd ne bi translated">。NET —使用参数化查询，如SqlCommand()或OleDbCommand()</li><li id="06b9" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp oo nc nd ne bi translated">PHP —对强类型参数化查询使用PDO(使用bindParam())</li><li id="72b1" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp oo nc nd ne bi translated">Hibernate —使用createQuery()(在Hibernate中称为命名参数)</li><li id="0074" class="mw mx iq lw b lx nf ma ng md nh mh ni ml nj mp oo nc nd ne bi translated">SQLite —使用sqlite3_prepare()</li></ul><p id="cebd" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">现在我就此打住，让您去探索更多关于二阶SQL注入的知识。</p><p id="dd45" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated">如果您想了解更多关于高级代码注入和测试过程的信息，请查看这篇文章。</p><h1 id="afa7" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">参考</h1><p id="5948" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">【https://www.owasp.org/index.php/SQL_Injection T2】号</p><p id="167b" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><a class="ae op" href="https://portswigger.net/kb/issues/00100210_sql-injection-second-order" rel="noopener ugc nofollow" target="_blank">https://ports wigger . net/kb/issues/00100210 _ SQL-injection-second-order</a></p><p id="353f" class="pw-post-body-paragraph lu lv iq lw b lx mq jr lz ma mr ju mc md ms mf mg mh mt mj mk ml mu mn mo mp ij bi translated"><a class="ae op" href="https://www.researchgate.net/publication/290768140_Detection_Method_of_the_Second-Order_SQL_Injection_in_Web_Applications" rel="noopener ugc nofollow" target="_blank">https://www . researchgate . net/publication/290768140 _ Detection _ Method _ of _ the _ Second-Order _ SQL _ Injection _ in _ Web _ Applications</a></p></div></div>    
</body>
</html>