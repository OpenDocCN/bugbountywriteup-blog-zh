<html>
<head>
<title>Race Condition Vulnerability in Unix Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unix系统中的竞争条件漏洞</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/race-condition-vulnerability-in-unix-systems-db86b6daceb6?source=collection_archive---------3-----------------------#2021-06-17">https://infosecwriteups.com/race-condition-vulnerability-in-unix-systems-db86b6daceb6?source=collection_archive---------3-----------------------#2021-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a43f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我们将学习如何发现并修复Unix系统中的竞争情况。这是漏洞的常见来源，也可能发生在其他领域，如Web应用程序。</p><p id="9862" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将首先定义什么是竞争条件，如何利用它，以及最终我们可以做什么来修复/减轻它。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/ada59d6f65090226a359e0022a2438ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/0*r9U87jOS3e2fbHjT"/></div></figure></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="b8e1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.什么是竞争条件？</h1><p id="752d" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">当多个进程/线程同时访问和操作相同的数据，并且它们的时序或事件顺序影响程序的结果时，就会出现争用情况。</p><p id="c4b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">竞态条件可能以不同的方式发生:</p><ul class=""><li id="cb59" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">如果一个特权程序存在竞争条件漏洞，攻击者可以运行一个并行进程来与特权程序“竞争”,并操纵与合法程序相同的数据。这就是我们将在本文中处理的例子。</li><li id="f0ab" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">线程上下文切换:2个线程同时访问相同的数据，相互干扰。在这种情况下，结果可能取决于线程访问共享数据的顺序。这里有一个例子:<a class="ae mr" href="https://stackoverflow.com/questions/7714220/how-race-conditions-will-caused-by-context-switching" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/7714220/how-race-conditions-will-reased-by-context-switching</a></li><li id="f701" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi">…</li></ul><p id="23b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是所有不同的竞争条件都有这些共同的特性:</p><ul class=""><li id="67af" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">并发属性:必须至少有两个流同时运行</li><li id="86d7" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">共享对象属性:两个并发流必须访问一个共享的race对象</li><li id="95d7" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">更改状态属性:至少有一个流必须改变对象的状态</li></ul><p id="9478" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进程/线程相互干扰的时间间隔称为竞争窗口。下面是一个比赛窗口的例子:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/7bfbba58d62c2ade833bd8a8511cd212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W-6MP2p97XxJGOwP"/></div></div></figure><h1 id="1c43" class="la lb iq bd lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt nb lv lw lx bi translated">2.如何利用竞争条件</h1><p id="9951" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们将看到一个竞争条件变成“检查时间到使用时间”错误的例子。它<strong class="jp ir"> </strong>利用被访问数据的<em class="nc">检查</em>和数据的<em class="nc">使用</em>之间的时间同时执行另一个程序:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/b5c56511760baee4ad1daf748eec8361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*L6DgSu49K_tLtf4Y-mJ9gw.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><a class="ae mr" href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use</a></figcaption></figure><p id="0caf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">访问功能检查真实用户(执行SUID程序的人)是否通常被允许(用他的真实用户ID)修改文件。访问功能和打开功能之间的时间是竞争窗口，可以这样利用:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ni"><img src="../Images/7d5f0387dec5c3a2c2221387bbae8437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o1iVsrYT5bY71z0GD5jhDw.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><a class="ae mr" href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use</a></figcaption></figure><p id="1d07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，通过在主受害者程序创建的文件和/etc/password文件之间创建链接，黑客可以覆盖password文件中的条目。链接的创建必须发生在检查和使用之间的窗口内；即在访问和开放调用之间。</p><p id="d025" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这需要精确的时间，但如果黑客多次运行该程序，通过自动化，这迟早会发生。</p><p id="692e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:通过将计算机系统暴露在异常大的负载下，有可能有效地延长执行竞争窗口所需的时间。</p><p id="6033" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想弄脏你的手，并试图利用Linux中的一个竞争条件，我建议你查看来自RootMe的这个挑战:<a class="ae mr" href="https://www.root-me.org/en/Challenges/App-System/ELF-x86-Race-condition" rel="noopener ugc nofollow" target="_blank">https://www . root-me . org/en/Challenges/App-System/ELF-x86-Race-condition</a></p><h1 id="124b" class="la lb iq bd lc ld mx lf lg lh my lj lk ll mz ln lo lp na lr ls lt nb lv lw lx bi translated">3.如何防止竞态条件？</h1><p id="8bdb" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">竞争条件下的保护机制:</p><ul class=""><li id="8a57" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">消除竞争条件的一种方法是使冲突的竞争窗口互斥。换句话说，一旦潜在的竞争窗口开始执行，在第一个竞争窗口完成之前，不允许执行任何冲突的竞争窗口。实现互斥的编程语言工具称为同步原语(如管道、信号量、锁变量等)。来自独立进程的竞争条件不能由同步原语解决。我们使用锁文件来代替。</li></ul><p id="0350" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nc">注意:锁定文件是锁定资源的文件，例如文件或设备。它通常不包含数据，仅作为空标记文件存在，但也可能包含锁的属性和设置。锁文件向应用程序发出信号，表明在释放锁之前不应使用资源。</em></p><ul class=""><li id="aeac" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">如果您的竞争条件涉及上下文切换，请尝试同时执行“检查并使用”。如果一个系统调用可以在同一个系统调用中同时执行“检查和使用”，那么它是安全的，因为上下文切换不会在系统调用中发生。</li><li id="31bf" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">重复:我们可以添加更多的竞争条件，而不是删除竞争条件，这样，为了危及程序的安全性，攻击者需要赢得所有这些竞争条件。基本思路是重复几次access()和open()；每次，我们打开文件，最后，我们通过检查它们的I节点来检查是否打开了相同的文件(它们应该是相同的) :</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nj"><img src="../Images/a352e2286f12990547f96f2fbdcdcaf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxC1wf1GRLOFHM3M2AU3jg.png"/></div></div></figure><p id="e24f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，赢得每场比赛的概率非常低。</p><p id="a2a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nc">注意:检查I-node确保相同的文件名指向相同的文件(即相同的I-node) </em></p><ul class=""><li id="6ee3" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">最小特权原则:程序员确实明白运行程序的用户可能太强大了，所以他/她引入了access()来限制用户的权力。然而，这不是正确的方法。更好的方法是应用最小特权原则。也就是说，如果用户不需要某些特权，则需要禁用该特权。我们可以使用setuid系统调用来暂时禁用root权限，以后如果需要的话再启用它</li></ul></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><p id="3ea2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读这篇文章！请在评论中告诉我你对此的看法！</p><p id="cd99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你读了这篇文章，你可能会花很多时间在你的电脑上，所以请随意查看我关于肌肉骨骼问题和电脑的文章:<a class="ae mr" href="https://malolegoff.medium.com/musculoskeletal-issues-due-to-computers-302d80ec97db" rel="noopener">https://malolegoff . medium . com/muscle skeletal-issues-due-to-computers-302d 80 EC 97 db</a></p><p id="00f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有任何问题或者想联系我，这里是我的LinkedIn:【https://www.linkedin.com/in/malo-le-goff-480452170/? T2】locale=en_US </p></div></div>    
</body>
</html>