<html>
<head>
<title>ASP.NET CORE Path Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP.NET核心路径遍历</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/asp-net-core-path-traversal-e2bed792d171?source=collection_archive---------0-----------------------#2021-09-24">https://infosecwriteups.com/asp-net-core-path-traversal-e2bed792d171?source=collection_archive---------0-----------------------#2021-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/01c3082adabc4ae90018fd8e0faf41dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CHfpBu36xcW6EDrWDUN5A.png"/></div></div></figure><h1 id="0d39" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">路径遍历:</h1><p id="cca6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">路径遍历攻击(也称为目录遍历)旨在访问存储在webroot文件夹之外的文件和目录。通过使用“点-点-斜线(../)"序列及其变体或使用绝对文件路径，就有可能访问存储在文件系统上的任意文件和目录，包括应用程序源代码或配置和关键系统文件。应当注意，对文件的访问受到系统操作访问控制的限制(例如在Microsoft Windows操作系统上锁定或使用文件的情况下)。</p><h1 id="6074" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">描述:</h1><p id="9a88" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这篇文章中，我将解释在ASP.NET核心中发现的路径遍历漏洞，即<code class="fe lu lv lw lx b">Path.combine</code>函数的不正确使用。</p><p id="6fc4" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">什么是<code class="fe lu lv lw lx b">Path.combine </code>？</p><p id="2d0d" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">此方法旨在将单个字符串连接成表示文件路径的单个字符串。</p><h1 id="1c43" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">组合(String[]):</h1><p id="1650" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">将字符串数组组合成一个路径。</p><p id="663e" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated"><code class="fe lu lv lw lx b">public static string Combine (params string[] paths);</code></p><p id="dd5e" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">此方法假定第一个参数是绝对路径，后面的一个或多个参数是相对路径。</p><h1 id="14bc" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">深入:</h1><p id="1072" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">关于在互联网上随处可见的技术细节已经说得够多了，让我们进入你想要的有趣信息吧。<br/>无论何时，当你进行代码审查或者甚至是黑盒方法时，你发现一个端点，例如<code class="fe lu lv lw lx b">https://alaa.blog/file.aspx?file=alaa.jpg</code>，在这种情况下，你必须假设，这个端点可能正在使用<code class="fe lu lv lw lx b">Path.combine</code>。</p><p id="c593" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">如果只是使用<code class="fe lu lv lw lx b">Path.combine</code>而没有其他规则或保护，那么我们可以轻松地逃离目录并访问系统上的任何其他文件。</p><p id="84fe" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">让我们看一个例子。</p><pre class="md me mf mg gt mh lx mi mj aw mk bi"><span id="600c" class="ml jz iq lx b gy mm mn l mo mp">using System;<br/>using System.Collections.Generic;<br/>using System.IO;<br/>using System.Linq;<br/>using System.Text;<br/>using System.Threading.Tasks;</span><span id="4825" class="ml jz iq lx b gy mq mn l mo mp">namespace ConsoleApp3<br/>{<br/>    class Program<br/>    {<br/>        static void Main(string[] args)<br/>        {<br/>            Console.WriteLine(Download(@"alaa.txt"));<br/>            Console.ReadLine();<br/>        }</span><span id="3b20" class="ml jz iq lx b gy mq mn l mo mp">        public static String Download(string fileName)<br/>        {<br/>            //fileName = Path.GetFileName(fileName);<br/>            fileName = Path.Combine(Path.GetTempPath(), fileName);<br/>            bool resultx = System.IO.File.Exists(fileName);<br/>            return resultx.ToString() + ", file: " + fileName;<br/>        }<br/>    }<br/>}</span></pre><p id="20a8" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">这只是我用C#做的一个小的控制台应用程序，用来模拟易受攻击的代码。</p><p id="d400" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">在第21行，我们可以看到该函数将临时路径与来自第14行的参数(alaa.txt)的条目相结合。</p><p id="55fd" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">因此，在这种情况下，完整的目录将是<code class="fe lu lv lw lx b">file: C:\Users\user\AppData\Local\Temp\alaa.txt</code></p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/71dc78e8ab8b42b4d87230435caefa3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sdPfOy6NBdOdme1F.jpg"/></div></div></figure><p id="bfa6" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">第22行是布尔型的，用于检查文件是否存在以便进一步测试，您可以忽略它。</p><p id="3b92" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">现在我们假设<code class="fe lu lv lw lx b">alaa.txt</code>是参数值，让我们改变它并尝试利用它。</p><p id="21e7" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">让我们输入<code class="fe lu lv lw lx b">C:\alaa.txt</code>并检查它是否会绕过目录。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/554328f4a71e75c264bf5ad3facfb7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EQmx88VEyXhVsadA.jpg"/></div></div></figure><p id="0dda" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">我们也可以使用<code class="fe lu lv lw lx b">../../../../</code>，但是让我们用DNS <a class="ae mt" href="https://portswigger.net/web-security/ssrf" rel="noopener ugc nofollow" target="_blank"> SSRF </a>来测试它，它也会容易受到攻击。</p><p id="37a4" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">我们现在将尝试访问</p><pre class="md me mf mg gt mh lx mi mj aw mk bi"><span id="cef8" class="ml jz iq lx b gy mm mn l mo mp">\\3ce0f3fcba9527b7dfa2785f14df.ns.pingb.in\a</span></pre><p id="398e" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">这只是概念的另一个证明，如果我们得到一个命中，那么它也是脆弱的，如果我们的路径遍历是盲目的，这可以被使用。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/f3e824610a98b13c515a31c1cf358d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Su2pWYpJSL_r_sMb.jpg"/></div></div></figure><p id="9970" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">结果将是:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/f93f39a01e372fe7b6e76a1be6f81879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vbmto0lSquonpAzq.jpg"/></div></div></figure><h1 id="e70d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">补救</h1><p id="5899" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有很多方法可以解决这个问题，但是我只说一种方法，在第20行，如果你取消注释，漏洞将很容易被修补。</p><p id="0722" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">函数<code class="fe lu lv lw lx b">Path.GetFileName(fileName);</code>将清理<code class="fe lu lv lw lx b">fileName</code>参数，并防止逸出路径。</p><p id="3d68" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">我相信这可能是最好的解决方案之一，在这种情况下，我已经尝试了很多次来绕过它，但没有运气。</p><h1 id="346d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">参考</h1><p id="9339" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><a class="ae mt" href="https://docs.microsoft.com/en-us/dotnet/api/system.io.path.combine?view=net-5.0" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/API/system . io . path . combine？view=net-5.0 </a></p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="0fe6" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">感谢你阅读这篇快速的文章，如果你做到了这一点，你可以在Twitter上关注我以获得更多的文章和技巧<a class="ae mt" href="https://twitter.com/alaa0x2" rel="noopener ugc nofollow" target="_blank"> @alaa0x2 </a>。</p><p id="26bf" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">上面使用的原始代码可以在GitHub <a class="ae mt" href="https://github.com/Alaa-abdulridha/path.combine.poc" rel="noopener ugc nofollow" target="_blank"> path.combine.poc </a>上找到</p></div></div>    
</body>
</html>