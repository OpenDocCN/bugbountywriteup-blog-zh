<html>
<head>
<title>Learning Linux &amp; InfoSec Principles Using OverTheWire’s Bandit — Part 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OverTheWire的Bandit学习Linux和InfoSec原理—第5部分</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/learning-linux-infosec-principles-using-overthewires-bandit-part-4-69803b6f43ed?source=collection_archive---------1-----------------------#2022-05-29">https://infosecwriteups.com/learning-linux-infosec-principles-using-overthewires-bandit-part-4-69803b6f43ed?source=collection_archive---------1-----------------------#2022-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4cc7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从一个有趣的在线“战争游戏”开始学习Linux</h2></div><h2 id="948b" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">简介</strong></h2><p id="5bd4" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">在之前的帖子(【https://bit.ly/3qFZACp】<a class="ae lu" href="https://bit.ly/3wWp01N" rel="noopener ugc nofollow" target="_blank"/>)中，我们已经用OverTheWire的强盗机器的14到18级继续了我们的Linux之旅。如果你还没有阅读前四篇文章，强烈推荐它们——你会有更好的介绍。</p><p id="39de" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">本质上，Bandit是OverTheWire.org网站提供的最基本的机器，旨在向人们介绍基本的Linux命令和信息安全思想。</p><p id="4b4d" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">本文的目标是通过使用强盗“wargame ”,为您提供一种实用而愉快的方式来了解Linux操作系统(尤其是<em class="ma"> bash </em> shell)。如果你已经阅读了之前的帖子，或者太热衷于继续这篇文章(我完全理解:)，那么让我们开始吧。</p><h2 id="535a" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">18级→19级</h2><p id="c4d6" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">在上一篇文章的最后，我们找到了18级的密码:kfb F3 eyk 5 bpbrzwjqutbbfe 887 SVC 5 yd。让我们像往常一样用它登录到这个级别。</p><p id="ffbc" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated"><code class="fe mb mc md me b">ssh bandit18@bandit.labs.overthewire.org -p 2220</code></p><p id="484c" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">哦哦！发生了什么事？我们提供了正确的密码，似乎认证过程成功了，但是我们立即被踢出服务器，得到消息“拜拜！”。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/3defffe54df00f8cd0be9a8afc5987b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*DmEJqE5zDA-Lo-fSsR_6mw.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">被踢出服务器</figcaption></figure><p id="78d9" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">不要害怕！让我给你看看17级指令的附录:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/aceb34fd0581ea64329683e792521c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*j-fP81oLkKMch6oZUG1lUg.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">奇怪信息的解释</figcaption></figure><p id="4a2b" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">所以我们需要升级到19级。这些说明是:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/6e75378c7dd075aaa51c85046a35ba5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*zJMdOuXhuxMQjNIaxp2jVw.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">19级指令</figcaption></figure><p id="18b5" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">我们认为必须检查<em class="ma"> </em>主目录中的<strong class="ld ir">自述文件</strong>的内容。还记得我在上一篇文章中建议保留它的密码吗？现在，我们将使用它进行初始访问，这将帮助我们超越“错误”。密码是:xlyvmn 9 we 5 zq 5 vhacb 0 szevqbrp 7 nbtn。但是一旦登录，我们发现我们没有权限读取相关文件，甚至连本地连接到<em class="ma"> bandit18 </em>都无法实现。</p><p id="551e" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">此外，即使密码是正确的，我们也被告知我们被排除在外的原因:有人修改了<strong class="ld ir">。bashrc </strong>文件。这是一个shell脚本，它初始化与终端的交互会话。它定义了几个属性，在我们的例子中，SSH登录到<strong class="ld ir"> bandit18 </strong>会立即将用户踢出。</p><p id="ae44" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">因此，我们必须找到一种方法，在我们注销之前，甚至在没有完全登录的情况下执行该命令。幸运的是，我们可以使用<strong class="ld ir"> SSH </strong>发送一个要执行的命令。为此，我们在<strong class="ld ir"> SSH </strong>行的末尾添加了带引号的命令。</p><p id="df73" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated"><code class="fe mb mc md me b">ssh bandit18@bandit.labs.overthewire.org -p 2220 'cat readme'</code></p><p id="58f6" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">主目录是默认的登录目录，我们知道文件名，所以我们成功地获得了下一个级别的密码。</p><h2 id="d20a" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">19级→20级</h2><p id="320e" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">为了继续下一个级别，我们需要利用主目录中的<strong class="ld ir"> setuid </strong>二进制文件。二进制文件是一个可执行文件，我们被告知执行它时不需要任何参数来理解它是如何工作的。</p><p id="8d53" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">我们马上就去做，但是首先让我们解释一下什么是<strong class="ld ir"> setuid </strong>。这是文件的一个属性，如果打开，意味着运行文件的不是实际运行它的用户，而是拥有它的用户。如果我们运行<strong class="ld ir"> ls -l </strong>:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/ecffa9fe65d9d6eeb5b61b1349355146.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*jOAU-aVG7wAR7maa5Zk2HQ.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">在<strong class="bd kh"> home </strong>目录下运行<strong class="bd kh"> ls -l </strong></figcaption></figure><p id="8925" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">你能认出左边的单个“s”吗？这证明了<strong class="ld ir"> setuid </strong>位确实开启。现在，如果我们执行二进制文件，我们将不是管理进程的用户，其权限将被继承给进程——所有者将运行它，而进程将拥有他的权限。我们可以看到，拥有者是下一级，<em class="ma"> bandit20 </em>。让我们执行脚本:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/b69b98a090f6cc797c816d33b2639058.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*rUzKbUtafYDzyT98RzynRg.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">不带参数运行<strong class="bd kh"> setuid </strong>脚本</figcaption></figure><p id="3abe" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">我们举了一个例子。我们可以在脚本名称后提供一个参数，这将由用户<em class="ma"> bandit20 </em>作为命令运行。让我们试试<strong class="ld ir"> whoami </strong>命令。它告诉我们我们是哪一个用户，正如我们所看到的，使用它的脚本显示<em class="ma"> bandit20 </em>，没有它的话— <em class="ma"> bandit19 </em>。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/44cf9cead7565fa3865949c4ebc142a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*2w03oEf0ifexdMK9HexPWA.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><strong class="bd kh">带和不带<strong class="bd kh"> setuid </strong>脚本的whoami </strong></figcaption></figure><p id="6ca8" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">现在，让我们运行一个更有用的命令，读取下一关的密码，该密码存储在文件<strong class="ld ir"> bandit20 </strong>内的<strong class="ld ir"> /etc/bandit_pass/ </strong>目录中，只有该用户可以读取。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/e271767d329a55d6b07340ede96b4a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*JJp9gI-vpkcymqL1OiP38w.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">读取下一关的密码</figcaption></figure><p id="d3aa" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">通过利用脚本，我们获得了<em class="ma"> bandit20 </em>用户的权限并读取了密码。让我们继续。</p><h2 id="dc67" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">20级→21级</h2><p id="ea5b" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">哇，这是一个很长的段落！</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/98e670fd1b7f14d58014d69133a9f68d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*RF_d6lyYtxUJqKPsWRVcAA.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">20级指令</figcaption></figure><p id="dc13" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">我们来总结一下。同样，我们有一个<strong class="ld ir"> setuid </strong>文件，它连接到<strong class="ld ir"> localhost </strong>的一个特定端口。然后，它读取收到的消息，并将其与当前级别的密码进行比较。提供的提示指导我们创建自己的“网络守护程序”——这意味着一个连接监听器，一个虚拟的“服务器”，我们将能够控制它，并因此向运行的<strong class="ld ir"> setuid </strong>脚本发送正确的密码。</p><p id="05fa" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">为了设置这个服务器，我们将使用<strong class="ld ir"> netcat </strong>:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/76ad9028d4c3eabbc3693980862baf03.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*wIcAw5NdM8lJs2kggfdm1Q.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">用<strong class="bd kh"> netcat </strong>设置虚拟服务器</figcaption></figure><p id="5752" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">我们已经处理了<strong class="ld ir"> netcat </strong>命令，但是让我们回顾一下参数的含义。<strong class="ld ir"> l </strong>声明我们想要监听传入的连接。<strong class="ld ir"> v </strong>代表verbose，我们提供它来告诉<strong class="ld ir"> netcat </strong>向我们显示尽可能多的数据。最后但同样重要的是，<strong class="ld ir"> p </strong>用于指定端口，稍后键入— 1234。</p><p id="7cfb" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">但是现在看起来我们好像被卡住了，因为netcat只是等待连接——但是我们应该发起连接，尽管如此！为了解决这个问题，我们将通过按Ctrl+Z暂停这个过程，在后台等待执行。现在，我们将使用适当的端口运行<strong class="ld ir"> setuid </strong>脚本:<code class="fe mb mc md me b">./suconnect 1234</code></p><p id="3e0c" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">同样，这也需要等待—记住，它需要检查从连接收到的消息。所以我们也需要暂停这个过程，回到上一个过程。再次，按Ctrl+Z。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/9c8565b889d99b981ff513db1b3e1e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*BIbpGInHR_6M4Rt9RVmifg.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">使用Ctrl+Z暂停进程</figcaption></figure><p id="f057" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">为了重新激活原来的进程，我们使用写在左边的数字—检索后台进程的命令是<strong class="ld ir"> fg {process number} </strong>，代表“前台”。在<code class="fe mb mc md me b">fg 1</code>之后，我们看到了我们所建立的联系的证据。现在，让我们发送20级的密码。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/8a6a643cb912b944cfb72a62f13c0b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*Kid1-WRppP6KBm1-DNB-mA.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">发送正确的密码</figcaption></figure><p id="2632" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">所有这些的目标是来自<strong class="ld ir"> suconnect </strong>脚本的输出——所以我们需要返回到。你已经知道如何暂停当前进程并移动另一个进程，它的编号是2。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/5c5ed8cab993235abae2427f69e49273.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*uWP8kfAYdJOftZJ0r37dnA.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">接收我们发送的密码</figcaption></figure><p id="520d" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">下一个密码已发送，因此我们将返回到<strong class="ld ir"> netcat </strong> one查看它。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/d7013c342bb9585b61569e48c9f461b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*B-Qwm2q6zYS1Dm2uWFuuxw.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">获取21级的密码</figcaption></figure><p id="adde" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">这就完成了。</p><h2 id="99a3" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">21级→22级</h2><p id="ad4f" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">我们来总结一下提供的细节:有一个相关的程序使用<strong class="ld ir"> cron </strong>定期运行——这是Linux的一个重要组成部分——它被称为作业调度器(job scheduler)，顾名思义，它管理在特定时间运行的进程。其设置和要执行的命令在<strong class="ld ir"> /etc/cron.d/ </strong>目录中指定，该目录配置<strong class="ld ir"> cron </strong>。让我们进入这个目录，看看里面有什么。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/34c503f5940258a55aed6c9777de2825.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*vJZts4bJaUDXt6IhQ5mvwQ.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">正在检查<strong class="bd kh"> /etc/cron.d/ </strong>目录</figcaption></figure><p id="93a1" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">我们可能应该检查的文件是对应于我们当前级别的文件。我们来读一下。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/81173d00ea81f5c04fc262735ef8eb4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*JmRAmC3lIpp_n-Ac6n_zkA.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><strong class="bd kh"> cronjob_bandit22 </strong>文件</figcaption></figure><p id="b5dd" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">这看起来像是毫无意义的咕哝，但是请耐心听我说:第一段定义了运行作业的频率/事件/时间——第一行指定在重新启动时执行，第二行指定“每分钟”。接下来，它提供负责的用户，然后是要运行的命令。在我们的例子中，一个脚本被执行，它的输出被丢弃(<strong class="ld ir"> /dev/null </strong>是一个文件，描述了一个丢弃所有写入它的信息的设备)。</p><p id="19e3" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">那很有趣！让我们自己来检查这个脚本。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/db7fc6659b21d087bdaebf314c7bb504.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*-Aw77a-RDSsZFI1d0fXhPw.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">读取脚本文件</figcaption></figure><p id="3a54" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">一个<strong class="ld ir">。Linux中的sh </strong>文件是一个可执行脚本，它能够执行我们习惯在命令行输入的命令。这个脚本有3行。他们的角色:</p><ol class=""><li id="f636" class="ng nh iq ld b le lv lh lw ko ni ks nj kw nk lt nl nm nn no bi translated">指定脚本的解释者——基本上是负责将脚本“翻译”成计算机可以理解的指令的人。这是bash shell，我们总是使用它，因此可以使用我们知道的常规命令。</li><li id="1dd8" class="ng nh iq ld b le np lh nq ko nr ks ns kw nt lt nl nm nn no bi translated">更改/tmp/t7O6lds9S0Rq的权限…..文件，这样每个人都可以阅读。我们现在就不深究权限了。</li><li id="29a2" class="ng nh iq ld b le np lh nq ko nr ks ns kw nt lt nl nm nn no bi translated"><em class="ma">有趣的部分:</em>读取存储22级密码的文件内容，并将输出重定向到/tmp目录中的文件。记住:第二行指定我们被允许读取这个文件！</li></ol><p id="8ce2" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">因此，我们需要做的就是读取相关文件并找到密码:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ce575696dbf2fe55899bd954c1f65c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*1cJYDFHRWBePxie4KEeePQ.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">获取22级的密码</figcaption></figure><p id="651f" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">恭喜你！我们做到了。现在保留这个密码，直到下一篇文章:)</p><h2 id="298f" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h2><p id="dc10" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">我们在本文中解决的几个层次向我们介绍了关于Linux OS的更高级的概念和方面。我们逐渐发现越来越多的，运行世界的操作系统的主要部分:<strong class="ld ir"> setuid，cron，暂停和恢复进程… </strong></p><p id="3c68" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">我希望通过这篇文章，您已经学习并提高了您的Linux技能。如前所述，我祈祷你也玩得开心！请留下一些评论，让我知道你更喜欢我做什么，或者希望我报道什么。</p><p id="ae18" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">我必须感谢你们每一个阅读我帖子的人——你们太棒了。现在再见。祝你玩得愉快，直到我们再次见面！</p></div></div>    
</body>
</html>