<html>
<head>
<title>BUFFER OVERFLOW</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓冲区溢出</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/exploiting-stack-buffer-overflows-over-functions-670765bf405a?source=collection_archive---------4-----------------------#2021-04-16">https://infosecwriteups.com/exploiting-stack-buffer-overflows-over-functions-670765bf405a?source=collection_archive---------4-----------------------#2021-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8bcae1422f4e46458ba52bdd60239ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QQuUz5UaaSh9RHhc-tyJlQ.png"/></div></div></figure><div class=""/><p id="b51b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当数据的大小超过内存缓冲区的存储容量时，就会发生缓冲区溢出</p><p id="e03d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，程序会尝试将数据写入缓冲区，覆盖更近的内存位置指令指针(IP)、基指针(BP)</p><p id="0c14" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">C和C++是两种非常容易受到缓冲区溢出攻击的语言，因为它们没有内置的保护措施来防止覆盖或访问内存中的数据</p><p id="bdd9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Mac OSX、Windows和Linux都使用C和C++编写的代码。</p><h1 id="6ef2" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是缓冲区？</h1><p id="3c0d" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">缓冲区是在数据从一个位置传输到另一个位置时临时保存数据的内存存储区域</p><h1 id="87d5" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">原因和缓解措施</h1><p id="7969" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">缓冲区溢出由用户输入触发</p><p id="dc2f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于缓冲区溢出漏洞，开发人员必须在使用任何可能导致溢出的函数之前检查输入长度</p><p id="0a07" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些攻击是由C #中易受攻击的函数引起的</p><p id="c5e9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下五种常见的不安全函数会导致缓冲区溢出漏洞:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d3a1" class="mi kx jb me b gy mj mk l ml mm">printf, sprintf, strcat, strcpy, and gets.</span></pre><p id="a88d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，基本C语言只提供了一种安全的选择:fgets(用来代替gets)。各种平台都有其非标准的实现。例如，微软版本的C包括sprintf_s、strcpy_s和strcat_s</p><p id="374a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以通过使用使用“金丝雀”的编译器扩展来防止缓冲区溢出</p><p id="1ca2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">金丝雀是编译器放在堆栈上缓冲区位置和控制数据位置之间的特殊值</p><p id="e489" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当发生缓冲区溢出时，首先损坏的是金丝雀，这种损坏可以立即检测出来</p><h1 id="4492" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">存储配置</h1><p id="aab1" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">堆栈中二进制文件的内存布局可以表示为</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mn"><img src="../Images/3502a8cccc2136d413d0ad0324037fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NLSiDgxCJfNxfPKn.png"/></div></div></figure><p id="3e15" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从较低的内存到较高的内存，缓冲区空间向基址指针(BP)和指令指针(IP)增长</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/8fda9048a7f06cab90e7dc1723bf2de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/0*hFMIMTtuGzmkRINp.png"/></div></figure><p id="abef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在基址指针(BP)下面将有指令指针(IP)/返回地址</p><p id="fd23" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">程序的堆栈组件总是存储在基址指针(BP)之上</p><h1 id="020c" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">例子</h1><p id="0e4e" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们考虑这个简单的程序</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/86755ba58feda152be6e161e8433c117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wxcdJDTtzeQN7EkF.png"/></div></div></figure><p id="d2c0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将此编译为二进制</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/bbb797ebd1bc1d5c075c6937e0a053dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tjwHHL32XPCl5UQB.png"/></div></div></figure><p id="5542" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们为32字节的char数组变量声明了一个“缓冲”空间</p><p id="555a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以从理论上讲，这个变量的缓冲空间应该只能容纳32个字节</p><p id="4e94" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过传递随机长度的输入来检查它</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mr"><img src="../Images/ac97cb1c59f6eaf14da9c7c559b0d86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-O0ss7dClQSN1WEp.png"/></div></div></figure><p id="24eb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们传递小于32字节的输入，它可以完美地运行</p><p id="ff12" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果超过了这个大小限制，它将从“缓冲区”的起始空间存储这个输入，并在输入数据结束的内存中结束</p><p id="285c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个大小之前，我们的输入可以覆盖堆栈内存中的缓冲空间</p><p id="b97c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这导致了一个严重的缺陷，攻击者可以通过它来改变程序的轨迹</p><p id="44c3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们覆盖一些重要的寄存器，如指令指针(IP)和基指针(BP)时，它指向一个可被利用的地址</p><p id="f41b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果地址没有意义，它会给出“错误”(分段错误/检测到堆栈崩溃/核心转储)</p><p id="1b30" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在输入值的帮助下，我们可以正确地重写这些重要的寄存器，以实现我们期望的任务/功能</p><h1 id="0bbe" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">剥削</h1><p id="b465" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们看看如何使用堆栈中的缓冲区溢出从内存中调用另一个函数</p><p id="f825" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个程序中，我们可以看到一个名为“hidden”的函数，它没有在“main()”中被调用</p><p id="d3bb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以实际的程序应该接收输入并将其作为输出打印出来</p><p id="0a99" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它不应该显示“hidden()”里面的内容</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ms"><img src="../Images/c6f23472038d240c558f4bb1a87d9a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UXGQa7shck90egmw.png"/></div></div></figure><p id="0e11" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要在Linux中测试基于堆栈的缓冲区溢出，您需要编译带有某些标志的源代码，以启用“禁用堆栈保护和堆栈执行”</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mt"><img src="../Images/e55ef73167bece258021c98eac4a71e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YDmUdfzhIx4ge1wl.png"/></div></div></figure><h1 id="5fef" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第一步:检查ASLR</h1><p id="93a5" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这里我们用一个调试行来打印“hidden()”函数的地址</p><p id="c357" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当需要调用这个函数时，我们的二进制使用ASM中的“call address_of_hidden()”来运行“hidden()”</p><p id="3e25" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个程序无论何时被调用都会打印出“hidden()”的随机地址</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/e5c80a648f83d503a3fb7b76d55b54ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nwakn-Ywm38DyCDI.png"/></div></div></figure><p id="8205" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为ASLR存在于机器中</p><h2 id="213f" class="mi kx jb bd ky mv mw dn lc mx my dp lg kj mz na lk kn nb nc lo kr nd ne ls nf bi translated">ASLR(地址空间布局随机化)</h2><blockquote class="ng nh ni"><p id="2ee5" class="jy jz nj ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><code class="fe nn no np me b">Address space layout randomization (ASLR) is a memory-protection process for operating systems (OSes) that guards against buffer-overflow attacks by randomizing the location where system executables are loaded into memory</code></p></blockquote><p id="d89d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们禁用ASLR来获取“hidden()”的固定地址，以成功执行缓冲区溢出攻击</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/5a1fd8eaa2641c43b4e08d548711164a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xAUjlaSuOrla1ZtL.png"/></div></div></figure><p id="9642" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在ASLR被禁用了</p><p id="5e8b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们检查“hidden()”的地址</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/9f89bb48ba3919ab2f945677287e95a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uOlU58SUWyRZ19tb.png"/></div></div></figure><p id="2142" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论我们运行多少次，当我们试图运行程序时，它总是给我们固定的地址“hidden()”，因为ASLR是禁用的</p><h1 id="5462" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第二步:使程序崩溃</h1><p id="701d" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当所有的保护都被禁用时，尝试用随机大小的输入使程序崩溃</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/4d2d191190b0a90c47d9df46ec464d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xsXlcSulKaj4XLQP.png"/></div></div></figure><p id="3f33" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到，由于传递的输入大于缓冲区的大小，这个程序也崩溃了</p><p id="b4fe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以使用“dmesg”查看带有陷阱的崩溃</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/ccf4f3d03d0f213bbdd724b0c1a8bab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dJ7kHXavOqXMsfqR.png"/></div></div></figure><p id="c0bd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看到这一点，我们可以得出结论，这个程序容易受到缓冲区溢出攻击</p><h1 id="ca73" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤3:寻找偏移</h1><p id="292e" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们传递输入数据来使程序崩溃，并在GDB调试器中测试它</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/d9aed856f0b37b1b5e6f25380cde85e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*swLc3sWpojui7JZt.png"/></div></div></figure><p id="e9ff" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，当我们在输入中传递随机垃圾“A”时，会导致错误</p><p id="ddaf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且在崩溃期间，基指针(BP)值被设置为0x4141414141414141</p><p id="c0f5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们可以说我们的垃圾输入覆盖了基址指针(BP)寄存器</p><p id="2146" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要找到基本指针(BP)的偏移量(位置),这样我们就可以精确地设计我们的有效载荷</p><p id="1a8b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用“GDB-PEDA”创建一个100字节的随机模式，并通过程序传递它</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/7e1499c60993ecfe73030ecf15c7d4a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m5G0PwWaXrKNOF_X.png"/></div></div></figure><p id="c99e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的模式溢出了缓冲区空间和基指针(BP ),导致了一个错误</p><p id="ab1f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们可以看到我们的基本指针(BP)被一个来自我们作为输入传递的模式的随机值填充</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/d16e033e7cd2930d8cab394cf37407c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KLDfTACngp2Sctd0.png"/></div></div></figure><p id="616e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个值是我们传递的模式的一部分</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/c0b5f27acc7be985907bb910fe640714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FqZ88WrdCZV_UQGU.png"/></div></div></figure><p id="a818" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这个值可以用来找到我们的基指针(BP)的偏移量</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/5345d279fb511dc4431b578b4e4a47af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/0*XQC1GbHvb14aoPjV.png"/></div></div></figure><p id="c38b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过计算偏移量，我们的基本指针(BP)内存在64字节的“缓冲”内存后开始</p><h1 id="df21" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤4:控制指令指针</h1><p id="36a2" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们知道我们的基本指针(BP)从哪里开始</p><p id="028b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">紧挨着基址指针(BP)的是指令指针(IP)</p><h2 id="faa1" class="mi kx jb bd ky mv mw dn lc mx my dp lg kj mz na lk kn nb nc lo kr nd ne ls nf bi translated">指令指针</h2><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0b0b" class="mi kx jb me b gy mj mk l ml mm">It is a register responsible for storing the address of next instruction which is needed to be executed in stack</span></pre><p id="fb3e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有缓冲区溢出攻击的主要目标是覆盖指令指针(IP ),这可以帮助攻击者将程序重定向到他们的目的</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="a40d" class="mi kx jb me b gy mj mk l ml mm">We know that for x64 architecture,</span><span id="937c" class="mi kx jb me b gy ny mk l ml mm">BasePointer (BP)&gt;8 bytes</span><span id="9f85" class="mi kx jb me b gy ny mk l ml mm">InstructionPointer(IP)&gt;6bytes</span><span id="a65c" class="mi kx jb me b gy ny mk l ml mm">'A' in hex---&gt; 0x41</span><span id="b26d" class="mi kx jb me b gy ny mk l ml mm">'B' in hex---&gt; 0x42</span></pre><p id="93b7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们传递一个在python的帮助下精心制作的输入，以检查我们是否可以覆盖IP</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/4ea7e9c34e624b6231118ad2fb82564a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iZtkgSz8Zdex96lz.png"/></div></div></figure><p id="40ba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们有A要加到BP</p><p id="09ff" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和8个B来填充BP</p><p id="a340" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和6个B来填充IP</p><p id="3ed2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们传递这个输入并检查它</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/8034f78c825eb5635406f0d0e6c16903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XcvkL_4NINrNm8IJ.png"/></div></div></figure><p id="5c88" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们可以看到BP和IP被成功覆盖</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/3412d18f85405661c22db4903bccdbb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/0*6Yru9SvAw5zpVkS-.png"/></div></figure><h1 id="af3a" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤5:利用有效负载</h1><p id="8b49" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在，我们已经验证了我们可以成功覆盖IP</p><p id="f422" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了生成函数“hidden()”，我们需要使用IP来调用它</p><p id="d386" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当IP地址指向“hidden()”时，它执行“hidden()”中的内容，并根据堆栈分配寄存器，继续执行</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/87a864e456f2fd5911018983653a4a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R6CWzMjnvm2gq-n3.png"/></div></div></figure><p id="8ce5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们使用的是“小端字节序”,所以我们的地址应该以相反的顺序表示</p><p id="e376" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们测试有效载荷</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oc"><img src="../Images/45abe427ea852e4cc6000055226ce0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mS1LN-tGVQ3IZw9t.png"/></div></div></figure><p id="8563" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们可以看到我们的“hidden()”函数已经成功地通过了pwn</p><p id="7289" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在调试器中尝试一下</p><figure class="lz ma mb mc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi od"><img src="../Images/d5caba36f633b3b31d2c80da7cda61a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ttFGpJlFASuSMEdz.png"/></div></div></figure><h2 id="79cd" class="mi kx jb bd ky mv mw dn lc mx my dp lg kj mz na lk kn nb nc lo kr nd ne ls nf bi translated">剥削结束了</h2><h2 id="83ee" class="mi kx jb bd ky mv mw dn lc mx my dp lg kj mz na lk kn nb nc lo kr nd ne ls nf bi translated">执行堆栈缓冲区溢出</h2><h2 id="df94" class="mi kx jb bd ky mv mw dn lc mx my dp lg kj mz na lk kn nb nc lo kr nd ne ls nf bi translated">GitHub Repo中提供了漏洞利用示例</h2><h2 id="68cc" class="mi kx jb bd ky mv mw dn lc mx my dp lg kj mz na lk kn nb nc lo kr nd ne ls nf bi translated"><a class="ae oe" href="https://github.com/AidenPearce369/ExploitDev" rel="noopener ugc nofollow" target="_blank">aiden peace 369</a></h2></div></div>    
</body>
</html>