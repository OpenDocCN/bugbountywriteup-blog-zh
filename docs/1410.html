<html>
<head>
<title>One Time Code Bypass With An Inverted Brute-Force Attack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用反向暴力攻击的一次性代码旁路</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/one-time-code-bypass-with-an-inverted-brute-force-attack-7c5a270196d1?source=collection_archive---------2-----------------------#2021-06-18">https://infosecwriteups.com/one-time-code-bypass-with-an-inverted-brute-force-attack-7c5a270196d1?source=collection_archive---------2-----------------------#2021-06-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><p id="025b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">“我们已经向您的电子邮件地址发送了一个六位数的代码。请在下面输入以登录。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/82b9cc19217b2244ac1e2752a5678001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QzzfWpii-UkLsXj9"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">阿尔文·列宁的照片在<a class="ae lf" href="https://unsplash.com/s/photos/glass-ball?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="7d3c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在测试web应用程序时，我们总是会看到它们。为了验证您的身份，该应用程序会向您注册的电子邮件地址或电话号码发送一个6位数字代码。目的是证明执行该动作的人也拥有该动作所附的电话或邮箱。没有权限，没有授权。给进程增加一点额外的安全性是第二个有用的因素。</p><p id="9640" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">如果你试着猜密码，它会在5次左右的尝试后失效。猜对的几率是5/100万，或者1/20万(0.0005%)。前5个之后的任何猜测都是无效的。这可以防止您强行使用从000000到999999的所有1，000，000个组合。</p><p id="71c9" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">听起来很安全，对吧？嗯，有可能。但有时开发人员会在他们的假设中犯错误。这是我最喜欢测试的一个错误，以及如何利用它。</p><h1 id="493d" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">一次性代码或pin(OTC或OTP)的标准使用</h1><p id="831a" class="pw-post-body-paragraph jr js iu jt b ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko in bi translated">在正常使用中，用户执行一个操作，生成一个一次性代码，发送到他们的电子邮件地址或电话号码。他们拿起手机，读取密码，第一次就输入正确。任务完成。</p><p id="297f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">当攻击者试图对受害者的帐户做同样的事情时，代码会被发送到所有者的设备。攻击者看不到代码，他们唯一的选择是试图猜测它。他们输入5个不同的代码，服务器使生成的OTC无效。无论从现在开始发生什么，即使他们尝试了剩下的999，995种可能的组合，也没有一种有效。如果他们生成另一个不同的代码，他们仍然只有5次尝试。</p><p id="9fdc" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">对尝试次数的限制已经奏效。</p><p id="efaf" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">上面的问题是，它只限制了对单个代码的猜测次数。它可以防止你对一个代码进行1，000，000次猜测并强行进入。</p><p id="0f0b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我最喜欢的攻击之一是强行生成代码，而不是代码本身。它是这样工作的。</p><h1 id="4e78" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">我们只需要一个匹配</h1><p id="9d45" class="pw-post-body-paragraph jr js iu jt b ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko in bi translated">对于OTC验证，我们不需要攻击者猜测服务器生成的代码，我们只需要攻击者和服务器都同意匹配相同的6位数。</p><p id="98e4" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">OTC验证在服务器端是一个两步过程。</p><ol class=""><li id="75e9" class="mj mk iu jt b ju jv jy jz kc ml kg mm kk mn ko mo mp mq mr bi translated">生成OTC并将其发送给账户所有人</li><li id="1353" class="mj mk iu jt b ju ms jy mt kc mu kg mv kk mw ko mo mp mq mr bi translated">从用户处接收OTC，并将其与生成的值进行比较</li></ol><p id="8f75" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">标准的强力攻击是在服务器端对一个代码尝试所有1，000，000个六位数代码。通过将生成的代码设置为在5次尝试后过期，开发人员对步骤2应用了速率限制。</p><p id="e566" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">相反，攻击者可以通过使用相同的静态代码并迫使服务器生成多达200，000次的新代码来颠倒这种逻辑。这利用了步骤1中速率限制的缺乏。</p><p id="c3ed" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">为简单起见，下面是一个只有一个代码645274的示例:</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/2abe94de926e7589bc1a5da9a2c4cab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-L28gU8tT72O2Kx3"/></div></div><figcaption class="lb lc gk gi gj ld le bd b be z dk translated">对一次性代码验证和生成的暴力攻击进行比较</figcaption></figure><p id="031b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">据统计，对6位数字代码进行5次尝试匹配的几率是200，000分之一。因此，通过在任何地方循环多达200，000次迭代，我们可能会看到攻击者和服务器同意匹配，绕过第二个因素的验证。</p><p id="5fec" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这种攻击的循环如下:</p><pre class="kq kr ks kt gu mx my mz na aw nb bi"><span id="a9ed" class="nc lh iu my b gz nd ne l nf ng">While (NotAMatch){ <br/>  GenerateNewCode() <br/>  SendCode1() <br/>  SendCode2() <br/>  SendCode3() <br/>  SendCode4() <br/>  SendCode5() <br/>}</span></pre><h1 id="29f0" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">计算机、随机性和选择要使用的OTC</h1><p id="5798" class="pw-post-body-paragraph jr js iu jt b ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko in bi translated">因为计算机在生成随机数方面很糟糕，所以这种几率可能远远高于20万分之一。在测试这种类型的bug时，我首先确定在生成的一次性代码过期之前我们尝试了多少次。然后，我生成相同数量的不同一次性代码，通常在5到10之间。然后我将所有这些代码用于我的静态列表。</p><p id="09e5" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">通过这样做，我知道我正在使用计算机已经生成的代码。电脑不擅长产生随机数。实际上，math.random()实际上只是一个很长的、预先确定的列表中的一个值，可能会对它执行一些进一步的计算。如果我知道一个代码已经生成过一次，我就知道它可以再次生成。</p><h1 id="cc37" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">影响</h1><p id="e511" class="pw-post-body-paragraph jr js iu jt b ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko in bi translated">像这样的错误的影响取决于一次性代码保护的是什么。如果是登录帐户，您可能会发现一个MFA旁路。如果它是为了验证你的电子邮件地址或电话号码，它可能只是一个次要控制的旁路。如果那个“验证过的”电子邮件地址或电话号码后来被用来将一个账户与另一个账户联系起来，那就完全是另外一种情况了，而且可能会更加严重。</p><p id="fda9" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">如果你发现了这样一个bug，在把你的报告提交给bug奖励计划之前，要创造性地探索潜在的影响。您对影响的描述可能是低评级漏洞和关键报告之间的唯一区别。</p></div><div class="ab cl nh ni hy nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="in io ip iq ir"><p id="a609" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">与我私人电子邮件列表中的其他人一起关注我的最新文章、视频、想法等。</p></div><div class="ab cl nh ni hy nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="in io ip iq ir"><p id="7520" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="no">原载于2021年6月18日</em><a class="ae lf" href="https://craighays.com/one-time-code-bypass-with-an-inverted-brute-force-attack/" rel="noopener ugc nofollow" target="_blank"><em class="no">【https://craighays.com】</em></a><em class="no">。</em></p></div></div>    
</body>
</html>