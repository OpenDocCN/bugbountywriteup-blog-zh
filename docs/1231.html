<html>
<head>
<title>Detecting Jakarta Expression Language injections with CodeQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用CodeQL检测Jakarta表达式语言注入</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/detecting-jakarta-expression-language-injections-with-codeql-41c25d45cdb3?source=collection_archive---------3-----------------------#2021-04-14">https://infosecwriteups.com/detecting-jakarta-expression-language-injections-with-codeql-41c25d45cdb3?source=collection_archive---------3-----------------------#2021-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="19c2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用CodeQL查找EL注入并修复它们</h2></div><p id="690e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近我写了一篇关于<a class="ae le" href="https://betterprogramming.pub/expression-language-injections-in-java-e08bd17addf4" rel="noopener ugc nofollow" target="_blank">用CodeQL </a>检测JEXL注射剂的帖子。JEXL是一个为简单表达式语言(EL)提供解释器的库。这一次，我将讨论使用Jakarta表达式语言的注入，以及如何使用CodeQL找到它们。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/fd4eafe4639771656f82d515b60fd824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*mKQZejy2Ib97Z5zQmWuFXQ.png"/></div></figure><h1 id="104e" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">雅加达表情语言是什么？</h1><p id="43dc" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">其中，Jakarta EE包含了表达式语言(EL)的规范，并为解释器定义了API。Jakarta EL是一种特殊用途的编程语言，主要用于在web应用程序中嵌入和计算网页中的表达式。但是解释器可以简单地用在任何其他地方。这些API有多种实现方式，例如:</p><ul class=""><li id="7e82" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated"><a class="ae le" href="http://juel.sourceforge.net/" rel="noopener ugc nofollow" target="_blank">朱尔</a></li><li id="66f6" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae le" href="https://commons.apache.org/dormant/commons-el/" rel="noopener ugc nofollow" target="_blank"> Apache Commons EL </a></li></ul><p id="63d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下示例显示了如何使用JUEL运行表达式:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="60bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对了，雅加达EE过去是Java EE。最初，EL的API位于包<code class="fe na nb nc nd b">javax.el</code>中。在Eclipse Foundation接管Java EE之后，这个包被重命名为<code class="fe na nb nc nd b">jakarta.el</code>。</p><h1 id="4c53" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">什么是表情语言注入？</h1><p id="7124" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">EL相当强大。特别是，它允许调用JVM中可用的方法。这很危险。如果使用不受信任的数据构建表达式，然后对其求值，在最坏的情况下，它可能允许攻击者运行任意代码。这就是所谓的表达式语言注入漏洞。</p><p id="4d26" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">影响通常很大，因为攻击者可以在JVM内部甚至外部运行几乎任何代码。成功攻击的可能性取决于攻击者注入恶意表达式的方式。在最坏的情况下，应用程序会收到来自未经身份验证的远程用户的表达式。例如，它可以从HTTP请求中读取它。这很可能导致远程代码执行(RCE)。</p><p id="6dbb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个易受攻击的代码示例。它只是从一个HTTP请求中获取一个表达式，然后立即运行它(还是用JUEL):</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="2d40" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">防止雅加达EL注射</h1><p id="23a0" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">如果可能的话，我宁愿避免在应用程序中使用Jakarta EL。如果表达式确实是必需的，那么只有授权用户才能运行它们。在限制性的沙箱中评估表达式也不错，但不幸的是，Jakarta EL规范没有为沙箱定义任何API。因此，解释器不实现任何沙箱。代替Jakarta EL，您可以考虑使用另一个允许定义沙箱的EL。比如阿帕奇JEXL。这篇文章有几个例子展示了如何用JEXL 实现沙箱。</p><p id="689b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了防止运行任意代码，在将传入的数据包含在表达式中之前，也可以对其进行检查。以下示例使用Regex模式来检查用户是否试图运行允许的表达式:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="4ed0" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">用于检测雅加达EL注射的CodeQL查询</h1><p id="6d8d" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated"><a class="ae le" href="https://securitylab.github.com/tools/codeql" rel="noopener ugc nofollow" target="_blank"> CodeQL </a>是一个代码分析引擎。它允许您为代码编写查询来检测各种问题，包括安全问题。让我们看看它如何帮助我们检测雅加达EL注射。</p><p id="c4c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CodeQL可以搜索从源到指定接收器的数据流。在Jakarta EL注入的情况下，接收器是计算表达式的方法调用，例如，<code class="fe na nb nc nd b">ValueExpression.getValue()</code>、<code class="fe na nb nc nd b">MethodExpression.invoke()</code>、<code class="fe na nb nc nd b">ELProcessor.eval()</code>等。最有趣的数据源是远程用户可用的数据源。例如，HTTP请求和网络套接字。从远程源到雅加达EL接收器之一的数据流可能是潜在的EL注入。我已经在<a class="ae le" href="https://github.com/github/codeql/pull/5471" rel="noopener ugc nofollow" target="_blank">这个CodeQL查询</a>中实现了这个想法(它已经被添加到了<a class="ae le" href="https://github.com/github/codeql/blob/main/java/ql/src/experimental/Security/CWE/CWE-094/JakartaExpressionInjection.ql" rel="noopener ugc nofollow" target="_blank">实验性的</a>查询集中)。让我们看看它是如何工作的。</p><p id="33b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，有一个配置用于跟踪从远程数据源到Jakarta EL sinks的污染数据:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f2b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它有三个主要组成部分:</p><ul class=""><li id="9a20" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated"><code class="fe na nb nc nd b">isSource()</code>谓词定义了数据源。它使用类<code class="fe na nb nc nd b">RemoteFlowSource</code>来描述网络套接字、HTTP请求和CodeQL核心库知道的其他远程数据源。</li><li id="ff4d" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><code class="fe na nb nc nd b">isSink()</code>谓词定义数据汇。它使用了类<code class="fe na nb nc nd b">ExpressionEvaluationSink</code>,该类列出了评估表达式的方法调用。</li><li id="4847" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">谓词告诉CodeQL引擎如何传播被感染的输入。</li></ul><p id="119d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里最有趣的是<code class="fe na nb nc nd b">ExpressionEvaluationSink</code>。让我们来看看:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b88f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，该类描述了立即计算表达式的方法:</p><ul class=""><li id="22e4" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated"><code class="fe na nb nc nd b">ValueExpression</code>中的<code class="fe na nb nc nd b">getValue()</code>和<code class="fe na nb nc nd b">setValue()</code>方法</li><li id="7c9a" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><code class="fe na nb nc nd b">invoke()</code><code class="fe na nb nc nd b">MethodExpression</code>和<code class="fe na nb nc nd b">LambdaExpression</code>中的方法</li><li id="d7e5" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><code class="fe na nb nc nd b">ELProcessor</code>中的<code class="fe na nb nc nd b">eval()</code>、<code class="fe na nb nc nd b">getValue()</code>和<code class="fe na nb nc nd b">setValue()</code>方法</li></ul><p id="f655" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，这个类提到了方法<code class="fe na nb nc nd b">ELProcessor.setVarialbe()</code>,它不直接计算表达式，而是将表达式赋给一个变量。该查询假设在使用变量时，注入的代码可能会晚一点运行。</p><p id="1e66" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谓词<code class="fe na nb nc nd b">isAdditionalTaintStep()</code>定义了另外两种传播被感染数据的方法:</p><ul class=""><li id="0bf0" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated"><code class="fe na nb nc nd b">TaintPropagatingCall</code>定义了创建<code class="fe na nb nc nd b">ValueExpression</code>、<code class="fe na nb nc nd b">MethodExpression</code>和<code class="fe na nb nc nd b">LambdaExpression</code>对象的方法调用。</li><li id="cac1" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><code class="fe na nb nc nd b">hasGetterFlow()</code>谓词定义了对可能保存被污染数据的对象上的getters的调用。当数据存储在复杂对象中时，该谓词有助于识别问题。然而，它没有考虑到数据是如何在这些对象内部流动的。因此，它可能会导致假阳性。</li></ul><p id="4590" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该查询在OpenFaces 中检测到一个已知的<a class="ae le" href="https://github.com/TeamDev-Archive/OpenFaces/issues/175" rel="noopener ugc nofollow" target="_blank"> RCE。</a></p><h1 id="fb39" class="ln lo it bd lp lq lr ls lt lu lv lw lx jz ly ka lz kc ma kd mb kf mc kg md me bi translated">参考</h1><ul class=""><li id="eb8b" class="mk ml it kk b kl mf ko mg kr ne kv nf kz ng ld mp mq mr ms bi translated"><a class="ae le" href="https://projects.eclipse.org/projects/ee4j.el" rel="noopener ugc nofollow" target="_blank">雅加达表情语言</a></li><li id="34a4" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae le" href="https://javadoc.io/doc/jakarta.el/jakarta.el-api/latest/index.html" rel="noopener ugc nofollow" target="_blank">雅加达表达式语言API </a></li><li id="524f" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated"><a class="ae le" href="https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection" rel="noopener ugc nofollow" target="_blank"> OWASP:表达式语言注入</a></li></ul></div></div>    
</body>
</html>