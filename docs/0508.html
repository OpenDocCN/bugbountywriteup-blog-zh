<html>
<head>
<title>How I exploit the JSON CSRF with method override technique</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何利用方法覆盖技术开发JSON CSRF</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/how-i-exploit-the-json-csrf-with-method-override-technique-71c0a9a7f3b0?source=collection_archive---------1-----------------------#2020-03-07">https://infosecwriteups.com/how-i-exploit-the-json-csrf-with-method-override-technique-71c0a9a7f3b0?source=collection_archive---------1-----------------------#2020-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/></div><div class="ab cl jq jr hx js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="im in io ip iq"><h1 id="9b11" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">简介——CSRF:</h1><p id="92b7" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><strong class="kx iu"> CSRF(跨站请求伪造)</strong>是一种web应用漏洞，利用这一点恶意用户可以在用户不知情的情况下伪造HTTP请求。这将导致web应用程序中出现严重的安全缺陷。</p><p id="a6af" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">在这篇文章中，我将解释如何识别JSON CSRF漏洞，以及我在最近的一个项目中升级这个漏洞所面临的挑战。</p><p id="2439" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">一般来说，JSON CSRF并不总是能够在每个使用JSON主体的web应用程序中实现。这主要取决于认证机制。为了识别这一点，我们必须确保HTTP请求满足以下条件。</p><ol class=""><li id="1d70" class="ly lz it kx b ky lt lc lu lg ma lk mb lo mc ls md me mf mg bi translated">身份验证机制应该是基于cookie的模型。(默认情况下，基于cookie的身份验证容易受到CSRF攻击)</li><li id="3e32" class="ly lz it kx b ky mh lc mi lg mj lk mk lo ml ls md me mf mg bi translated">HTTP请求不应该在消息头和消息体中使用自定义的随机标记来增强。</li><li id="572d" class="ly lz it kx b ky mh lc mi lg mj lk mk lo ml ls md me mf mg bi translated">HTTP请求不应该被<a class="ae mm" href="https://www.netsparker.com/whitepaper-same-origin-policy/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu">同源策略加强。</strong> </a></li></ol><blockquote class="mn mo mp"><p id="35dc" class="kv kw mq kx b ky lt la lb lc lu le lf mr lv li lj ms lw lm ln mt lx lq lr ls im bi translated">“如果满足上述条件，我们可以通过简单地从另一个<strong class="kx iu">源发出Ajax请求来直接伪造JSON请求。</strong>”</p></blockquote><p id="06fd" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated"><strong class="kx iu">注:</strong>这些是实现JSON中CSRF的首要条件。但是有可能利用<strong class="kx iu"> JSON CSRF </strong>即使<strong class="kx iu">第二点和第三点</strong>不满足。</p><h1 id="5194" class="jx jy it bd jz ka mu kc kd ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku bi translated">我在最近的Bug Bounty中利用JSON CSRF所面临的挑战:</h1><h2 id="3392" class="mz jy it bd jz na nb dn kd nc nd dp kh lg ne nf kl lk ng nh kp lo ni nj kt nk bi translated"><strong class="ak">观察:</strong></h2><p id="7361" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">每当我测试web应用程序时，我都会仔细观察应用程序的身份验证机制。如果这是基于cookie的认证，那么我直接寻找CSRF漏洞。</p><p id="365e" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">如上所述，第一点满足了以下要求。但是第二个和第三个不满意。请求通过由'<strong class="kx iu"> X-Auth-Token </strong>'标头指定的自定义令牌得到加强，并且还验证了<a class="ae mm" href="https://www.netsparker.com/whitepaper-same-origin-policy/" rel="noopener ugc nofollow" target="_blank">来源</a>标头。请仔细观察下面的图片。</p><figure class="nm nn no np gt nq gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nl"><img src="../Images/ff53b5659adb8baed088c6fd53276f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CFjGNhszy9z_uQCFVevd2A.png"/></div></div></figure><figure class="nm nn no np gt nq gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nx"><img src="../Images/dcaa22bb285da8cfb7b6abfb178631d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zskzA_AGKQpgn0sejxGD1w.png"/></div></div></figure><figure class="nm nn no np gt nq gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi ny"><img src="../Images/37b1e04be9935420b416531b1c1c529b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQdVoxgESeb5sw_Kt2EagQ.png"/></div></div></figure><p id="92ef" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">一般来说，我会在推特上关注<strong class="kx iu"> bug赏金提示</strong>。因此，我有一些其他的测试案例来检查请求的强化机制。</p><p id="926e" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">这些提示是:</p><ul class=""><li id="ff07" class="ly lz it kx b ky lt lc lu lg ma lk mb lo mc ls nz me mf mg bi translated">将请求方法更改为GET append body作为查询参数。</li><li id="19ee" class="ly lz it kx b ky mh lc mi lg mj lk mk lo ml ls nz me mf mg bi translated">在没有<strong class="kx iu">定制令牌和报头的情况下测试请求。</strong></li><li id="d335" class="ly lz it kx b ky mh lc mi lg mj lk mk lo ml ls nz me mf mg bi translated">用完全相同的长度但不同的令牌测试请求。</li></ul><blockquote class="mn mo mp"><p id="32c5" class="kv kw mq kx b ky lt la lb lc lu le lf mr lv li lj ms lw lm ln mt lx lq lr ls im bi translated">幸运的是，第二个建议对我有效:)</p></blockquote><p id="80e4" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">应用程序正在接受请求，但请求中没有“X-Auth-Token:”标头。</p><figure class="nm nn no np gt nq gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi oa"><img src="../Images/5b42dbbcf0651e12f73930381b82cd02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BaiKhCG6WIBRJcaZVfQpuQ.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">授权令牌验证</figcaption></figure><p id="2702" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">即使应用程序有<strong class="kx iu">令牌头验证</strong>缺陷。我们不能利用这个漏洞，因为请求在<strong class="kx iu"> PUT方法</strong>中，并且服务器验证了请求中的<strong class="kx iu"> Origin报头</strong>。</p><blockquote class="mn mo mp"><p id="fd6b" class="kv kw mq kx b ky lt la lb lc lu le lf mr lv li lj ms lw lm ln mt lx lq lr ls im bi translated">“如果服务器接受另一个源头，我们可以用另一个源的PUT方法用JSON主体发出一个Ajax请求。”</p></blockquote><p id="c740" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated"><strong class="kx iu"> <em class="mq">现在我们要寻找另一个漏洞来利用这个漏洞</em> </strong> <em class="mq">。</em></p><p id="469b" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">经过一些分析，我得到了下面的问题</p><ol class=""><li id="1479" class="ly lz it kx b ky lt lc lu lg ma lk mb lo mc ls md me mf mg bi translated">如果我将此作为POST请求而不使用<strong class="kx iu"> Origin头，会发生什么情况。？</strong></li></ol><figure class="nm nn no np gt nq gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi ny"><img src="../Images/e8064eacb950769cc88505a5715c11f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C421TwXQ74m37hAvSBXK4A.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">过帐方法检查</figcaption></figure><p id="cdd3" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">服务器不允许使用<strong class="kx iu"> POST </strong>方法。</p><figure class="nm nn no np gt nq gh gi paragraph-image"><div class="gh gi of"><img src="../Images/ae31ad05ef94e684ab0b769ec0c6ba82.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*qdcOyQsZW9QVUm3lAH0YnQ.jpeg"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">他妈的…</figcaption></figure><p id="af01" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">没问题，有一种技术可以通过<strong class="kx iu">方法覆盖函数来观察服务器的行为。</strong></p><blockquote class="mn mo mp"><p id="fc66" class="kv kw mq kx b ky lt la lb lc lu le lf mr lv li lj ms lw lm ln mt lx lq lr ls im bi translated">雅虎！服务器接受了方法覆盖功能</p></blockquote><figure class="nm nn no np gt nq gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi og"><img src="../Images/08e0915d45b900785d6b30408bb8bb08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NoNUMaxkAshEcKYjKvQIjQ.png"/></div></div></figure><p id="b40e" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">现在是时候为POC 创建<strong class="kx iu">漏洞脚本了</strong></p><figure class="nm nn no np gt nq"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">csrfjson html脚本</figcaption></figure><p id="aec5" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated"><strong class="kx iu">结论:</strong></p><p id="7398" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">发生这种情况是因为anti-csrf令牌的验证不佳，并且内容类型报头的验证也不佳。所以要确保测试人员在测试的时候不会遗漏任何一个测试用例。理解CORS的基础知识，学习不同的滥用浏览器行为的覆盖技术。</p><p id="985b" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">感谢阅读。如果你喜欢这篇<strong class="kx iu">文章</strong>，请关注我，关注更多<strong class="kx iu">黑客技术。</strong></p><figure class="nm nn no np gt nq gh gi paragraph-image"><a href="https://www.buymeacoffee.com/secureitmania"><div class="gh gi oj"><img src="../Images/ffa8556399e3acd2b781c5baa694be13.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*WfbwTpxi0c0k2Vwzp3s5yg.jpeg"/></div></a><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">寻求支持</figcaption></figure></div></div>    
</body>
</html>