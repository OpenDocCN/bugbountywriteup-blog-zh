<html>
<head>
<title>Vulnerabilities in PHP Based Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于PHP的应用程序中的漏洞</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/vulnerabilities-in-php-based-applications-fb6224865d43?source=collection_archive---------0-----------------------#2022-04-12">https://infosecwriteups.com/vulnerabilities-in-php-based-applications-fb6224865d43?source=collection_archive---------0-----------------------#2022-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/7b50555c16376452da25b338b99698ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*MbyXqrTiSU8-PUe3_gSYnA.jpeg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">照片由<a class="ae kb" href="https://unsplash.com/@shams_ad?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Shamsudeen Adedokun </a>在<a class="ae kb" href="https://unsplash.com/@shams_ad?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="1df3" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">简介</strong></h1><p id="6595" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">到目前为止，PHP是构建web应用时最常用的语言之一，其他语言有JS、go和Ruby。PHP无处不在，以至于像WordPress和Joomla这样的内容管理系统都是专门基于PHP构建的。</p><p id="0cc0" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">多年来，PHP中已经发现了几个漏洞，PHP开发团队已经发布了许多更新来纠正这些问题。</p><p id="d14a" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">在这篇博客文章中，我们将讨论你在处理PHP应用程序时可能遇到的漏洞。一些漏洞是PHP特有的，而另一些则是普遍存在的。</p><h1 id="8180" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">类型杂耍</strong></h1><p id="4151" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">你认为下面这行代码的结果会是什么？</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="5490" class="mm kd it mi b gy mn mo l mp mq">if("7 hashes" == 7)</span></pre><p id="09a1" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">如果你说<strong class="lc iu">正确</strong>，恭喜你是对的。但是不应该是假的吗？它们不仅不同，而且数据类型也不同。现在让我们来看看怎么做。</p><p id="7d84" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">在比较不同类型的值之前，PHP将它们转换为单一的可比较类型。在上面的例子中，PHP将尝试从字符串<strong class="lc iu"> (7个散列)</strong>中提取整数<strong class="lc iu"> 7 </strong>，然后将其与整数7进行比较，从而给出一个<strong class="lc iu"> True </strong>值。</p><p id="aeee" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">鉴于不同的语言如何提供严格的比较，这乍一看似乎很奇怪。类型欺骗会导致身份验证和业务逻辑绕过漏洞。</p><p id="8e8b" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">例如，看看这段代码</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="714c" class="mm kd it mi b gy mn mo l mp mq">if ($_POST["password"] == "AdminIsHere")<br/>{<br/>    admin_login();<br/>}</span></pre><p id="088e" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">如果您提供一个整数，如<strong class="lc iu"> 0 </strong>，您将作为<strong class="lc iu">管理员</strong>登录</p><p id="77d9" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">然后，只需提交一个0的整数输入就可以成功地以管理员身份登录，因为这将计算为真:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="a9b1" class="mm kd it mi b gy mn mo l mp mq">(0 == "AdminIsHere") -&gt; True</span></pre><p id="b891" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated"><strong class="lc iu">缓解</strong>:</p><p id="fdd8" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">您应该使用三重等号(===)而不是双等号(==)，因为它将检查值以及操作数的类型是否相等。</p><h1 id="3083" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">空字节注入</strong></h1><p id="5f1d" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在PHP 5 . 3 . 4及更高版本中，空字节已得到修复。但是如果你遇到一个建立在PHP版本&lt; 5.3.4上的应用程序，检查一下空字节注入是值得的。<em class="mr">除了PHP，空字节注入在c语言中也是可能的</em></p><p id="d50d" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">空字节简单来说就是指<strong class="lc iu"> 0x00(十六进制)</strong>，<strong class="lc iu">% 00(URL编码)</strong>。</p><p id="2d1f" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">PHP会忽略空字节之后的任何内容。这有什么用？我们举个例子。</p><p id="3c8e" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">假设有一个应用要求你上传头像。头像需要有扩展名。要上传的png。测试是否可以上传反向shell的最简单方法是使用PHP创建一个反向shell，并将其重命名为<strong class="lc iu"> reverseshell.php%00.png </strong>。</p><p id="01f6" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">只要文件以long扩展名结尾，它就会被客户端上载，这将允许它逃避各种安全检查，因为。png扩展名。但是，在解析它时，跟在%00后面的部分将被省略，因为它是空字节。通俗地说，空字节被视为一个信号，表示一个进程的结束。因此，它将被服务器解释为PHP脚本，并被执行。结果会上传外壳，这将允许您在服务器上执行它，从而破坏它。</p><p id="23f1" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated"><strong class="lc iu">缓解</strong></p><p id="73c1" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">将您的PHP更新到高于或等于5.3.4的版本，并在处理用户输入之前对其进行清理。</p><h1 id="2f45" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">信息披露和差错处理问题</strong></h1><p id="e42e" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">对于开发人员来说，在处理项目时忘记打开调试器模式是很常见的。这可能会导致完整路径的泄露，其中可能包含机密密钥、硬编码的凭据或注释等。</p><p id="324a" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">将意外值传递给程序可能会导致发生错误，这可能会导致堆栈跟踪或其他内部信息从应用程序中泄漏。通常，它还会显示错误发生的源代码行的上下两行。考虑当您在网站的用户名或密码字段中输入引号(')时，SQL查询显示的错误消息。</p><p id="7f46" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">攻击者可以使用这些信息对应用程序做出有根据的假设，这可能使他更容易侵入系统。然而，这不仅适用于基于PHP的应用程序，也适用于用其他编程语言编写的程序。这可用于揭示完整路径、SQL查询中的错误，从而揭示完整查询等。</p><p id="67e1" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated"><strong class="lc iu">缓解措施</strong></p><p id="c876" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">关闭代码中的调试器模式，执行源代码审查，并测试哪些参数可能导致错误。如果出现错误，请确保将用户重定向到404页面，并确保执行正确的错误处理。</p><h1 id="5e6c" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">危险功能的使用</strong></h1><p id="6ded" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">假设您正在构建一个计算器。您可以考虑使用<strong class="lc iu"> exec() </strong>函数，而不是为每个操作编写复杂的逻辑，这可能会使代码变得很长。</p><p id="a2c2" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">这似乎是一个救命的功能，但实际上，它会损害应用程序的完整性。像<strong class="lc iu"> exec() </strong>、<strong class="lc iu"> system() </strong>这样的函数，通过使用PHP来执行系统/操作系统命令。</p><p id="edc1" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">这可能导致在系统上执行任意代码和远程代码。</p><p id="5382" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated"><strong class="lc iu">缓解</strong></p><p id="2d58" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated"><strong class="lc iu">移除exec()、system()、passthru()等函数。</strong>如果有必要保留这些函数，请确保使用escapeshellarg()或escapeshellcmd()来确保用户无法诱骗系统执行任意命令。</p><h1 id="c3ca" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">加密技术的不安全使用</strong></h1><p id="f1b2" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">加密库和插件用于签署会话密钥、cookies、加密敏感数据、生成密码和数据的散列。不建议使用安全加密方案。要么遵循您公司的策略，使用<strong class="lc iu"> SHA256/SHA512 </strong>进行哈希处理(也考虑使用salts来增加复杂性)，使用AES256进行加密。<strong class="lc iu">还要确保种子短语IV加密密钥不是硬编码的</strong>。如果泄露，任何恶意用户都可以冒充任何其他用户，包括管理员帐户，并解密敏感信息。</p><p id="628e" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated"><strong class="lc iu">注意存储加密密钥的目录/文件</strong>。如果框架或库有一个默认名称，如果可能的话，请尝试重命名它。这将确保即使用户能够找到目录遍历漏洞，他也不能轻易猜出文件/文件夹的名称。总是建议对密码进行哈希运算，而不是加密。所有的PII信息必须通过加密存储，密钥必须存储在一个安全的地方；大多数组织使用密钥管理器来管理这些密钥。</p><p id="16fb" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated"><strong class="lc iu">缓解</strong></p><p id="6073" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">使用mcrypt库/包来实现加密方案。避免使用硬编码值作为加密方案的密钥和IV。</p><h1 id="6e89" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">文件包含</strong></h1><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/174ff323c7e92be74ba8e623a296d2c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SMH40e5zihi2M5h_PQ-sig.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated"><a class="ae kb" href="https://secnhack.in/local-file-inclusion-lfi-types-mitigation-and-exploit/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="8063" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">应用程序从本地或远程位置读取文件是很常见的。但是当用户能够本地或远程读取任何文件时，这被称为文件包含漏洞。当应用程序使用用户可控制的参数从服务器获取文件时，会出现此漏洞，因此用户将能够操纵文件路径并从服务器读取敏感文件。如果恶意参与者能够从服务器本身读取文件，则称为本地文件包含，但如果他能够从远程源读取文件，则称为远程文件包含。详细的博文可以参考这篇<a class="ae kb" href="https://securitylit.medium.com/everything-about-path-traversal-vulnerability-9658dd4191ee?source=user_profile---------23-------------------------------" rel="noopener">文章</a>。</p><p id="9a3a" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated"><strong class="lc iu">缓解</strong></p><p id="246c" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">不要简单地将用户输入传递给includes()函数。对用户的输入进行验证。您还可以维护用户可以访问的文件的白名单。</p><h1 id="563f" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">会话劫持</strong></h1><p id="4fa6" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">会话是分配给每个用户的一次性标识符。它有助于区分每个用户，以维护用户会话的状态(验证他们是否登录)和每个用户角色。当恶意参与者能够控制用户的会话cookie并使用它来冒充网络上的其他用户时，就会发生会话劫持。大多数情况下，当用户登录后应用程序没有生成新的会话cookie时，就会出现这种情况。如果应用程序创建的会话密钥的熵值很低并且很容易被猜到，它也可能会遇到这个问题。在这种情况下，攻击者可以轻易猜出会话令牌，并使用它来访问帐户。</p><p id="4c5d" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">缓解措施:</p><ol class=""><li id="2095" class="mx my it lc b ld ly lh lz ll mz lp na lt nb lx nc nd ne nf bi translated">确保所有与会话相关的重要cookies都设置了http标志。</li><li id="aeb4" class="mx my it lc b ld ng lh nh ll ni lp nj lt nk lx nc nd ne nf bi translated">确保在用户从服务器端注销后删除会话cookie。</li><li id="d2c2" class="mx my it lc b ld ng lh nh ll ni lp nj lt nk lx nc nd ne nf bi translated">确保生成的会话令牌应该具有高熵并且不容易被猜测。</li></ol><h1 id="7533" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> CSRF </strong></h1><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nl"><img src="../Images/e9b2b4c34de75f1f7b0dbd1b01d6028f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yn3-9ecigpcfMA0moO-pQw.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated"><a class="ae kb" href="https://www.imperva.com/learn/application-security/csrf-cross-site-request-forgery/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="e39d" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated"><strong class="lc iu"> CSRF代表跨站点请求伪造</strong>。<em class="mr">跨站点请求伪造(CSRF)是一个漏洞，允许攻击者欺骗用户执行他们不想完成的操作</em>。他们将收到一封带有链接的电子邮件，在他们点击该链接后，将向服务器发出请求，根据具体情况，请求可能是更改电子邮件地址或任何其他信息。黑客可以利用该漏洞部分规避同源策略，该策略旨在阻止各种网站之间的交互。在CSRF攻击中，恶意用户可以在受害者不知情的情况下让受害者发出命令。这可能会导致用户帐户的删除、资金转移、自动注销，以及用户可以引入的几乎任何操作。</p><p id="f872" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated"><strong class="lc iu">缓解</strong></p><p id="9de8" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">使用名为CSRF令牌的唯一令牌。对于用户发出的每个请求，还会发送一个CSRF令牌。攻击者不知道受害者的CSRF令牌，因此所有请求都将被视为无效。</p><h1 id="ea89" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> XSS </strong></h1><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nm"><img src="../Images/58174e2d72b5f41f34d53074a117b55c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBHP_IDyxI3cdKyUehpW9g.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated"><a class="ae kb" href="https://www.geeksforgeeks.org/how-to-prevent-xss-with-html-php/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="615a" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">XSS代表跨站脚本。当应用程序接受用户输入，但不对用户输入执行任何类型的清理时，就会出现此漏洞，因此浏览器会认为源代码是应用程序的一部分，并最终执行它。XSS会导致严重的漏洞，例如窃取cookies、将用户重定向到不同的网站等等。这可能导致页面变形、会话劫持、帐户接管等。</p><p id="c270" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">定制的应用程序最容易受到跨站点脚本攻击。</p><p id="e8f8" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated"><strong class="lc iu">缓解</strong></p><p id="e9fe" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">对用户的任何输入进行输入净化和验证。</p><h1 id="a164" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> SQL注入</strong></h1><p id="9877" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">应用程序使用数据库来存储用户信息，如他们的登录名和密码，以及其他信息，如用户的个人资料图像等。SQL是大多数基于PHP的应用程序使用的最流行的数据库类型；然而，NoSQL数据库正迅速受到欢迎。</p><p id="f811" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">当用户提供的输入直接传递到SQL查询中时，就存在SQL注入漏洞。因此，攻击者可以将任意SQL查询注入SQL数据库，从而允许他们转储存储在SQL数据库中的所有数据。这些信息可能包括各种项目，如用户密码哈希、个人身份信息(PII)等等。关于SQL攻击更详细的描述和类型，可以参考这篇<a class="ae kb" href="https://securitylit.medium.com/a-definitive-guide-to-sql-injection-8d8932e51816" rel="noopener">文章</a>。</p><p id="4b5e" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated"><strong class="lc iu">缓解</strong></p><p id="c5ec" class="pw-post-body-paragraph la lb it lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx im bi translated">在将用户输入传递给SQL查询之前，必须对所有用户输入执行用户输入清理</p><h1 id="1f73" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">结论</strong></h1><p id="4983" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">尽管开发人员越来越多地转向其他语言，如JS、Go和Ruby，但仍然有大量的应用程序正在开发，而且已经用PHP开发了。这篇博文包含了许多在基于PHP的应用程序中相对常见的漏洞，并对它们进行了详细的讨论。我们从一些最关键的漏洞开始，逐步深入到更普遍的漏洞。</p></div></div>    
</body>
</html>