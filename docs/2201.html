<html>
<head>
<title>HTB-Business CTF</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTB-CTF商业</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/htb-business-ctf-e388db78649?source=collection_archive---------0-----------------------#2022-07-20">https://infosecwriteups.com/htb-business-ctf-e388db78649?source=collection_archive---------0-----------------------#2022-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="ccf1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">回报PWN挑战</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/33b65d4778d903448b15e5be349d04cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5tO8B2Pvn6nLAoRHhkAgg.png"/></div></div></figure><p id="a8d7" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">你好。我知道我已经很久没有写博客了，但是我现在又回来了！</p><p id="6f3c" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我总是喜欢CTF的pwn挑战赛，尽管我并不擅长。但是，我仍然试着去学习它们，练习它们，以便有一天我能在这方面做得很好。今天就是这样的一天，我学到了一些非常酷的东西，我很高兴与你分享，我的朋友！</p><p id="4a88" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">所以让我直接进入挑战吧！</p><p id="e6d2" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">请读者注意，我在CTF期间没有解决这个挑战，因为我被困在一个点上，毫无头绪，但我确实学到了一个新东西，它帮助我在CTF之后解决了这个问题。</p><p id="3362" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">所以挑战在于，我们得到了一个二进制文件、源代码、加载器、libc和其他一些东西，如下所示。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/047446407a1eb0bd2086c30a727eb176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*yrjDC-XDFVkfG7YzbWoQ2g.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">挑战文件</figcaption></figure><p id="560c" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">对于每一项挑战，首先要了解二进制文件，以及现有的不同保护措施，我们会选择二进制文件利用中最常用的工具，</p><blockquote class="ma mb mc"><p id="d1a2" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated">检查秒</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mh"><img src="../Images/deb4d75829bf3b503026fe4c6c099ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5wz34DggsK4aKRbwROq8zA.png"/></div></div></figure><p id="1604" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">由此获得的信息:</p><p id="fb3a" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">架构是<strong class="kz ir"> amd64。</strong></p><ol class=""><li id="d2fa" class="mi mj iq kz b la lb le lf li mk lm ml lq mm lu mn mo mp mq bi translated"><strong class="kz ir"> NX </strong>位被置位:这意味着我们不能从堆栈中执行外壳代码，即使我们在二进制中得到一个缓冲区溢出。但这并没有阻止我们，因为我们是<strong class="kz ir">最有创造力的人</strong>(但我不会在这篇文章中谈论方法)</li><li id="8412" class="mi mj iq kz b la mr le ms li mt lm mu lq mv lu mn mo mp mq bi translated"><strong class="kz ir"> PIE(独立于位置的可执行文件)</strong>:这是我从这次挑战中了解到的一件很酷的事情。这种保护会在每次执行时将程序及其各种依赖项加载到不同的内存区域中。因此，在gdb这样的调试器中，你看不到程序的确切内存地址，相反，你看到的是从elf二进制文件开始的偏移量。</li></ol><p id="a099" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我知道这真的很无聊和枯燥，所以我会给你看一些很酷的图片来描述上面的内容。</p><p id="b653" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">既然我们有了源代码，我将在不启用PIE的情况下编译程序(是的，这确实是可能的),并向您展示不同之处。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/8d8302a8745ea5f8beaf070246a41958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mt0eqJPKge-oDbrcYE8mHA.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">编译源代码</figcaption></figure><p id="c9b4" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">差别</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/4a250e48c1ef343d5fc37811226b7159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*be55l9sNC3jnAStA5jxQBQ.png"/></div></div></figure><p id="4447" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">您可以看到，没有禁用PIE的二进制文件(左边一个)具有每个指令的内存位置的确切地址，而启用PIE的二进制文件(右边一个)具有从ELF二进制文件的基址的偏移量。所以当程序被执行时，二进制文件被加载到一个随机的内存位置，指令的加载是通过把偏移量加到基数上来实现的。</p><p id="20a3" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">虽然这可能对挑战没什么用，但我希望你能理解这位朋友。</p><p id="ffd2" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">4.这就是阻止我并让我对挑战一无所知的原因。这种保护在启用时不允许在执行期间对全局偏移表进行任意写入。</p><p id="6e6a" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">链接器将在链接时(在执行开始之前)执行所有的符号查找，然后它将从get中移除写权限。</p><p id="17b5" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">过程链接表成为全局偏移表的一部分。</p><p id="d88b" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果上面的一些术语听起来很吓人或者让你不知所措，请参考下面LiveOverFlow的视频。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2628" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">5)最后一个boss是<strong class="kz ir"> ASLR </strong>使能的:这可能不直接可见，但大多数现代系统都默认使能。这种保护使每次执行时系统可执行文件在内存中的位置随机化。系统可执行文件包括LIBC，它是C程序使用的库，用于使用printf、scanf等普通函数。！！</p><p id="3968" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果你曾经想知道这些函数是在哪里定义和声明的，现在明白了吧，伙计，它们都在LIBC内部！！！！！</p><h2 id="abdb" class="na jo iq bd jp nb nc dn jt nd ne dp jx li nf ng kb lm nh ni kf lq nj nk kj nl bi translated">现在让我们看看ASLR的行动</h2><p id="8b22" class="pw-post-body-paragraph kx ky iq kz b la nm lc ld le nn lg lh li no lk ll lm np lo lp lq nq ls lt lu ij bi translated">我们使用<strong class="kz ir"> ldd </strong>工具打印可执行文件的<strong class="kz ir">(运行时成功执行程序所需的文件和可执行文件)</strong>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/f72ce9c2262cad92843682cc4ac97195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sBsz7uKHhMr3sb_oOjtY0w.png"/></div></div></figure><p id="e232" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">每次将libc.so.6加载到不同的内存位置。</p><h2 id="75ed" class="na jo iq bd jp nb nc dn jt nd ne dp jx li nf ng kb lm nh ni kf lq nj nk kj nl bi translated">剥削:</h2><p id="0aa6" class="pw-post-body-paragraph kx ky iq kz b la nm lc ld le nn lg lh li no lk ll lm np lo lp lq nq ls lt lu ij bi translated">现在来看挑战的源代码，我们基本上看到了3个实际有效的操作。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/bf9ca5493cbf3c0f03eb543bcfc5ef18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*s4Ub6FWXUghPV_awSXEaGQ.png"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/45379867ac644ed4350823f6f5a504b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mEIvbOZE9_FUoT0x_t9trw.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">假的</figcaption></figure><p id="097b" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">5，6，7只是在控制台中打印字符串，什么也不做！</p><p id="841d" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">所以<strong class="kz ir">有趣的</strong>是<strong class="kz ir">添加、编辑和删除</strong> bot功能。</p><p id="4df9" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">bot是一个用户定义的结构，其中包含id和URL变量。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f5a02341a83ee21fc1776fa1ea14f31a.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*xQVECa-JXnur3IcikGql_A.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">Bot结构</figcaption></figure><p id="8e68" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在阅读源代码后，我们找到了罪魁祸首……..</p><h1 id="fb30" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">删除bot功能。</strong></h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nv"><img src="../Images/caa8cc4e5374ecde3b1f29a196ba831c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOIdXqaYdx7b02UwT_bnrw.png"/></div></div></figure><p id="b2c9" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这些漏洞是:</p><blockquote class="ma mb mc"><p id="fed6" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated">用户输入直接传递给printf函数，导致<strong class="kz ir">格式字符串漏洞</strong></p><p id="e1e6" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated">我在CTF之后学到的另一个是另一个用户输入被传递到免费函数，没有保护。(<strong class="kz ir">滥用自由钩函数指针</strong>)</p></blockquote><h2 id="fe64" class="na jo iq bd jp nb nc dn jt nd ne dp jx li nf ng kb lm nh ni kf lq nj nk kj nl bi translated">自由钩:</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nw"><img src="../Images/118073874fe1395a7fa829599cf43a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NDDqIZe0ih_BFnRdvHQ5A.png"/></div></div></figure><p id="0125" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这基本上是给开发人员一种方法来定义他们自己的函数，每当free、malloc或任何类似的函数被调用时，这些函数就会被执行。</p><p id="927e" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">所以开发开发如下，</p><blockquote class="ma mb mc"><p id="298a" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated"><strong class="kz ir"> a) </strong>利用<strong class="kz ir">格式字符串漏洞</strong>从堆栈中泄漏一些内容</p><p id="7ffb" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated"><strong class="kz ir"> b) </strong>找到一个<strong class="kz ir"> libc地址</strong>，这个地址在二进制每次运行时都在堆栈中的一个固定位置。</p><p id="9566" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated"><strong class="kz ir"> c) </strong>使用gdb找到你从libc基址泄露的libc地址的偏移量<strong class="kz ir">找到libc基址</strong>。(ASLR战败)</p><p id="6a57" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated"><strong class="kz ir"> d) </strong>现在计算<strong class="kz ir">自由钩</strong>、<strong class="kz ir">系统libc函数</strong>的地址，用<strong class="kz ir">格式字符串用给我们一个shell的系统libc函数覆盖</strong>自由钩指针。</p><p id="66d5" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated"><strong class="kz ir"> e) </strong>调用delete bot，<strong class="kz ir">将参数as /bin/sh </strong>传递给自由函数(它现在指向系统)</p><p id="5307" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated">现在，看看弹开的外壳，享受一下这种感觉吧！！！</p></blockquote><h2 id="9da7" class="na jo iq bd jp nb nc dn jt nd ne dp jx li nf ng kb lm nh ni kf lq nj nk kj nl bi translated"><strong class="ak">第一步</strong>:</h2><p id="f370" class="pw-post-body-paragraph kx ky iq kz b la nm lc ld le nn lg lh li no lk ll lm np lo lp lq nq ls lt lu ij bi translated">添加一个随机数据的机器人，并选择删除机器人，并提供一个有效的id是0在这里，并在原因输入有效载荷，以收集一些信息。</p><h2 id="f5d9" class="na jo iq bd jp nb nc dn jt nd ne dp jx li nf ng kb lm nh ni kf lq nj nk kj nl bi translated">初始有效载荷:</h2><blockquote class="ma mb mc"><p id="fd90" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated">AAAAAAAA | % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p % p</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nx"><img src="../Images/13065cd2ac890eede3034ccfb0a524fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPBQ8pZ8iYIiO0n9Hr2JLA.png"/></div></div></figure><p id="3d16" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">%p是打印堆栈中的64位内存地址！</p><h2 id="d625" class="na jo iq bd jp nb nc dn jt nd ne dp jx li nf ng kb lm nh ni kf lq nj nk kj nl bi translated"><strong class="ak">输出:</strong></h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ny"><img src="../Images/f697830d797817424abfd335e81c89eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PC81b14dI5Sz1KpilkVjAQ.png"/></div></div></figure><p id="bca3" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">首先，我们看到0x4141…这是AAA…我们提供的输入。这很直观，因为我们提供的输入也在堆栈中，作为传递给printf函数的参数。</p><p id="0bbe" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">所以堆栈的第8个位置是out输入。</p><p id="a586" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">步骤2:现在，我们有一些以0x7f开头的地址，它们通常是堆栈地址。你可以看到这是gdb，现在我们需要找到其中哪个是有效的libc地址来击败ASLR。</p><p id="aa9f" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">为此，如下所示将gdb连接到正在运行的进程，并调查地址。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nz"><img src="../Images/24d8c919f96926cd2a6957c6fb8b5a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AUHquftHLdNAbbFGCmrwTw.png"/></div></div></figure><p id="09cf" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">检查我们看到的gdb中的最后一个地址</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oa"><img src="../Images/bb8d7caeb24c62b0f2bc9b01b458b5d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5FXO3_9pdamBzrtBB6qJA.png"/></div></div></figure><h2 id="f3a8" class="na jo iq bd jp nb nc dn jt nd ne dp jx li nf ng kb lm nh ni kf lq nj nk kj nl bi translated">嘣！！！</h2><p id="6b6b" class="pw-post-body-paragraph kx ky iq kz b la nm lc ld le nn lg lh li no lk ll lm np lo lp lq nq ls lt lu ij bi translated">我们找到了一个有效的libc地址太好了！这不会在每次运行中改变。</p><p id="3600" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在按照下面的步骤，找出这个从libc基址的偏移量。</p><blockquote class="ma mb mc"><p id="88f8" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated">在同一个gdb窗口中输入vmmap。</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ob"><img src="../Images/72f98ab3ed88a571e0259c5a576ec397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZRdfj4IP-IHDuaSQYUOAwQ.png"/></div></div></figure><blockquote class="ma mb mc"><p id="d1c9" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated">第一个看到libc.so.6的地址是它的基址。</p><p id="7336" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated">计算泄漏地址的偏移量—基址</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/09ab389b9c3437dd082fe847f3428fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqOwcDDRIEeb0PFqtr_ZAA.png"/></div></div></figure><p id="bf4c" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">至此，整个挑战基本完成。是的，已经结束了，相信我！！</p><p id="a6eb" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在我们需要计算free-hook和系统的libc地址，并使用printf而不是打印堆栈来写入它们。</p><p id="9946" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">有关格式字符串漏洞的更多信息，请参见下面的链接。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="abe6" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">使用pwntools，格式字符串攻击变得非常容易。它们是二进制开发的最通用和最好的工具，这使得工作变得有点容易！！</p><p id="9fe4" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">您可以通过以下方式生成进行写入的有效负载</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi od"><img src="../Images/27943435658879967c04127d7527f4e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXVswirrx0VqC6my2-RYcg.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">从格式字符串计算libc基数</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/941de303bcebcc479443e8cd558cd79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*lLGErrnC-IWcPs212CwOBw.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">用计算的值更新libc</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi of"><img src="../Images/f6b9df5c69833493736b3dceeb09566c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LxQHD9N5wXZ1uZ82JHB9UA.png"/></div></div></figure><p id="dcdb" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">您只需要用您计算的libc基数更新libc变量，并使用fmt_str生成一个有效负载来覆盖。</p><h2 id="17a0" class="na jo iq bd jp nb nc dn jt nd ne dp jx li nf ng kb lm nh ni kf lq nj nk kj nl bi translated"><strong class="ak">所以现在下一次我们调用删除bot函数时，这个函数是免费的。url)将执行系统libc函数。</strong></h2><p id="e6fd" class="pw-post-body-paragraph kx ky iq kz b la nm lc ld le nn lg lh li no lk ll lm np lo lp lq nq ls lt lu ij bi translated">为此，您必须再次添加一个URL为<strong class="kz ir"> /bin/sh </strong>的机器人。</p><blockquote class="ma mb mc"><p id="84e4" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated">这是因为这个字符串实际上被传递给了free，它现在指向系统。现在，它执行system("/bin/sh ")，打开一个shell。</p></blockquote><p id="dbf3" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在删除你在上面创建的机器人，并看到你的外壳弹出打开！！！</p><h1 id="efe8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">伙计，你成功了！太棒了。！</h1><p id="b602" class="pw-post-body-paragraph kx ky iq kz b la nm lc ld le nn lg lh li no lk ll lm np lo lp lq nq ls lt lu ij bi translated">这是我曾经解决过的一个很好的挑战，它让我学到了很多东西，并将我的理解推向了一个很好的程度。我希望这对你也有用！</p><p id="dc4d" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">请务必参考我的Github的挑战文件和漏洞！</p><blockquote class="ma mb mc"><p id="414b" class="kx ky md kz b la lb lc ld le lf lg lh me lj lk ll mf ln lo lp mg lr ls lt lu ij bi translated"><a class="ae og" href="https://github.com/Thirukrishnan/Payback-PWNchallenge" rel="noopener ugc nofollow" target="_blank">https://github.com/Thirukrishnan/Payback-PWNchallenge</a></p></blockquote></div></div>    
</body>
</html>