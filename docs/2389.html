<html>
<head>
<title>Connection State Attack — First Request Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">连接状态攻击—首次请求验证</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/connect-state-attack-first-request-validation-2bea8e42a647?source=collection_archive---------0-----------------------#2022-09-25">https://infosecwriteups.com/connect-state-attack-first-request-validation-2bea8e42a647?source=collection_archive---------0-----------------------#2022-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="84bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HTTP主机头的作用是帮助识别客户端想要与哪个后端服务进行通信，此外，许多应用程序依赖主机头来生成密码重置链接或重定向地址等。逻辑缺陷或错误配置可能导致不同类型的HTTP主机报头攻击。其中之一是HTTP连接请求走私，即仅在通过HTTP连接发送的第一个请求中验证主机头。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/08f0281bcf7ab9b4c547702ae328e146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fwiy2iuQBGipqIj3MXmjzQ.png"/></div></div></figure><p id="c55a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博文将带您通过PortSwigger实验室了解HTTP连接请求走私攻击。</p><p id="f5bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在开始PortSwigger实验之前，您需要熟悉一些概念。</p><h1 id="24fb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.必备知识</h1><h1 id="ea29" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.1虚拟主机</h1><p id="38a6" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在一个系统或web服务器上托管多个网站或应用程序，共享CPU和内存等资源是很常见的。以这种方式托管在一台服务器上的网站被称为“虚拟主机”。网站或应用程序的访问者通过以下虚拟主机方法被路由到正确的虚拟主机:</p><ul class=""><li id="cbc2" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">基于IP的</li></ul><p id="25ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于IP的虚拟主机要求每个虚拟主机有一个专用的IP地址。这是通过为单个web服务器创建多个IP地址来实现的。</p><ul class=""><li id="f9ee" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">基于端口的</li></ul><p id="e46d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于端口的虚拟主机使用不同的端口，web服务器被配置为通过端口将流量路由到虚拟主机。</p><ul class=""><li id="c23a" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">基于名称的</li></ul><p id="f435" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于名称的虚拟主机允许一个IP地址托管多个网站。流量在HTTP请求中按主机名路由。这种方法要求客户端必须支持HTTP 1.1(或带有1.1扩展的HTTP 1.0)。</p><h1 id="f786" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.2通过中间设备路由流量</h1><p id="2f71" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">另一种常见的情况是，不同的网站托管在不同的后端服务器上，但它们都要通过中间设备才能到达目标后端服务器。通常，反向代理服务器和负载平衡器可以充当这样的中介，位于请求路径中。这种设计允许多个网站被解析到中间组件的单个IP地址，请求被相应地分发到中间组件后面的预期后端服务器。为了实现这一点，路由可以基于请求中的主机名。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/5f4f6b9e2718f9ede315468fa5264bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*pDkufVfDae1NnBqwtbvR8g.png"/></div></figure><h1 id="02c6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.3主机标题</h1><p id="0765" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">主机报头对于基于名称的虚拟主机和通过中间设备的基于主机的路由非常重要，以便知道请求到达后将流量转发到哪里。当用户访问网站时，URL将解析为特定服务器或中间设备的IP地址。在请求中，主机头指定客户端想要访问的域名。</p><h1 id="1fa3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.4 HTTP主机报头攻击</h1><p id="1b38" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">由于主机头实际上是用户可控制的，这种做法会导致许多问题。HTTP主机标头攻击利用易受攻击的网站，这些网站信任主机标头而不正确验证它。攻击者可以通过畸形或复制篡改主机头，操纵后端服务器的行为。公司有时会在同一服务器上托管可公开访问的网站和内部网站，攻击者可能能够通过主机标题操作来访问内部网站。</p><h1 id="6894" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.5保持活动连接</h1><p id="5c0e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">TCP连接是通过三次握手建立的，它要求服务器和客户端在传输数据之前交换SYN和ACK数据包。默认情况下，HTTP连接在每次请求后关闭，下一次请求将建立新的连接。握手会导致连接开销，并降低整个连接过程的速度。为了提高性能，HTTP keep-alive头保持TCP套接字/连接打开，并允许多个请求和响应重用一个已建立的TCP连接。</p><p id="442d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">禁用和启用保活时的工作流(不包括SSL握手)如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mk"><img src="../Images/9efec918f0519abaf57efaf7543853e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aC2lc4PTZSOmbMKXzlhoHA.png"/></div></div></figure><p id="b69c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用cURL命令来更好地理解重用同一个连接如何减少连接延迟。</p><p id="ee77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要测量向服务器发出请求需要多长时间，可以在cURL命令中指定时间。</p><p id="b1a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> time_connect </strong>是客户端角度的TCP三次握手。<strong class="jp ir"> time_appconnect </strong>这里是TLS设置。<strong class="jp ir"> time_starttransfer </strong>就在cURL从网络中读取第一个字节之前(它实际上还没有读取)。</p><p id="99e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">发出如下类似的cURL命令:</p><pre class="km kn ko kp gt ml mm mn mo aw mp bi"><span id="b837" class="mq ky iq mm b gy mr ms l mt mu"># curl -v -s -w "TCP time: %{time_connect}, TLS setup time: %{time_appconnect}, Time to first byte: %{time_starttransfer}\n\n"   -o /dev/null <a class="ae mv" href="https://example.com/" rel="noopener ugc nofollow" target="_blank">https://example.com/</a> -o /dev/null <a class="ae mv" href="https://example.com/" rel="noopener ugc nofollow" target="_blank">https://example.com/</a><br/>*   Trying ***:443...<br/>* Connected to example.com (***) port 443 (#0)<br/>* schannel: disabled automatic use of client certificate<br/>* ALPN: offers http/1.1<br/>* ALPN: server did not agree on a protocol. Uses default.<br/>&gt; GET / HTTP/1.1<br/>&gt; Host: example.com<br/>&gt; User-Agent: curl/7.83.1<br/>&gt; Accept: */*<br/>&gt;<br/>* Mark bundle as not supporting multiuse<br/>&lt; HTTP/1.1 200 OK<br/>...<br/>&lt; Keep-Alive: timeout=10<br/>&lt; Content-Length: 0<br/>&lt;<br/>* Connection #0 to host example.com left intact<br/>TCP time: 0.571379, TLS setup time: 1.441327, Time to first byte: 1.867394<br/>​<br/>* Found bundle for host: 0x1bcf22be890 [serially]<br/>* Re-using existing connection #0 with host example.com<br/>* Connected to example.com (***) port 443 (#0)<br/>&gt; GET / HTTP/1.1<br/>&gt; Host: example.com<br/>&gt; User-Agent: curl/7.83.1<br/>&gt; Accept: */*<br/>&gt;<br/>* Mark bundle as not supporting multiuse<br/>&lt; HTTP/1.1 200 OK<br/>...<br/>&lt; Keep-Alive: timeout=10<br/>&lt; Content-Length: 0<br/>&lt;<br/>* Connection #0 to host example.com left intact<br/>TCP time: 0.005519, TLS setup time: 0.005520, Time to first byte: 0.428777</span></pre><p id="a33c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查curl命令的结果，您可以看到连接# 0是在第一个请求中创建的，并被第二个请求重用。同一连接中两个请求的连接时间概述如下:</p><pre class="km kn ko kp gt ml mm mn mo aw mp bi"><span id="27f4" class="mq ky iq mm b gy mr ms l mt mu">...<br/>TCP time: 0.571379, TLS setup time: 1.441327, Time to first byte: 1.867394<br/>...<br/>TCP time: 0.005519, TLS setup time: 0.005520, Time to first byte: 0.428777</span></pre><p id="153c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个TCP连接时间是0.571379秒，第二个请求总共只需要0.005519秒。</p><p id="9b61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但并不是所有的服务器都启用了keepalive，因为禁用keepalive是一种减缓滥用客户端速度以减少一些攻击流量的解决方案。</p><h1 id="6d5d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.连接状态攻击-首次请求验证</h1><p id="7de7" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在连接状态攻击中，一些应用程序只对连接中的第一个请求执行主机头验证。这意味着攻击者可以通过向合法的主机名发出请求，然后通过相同的连接向内部网站发出请求，来获得对内部网站的访问权限。portswigger站点中的连接状态攻击实验室易受基于路由的SSRF的攻击，您可以获得实验室的<a class="ae mv" href="https://portswigger.net/web-security/host-header/exploiting#connection-state-attacks" rel="noopener ugc nofollow" target="_blank">条目</a>。现在我们将一起浏览实验室。</p><p id="1651" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当用户访问易受攻击的网站时，使用burpsuite捕获<code class="fe mw mx my mm b">GET /</code>请求，我们称之为请求#1:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/c1c2d090f752222c328a81542ab94da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qee1qpHl08zXQCd3mnVhMQ.png"/></div></div></figure><p id="73a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将上面的请求复制为请求#2，并将请求的路径设置为/admin，将主机头设置为<code class="fe mw mx my mm b">192.168.0.1</code>，发送请求。</p><p id="541d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">据观察，您只是被重定向到主页。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/98a64cc5e5767bafd34c55307439f97f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFJeihRPobkVJvLvvdf4hQ.png"/></div></div></figure><p id="e3f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在创建一个选项卡组，将请求#1和请求#2放在一起。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/cb61d1e9144a6c4adb9418221483813c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cX6U2CGeLDoaEa5UQYlzOg.png"/></div></div></figure><p id="d0bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将选项卡组命名为Group 1，并将请求#1和请求#2添加到该组中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/783e1f3e6a44e857e31651abafc3995b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5ZnWgp8o9peQZUNB6xOYA.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nd"><img src="../Images/7e4abcd91d693c9c7c77ab4c107eddd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUafAfwQqeH9bw3A6k82Fw.png"/></div></div></figure><p id="fd1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择“按顺序发送组(单个连接)”，将这两个请求放在一个HTTP连接中。</p><p id="19dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将两个请求中的连接更改为keep-alive，并单击“按顺序发送组(单个连接)”按钮。可以看到，第二个请求已经成功地访问了内部管理面板。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/5230e829b0d8dccc5db158a8e83d9d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j22BcYW1I3ptQNT62o6wCw.png"/></div></div></figure><p id="5ff4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原因是请求#1中的主机报头通过了验证，但是验证没有应用到与请求#1相同的HTTP连接下的后续请求，因此当请求#2中的主机报头被篡改时，请求#2被成功路由到内部网站192.168.0.1，管理面板暴露给最终用户。</p><p id="44b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以按照portswigger站点中的解决方案来完成实验。</p><h1 id="942b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">最后的想法</h1><p id="04f3" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果您有任何问题或反馈，请随时发表评论。如果你认为这篇博文有帮助，请点击拍手👏按钮下面几下，以示支持！</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h2 id="7648" class="mq ky iq bd kz nm nn dn ld no np dp lh jy nq nr ll kc ns nt lp kg nu nv lt nw bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae mv" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4个线程、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>