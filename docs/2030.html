<html>
<head>
<title>Advanced Docker Security Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级码头安全第二部分</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/advanced-docker-security-part-ii-4a6994f0c328?source=collection_archive---------0-----------------------#2022-04-26">https://infosecwriteups.com/advanced-docker-security-part-ii-4a6994f0c328?source=collection_archive---------0-----------------------#2022-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5fe4b99231c4caf6260257d0ef6ed9ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRcI2Y7WBKbSTsEuqVLPyg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://nickjanetakis.com/blog/differences-between-a-dockerfile-docker-image-and-docker-container" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h1 id="42e7" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">简介</strong></h1><p id="34b7" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这是高级docker系列的第二部分，我们将介绍一些高级概念，以保护您的Docker容器，并确保即使您的容器受到损害，攻击者也无法实现太多目标。如果你错过了这个系列的第一部分，你可以在这里查看<a class="ae kf" href="https://securitylit.medium.com/advanced-docker-security-2ef31ac7547f" rel="noopener"/>。</p><h1 id="21e6" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">限制资源</strong></h1><p id="8705" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Docker的安全性和影响它的因素可以分为两个核心和关键的类别:名称空间和cgroups是用来描述它们的术语。</p><p id="935b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">根据Docker网站的说法，名称空间“为正在运行的进程(容器)提供隔离，限制它们对系统资源的访问，而正在运行的进程并不知道这些约束。”Docker没有引入名称空间。在撰写本文时，它已经作为Linux内核的一部分出现了。</p><p id="1322" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">第二个需要了解的最重要的事情是关于cgroups。它是Linux内核的一个特性，允许您将对进程和容器的访问限制在特定的系统资源上，比如CPU、RAM、IOPS和网络连接。</p><h1 id="a3ff" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">限制PID</strong></h1><p id="37d8" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">PID是容器创建的进程或线程的数量。PIDS列包含容器在上一步中创建的进程和内核线程的总数。Linux内核称之为“线程”或者，“轻量级进程”或“内核作业”被用来描述同样的事情。PIDS列中大量进程的出现和适度进程的出现(如ps或top所报告的)可能表明容器中的某些东西正在生成大量线程。如果攻击者获得了对您的容器的访问权，他可以通过耗尽服务器的所有资源并使其停止来削弱它。因此，建议减少系统中可以产生的进程数量。</p><p id="0c16" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">让我们首先学习如何检查一个容器可以产生的PID的最大数量。</p><p id="a882" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">要检查当前的PID，您可以通过键入<strong class="lg iu"> docker stats </strong>找到它</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/3b2e7f80737cf72ebf34fefbbee0b6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bp9QlHzEeqB7uczr1z9eLg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">码头统计</figcaption></figure><p id="eacc" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">让我们以分离模式运行docker容器。</p><p id="8747" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在分离模式下，容器启动并在后台运行。这意味着，您启动容器，并可以在启动后使用控制台执行其他命令。</p><p id="a276" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">与分离模式相对的是前台模式。当不使用-d选项时，这是默认模式。在这种模式下，您用来执行docker运行的控制台将连接到标准输入、输出和错误。这意味着您的控制台附加到容器的进程。</p><p id="c1db" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">你可以通过添加一个额外的标志<strong class="lg iu"> d </strong>和<strong class="lg iu">–it</strong>在分离模式下运行docker。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/2e4812402c631571e1280850d472c09e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7fSNKTpZTWBzzVNlbujuw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">码头工人运行-itd <image_id/></figcaption></figure><p id="0f46" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们可以看到，它为我们提供了一个ID，<strong class="lg iu">fa 7175306 b 6 AE 53 D2 be 39 D1 e 53d 47 e 12d 98 fbb 2 cfac 9 F8 d 3 abf 82752 f 60 cca0e</strong></p><p id="a320" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这只是我们刚刚生成的容器的一个目录。这个目录的内容将包含重要的信息。</p><pre class="mi mj mk ml gt mn mo mp mq aw mr bi"><span id="f702" class="ms kh it mo b gy mt mu l mv mw">find /sys/fs/cgroup -name fa7175306b6ae53d2be39d1e53d47e12d98fbb2cfac9f8d3abf82752f60cca0e</span></pre><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/f65e6fdf47891c706ad9da08455d6c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3apq0EDOauAjiiO1HJYhg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">匹配的目录列表</figcaption></figure><p id="baab" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果您查看第一个目录的命名约定，您会注意到其中的<strong class="lg iu">PID</strong>。这个目录将包含关于我们刚刚生成的容器的PID的信息。我们关注的目录是<strong class="lg iu">/sys/fs/cgroup/pids/docker/fa7…ca0e</strong></p><p id="6dd6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">查看内容，您会看到目录中存储了一堆文件。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/1ee73541173d56b8f94ba0119f60c2db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NUjhgmw3LkvvXs55fd8PsQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">切换到我们容器的pids目录</figcaption></figure><p id="6ccc" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> pids.max </strong>文件包含了docker容器中可以产生的最大进程数。如果您查看pids.max文件的内容，您会发现它包含单词<strong class="lg iu"> max。这意味着在我们的容器中可以产生任意数量的进程。</strong></p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/0e9bbafcb0f48b3b480276ffac15f7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t1nMNuAJxY4rcu7CNYGyfg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">pids.max设置为max</figcaption></figure><p id="e80a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">根据不同的用例，您可以设置可以产生的PID数量的上限。</p><pre class="mi mj mk ml gt mn mo mp mq aw mr bi"><span id="5701" class="ms kh it mo b gy mt mu l mv mw">docker run –pids-limit 100 825d55fb6340</span></pre><p id="3de5" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">注意:这里825d55fb6340是图像ID。要查看您的图片id，只需输入<strong class="lg iu"> docker图片</strong></p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/49608eae8ab4982255daa8ee070627ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qehYP3oV8VnIDnpNWAaf0g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">pids-限制设置为100</figcaption></figure><p id="c368" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在上面的例子中，我设置了可以产生的进程数量的最大限制，实际上是100。深入了解您的用例，您可以将其设置得更低或更高。</p><p id="c30b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">让我们通过访问<strong class="lg iu">/sys/fs/cgroup/pids/docker/08 a1b 005840 b 54 BDA 92116 ad 810 ea 228 AE 32d 558 a6fc 81491 b 5f 6ba 042244 f 7e/pids . max文件</strong>来确认一下。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/51e4e62bde5df268e2818a4861f67ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l4hQacSA7eJoIZvzx8deQQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">pids-限制设置为100</figcaption></figure><p id="6eb2" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如您所见，PID的最大数量已经设置为100。</p><h1 id="af04" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">对接插座</strong></h1><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/a4130f50aa507b77792f99519c4d26ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRndYa900MJcRpW_y4HitA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://betterprogramming.pub/about-var-run-docker-sock-3bfd276e12fd?gi=6426fa1d605a" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="5cf4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">先来了解一下什么是socket</p><p id="ffe0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">套接字通常是指IP地址和端口。要与网站或界面交互，您只需要一个套接字，这意味着一个IP地址和一个与运行服务的IP地址相关联的端口。</p><p id="3fcb" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">然后，您可以向套接字发送请求并期待响应。这通常被称为TCP套接字。还有一种套接字叫做UNIX套接字。这些套接字通常用于同一计算机/系统内的进程间通信(IPC)。</p><p id="36bd" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Docker套接字是一个UNIX套接字。当你输入一个docker命令，比如docker pull、run等。在后台，docker客户机通过UNIX套接字与docker守护进程进行交互，以执行您的命令。</p><p id="bbbe" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu"> docker.sock </strong>文件位于/var/run目录中，文件的所有者是根。务必不要篡改该文件的权限，因为这会导致攻击者获得对底层主机系统的访问权限。</p><p id="78cb" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">此外，不建议将此文件安装到新旋转的docker容器中，因为恶意用户可能会滥用它来获得对底层主机系统的访问权限。但是为什么会有人在容器上安装<strong class="lg iu"> /var/run/docker.sock </strong>文件呢？</p><p id="c5f6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果您有几个docker容器，并且您想从不同的docker容器访问/控制它们，那么您需要将这个文件挂载到docker容器，您想从这个容器控制/访问其余的docker容器。</p><p id="6b06" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">挂载的过程是添加<strong class="lg iu">–v</strong>标签，然后是你希望挂载的内容和挂载的位置。</p><p id="aec4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">示例<strong class="lg iu">，-v /opt/important:/tmp </strong></p><p id="8ddb" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在这个例子中，我已经将主机系统中的<strong class="lg iu"> /opt/important </strong>目录挂载到docker容器中的<strong class="lg iu"> /tmp </strong>目录。</p><p id="755a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">因此，如果您遇到一个docker文件，其行类似于下面提供的行，那么您可以肯定这样一个事实:任何恶意用户，只要访问docker容器，就能够安装主机文件系统并读取所有敏感文件。</p><pre class="mi mj mk ml gt mn mo mp mq aw mr bi"><span id="4dab" class="ms kh it mo b gy mt mu l mv mw">docker run –it –name ubuntu –v /var/run/docker.sock:/var/run/docker.sock /bin/bash</span></pre><h1 id="91c2" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">结论</strong></h1><p id="4ce9" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这是一篇更侧重于实际的博客文章。我们了解了进程id的概念以及如何限制对它们的访问。后来，我们发现挂载docker.sock文件会导致docker容器中的安全漏洞。安全性在Docker环境中极其重要。除了复杂，技术安全也很难做到。因此，在部署之前，我们必须确保一切都得到正确的纠正和保护。</p></div></div>    
</body>
</html>