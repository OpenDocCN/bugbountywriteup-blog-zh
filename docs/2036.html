<html>
<head>
<title>Shellcode Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">外壳代码分析</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/shellcode-analysis-313bf4ca4dec?source=collection_archive---------0-----------------------#2022-04-29">https://infosecwriteups.com/shellcode-analysis-313bf4ca4dec?source=collection_archive---------0-----------------------#2022-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5fdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看什么是外壳代码，以及如何识别和分析它们。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/83ab7267a206b19ca0eee64408f523db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gZ7FRF1rEJ76_Wle8-oDg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">外壳代码插图</figcaption></figure><h1 id="9950" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">背景</h1><p id="96c9" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">外壳代码是一系列指令(操作码)，代表十六进制值，可以在代码中以不同的格式出现(作为字符串)。该序列用作利用漏洞后在内存中执行的代码的有效载荷。它的名字来源于攻击者使用它来获取系统的外壳。</p><h1 id="bd7e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">属国</h1><p id="69be" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">外壳代码有一些依赖性，这可能会使编写它们变得有点困难。</p><ol class=""><li id="4398" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">长度—因为外壳代码利用了内存中的特定漏洞，所以序列需要尽可能高效。这意味着攻击者必须使其长度适合缓冲区的大小，这样所有的指令都将在内存空间中运行。<br/>如果外壳代码的长度大于缓冲区的大小，可能会导致程序崩溃甚至被利用(如缓冲区溢出)。</li><li id="abdf" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">不允许的字符—当字符如<code class="fe ms mt mu mv b">‘\r’</code>、<code class="fe ms mt mu mv b">‘\n’</code>、<code class="fe ms mt mu mv b">0x00</code>等。出现在外壳代码中，应该运行的代码将终止而不会完成。#为什么？<br/>例如，当读取“空字节”(如<code class="fe ms mt mu mv b">0x00</code>值)时，CPU将其识别为字符串的结尾(空终止符)。</li></ol><h1 id="9644" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Unix外壳代码</h1><p id="dc5e" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">Unix操作系统通过指令<code class="fe ms mt mu mv b">int 0x80</code>提供了与内核通信和管理内核的直接访问。因此，当系统调用遵循该指令时，外壳代码将被赋予以高权限执行的能力，而无需攻击者的特别努力。</p><h1 id="fbd1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Windows外壳代码</h1><p id="ecb4" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在基于Windows的操作系统中，由于ASLR(地址空间布局随机化)等内存保护机制，创建外壳代码可能会稍微困难一些。</p><h2 id="eecb" class="mw lc iq bd ld mx my dn lh mz na dp ll jy nb nc lp kc nd ne lt kg nf ng lx nh bi translated">在内存中查找API函数的地址</h2><p id="ccb8" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">大多数情况下，外壳代码被注入到一个正在运行的进程中，因此它没有任何关于内存状态以及API函数地址的先验知识。<br/>结论:不能基于静态地址。</p><p id="f02d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，外壳代码无法使用指令作为<code class="fe ms mt mu mv b">Call CreateProcessA</code>或<code class="fe ms mt mu mv b">jmp sub_40100000</code>，必须独立于其位置运行，以找到所需的API函数并手动解析地址。换句话说，找到它想要使用的DLL，而不考虑地址，而是基于内存中对象的结构。这也是它被称为位置无关码(PIC)的原因。</p><p id="90d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比如要调用<code class="fe ms mt mu mv b">GetProcAddress</code>，shellcode需要找到<code class="fe ms mt mu mv b">Kernel32.dll</code> DLL的地址。</p><p id="1201" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么如何才能做到呢？</p><h2 id="a395" class="mw lc iq bd ld mx my dn lh mz na dp ll jy nb nc lp kc nd ne lt kg nf ng lx nh bi translated">PEB —过程环境区块</h2><p id="b2b7" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">由于PEB对象总是被加载到内存的同一个地址— <code class="fe ms mt mu mv b">FS:[0x30]</code>，外壳代码可以使用它！</p><p id="ad17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它需要做什么:</p><ol class=""><li id="073b" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">转到PEB对象。</li><li id="6ea3" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">穿过<code class="fe ms mt mu mv b">PEB_LDR_DATA</code>对象，直到到达<code class="fe ms mt mu mv b">InMemoryOrderModuleList</code>链表，该链表包含关于进程加载的模块的信息。在这之后，shellcode将保存想要的模块(通常<code class="fe ms mt mu mv b">Kernel32.dll</code>是第三个对象)。</li><li id="bbbd" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">使用<code class="fe ms mt mu mv b">DllBase </code>字段查找所需DLL的基地址。</li><li id="be63" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">找到它的导出表。</li><li id="8995" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">定位想要的功能(如<code class="fe ms mt mu mv b">GetProcAddress</code>)。</li><li id="c94a" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">使用<code class="fe ms mt mu mv b">GetProcAddress</code>函数获取函数的地址。</li><li id="10c7" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">最后，使用合适的参数运行所需的函数。</li></ol><h2 id="49ea" class="mw lc iq bd ld mx my dn lh mz na dp ll jy nb nc lp kc nd ne lt kg nf ng lx nh bi translated">使用SEH —结构化异常处理</h2><p id="f270" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">该技术是关于访问SEH链的底部，通过在TIB(线程信息块)中输入第一个属性，它有一个固定的地址— <code class="fe ms mt mu mv b">FS:[0x0]</code>。它包含<code class="fe ms mt mu mv b">Kernel32.dll</code>模块的默认异常处理程序。为了定位所需模块的地址，可以返回内存地址，直到找到模块的入口点(例如使用<code class="fe ms mt mu mv b">MZ</code>签名或<code class="fe ms mt mu mv b">0x5A4D</code>)。</p><h2 id="385e" class="mw lc iq bd ld mx my dn lh mz na dp ll jy nb nc lp kc nd ne lt kg nf ng lx nh bi translated">使用TEB —线程环境块</h2><p id="de31" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">像SEH技术一样，可以访问TEB对象，它在内存中有一个固定的位置— <code class="fe ms mt mu mv b">FS:[0x18]</code>。穿过这个物体可能会把你带到SEH链，如上所述。</p><h2 id="dc39" class="mw lc iq bd ld mx my dn lh mz na dp ll jy nb nc lp kc nd ne lt kg nf ng lx nh bi translated">顶部堆叠</h2><p id="bf3f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这种方法并不常见，因为它依赖于拥有所需DLL的地址，而该DLL在堆栈中具有所需的API函数。</p><h2 id="5a5e" class="mw lc iq bd ld mx my dn lh mz na dp ll jy nb nc lp kc nd ne lt kg nf ng lx nh bi translated">通过哈希查找API函数</h2><p id="437c" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这种技术也被称为SFHA(斯蒂芬·诺瑟的哈希API)。它用4个字节来表示<code class="fe ms mt mu mv b">EAX </code>寄存器内<code class="fe ms mt mu mv b">DLL!WinAPI</code>函数的哈希值。然后，对那个地址进行一个<code class="fe ms mt mu mv b">JMP </code>来调用那个函数。注意<code class="fe ms mt mu mv b">EAX</code>调用了哪个函数，得到了什么参数(可以在MSDN查)。然后，与内存中的实际值进行比较。例如，如果shellcode调用了<code class="fe ms mt mu mv b">Win_Exec</code>函数，它将通过每一个使用其他技术之一的<code class="fe ms mt mu mv b">DLL!WinApi</code>，并带有其他参数(我们可以在register调用之前通过<code class="fe ms mt mu mv b">PUSH</code>指令来识别它们)。当我们输入参数的内存地址时，我们可能知道那里有什么(可能是一个<code class="fe ms mt mu mv b">PS1</code>脚本或编码命令..).</p><h1 id="cc8e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">侦查</h1><p id="91a7" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在我们稍微了解了外壳代码是什么之后，让我们来看看如何检测它们。<br/>注意去混淆，解密一个混淆或加密的脚本，暴露外壳代码！</p><h2 id="d57f" class="mw lc iq bd ld mx my dn lh mz na dp ll jy nb nc lp kc nd ne lt kg nf ng lx nh bi translated">使用行为模式</h2><p id="9600" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如上所述，外壳代码是代表指令的操作码序列。因此，我们可以找到这个序列并检查它。</p><p id="3a9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们有运行外壳代码(如PowerShell或JavaScript)的恶意程序的源代码，我们可以寻找可能代表操作码的值/变量/字符串，这可能会引导我们找到外壳代码本身。</p><p id="cc6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来看看说明:<code class="fe ms mt mu mv b">mov ebp, esp</code>。外壳代码将使用的字符序列可以有几种格式:</p><ul class=""><li id="607f" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ni mk ml mm bi translated">六进制值:<code class="fe ms mt mu mv b">8B EC</code></li><li id="71fd" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ni mk ml mm bi translated">反斜杠六进制值:<code class="fe ms mt mu mv b">\x8B\EC</code></li><li id="3f77" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ni mk ml mm bi translated">百分比Unicode: <code class="fe ms mt mu mv b"> %u8B%EC</code></li><li id="b800" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ni mk ml mm bi translated">反斜杠Unicode: <code class="fe ms mt mu mv b">\u8B\uEC</code></li><li id="dbd3" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ni mk ml mm bi translated">数组:<code class="fe ms mt mu mv b">[0x8B, 0xEC]</code></li></ul><p id="cb7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在识别出这些字符的序列可以代表CPU指令之后——我们将把重点放在它上面。</p><h1 id="c6f8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">转储外壳代码</h1><p id="0b0a" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">检测到潜在的外壳代码后，将它转储到二进制文件中是实现我们目标的第一步。</p><ul class=""><li id="9a77" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ni mk ml mm bi translated"><code class="fe ms mt mu mv b">base64dump.py</code>工具—允许找到可能包含外壳代码的部分，并将其转储到二进制文件(<code class="fe ms mt mu mv b">.bin</code>)中，以便进行分析。<br/> <code class="fe ms mt mu mv b">base64dump.py -e {param} {file}<br/></code> <strong class="jp ir">参数:</strong> <br/> 1。<code class="fe ms mt mu mv b">pu</code> —允许搜索用于百分比Unicode编码的字符串(<code class="fe ms mt mu mv b">%u</code>)。<br/> 2。<code class="fe ms mt mu mv b">bu</code> —允许搜索反斜杠Unicode编码的字符串用法(<code class="fe ms mt mu mv b">\u</code>)。<br/> 3。<code class="fe ms mt mu mv b">hex</code> —允许搜索用作十六进制值的字符串。<br/> 4。<code class="fe ms mt mu mv b">base64</code> —允许使用Base64编码搜索字符串。<br/> <code class="fe ms mt mu mv b">base64dump.py -e {param} {file} -s {sectionID} -d &gt; {outFile.bin}<br/></code>允许通过ID定位想要的部分，并将其转储到二进制文件中。大多数情况下，会选择最大的部分。<br/> <code class="fe ms mt mu mv b">base64dump.py -e {param} {file} -s {sectionID} -a<br/></code>显示所选截面的十六进制视图。</li><li id="8f3e" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ni mk ml mm bi translated"><code class="fe ms mt mu mv b">objdump.py</code>工具-允许在提取外壳代码时转储外壳代码。</li><li id="c311" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ni mk ml mm bi translated">使用十六进制编辑器——十六进制编辑器可用于删除不相关的部分。因此，只有外壳代码保留下来，并可以保存到<code class="fe ms mt mu mv b">.bin</code>文件中。</li></ul><h1 id="f857" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何分析外壳代码？</h1><p id="0b62" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">外壳代码分析有两种主要方式:静态和动态分析。</p><h2 id="077c" class="mw lc iq bd ld mx my dn lh mz na dp ll jy nb nc lp kc nd ne lt kg nf ng lx nh bi translated">静态分析—代码分析</h2><p id="899a" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这样，包含外壳代码的二进制文件将被转换为可执行文件，并被加载到反汇编程序(如IDA PRO)中。然后，它将被分析为一个可执行文件。</p><p id="eddf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用法:</p><ul class=""><li id="aacc" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ni mk ml mm bi translated"><code class="fe ms mt mu mv b">shellcode2exe.py {file.bin}</code></li><li id="8eca" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ni mk ml mm bi translated"><code class="fe ms mt mu mv b">shellcode2exe.bat {32\64} {file.bin} {file.exe}</code></li></ul><h2 id="f648" class="mw lc iq bd ld mx my dn lh mz na dp ll jy nb nc lp kc nd ne lt kg nf ng lx nh bi translated">动态分析</h2><p id="48a5" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><code class="fe ms mt mu mv b">scdbg</code>工具——允许模拟外壳代码的执行，以找到它使用的API函数，这可以指示它的许多行为。</p><ul class=""><li id="6e96" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ni mk ml mm bi translated"><code class="fe ms mt mu mv b">scdbg -s {steps} -f {file.bin}</code></li><li id="c18b" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ni mk ml mm bi translated">运行GUI <code class="fe ms mt mu mv b">scdbg</code>工具并启动二进制文件。</li><li id="6668" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk ni mk ml mm bi translated">使用<code class="fe ms mt mu mv b">FindSC</code>将在加载的二进制文件中找到外壳代码的开头。</li></ul><p id="7f35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">jmp2it</code>工具——允许在专用进程下执行外壳代码，用作可执行文件的“外壳”。因此，将调试器附加到正在运行的进程，使您能够调试外壳代码。</p><ul class=""><li id="df10" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk ni mk ml mm bi translated"><code class="fe ms mt mu mv b">jmp2it {file.bin} {offset}</code>—<code class="fe ms mt mu mv b">offset</code>表示外壳代码从二进制入口点的偏移量(<code class="fe ms mt mu mv b">0x0</code>表示开始)。</li></ul><p id="bb16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">shellcode_launcher.exe</code> —与前一个工具类似。</p><h1 id="255d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ade2" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在这篇文章中，我们了解了如何使用几种工具来识别和分析外壳代码。<br/>我希望你能从这篇文章中学到一些东西。</p><p id="af3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>