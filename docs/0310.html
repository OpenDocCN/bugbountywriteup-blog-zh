<html>
<head>
<title>Windows-Based Exploitation —VulnServer TRUN Command Buffer Overflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Windows的攻击—VulnServer TRUN命令缓冲区溢出</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/windows-based-exploitation-vulnserver-trun-command-buffer-overflow-707faa669b4c?source=collection_archive---------0-----------------------#2019-05-30">https://infosecwriteups.com/windows-based-exploitation-vulnserver-trun-command-buffer-overflow-707faa669b4c?source=collection_archive---------0-----------------------#2019-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8c60" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用IDA Pro反转并用Python注入外壳代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aaaeec07ec842769c736a446019b2fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mo4oXm6AT8J1i_Dv-g3CvA.png"/></div></div></figure><p id="63c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嘿伙计们！随着我越来越多地参与漏洞开发，我在各种默认易受攻击的软件上进行练习，其中之一就是<a class="ae lq" href="https://github.com/stephenbradshaw/vulnserver" rel="noopener ugc nofollow" target="_blank"> VulnServer </a>。</p><p id="a268" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之，VulnServer是一个很小的服务器，它暴露了一组到处都有漏洞的命令，随时可以被利用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/6be9f9f006f5e835e27c87ef217fbdc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*0l1lCVYcs4aEhZjVqdDNQg.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">VulnServer命令概述</figcaption></figure><p id="ba12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它的一个漏洞存在于TRUN命令逻辑中，这也正是我在这篇博文中要针对的。</p><p id="50e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于这是一个Windows x86软件，我将为该漏洞利用工作的环境是Windows 10，带有IDA Pro、WinDbg调试器和Python 2，用于构建该漏洞利用。</p><p id="2d83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我会试着边走边解释，所以你可以随意跟着走。</p><h1 id="ad37" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">回动的</h1><p id="7d2f" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">虽然我有服务器的完整源代码，但我将反转TRUN命令的逻辑，因为这样更有趣！(我们了解更多..对吗？)我在这里的唯一假设是TRUN命令中存在漏洞。漏洞的类型和位置将是未知的！</p><p id="c290" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在IDA I中打开vulnserver.exe可以快速跟踪套接字的创建和连接处理。然而，所有这些现在都无关紧要，所以我浏览了二进制文件的字符串以找到“TRUN”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/7206f2570834ca41dff0c4ae0cbb6607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ap8OLnxN5UKN-6IEENylVA.png"/></div></div></figure><p id="fa32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果跟随，按ENTER键，然后按Ctrl+X显示对该字符串的所有引用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/0f1c6c90091f02cec23d4c0d02be6547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HoHPR-p9HcY5na01wyiZ9Q.png"/></div></div></figure><p id="7f5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在再次按回车键跳转到代码中唯一的引用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/8e172a5db97bdc79f47c35ce2b21d3a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*3fAXxHjOWFkKZagqH0wo6w.png"/></div></figure><p id="e7e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从反汇编的代码来看，程序似乎通过调用<em class="mw"> _strncmp来检查缓冲区(可能是输入)是否等于“TRUN”。</em>为了方便起见，IDA自己为<em class="mw"> _strncmp </em>调用做了一些智能参数命名。</p><p id="6a96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，让我们通过按F2键在代码块的开头放置一个断点，并调试代码，以检查测试值实际上在做什么。确保您已经安装了WinDbg并选择它作为IDA中的调试器，然后单击Run。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/1aaeda5ba7cb1c8b6697ac3b2fca5ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*g_pG5F-cBpcyu_RH6UWwfg.png"/></div></figure><p id="57a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">服务器启动了，现在我们需要向套接字发送数据。由于Windows OS默认没有安装netcat，所以从<a class="ae lq" href="https://joncraton.org/files/nc111nt_safe.zip" rel="noopener ugc nofollow" target="_blank">这里</a>下载，解压zip(密码:nc) <em class="mw"> </em>复制到你的System32文件夹。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/37534440d4042f1770f374312490fa31.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*ptG3TYXIu4Z8MKXlqMPDzQ.png"/></div></figure><p id="0a25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用netcat向服务器发送带有一些测试数据的TRUN命令。(默认端口是9999)</p><p id="f1f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用F8遍历前几行，我们可以看到程序确实检查了输入的前5个字符是否等于“TRUN”。如果是，它将向堆分配3000个字节，并将它们设置为0。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/942f4d3478c973ff04d2d4df5df60acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*I7H62bZwWnYaIqgp-2AQsg.png"/></div></figure><p id="c126" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后有一个有趣的行，它检查剩余输入的第一个字符是否是2E，如果转换为ASCII，则是“.”性格。而一个“.”字符，程序将在缓冲区中循环，如果没有找到，程序将退出。让我们再次调试，但现在输入以“.”开头。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/ee5d7dff2d066b05df902992e093edff.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*8Fgi4_37qF9ohpMBO6b-nQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/b0432dfc9fc9449c7c04a72582be17d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*71hyfIS6Zyx7Li3lLXDHJA.png"/></div></figure><p id="565f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在第一次检查通过了，程序将输入复制到之前分配的堆空间中。再往前走一点，会调用一个有趣的函数，名为“_Function3”。使用F7单步执行该函数，我们可以看到，该函数将堆空间的内容复制到堆栈中的缓冲区，但没有任何缓冲区边界检查，因此，理论上，应该可以覆盖缓冲区，从而覆盖返回地址！(注意，堆中分配的空间是3000字节，Function3中的整个堆栈缓冲区是2024 (7E8h)字节。)</p><h1 id="8e58" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">剥削</h1><p id="7956" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">既然我们已经走了这么远，并且颠倒了程序，让我们更勇敢一点，不模糊地执行溢出，而是通过计算找到偏移量。假设传递给<em class="mw"> _strcpy </em>的目的地址是$EBP-7D8h (7D8是2008字节)，我们需要2012 (+4字节来填充目的地当前指向的地址)字节来填充堆栈，直到EBP，然后，下一个字(4字节)是返回地址！</p><p id="dbc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们试试吧！使用以下python代码将有效负载发送到服务器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7714" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回到艾达，这是正确的观点！RIP已被0x42424242覆盖！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/d5090ebcde8373087cb5571adf69f9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ix7knZTBEvVwhCz5T6OHMw.png"/></div></div></figure><p id="64eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在的下一个任务是创建一些外壳代码，将它作为有效载荷的一部分注入堆栈，并跳转到它。然而，我们不能在EIP直接硬编码堆栈地址，因为每次都不一样。因此，需要找到一个可靠的小工具，允许我们跳转到外壳代码。“jmp esp”指令正是我们所需要的，因为它直接指向我们覆盖的返回地址之后。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/113665169ba3066e20d4f9e5ff0f42c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*z_vvrTtirxiuNEd1LFGGvg.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">在esfunc.dll搜索“jmp esp”指令</figcaption></figure><p id="d258" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">IDA可以用来搜索指令，就像它可以用来搜索文本一样。按Alt+T，输入“jmp *esp”。不幸的是，vulnserver.exe没有这样的指令，但是它附带的库(esfunc.dll)呢？事实上，esfunc.dll在0x625011AF中有一个“jmp esp”指令。</p><p id="c072" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，让我们制作一个弹出计算器的外壳代码(太经典了！)用作概念证明。由于我们将为此使用<em class="mw"> msfvenom </em>，请确保您已经安装了<a class="ae lq" href="https://www.metasploit.com/" rel="noopener ugc nofollow" target="_blank"> metasploit框架</a>。运行以下命令获取外壳代码。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="81b7" class="nl lx it nh b gy nm nn l no np">msfvenom -p windows/exec CMD='calc.exe' exitfunc=thread -a x86 -f python -b '\x00'</span></pre><p id="834a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意-b参数，它设置了不良字符。考虑到输入缓冲区是使用<em class="mw"> strcpy </em>和<em class="mw"> strncpy </em>复制的，我们不希望我们的shell代码包含任何空字节，因为它们会中途终止复制。</p><p id="6bb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，有了这些，我们就有了构建我们的概念利用证明所需的所有部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9021" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管返回到“jmp esp”会直接跳到我们的外壳代码上，但是如果你没有包含足够大的NOP sled，它就不会工作。比如一个8字节的NOP sled就不行。这是因为外壳代码需要一些填充来编码，因此你需要通过NOPs给它一些空间。</p><p id="a0bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">表演时间到了！运行服务器，然后利用python漏洞。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1ae8ce79b9f83981126bf134a55b1137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4r4NtPbQiM23aQ2J9gL8fg.png"/></div></div></figure><p id="a02f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嘣！我们的恶意计算器弹出来了！😈</p><p id="6f60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下次见，伙计们。</p></div></div>    
</body>
</html>