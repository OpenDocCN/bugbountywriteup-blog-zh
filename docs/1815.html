<html>
<head>
<title>Learning Linux &amp; InfoSec Principles Using OverTheWire’s Bandit — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OverTheWire的Bandit学习Linux和InfoSec原理—第2部分</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/learning-linux-infosec-principles-using-overthewires-bandit-part-2-5beecb56e270?source=collection_archive---------4-----------------------#2022-01-18">https://infosecwriteups.com/learning-linux-infosec-principles-using-overthewires-bandit-part-2-5beecb56e270?source=collection_archive---------4-----------------------#2022-01-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="420f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从一个有趣的在线“战争游戏”开始学习Linux</h2></div><p id="dccb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">简介</strong></p><p id="3c28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在之前的帖子(<a class="ae lb" href="https://bit.ly/3r0woVT" rel="noopener ugc nofollow" target="_blank">https://bit.ly/3r0woVT</a>)中，我们已经从OverTheWire的强盗机器的前6关开始了我们的Linux之旅。如果你还没有读这篇文章，强烈推荐你——你会有一个更好的介绍。</p><p id="0a94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本质上，Bandit是OverTheWire.org网站提供的最基本的机器，旨在向人们介绍基本的Linux命令和信息安全思想。</p><p id="d722" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文的目标是通过使用强盗“wargame ”,为您提供一种实用而愉快的方式来了解Linux操作系统(尤其是<em class="lc"> bash </em> shell)。如果你已经阅读了第一篇文章，或者对这篇文章过于热情(我完全理解:)，那么让我们开始吧。</p><h1 id="1e17" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">我们停下来的地方</h1><p id="beb3" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">上一篇文章中我们做的最后一件事是获取6级的密码，也就是:dxjzpullxyr 17 uwoi 01 bnlqbtfemego 7。</p><p id="4f23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们连接到这一层。ssh的<em class="lc">命令是:</em></p><p id="3487" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ma mb mc md b">ssh -p 2220 bandit6@bandit.labs.overthewire.org</code></p><p id="3b9e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">SSH是一种用于到目标的安全外壳连接的协议。我们指定要在端口号2220上连接到主机<strong class="kh ir">bandit.labs.overthewire.org</strong>中的用户<strong class="kh ir"> bandit6 </strong>。输入密码，我们就进入了。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi me"><img src="../Images/c447a812c22148b2c8fe44c8dca8bf6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*i6ge6m2ug39ylgpUR9iMGg.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">登录<strong class="bd lf">盗匪</strong>机，<strong class="bd lf">6级</strong></figcaption></figure><h1 id="4619" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">6级→7级</h1><p id="5261" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我们在这一关的目标是找到下一关的密码。我们被告知密码文件可以位于服务器的任何地方<strong class="kh ir">，这意味着每个目录(文件夹)都可能是它的容器。我们还被告知，该文件归<strong class="kh ir"> bandit7 </strong>用户以及<strong class="kh ir"> bandit6 </strong>组所有。而且，文件的大小是<strong class="kh ir"> 33字节</strong>。</strong></p><p id="551a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Linux中，一个文件同时属于一个用户和一个组。这些设置决定了用户在系统上的权限，他们可以对给定文件做什么，不可以做什么。</p><p id="6314" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然拥有用户是不言自明的，但是<strong class="kh ir">组</strong>机制更加复杂。基本上，一个用户可以是几个组的成员，这些组是系统中的逻辑结构，每个组都有不同的权限。创建组有多种目的，例如:管理服务(数据库、web服务器……)、使用资源(打印机和其他硬件)等等。文件所属的组对其访问文件有特殊的权限。</p><p id="fc2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们知道<em class="lc"> ls </em>命令，它用于列出给定目录的内容。我们也遇到了这个命令的<em class="lc"> -l </em>选项，但是还没有彻底研究它——我们只是说它提供了更多的信息。现在就来研究一下吧。</p><p id="0e77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<em class="lc"> cd </em>命令，我导航到<strong class="kh ir"> /home/bandit4/inhere </strong>目录，我们上次访问过这个目录。在这里输入<em class="lc"> ls </em>可以看到有一些文件。让我们添加<em class="lc"> -l </em>选项:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/83050854ac87db08311c6a28d70cfd7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*sHeuSRt3-1e6a3lmbLvpgQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">执行<strong class="bd lf"> /home/bandit4/inhere </strong>目录下的<strong class="bd lf"> ls -l </strong></figcaption></figure><p id="729d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们发现我们收集了更多的信息。第一列，看起来像一个随机的字母序列，指定了文件的不同权限:我们现在忽略它。第二列显示了<strong class="kh ir">硬链接</strong>的数量，这是一个更高级的概念，我们将在后面讨论。</p><p id="a643" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来的专栏与我们更相关。第三列指定拥有该文件的用户(记住，我们搜索由<strong class="kh ir"> bandit7 </strong>拥有的文件)，下一列显示拥有该文件的组(desired: <strong class="kh ir"> bandit6 </strong>，如说明中所指定)。第五列显示文件的大小(所需:<strong class="kh ir"> 33 </strong>)。最后的细节是最后修改的日期&amp;时间。</p><p id="7f0a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们重新使用上次的策略:递归地列出所有文件，并对输出进行grep。递归地列出系统中所有文件的命令如下:</p><p id="c64a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ma mb mc md b">ls -laR /</code></p><p id="798f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经讨论过<em class="lc"> ls -l </em>。<em class="lc"> a </em>选项告诉<em class="lc"> ls </em>命令列出隐藏文件，而<em class="lc"> R </em>选项意味着<strong class="kh ir">递归列出</strong> —“进入”所有文件夹。末尾的/(斜杠)指示<em class="lc"> ls </em>开始列出来自操作系统的<strong class="kh ir">根的所有文件，即文件系统的“开始”。但是如果我们单独键入这个命令，我们将得到大量的输出，手动搜索效率极低。所以我们可以利用<em class="lc"> grep </em>命令。</strong></p><p id="a98b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc"> grep </em>是一个在一串文本中搜索模式的命令。通常，我们通过<strong class="kh ir">管道| </strong>使用它——使用另一个程序的输出作为<em class="lc"> grep </em>的输入。例如:</p><p id="56c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ma mb mc md b">ls -laR / | grep to_search</code></p><p id="c70d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将只显示包含短语“to_search”的<em class="lc"> ls </em>的输出行。我们希望根据<em class="lc"> ls </em>命令格式和我们级别的要求，搜索包含短语“bandit7 bandit6 33”的<em class="lc"> ls </em>条目。由于<em class="lc"> ls </em>格式化其输出的方式，我们现在将省略“33 ”,并运行以下命令:</p><p id="604f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ma mb mc md b">ls -laR / | grep "bandit7 bandit6"</code></p><p id="7081" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意引号，当我们搜索的模式包含空格时，我们必须用它们封装字符串。</p><p id="7329" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到很多输出，其中大部分是错误消息。在Linux中，错误消息被打印到<strong class="kh ir"> stderr </strong>文件中。目前，<strong class="kh ir"> stderr </strong>文件被定义为与<strong class="kh ir"> stdout </strong>相同——我们的默认输出流。这就是我们看到错误消息的原因。为了省略这些不必要的消息，我们将<strong class="kh ir">将错误输出文件重定向</strong>到一个名为<strong class="kh ir"> /dev/null </strong>的文件，该文件接收输入(被写入)并丢弃所有内容。为此，我们键入<em class="lc"> 2 &gt; /dev/null </em>。2 &gt;指定了错误消息将被发送到哪里，在我们的例子中→发送到<strong class="kh ir"> /dev/null </strong>文件。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/5c03699ef0b957c661276a681f0274fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*C8j8-Mq_Av2avZ_a1-v8ow.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">查找所需的文件</figcaption></figure><p id="36ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">万岁！我们得到了文件，我们知道它叫做<strong class="kh ir"> bandit7.password </strong>。但是我们不知道如何访问它，因为它的目录(完整路径)是未知的。为此，我们将使用<em class="lc">查找</em>命令，如下所示:</p><p id="ed41" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ma mb mc md b">find / -name bandit.password 2&gt; /dev/null</code></p><p id="e87d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">命令是<em class="lc"> find </em>，您已经知道/(斜杠)代表什么——find工具将从这个文件夹开始搜索。<em class="lc"> -name </em>参数表示我们将根据文件名搜索文件，我们接下来将提供文件名。最后但同样重要的是，我们像以前一样丢弃错误消息。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/3ae5121cfcc5c54fe29688f78b5dea83.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*q5FkJioiWUiYrzgv1_CquQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">查找密码文件的完整路径</figcaption></figure><p id="e7bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们读取文件，获取密码，进入下一关！</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/5788e9bdd3ec4060696e62823135ce8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*3KTeifzRGayf47aNNI3dJg.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">读取<strong class="bd lf">第7级</strong>的密码</figcaption></figure><h1 id="69e2" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">7级→8级</h1><p id="db8e" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">首先，使用我们刚刚收集的密码登录同一台机器，登录到用户<strong class="kh ir"> bandit7 </strong>。我们现在被告知，密码可以在<strong class="kh ir"> data.txt </strong>文件中找到，在第<strong class="kh ir">百万个</strong>字附近。</p><p id="d848" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还记得我们通常<strong class="kh ir"> pipe | </strong>输出到grep吗？看文件和<em class="lc">翻文件没什么区别！因此，让我们阅读该文件(在我们当前的目录中找到，执行一个基本的<em class="lc"> ls </em>并自己查看)，并grep单词<strong class="kh ir"> millionth </strong>:</em></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/a824b67290e9e01dcfaf6c3cdf64f92c.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*fIj6Jq8p9Hv36wpkvkzn_g.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">读取<strong class="bd lf">第8级</strong>的密码</figcaption></figure><h1 id="8e14" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">8级→9级</h1><p id="c3ce" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">现在，密码再次存储在<strong class="kh ir"> data.txt </strong>文件中，指令向我们揭示了它是唯一出现一次的文本行。如果我们试图读取文件，我们会看到大量的数据，我们无法手动处理，更不用说找到出现一次的行。</p><p id="35a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，我们不需要这么做。有一个强大的bash实用程序叫做<em class="lc"> uniq </em>，它可以立即向我们显示哪一行没有重复。<em class="lc"> uniq </em>的输入必须排序，所以我们也将使用<em class="lc">排序</em>命令。让我们看看怎么做。</p><p id="bf9f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经知道如何读取文件。为了对<strong class="kh ir"> data.txt </strong>的内容进行排序，我们将再次<strong class="kh ir"> pipe | </strong>输出<em class="lc"> cat </em>命令，对<em class="lc">进行排序</em>:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/b868670ca515d23151b579223fd9e447.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*CwnTCaguD4ior8FImUotEQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">读取<strong class="bd lf"> data.txt </strong>文件并排序</figcaption></figure><p id="f34e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以看到，现在所有相同的密码被分组在一起。同样，因为文件的内容太大，我们无法看到整个输出。</p><p id="68c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们前往uniq 。我们如何将最后一个命令的输出作为输入传递给uniq ？你猜对了，<strong class="kh ir">滚边| </strong>！因此，我们将重新执行最后一个命令，将它传送到<em class="lc"> uniq </em>。确保使用<em class="lc"> -u </em>选项运行<em class="lc"> uniq </em>，以便只输出完全唯一(出现一次)的行。注意，使用几个管道完全没问题。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/31cb6b618165dd572a0f7841777305ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*ytGTHx27kxHyfmStpOhMWA.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">读取<strong class="bd lf">第9级</strong>的密码</figcaption></figure><h1 id="521c" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">9级→10级</h1><p id="8bff" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">登录<strong class="kh ir"> bandit9 </strong>用户，阅读水平仪的说明:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/70a41f3f4c40631dc352c23651e6f13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*WyzLNwO4jXNYMjmcM-oPsQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><strong class="bd lf">第9级</strong>的说明</figcaption></figure><p id="6223" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们需要搜索<strong class="kh ir"> data.txt </strong>文件，寻找人类可读的字符串。如果您还记得以前的帖子，您可以回忆起<em class="lc"> strings </em>命令，它只输出人类可读的输入内容，我相信您知道我们将如何为这个命令提供输入。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi my"><img src="../Images/98f01e9e423a2b3d59f7096b3b3dc4be.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*Vl6f8A9hQb-jn4pUqSrEvA.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">在<strong class="bd lf"> data.txt </strong>文件中搜索人类可读的字符串</figcaption></figure><p id="78eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出与我们预期的一样，但仍然太大，我们无法手动探索。让我们利用这个级别的最后一个提示:密码前面有“=”。怎样才能找到包含这个字符的行？当然，你答对了。我们用<em class="lc"> grep </em>:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/8c8e9fec8a567692fe495c55ea8f218b.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*9rSABQvbmPlsKR4JFurUDw.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">读取<strong class="bd lf">10级</strong>的密码</figcaption></figure><p id="7e84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干得好。我们已成功获取密码！留到下一个帖子…</p><h1 id="76c2" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">结论</h1><p id="774e" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我希望通过这篇文章，您已经学习并提高了您的Linux技能。如前所述，我祈祷你也玩得开心！请留下一些评论，让我知道你更喜欢我做什么，或者希望我报道什么。</p><p id="8cb0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我必须感谢你们每一个阅读我帖子的人——你们太棒了。现在再见。祝你玩得愉快，直到我们再次见面！</p></div></div>    
</body>
</html>