<html>
<head>
<title>How I was able to Turn a XSS into a Account Takeover</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何把一个XSS变成一个帐户接管</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/how-i-was-able-to-turn-a-xss-into-a-account-takeover-ae0c478640e7?source=collection_archive---------0-----------------------#2021-02-03">https://infosecwriteups.com/how-i-was-able-to-turn-a-xss-into-a-account-takeover-ae0c478640e7?source=collection_archive---------0-----------------------#2021-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c3ff5a22816e0a543074ea739ecc4c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fmeIX9ateFf0oHtz8fH1A.jpeg"/></div></div></figure><p id="6e07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，这是我在一次bug赏金任务中发现的一个漏洞。我会把它分成两部分，或者两个独立的漏洞。第一部分是通过X头的网络缓存中毒。这部分允许我用两个头的组合在每个端点上实现XSS。接下来的部分是OAuth流缺陷，它允许我通过一种我称之为cookie覆盖的技术，将我之前提供的XSS功能用于帐户接管。在我开始解释这个漏洞链之前，我必须说，由于这是一个私人程序，我不能透露它是在哪个网站上被发现的。</p><p id="0ad8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Web缓存中毒:</p><p id="2183" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">James Kettle在Portswigger上很好地记录了这个漏洞，这也是我第一次听说它的地方，所以要获得更深入的介绍，我推荐阅读那篇文章。但是，对于快速入门者来说，web缓存中毒是一个漏洞，它允许攻击者通过将恶意代码注入非键控HTTP请求标头来毒害HTTP响应。web缓存基本上是网站通过向用户重播资源而无需多次请求服务器来降低服务器负载的一种方式。它们在HTTP请求中寻找特定的键，以确定它们是否已经缓存了资源，如果已经缓存了，那么任何匹配该请求的用户都会得到服务。这些缓存键可以是从URI到接受HTTP请求头的任何内容。但是，有一些HTTP请求头是没有关键字的，根据所实现的代码，可能会将反射输出引入到HTTP响应中。一个流行的并且将在本报告中被利用的是X-Forwarded-Host报头。该报头可以填充XSS有效载荷，并用于将XSS有效载荷反映到HTTP响应中。在缓存获得这个响应并保存它而没有未加密的头之后，您可以认为缓存中毒了，它会将响应传递给访问该URL的每个用户。这是攻击的基础，但这可以用另一个未加密的标题来补充，以增加严重性，这样您就可以毒害网站上每个URL的缓存。这个头是X-Rewrite-Url头，它基本上重写了被缓存的URN。假设HTTP请求中的URN是/home，缓存认为它保存了这个HTTP响应。但是如果添加X-Rewrite-Url头，它实际上会在/evil加载恶意的HTTP响应。标头通常是未加密的，因此它将为任何请求/home的用户提供中毒响应。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/0ee73c40b6068dd92d786766b5e4452a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JO8KDFrktMhU5O6FaTxs3Q.png"/></div></div></figure><p id="59c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">漏洞链(第1部分):</p><p id="fb70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事情是这样的，我找到了一个支持这两种头的站点，并且有一个页面在其中一个页面的JavaScript变量中反映了X-Forwarded-Host头。使用X-Forwarded Host和X-Rewrite-Url头的组合，我能够在没有用户交互的情况下在站点的每个页面上获得XSS。然而，它实际上只缓存了大约3分钟。为了提高严重性，我编写了一个脚本来自动中毒，声明我可以每3分钟毒害一次主页端点，以感染访问该站点的每个用户。然而，接受报告的团队希望保持中等严重性。这不是我想看到的，所以我去寻找另一种方式来增加严重性。这让我想到了这篇文章的第二部分，由于Oauth流程中的一个缺陷导致的帐户接管。</p><p id="5676" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">OAuth流动缺陷:</p><p id="4428" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您不熟悉OAuth，这一节将介绍授权的流程，这就是本例中使用的授权。这个授权有四个主要实体，应用程序、用户、授权服务器和资源提供者。第一步是用户请求访问资源。应用程序或OAuth客户端看到这个请求，并将用户重定向到授权服务器。用户向授权服务器验证他们的凭证，如果被批准，则获得访问代码。在这之后，用户被重定向回应用程序，客户端获取这个访问代码。然后，应用程序获取该代码，并通过授权服务器对其进行验证，最后获得一个访问令牌。这个访问令牌用于代表用户从资源提供者检索数据。该站点上的问题是，在代码被发回后，它被一个url处理，该URL接受cookie中的一个值，该值是另一个受信任的OAuth回调URL，并将代码附加到该URL末尾的一个哈希片段之后，并将浏览器重定向到该位置。这使得任何更改cookie值的人都可以将代码重定向到任意位置。之后，攻击者只需将代码提交给授权服务器，就可以代表目标用户获得访问令牌。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/6949ad259978688df65cb11e08180bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nR_V4SS14CWJu4tIMqqc6g.png"/></div></div></figure><p id="c2b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Cookie覆盖:通常这不是一个问题，因为两个因素，cookie是HTTPOnly，第二，cookie中的URL被列入白名单，只允许受信任的站点访问。第二个问题在我的案例中已经解决了，因为缓存中毒XSS已经在一个受信任的子域上。第一个问题是必须解决的问题。如何使用XSS来更改HTTPOnly的cookie值？答案是不需要，您可以制作一个看起来像HTTPOnly cookie的cookie，并将path参数设置为使用该cookie的某个URN。如果浏览器看到两个同名的cookie，但其中一个有更具体的路径，当对该路径的HTTP请求被请求时，它将优先选择具有特定路径的cookie。有了这个，我就可以使用XSS在中毒子域上创建一个cookie，这个cookie可以在根域下的所有子域上工作，并且它会将特定路径设置为在cookie值中启动URL的路径。</p><p id="c571" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">漏洞链(第2部分):</p><p id="5542" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在组装了所有的部分之后，全球中毒XSS，cookie覆盖，OAuth缺陷问题是我如何把这些放在一起，并实际接管帐户。这是我想出的漏洞链。考虑到时间限制，首先我毒死了两个端点。第一个端点具有XSS有效负载，并且位于站点的主页上。它将恶意cookie写入用户的浏览器，然后将浏览器重定向到OAuth流。第二个中毒端点位于不存在的端点上，该端点的404响应代码被中毒响应覆盖。此端点处理来自插入cookie中的重定向URL的回调。该URL包含来自OAuth流的代码，在收到代码后，有效负载使用另一个document.location将代码以查询字符串的形式发送到攻击者的站点。在攻击者站点的端点上，我添加了另一个document.location。在记录了URL和代码之后，将用户的浏览器返回到站点的一个常规页面。整个过程执行大约需要5秒钟，避免了时间限制。</p><p id="1ae4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结论:</p><p id="78b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是在HackerOne上报告的，并且严重性被提升到临界。</p><p id="a900" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参考资料:</p><p id="340a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lc" href="https://portswigger.net/research/practical-web-cache-poisoning" rel="noopener ugc nofollow" target="_blank">https://ports wigger . net/research/practical-we B- cache-poisoning</a></p><ul class=""><li id="c2d7" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated">与我联系:Twitter @Pullerze</li></ul></div></div>    
</body>
</html>