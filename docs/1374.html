<html>
<head>
<title>Securing REST with free API Firewall🔒 How-to guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用免费API防火墙保护REST🔒操作指南</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/securing-rest-with-free-api-firewall-how-to-guide-6375aefeb5be?source=collection_archive---------3-----------------------#2021-06-08">https://infosecwriteups.com/securing-rest-with-free-api-firewall-how-to-guide-6375aefeb5be?source=collection_archive---------3-----------------------#2021-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c309" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在当今世界，网络应用变得越来越重要。坏演员知道这一点，他们比以往任何时候都更频繁地针对他们。这不太可能很快停止，因为随着对技术的依赖，世界需要的网络应用数量只会增加。完全防止攻击是不可能的，但我们需要尽最大努力做到这一点，在这个领域的日常斗争中，我们有一种武器，称为“硬化”。</p><h1 id="0157" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是硬化</h1><p id="1645" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">从最基本的意义上来说，强化你的服务器意味着增强它的防御能力，但实际上，服务器有很多易受攻击的地方。一种常用的技术是净化我们应用程序中的用户输入。用户数据可能包含恶意代码或意想不到的输入，我们应该小心加强我们的服务器对这种行为。</p><p id="efc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种经常使用的强化技术是javascript混淆。Web应用不再是过去的静态网站。它们包含大量javascript，这些javascript可能会向潜在的黑客透露大量信息。为了防止这种情况，代码被混淆，这样黑客就很难弄清楚应用程序的内部工作方式。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/948a7970a7127eede02a9b9f547b02e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZyuZkp8Yg4p1CuLc"/></div></div></figure><p id="5e69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据包级别的防火墙已经在生产环境中实施了很长时间，但是最近<a class="ae ma" href="https://www.wallarm.com/product/cloud-waf" rel="noopener ugc nofollow" target="_blank"> Web应用防火墙</a>正在快速普及。他们将检查任何http请求，根据配置，他们可能会报告或阻止任何包含意外或恶意输入的调用。这只是现代系统管理员工具箱中的一个工具，但却是一个非常重要的工具。</p><h1 id="4e5c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">硬化与不硬化</h1><p id="2109" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">像生活中所有美好的事情一样，强化web应用程序也是有代价的。更坚固的服务器将更安全，不会受到攻击者的攻击，但它也会更慢，因为所有这些安全措施都是有代价的。它们将需要整个系统及其组件更多的处理时间，这可能会大大降低应用程序的速度。</p><p id="dc26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正是因为这个原因，通常需要在实施太少的强化和实施太多的强化之间取得平衡。</p><h1 id="6791" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">符合API防火墙</h1><p id="0eb1" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">API Firewall是一款轻量级API防火墙，通过API模式验证来保护云原生环境中的API端点。API Firewall依赖于一个积极的安全模型，允许符合预定义API规范的调用，同时拒绝其他所有调用。</p><p id="3b62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从技术上来说，API Firewall是一个反向代理，内置了OpenAPI v3请求和响应验证器，用Go编写，并针对极高的性能和接近零的额外延迟进行了优化。</p><h1 id="03bb" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">先决条件</h1><p id="7052" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">要安装API防火墙，我们需要满足几个先决条件。</p><ul class=""><li id="f8d2" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">Docker守护程序已安装(<a class="ae ma" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank">https://www.docker.com/</a>)</li><li id="9cdd" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">需要安装git(【https://www.atlassian.com/git/tutorials/install-git】T2</li><li id="662b" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">API防火墙，我们将在稍后的指南中下载(【https://hub.docker.com/r/wallarm/api-firewall】T4)</li><li id="7d18" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">Zalando的连接演示API repo<a class="ae ma" href="https://github.com/zalando/connexion" rel="noopener ugc nofollow" target="_blank">https://github.com/zalando/connexion</a></li></ul><h1 id="f70b" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">安装连接演示</h1><p id="3595" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">为了测试我们的WAF，我们将使用Zalando提供的<em class="mp">连接</em>演示。当然，我们需要安装并运行它。我们可以通过一个简单的命令做到这一点。</p><p id="843f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">pip安装连接[swagger-ui]稍后我们将启动<em class="mp">连接</em>，这样我们就可以用我们的API防火墙测试它。</p><h1 id="dffc" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">安装</h1><p id="a0f6" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">首先，在克隆连接库之前，我们进入/ <em class="mp"> tmp </em>目录。</p><pre class="lp lq lr ls gt mq mr ms mt aw mu bi"><span id="02e3" class="mv km iq mr b gy mw mx l my mz">cd /tmp<br/>git clone &lt;https://github.com/zalando/connexion&gt;</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi na"><img src="../Images/a13e10c0097d0bd13c8f192af6423181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/0*LhbwfIOc_eCHOMTp"/></div></figure><p id="dfaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要从docker hub中取出<em class="mp"> api-firewall </em> docker文件</p><p id="ed4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">docker拉墙/API-防火墙</p><p id="5600" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步，我们可以使用以下命令轻松运行API防火墙</p><pre class="lp lq lr ls gt mq mr ms mt aw mu bi"><span id="c017" class="mv km iq mr b gy mw mx l my mz">docker run -d -v /tmp/connexion/examples/openapi3/methodresolver/openapi/:/tmp -e APIFW_SERVER_URL=http://178.79.152.114:9090/v1.0/ -e APIFW_API_SPECS=/tmp/pets-api.yaml -e APIFW_REQUEST_VALIDATION=BLOCK -e APIFW_RESPONSE_VALIDATION=BLOCK -p 8282:8282 wallarm/api-firewall</span></pre><p id="f6f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将在后台启动我们的docker容器，并为我们提供docker容器的标识符。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nb"><img src="../Images/c866c5e6cfde3563eff1f4a58b3ca5b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5tlPCyaj6MvRn346"/></div></div></figure><p id="8891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来是启动connexion python应用程序，因为我们需要测试一些东西。我们可以通过进入“methodresolver”目录并使用python3启动应用程序来实现这一点。</p><pre class="lp lq lr ls gt mq mr ms mt aw mu bi"><span id="fc7b" class="mv km iq mr b gy mw mx l my mz">cd /tmp/connexion-master/examples/openapi3/methodresolver/<br/>python3 app.py</span></pre><p id="3918" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以查看它在日志中使用的URL。</p><p id="eb52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们需要测试使用curl时一切都正常。我们将尝试发出一个PUT请求来更新一些数据，看看是否可行。我们必须从外部计算机执行这个请求，因为我们将与服务器的公共IP地址对话。确保用你的IP地址替换我们的。</p><pre class="lp lq lr ls gt mq mr ms mt aw mu bi"><span id="9f95" class="mv km iq mr b gy mw mx l my mz">curl -X PUT -H 'content-type: application/json' -d '{"name":"homyak-2", "tag":"aa"}' &lt;http://178.79.152.114:8282/v1.0/pets/3&gt;</span></pre><p id="7b0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这应该会返回以下输出。</p><pre class="lp lq lr ls gt mq mr ms mt aw mu bi"><span id="fa24" class="mv km iq mr b gy mw mx l my mz">{ "id": 3, "last_updated": "2021-06-05T19:21:35.399530Z", "name": "homyak-2", "tag": "aa" }</span></pre><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/cdd9eda6c70fa70150c7f774e6e9780f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/0*h6ZsXq8YlVLNq6zd"/></div></figure><p id="94ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个工作的API框架和一个工作的API防火墙，我们可以尝试发出一个恶意的请求。</p><pre class="lp lq lr ls gt mq mr ms mt aw mu bi"><span id="56ba" class="mv km iq mr b gy mw mx l my mz">curl -X PUT -H 'content-type: application/json' -d '{"name":111, "tag":"aa"}' &lt;http://178.79.152.114:8282/v1.0/pets/3&gt;</span></pre><p id="470c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将返回403错误响应。</p><p id="01c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在服务器上检查这一点，我们可以使用命令“docker logs CONTAINERID”返回并检查docker容器的日志，其中CONTAINERID是我们通过运行“docker run”命令获得的。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nb"><img src="../Images/44eccdd27129bc99ad193934275a6922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ep-aMb10l36Cdfp4"/></div></div></figure><p id="4c58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您丢失了这个ID，这不是问题，您可以使用“docker容器”来检查正在运行的docker容器。接下来，我们可以运行“docker logs”命令来查看我们的日志，并看到API防火墙正在过滤掉请求并阻止它们。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/34a2ee16276a1d2b32c76a33b9eaa6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EfwqP2VxFbR0tlDM"/></div></div></figure><h1 id="2f5a" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">基本细节</h1><p id="a753" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">让我们谈一谈我们正在做的事情。首先，我们正在下载connexion，这是一个演示应用程序，将帮助我们测试我们的API防火墙。为了运行它，我们需要通过python的pip来安装它。</p><p id="c3f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拉出docker容器后，我们使用docker容器在端口8282上启动防火墙。使用了以下命令。</p><pre class="lp lq lr ls gt mq mr ms mt aw mu bi"><span id="a50c" class="mv km iq mr b gy mw mx l my mz">docker run -d -v /tmp/connexion/examples/openapi3/methodresolver/openapi/:/tmp -e APIFW_SERVER_URL=http://178.79.152.114:9090/v1.0/ -e APIFW_API_SPECS=/tmp/pets-api.yaml -e APIFW_REQUEST_VALIDATION=BLOCK -e APIFW_RESPONSE_VALIDATION=BLOCK -p 8282:8282 wallarm/api-firewall</span></pre><p id="b596" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在其中，我们使用以下标志来表示端口8282应该被转发。</p><p id="72a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-p 8282:8282</p><p id="0fdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还使用标志-e API fw _ SERVER _ URL = http://178 . 79 . 152 . 114:9090/v 1.0/来指示我们的web服务器在哪里运行。稍后导航到“/tmp/connexion-master/examples/open API 3/method resolver/”并使用“python3 app.py”启动应用程序，该web服务器将由来自connexion演示的pets示例组成。当然，您需要稍后将ip地址替换为您自己的服务器的IP地址，并且不要忘记更改端口。您可以将您的web服务器托管在与API-firewall相同的服务器上，也可以托管在不同的服务器上，在我们的例子中，我们将运行在相同的服务器上。</p><p id="9740" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“-e API fw _ REQUEST _ VALIDATION = BLOCK-e API fw _ RESPONSE _ VALIDATION = BLOCK”标志确保未通过验证规则的请求会被阻止。</p><p id="01bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-v参数将本地驱动器上的“/tmp/connexion/examples/open API 3/method resolver/open API/”文件夹挂载到docker容器上的“/tmp”文件夹。</p><p id="eb0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后-d标志确保docker容器将在后台运行。</p><p id="3bd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还想说的一件事是docker中的“-e”标志表示一个环境变量。既然我们正在保护我们的应用程序，我们也需要启动它。当我们转到/tmp/connexion/examples/open API 3/method resolver/并运行“python3 app.py”时，这正是我们要做的。这将在端口9090上启动一个web服务器，并为API提供服务。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/2970b0eca4f72af38e3cb7641c25ce48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G4KznDCJHucEZkGZ"/></div></div></figure><p id="5381" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们有了一个API防火墙的工作系统，它过滤流向我们API的流量。在现实生活中，我们现在将禁止外部网络访问端口9090，只允许来自内部网络的流量。</p><h1 id="536e" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">其他环境变量</h1><p id="73f4" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">除了前面提到的使用“-e”标志的环境变量之外，我们还有其他几个选项。</p><p id="2cc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">主要部分:</strong></p><pre class="lp lq lr ls gt mq mr ms mt aw mu bi"><span id="ffb8" class="mv km iq mr b gy mw mx l my mz">APIFW_URL: "http://0.0.0.0:8081" # listening protocol, address and port APIFW_LOG_LEVEL: "DEBUG" # could be INFO, ERROR, WARNING or DEBUG APIFW_READ_TIMEOUT: "5s" APIFW_WRITE_TIMEOUT: "5s" APIFW_SHUTDOWN_TIMEOUT: "5s" APIFW_REQUEST_VALIDATION: "BLOCK" # could be BLOCK, LOG_ONLY or DISABLE APIFW_RESPONSE_VALIDATION: "BLOCK" # could be BLOCK, LOG_ONLY or DISABLE</span></pre><p id="3903" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> TLS部分</strong></p><pre class="lp lq lr ls gt mq mr ms mt aw mu bi"><span id="3c56" class="mv km iq mr b gy mw mx l my mz">APIFW_TLS_CERTS_PATH: "/api-firewall/resources/certs" APIFW_TLS_CERT_FILE: "localhost.crt" APIFW_TLS_CERT_KEY: "localhost.key"</span></pre><p id="b8b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> OpenAPI规范章节</strong></p><p id="a0c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">API-防火墙仅支持OpenAPI spec v3。该文件可能有JSON或YAML扩展名。</p><pre class="lp lq lr ls gt mq mr ms mt aw mu bi"><span id="59a1" class="mv km iq mr b gy mw mx l my mz">APIFW_API_SPECS: "/api-firewall/resources/swagger.json"</span></pre><p id="e98c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">服务器部分</strong></p><p id="fe04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本节配置API防火墙保护的API后端。</p><pre class="lp lq lr ls gt mq mr ms mt aw mu bi"><span id="5174" class="mv km iq mr b gy mw mx l my mz">APIFW_SERVER_URL: "http://example.com/v1/" APIFW_SERVER_MAX_CONNS_PER_HOST: 512 APIFW_SERVER_READ_TIMEOUT: "5s" APIFW_SERVER_WRITE_TIMEOUT: "5s" APIFW_SERVER_DIAL_TIMEOUT: "200ms"</span></pre><h1 id="3406" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="9dff" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在使用API防火墙并安装之后，我们看到了它的安装和定制的简易性。我们可以很容易地设置我们想要监控什么api，以及在恶意代码被明确识别的情况下我们想要做什么。所有这些都是免费的，没有任何限制，这使得它更好，因为一些WAF解决方案可能会变得非常昂贵。</p><p id="f368" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于API防火墙是在docker容器中提供的，我们可以通过helm chart轻松地将该容器部署到kubernetes集群中，该helm chart可以在<a class="ae ma" href="https://github.com/wallarm/api-firewall/tree/main/helm/api-firewall" rel="noopener ugc nofollow" target="_blank">https://github . com/wall arm/API-firewall/tree/main/helm/API-firewall</a>找到，或者使用docker-compose选项，我们可以在<a class="ae ma" href="https://github.com/wallarm/api-firewall/tree/main/demo/docker-compose" rel="noopener ugc nofollow" target="_blank">https://github . com/wall arm/API-firewall/tree/main/demo/docker-compose</a>找到演示。最后，我想呼吁大家采取行动，如果您有任何改进，请毫不犹豫地向https://github.com/wallarm/api-firewall<a class="ae ma" href="https://github.com/wallarm/api-firewall" rel="noopener ugc nofollow" target="_blank">的同一个存储库提出请求。事实上，这些配置是开源的，这让我对它们的操作更有信心，我希望我能激励你们中的一些人研究这些配置，甚至可能创建自己的拉请求。</a></p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="9425" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mp">原载于2021年6月8日https://lab.wallarm.com</em><em class="mp"/><a class="ae ma" href="https://lab.wallarm.com/securing-rest-with-free-api-firewall-how-to-guide/" rel="noopener ugc nofollow" target="_blank"><em class="mp">。</em></a></p></div></div>    
</body>
</html>