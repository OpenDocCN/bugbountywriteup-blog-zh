<html>
<head>
<title>Why does my app send network requests when I open an SVG file?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当我打开SVG文件时，为什么我的应用程序会发送网络请求？</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/why-does-my-app-send-network-requests-when-i-open-an-svg-file-760d8bd51fea?source=collection_archive---------2-----------------------#2022-02-18">https://infosecwriteups.com/why-does-my-app-send-network-requests-when-i-open-an-svg-file-760d8bd51fea?source=collection_archive---------2-----------------------#2022-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1405e225e6c607286d6a5bff9fb5bd39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zKXfXkCdgLMydCCg.png"/></div></div></figure><p id="2543" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你决定开发一个支持SVG的应用程序。在热情的鼓舞下，你收集了图书馆并成功地提出了申请。但是突然你发现app在发奇怪的网络请求。数据从主机中泄漏。为什么</p><p id="1956" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在当今世界，你可以在任何场合拥有一个图书馆。因此，让我们不要为我们的应用程序重新发明轮子，并采取现成的解决方案。例如，SVG.NET图书馆。该项目的源代码是GitHub 上的<a class="ae kw" href="https://github.com/svg-net/SVG" rel="noopener ugc nofollow" target="_blank">。NuGet是作为一个NuGet包分发的，如果您想将库添加到项目中，这个包会很方便。顺便说一下，根据NuGet Gallery </a>中<a class="ae kw" href="https://www.nuget.org/packages/svg" rel="noopener ugc nofollow" target="_blank">项目的页面，该图书馆有250万次下载——令人印象深刻！</a></p><p id="6cd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看前面描述的应用程序的合成代码示例:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="febf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">程序的逻辑很简单:</p><ul class=""><li id="169f" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated">我们从用户那里得到一张照片。我们如何得到照片并不重要。</li><li id="ab98" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">创建了<em class="lr"> SvgDocument </em>类型的实例。此外，某些操作是通过该实例执行的。比如一些变换。</li><li id="0b7e" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">应用程序将修改后的图片发送回用户。</li></ul><p id="79e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，<em class="lr"> GetSvgFromUser </em>和<em class="lr"> SendSvgToUser </em>方法的实现并不重要。我们假设第一种方法通过网络接收图片，第二种方法发送回来。</p><p id="7b0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">「SVG文档处理…」背后隐藏着什么？同样，隐藏什么对我们来说并不重要，所以…应用程序不会执行任何操作。</p><p id="5cda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，我们只是上传图像，然后取回它。好像没什么复杂的。但这足以让奇怪的事情开始发生。:)</p><p id="5725" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的实验，让我们取一个特别准备的SVG文件。它看起来像PVS-Studio分析仪的标志。让我们看看徽标在浏览器中的样子，以确保一切正常。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/3720a25ff70e9c2bc8b54b0947525682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/0*ynhnaG8872A6vnMV.png"/></div></figure><p id="61d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，商标没有问题。接下来，我们把它上传到app上。应用程序不执行任何操作(让我提醒您，上面代码中的注释后面没有隐藏任何东西)。应用程序只是把SVG文件发回给我们。</p><p id="2e96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们打开收到的文件，并期待看到相同的图片。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/f5cbf3ae655674637f673f7622d2baf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/0*LHfP_uIf6NPrCIKW.png"/></div></figure><p id="9972" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最有趣的事情发生在幕后(在<em class="lr"> SvgDocument期间。打开&lt;T&gt;T11】方法调用)</em></p><p id="6e6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，应用程序向<a class="ae kw" href="https://pvs-studio.com/" rel="noopener ugc nofollow" target="_blank">pvs-studio.com</a>发送了一个计划外的请求。例如，通过监控应用程序的网络活动，您可以看到这一点。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lt"><img src="../Images/30ddd1ed2ffe112d68bbc59796babdc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FXtP1nELlV5_IQSs.png"/></div></div></figure><p id="ae52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其次，应用程序的用户从打开SVG的机器上接收到了<a class="ae kw" href="https://en.wikipedia.org/wiki/Hosts_(file)" rel="noopener ugc nofollow" target="_blank"> hosts </a>文件。</p><p id="13c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">怎么会？主机文件在哪里？让我们看看从应用程序接收的SVG文件的文本表示。让我去掉不必要的部分，这样它们就不会分散我们的注意力。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><pre class="kx ky kz la gt lu lv lw lx aw ly bi"><span id="b98d" class="lz ma iq lv b gy mb mc l md me">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;!DOCTYPE svg .... &gt;<br/>&lt;svg ....&gt;<br/>  &lt;style type="text/css"&gt;<br/>    ....<br/>  &lt;/style&gt;<br/>  &lt;polygon .... /&gt;<br/>  &lt;polygon .... /&gt;<br/>  &lt;polygon .... /&gt;<br/>  &lt;polygon .... /&gt;<br/>  &lt;polygon&gt;# Copyright (c) 1993-2009 Microsoft Corp.<br/>#<br/># This is a sample HOSTS file used by Microsoft TCP/IP <strong class="lv ir">for</strong> Windows.<br/>#<br/># This file contains the mappings of IP addresses to host names. Each<br/><strong class="lv ir"># entry should be kept on an individual line. The IP address should</strong><br/><strong class="lv ir"># be placed in the first column followed by the corresponding host name.</strong><br/># The IP address <strong class="lv ir">and</strong> the host name should be separated by at least one<br/><strong class="lv ir"># space.</strong><br/>#<br/># Additionally, comments (such as these) may be inserted on individual<br/><strong class="lv ir"># lines or following the machine name denoted by a '#' symbol.</strong><br/>#<br/># For example:<br/>#<br/>#      102.54.94.97     rhino.acme.com          <strong class="lv ir"># source server</strong><br/>#       38.25.63.10     x.acme.com              <strong class="lv ir"># x client host</strong><br/>#<br/><strong class="lv ir"># localhost name resolution is handled within DNS itself.</strong><br/>#   127.0.0.1       localhost<br/>#   ::1             localhost<br/>#<br/># A special comment indicating that XXE attack was performed successfully.<br/>#&lt;/polygon&gt;<br/>&lt;/svg&gt;</span></pre><p id="4bb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是机器上的hosts文件——小心地隐藏在SVG文件中，没有任何外部表现。</p><p id="3381" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主机内容来自哪里？额外的网络请求来自哪里？好吧，让我们弄清楚。</p><h1 id="4a74" class="mf ma iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">关于XXE袭击事件</h1><p id="792f" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">那些知道XXE<a class="ae kw" href="https://pvs-studio.com/en/blog/terms/6546/" rel="noopener ugc nofollow" target="_blank">袭击</a>的人可能已经弄清楚发生了什么。如果你没有听说过XXE或者已经忘记了它是什么，我强烈推荐你阅读下面这篇文章:“<a class="ae kw" href="https://pvs-studio.com/en/blog/posts/csharp/0918/" rel="noopener ugc nofollow" target="_blank">由于XML文件处理带来的漏洞:理论和实践中C#应用中的XXE</a>”。在文章中，我谈了什么是XXE，攻击的原因和后果。理解本文的其余部分需要这些信息。</p><p id="3367" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我提醒你，执行XXE攻击你需要:</p><ul class=""><li id="1f6b" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated">可能受到危害的用户数据；</li><li id="6882" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">具有不安全配置的XML分析器。</li></ul><p id="b0b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果XML解析器处理的受损数据以某种形式返回给攻击者，攻击者也会受益。</p><p id="954f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，“所有的星星都对齐了”:</p><ul class=""><li id="46c3" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated">受损数据是用户发送给应用程序的SVG文件；</li><li id="4062" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">不安全配置的XML解析器——我们在SVG处理库中有它；</li><li id="bf9a" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">解析器的工作结果以“处理过的”SVG文件的形式返回给用户。</li></ul><h1 id="f7f9" class="mf ma iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">受损数据</h1><p id="086d" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">首先，记住<a class="ae kw" href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics" rel="noopener ugc nofollow" target="_blank"> SVG格式是基于XML </a>的。这意味着我们可以在SVG文件中定义和使用XML实体。这些是XXE所需要的实体。</p><p id="d45a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管“虚拟”SVG文件在浏览器中看起来很正常，但它包含两个实体的声明:</p><pre class="kx ky kz la gt lu lv lw lx aw ly bi"><span id="1146" class="lz ma iq lv b gy mb mc l md me">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;!DOCTYPE polygon [<br/>  &lt;!ENTITY queryEntity <br/>   SYSTEM "https://files.pvs-studio.com/rules/ccr.xml"&gt;<br/>  &lt;!ENTITY hostsEntity <br/>   SYSTEM "file:///C:/Windows/System32/drivers/etc/hosts"&gt;<br/>]&gt;<br/>&lt;svg id="Layer_1" <br/>     data-name="Layer 1" <br/>      <br/>     viewBox="0 0 1967 1933.8"&gt;<br/>  &lt;style type="text/css"&gt;<br/>    ....<br/>  &lt;/style&gt;<br/>  ....<br/>  &lt;polygon&gt;&amp;queryEntity;&lt;/polygon&gt;<br/>  &lt;polygon&gt;&amp;hostsEntity;&lt;/polygon&gt;<br/>&lt;/svg&gt;</span></pre><p id="ce4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果XML解析器使用外部实体，那么:</p><ul class=""><li id="2f1a" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated">当处理<em class="lr"> queryEntity </em>时，它会向files.pvs-studio.com发送一个网络请求；</li><li id="afec" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">当处理<em class="lr"> hostsEntity </em>时，它将替换hosts文件的内容，而不是实体。</li></ul><p id="1915" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这被证明是一种SVG陷阱:在渲染时，文件看起来很正常，但在内部——它有一些棘手的东西。</p><h1 id="6b43" class="mf ma iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">配置不安全的XML解析器</h1><p id="ee2b" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">记住，使用外部库是要付出代价的。如果您已经列出了可能的负面后果，那么还有一件事—潜在的安全缺陷。</p><p id="5f3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了创建<em class="lr"> SvgDocument </em>实例，我们使用了<em class="lr">Open&lt;T&gt;T3】方法。它的源代码如下所示:</em></p><pre class="kx ky kz la gt lu lv lw lx aw ly bi"><span id="2668" class="lz ma iq lv b gy mb mc l md me"><strong class="lv ir">public</strong> <strong class="lv ir">static</strong> T Open&lt;T&gt;(Stream stream) where T : SvgDocument, <strong class="lv ir">new</strong>()<br/>{<br/>  <strong class="lv ir">return</strong> Open&lt;T&gt;(stream, null);<br/>}</span></pre><p id="a6f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个方法又会调用另一个重载:</p><pre class="kx ky kz la gt lu lv lw lx aw ly bi"><span id="fb76" class="lz ma iq lv b gy mb mc l md me"><strong class="lv ir">public</strong> <strong class="lv ir">static</strong> T Open&lt;T&gt;(Stream stream, <br/>                        Dictionary&lt;string, string&gt; entities) <br/>  where T : SvgDocument, <strong class="lv ir">new</strong>()<br/>{<br/>  <strong class="lv ir">if</strong> (stream == null)<br/>  {<br/>    <strong class="lv ir">throw</strong> <strong class="lv ir">new</strong> ArgumentNullException("stream");<br/>  }</span><span id="a3bf" class="lz ma iq lv b gy nh mc l md me">  <em class="lr">// Don't close the stream via a dispose: that is the client's job.</em><br/>  var reader = <strong class="lv ir">new</strong> SvgTextReader(stream, entities)<br/>  {<br/>    XmlResolver = <strong class="lv ir">new</strong> SvgDtdResolver(),<br/>    WhitespaceHandling = WhitespaceHandling.Significant,<br/>    DtdProcessing = <br/>      SvgDocument.DisableDtdProcessing ? DtdProcessing.Ignore <br/>                                       : DtdProcessing.Parse,<br/>  };<br/>  <strong class="lv ir">return</strong> Open&lt;T&gt;(reader);<br/>}</span></pre><p id="929b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">展望未来，我想说的是在<em class="lr">打开&lt; T &gt;(阅读器)</em>中，读取SVG文件并创建<em class="lr"> SvgDocument </em>的实例。</p><pre class="kx ky kz la gt lu lv lw lx aw ly bi"><span id="7b12" class="lz ma iq lv b gy mb mc l md me"><strong class="lv ir">private</strong> <strong class="lv ir">static</strong> T Open&lt;T&gt;(XmlReader reader) where T : <br/>  SvgDocument, <strong class="lv ir">new</strong>()<br/>{<br/>  ....<br/>  T svgDocument = null;<br/>  ....</span><span id="9d1c" class="lz ma iq lv b gy nh mc l md me">  <strong class="lv ir">while</strong> (reader.Read())<br/>  {<br/>    <strong class="lv ir">try</strong><br/>    {<br/>      <strong class="lv ir">switch</strong> (reader.NodeType)<br/>      {<br/>        ....<br/>      }<br/>    }<br/>    <strong class="lv ir">catch</strong> (Exception exc)<br/>    {<br/>      ....<br/>    }<br/>  }<br/>  ....<br/>  <strong class="lv ir">return</strong> svgDocument;<br/>}</span></pre><p id="f00b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lr">虽然(读者。Read()) </em>和<em class="lr">switch(reader . nodetype)</em>构造应该是每个使用过<em class="lr"> XmlReader </em>的人都熟悉的。这是一种典型的XML读取代码，让我们不要纠缠于此，而是回到创建XML解析器。</p><pre class="kx ky kz la gt lu lv lw lx aw ly bi"><span id="e9aa" class="lz ma iq lv b gy mb mc l md me">var reader = <strong class="lv ir">new</strong> SvgTextReader(stream, entities)<br/>{<br/>  XmlResolver = <strong class="lv ir">new</strong> SvgDtdResolver(),<br/>  WhitespaceHandling = WhitespaceHandling.Significant,<br/>  DtdProcessing = <br/>    SvgDocument.DisableDtdProcessing ? DtdProcessing.Ignore <br/>                                     : DtdProcessing.Parse,<br/>};</span></pre><p id="32f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要了解解析器配置是否不安全，您需要澄清以下几点:</p><ul class=""><li id="7d5a" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated">SvgDtdResolver实例是什么；</li><li id="59a9" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">是否启用DTD处理。</li></ul><p id="efca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里我想再说一次——向开源致敬！这是一种难以言喻的快乐——有机会修改代码并理解某些东西是如何工作的。</p><p id="34a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从依赖于<em class="lr"> SvgDocument的<em class="lr"> DtdProcessing </em>属性开始。禁用处理</em>:</p><pre class="kx ky kz la gt lu lv lw lx aw ly bi"><span id="aff7" class="lz ma iq lv b gy mb mc l md me"><em class="lr">/// &lt;summary&gt;</em><br/><em class="lr">/// Skip the Dtd Processing for faster loading of</em><br/><em class="lr">/// svgs that have a DTD specified.</em><br/><em class="lr">/// For Example Adobe Illustrator svgs.</em><br/><em class="lr">/// &lt;/summary&gt;</em><br/><strong class="lv ir">public</strong> <strong class="lv ir">static</strong> <strong class="lv ir">bool</strong> DisableDtdProcessing { get; set; }</span></pre><p id="48b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个静态属性，它的值没有改变。属性也不会出现在类型构造函数中。其默认值为<em class="lr">假</em>。相应地，<em class="lr"> DtdProcessing </em>采用<em class="lr"> DtdProcessing。解析</em>值。</p><p id="6256" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们继续讨论<em class="lr"> XmlResolver </em>属性。让我们看看<em class="lr"> SvgDtdResolver </em>类型是什么样的:</p><pre class="kx ky kz la gt lu lv lw lx aw ly bi"><span id="a98b" class="lz ma iq lv b gy mb mc l md me">internal <strong class="lv ir">class</strong> <strong class="lv ir">SvgDtdResolver</strong> : XmlUrlResolver<br/>{<br/>  <em class="lr">/// ....</em><br/>  <strong class="lv ir">public</strong> <strong class="lv ir">override</strong> object <strong class="lv ir">GetEntity</strong>(Uri absoluteUri, <br/>                                   string role, <br/>                                   Type ofObjectToReturn)<br/>  {<br/>    <strong class="lv ir">if</strong> (absoluteUri.ToString()<br/>                   .IndexOf("svg", <br/>                            StringComparison<br/>                             .InvariantCultureIgnoreCase) &gt; -1)<br/>    {<br/>      <strong class="lv ir">return</strong> <br/>        Assembly<br/>         .GetExecutingAssembly()                          <br/>         .GetManifestResourceStream("Svg.Resources.svg11.dtd");<br/>    }<br/>    <strong class="lv ir">else</strong><br/>    {<br/>      <strong class="lv ir">return</strong> base.GetEntity(absoluteUri, role, ofObjectToReturn);<br/>    }<br/>  }<br/>}</span></pre><p id="dd52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其实<em class="lr"> SvgDtdResolver </em>还是那个<em class="lr"> XmlUrlResolver </em>。对于<em class="lr"> absoluteURI </em>包含<em class="lr">“SVG”</em>子串的情况，逻辑略有不同。从关于XXE 的<a class="ae kw" href="https://pvs-studio.com/en/blog/posts/csharp/0918/" rel="noopener ugc nofollow" target="_blank">文章中，我们记得使用<em class="lr"> XmlUrlResolver </em>实例来处理外部实体充满了安全问题。原来同样的情况发生在<em class="lr"> SvgDtdResolver </em>上。</a></p><p id="c394" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，所有必要的条件都满足了:</p><ul class=""><li id="cbdd" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated">启用DTD处理(<em class="lr"> DtdProcessing </em>属性具有<em class="lr"> DtdProcessing。解析</em>值)；</li><li id="d6fe" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated">解析器使用了一个不安全的解析器(<em class="lr"> XmlResolver </em>属性引用了一个不安全的<em class="lr"> SvgDtdResolver </em>的实例)。</li></ul><p id="05d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，创建的<em class="lr"> SvgTextReader </em>对象可能容易受到XXE攻击(正如我们在实践中看到的，它实际上是易受攻击的)。</p><h1 id="67a8" class="mf ma iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">问题修复</h1><p id="e53b" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">在GitHub的项目页面上就这个问题开了一个问题——“<a class="ae kw" href="https://github.com/svg-net/SVG/issues/869" rel="noopener ugc nofollow" target="_blank">安全:易受XXE攻击</a>”。一周后，<a class="ae kw" href="https://github.com/svg-net/SVG/issues/872" rel="noopener ugc nofollow" target="_blank">又开了一期</a>。每期都制作了一个PR:第一个<a class="ae kw" href="https://github.com/svg-net/SVG/pull/870" rel="noopener ugc nofollow" target="_blank">的</a>拉动请求，第二个<a class="ae kw" href="https://github.com/svg-net/SVG/pull/873" rel="noopener ugc nofollow" target="_blank">的</a>拉动请求。</p><p id="6cbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，修复方法如下:默认情况下，外部实体的处理是关闭的。</p><p id="2f7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第一个PR中，添加了<em class="lr"> ResolveExternalResources </em>选项。该选项负责<em class="lr"> SvgDtdResolver </em>是否处理外部实体。默认情况下，处理是禁用的。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/1cddd6e283c2dce2d95bf9fec578772b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dYFL7ybbBLPk0tOz.png"/></div></div></figure><p id="9c28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第二个PR中，贡献者添加了更多代码，布尔标志被替换为枚举。默认情况下，仍然禁止解析外部实体。代码中有更多的变化。如果你有兴趣，你可以在这里查看它们<a class="ae kw" href="https://github.com/svg-net/SVG/pull/873/files" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7cfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们将“SVG”包更新为安全版本，在相同的应用程序中使用相同的输入数据(即，使用虚拟Svg文件)运行它，我们将得到不同的结果。</p><p id="dc69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序不再执行网络请求，也不再“窃取”文件。如果您查看生成的SVG文件，您可能会注意到这些实体根本没有经过处理:</p><pre class="kx ky kz la gt lu lv lw lx aw ly bi"><span id="627e" class="lz ma iq lv b gy mb mc l md me">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;!DOCTYPE svg ...&gt;<br/>&lt;svg version="1.1"<br/>     ....&gt;<br/>  &lt;style type="text/css"&gt;<br/>    ....<br/>  &lt;/style&gt;<br/>  ....<br/>  &lt;polygon /&gt;<br/>  &lt;polygon /&gt;<br/>&lt;/svg&gt;</span></pre><h1 id="4598" class="mf ma iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">如何保护自己？</h1><p id="d7ea" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">看谁想保险起见。:)</p><p id="be9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至少，您应该了解XXE，以便在处理XML文件时更加小心。当然，这些知识并不能防止所有的危险情况(老实说，没有什么能防止它们)。但是，它会让你对可能的后果有所认识。</p><p id="589a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SAST解决方案可以帮助在代码中找到类似的问题。事实上，SAST可以抓住的东西很多。XXE很可能就在这个名单上。</p><p id="d15a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您使用外部库，而不是使用源代码，情况会有所不同。例如，在我们的应用程序中，当SVG库作为NuGet包添加时。在这里，SAST不会提供帮助，因为该工具无法访问库的源代码。尽管如果静态分析器处理中间代码(例如IL)，它仍然可以检测到问题。</p><p id="8ecc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，单独的工具——SCA解决方案——用于检查项目依赖性。你可以阅读下面的<a class="ae kw" href="https://pvs-studio.com/en/blog/posts/csharp/0876/" rel="noopener ugc nofollow" target="_blank">文章</a>来了解SCA工具。此类工具监控具有已知漏洞的依赖项的使用，并发出警告。当然，在这种情况下，这些易损部件的底座起着重要的作用。基数越大越好。</p><p id="d974" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，记得更新软件组件。毕竟除了新功能和bug修复，新版本中还修复了安全缺陷。例如，在SVG.NET，本文中处理的安全缺陷在<a class="ae kw" href="https://www.nuget.org/packages/Svg/3.3.0" rel="noopener ugc nofollow" target="_blank"> 3.3.0 </a>版本中被关闭。</p><h1 id="857f" class="mf ma iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">结论</h1><p id="7b0b" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">我已经说过，XXE是一件相当棘手的事情。本文中描述的实例非常复杂。它不仅隐藏在处理SVG文件的背后，还通过NuGet包“潜入”应用程序。谁知道还有多少其他漏洞隐藏在不同的组件中并被成功利用？</p><p id="3992" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">遵循一个好的传统，我邀请你在Twitter上关注<a class="ae kw" href="https://twitter.com/_SergVasiliev_" rel="noopener ugc nofollow" target="_blank">我</a>，以免错过有趣的出版物。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="1732" class="mf ma iq bd mg mh nq mj mk ml nr mn mo mp ns mr ms mt nt mv mw mx nu mz na nb bi translated">🔈 🔈Infosec Writeups正在组织其首次虚拟会议和网络活动。如果你对信息安全感兴趣，这是最酷的地方，有16个令人难以置信的演讲者和10多个小时充满力量的讨论会议。<a class="ae kw" href="https://iwcon.live/" rel="noopener ugc nofollow" target="_blank">查看更多详情并在此注册。</a></h1><div class="nv nw gp gr nx ny"><a href="https://iwcon.live/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">IWCon2022 - Infosec书面报告虚拟会议</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">与世界上最优秀的信息安全专家建立联系。了解网络安全专家如何取得成功。将新技能添加到您的…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">iwcon.live</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om jw ny"/></div></div></a></div></div></div>    
</body>
</html>