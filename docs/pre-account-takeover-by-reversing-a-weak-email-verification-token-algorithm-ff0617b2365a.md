# 通过逆转脆弱的电子邮件验证令牌算法预先接管帐户

> 原文：<https://infosecwriteups.com/pre-account-takeover-by-reversing-a-weak-email-verification-token-algorithm-ff0617b2365a?source=collection_archive---------0----------------------->

我欺骗他人的电子邮件，以便在他们首次注册之前预先窃取用户帐户。我是这样做的。

![](img/f69e7174c51f8e38bf260ae0bf16f632.png)

马库斯·温克勒在 [Unsplash](https://unsplash.com/s/photos/padlock?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

我在入侵 bug bounty 程序时经常测试的一件事是应用程序如何生成令牌。令牌用于密码重置、电子邮件地址验证、一键式登录等。

在入侵一个私人程序时，我发现一个应用程序生成电子邮件验证令牌的算法很弱。这就是我处理这个问题的方式，也是我如何找到一种方法来生成有效的令牌来验证任何电子邮件地址的所有权，甚至是那些我实际上无法访问的电子邮件地址。这使我能够用我选择的密码在任何电子邮件地址上预先注册帐户，这导致当真正的所有者最终注册时帐户被接管。

# 令牌生成算法分析

在攻击任何有 bug bounty 范围的 web 应用程序时，我首先测试的是帐户创建和身份验证功能。这一次，我发现每次我创建一个新的用户帐户，应用程序不让我做任何事情，直到我验证了我的电子邮件地址的所有权。目标应用程序会通过电子邮件给我发送一个验证链接，并提示我检查我的收件箱，这就是我所能做到的

通过强迫我验证我的电子邮件地址，应用程序所有者可以防止预帐户接管。

# 账户前接管

现代 web 应用程序通常有多种登录用户帐户的方式。这些可以包括:

*   用户名和密码
*   电子邮件地址和密码
*   Oauth，例如“用脸书登录”或“用 Twitter 登录”
*   来自任何 SAML 兼容身份提供商(IdP)的 SAML 单点登录
*   使用令牌化“神奇”链接的无密码

预帐户接管是指攻击者使用一种登录方法创建一个用户帐户，然后受害者使用另一种登录方法创建另一个帐户。然后，应用程序根据匹配的电子邮件地址将两个帐户链接在一起。如果电子邮件地址未经验证，或者验证被绕过，这可能会导致帐户创建前或创建后被接管。

攻击发生的过程如下:

1.  攻击者使用他们不拥有的电子邮件地址在 web 应用程序上创建一个用户帐户。
2.  应用程序不验证他们是电子邮件地址的所有者
3.  该帐户会休眠一段时间
4.  该电子邮件地址的真正所有者选择“登录脸书”,脸书向用户提供经过验证的电子邮件地址。
5.  脸书的电子邮件地址与攻击者注册的电子邮件地址相匹配，这两个帐户被关联起来。
6.  现在，攻击者可以用他们提供的电子邮件地址和密码登录受害者的帐户，他们可以看到受害者每次用脸书登录时在他们帐户内做的一切。

# 电子邮件验证令牌识别

在检查我的收件箱时，我发现了“确认你的账户”的邮件，并把链接复制到了我最喜欢的文本编辑器中。我总是保存所有通过电子邮件发给我的一次性链接，以及帐户名、电子邮件地址、注册时间等等，以防在测试时出现任何模式。

该链接的格式为 https://craighays.com/verify/?P1=randomString & P2 =随机字符串& P3 =静态文本& P4 =静态文本(不含空格)。

在为不同的账户生成了几封验证邮件后，我发现 P3 和 P4 总是一样的。然而，P1 和 P2 总是在每次发送电子邮件时改变。在删除或更改 P1 或 P2 后打开链接会导致一条错误消息，并且电子邮件地址未得到验证。因此，P1 和 P2 的组合一起形成了两部分的电子邮件地址所有权验证令牌。

# 深入挖掘

既然我已经确定了用于确认电子邮件地址的由两部分组成的令牌，我就更深入地研究这两个参数。

P1 和 P2 都是 base64 编码的字符串。发现这一点的一个简单方法是当一个随机出现的字符串以单个=或双==结尾时。这些= chars 用作填充符，以确保预编码字符串符合最小位长度。但情况并不总是这样，因为长度完美的字符串不需要填充。如果有疑问，总是通过不同的解码器传递随机字符串，看看是否有什么有趣的东西出来。

在解码了来自不同链接的多个 P1 和 P2 参数后，我可以看到 P1 总是有 4 个静态字符后跟 12 个数字字符的格式，如 TEXT000123456789，P2 总是有 9 个数字字符的格式，如 123456789。通过查看我的解码 P1 和 P2 字符串列表，我可以看到这些数字正在增加，从一个电子邮件验证链接到另一个链接都在大幅增加。P1 和 P2 除了都上涨之外，没有任何关联。

起初，我试图根据 HTTP 响应中的时间戳猜测带编号的字符串，但是毫无结果。相反，我的想法是定义一个电子邮件地址的有效令牌的上限和下限。在一个小范围内，甚至一个 9 或 12 位数字都可能被暴力破解来创建一个有效的令牌。

# 上限和下限

从数学角度来看这个问题，我需要猜两个 9 位数。十二位数总是以 000 开头，所以实际上是 9 位数。一个 9 位数有 1，000，000，000 种可能的组合。因为我有两个，所以每个电子邮件验证令牌有 1，000，000，000 * 1，000，000，000 种可能的组合。相当安全。

这个应用程序的问题是，在生成的每个令牌中，P1 和 P2 的数字大于之前的 P1 和 P2，但小于之后的 P1 和 P2。如果我能创建一个我看得见的令牌，然后创建一个我看不见的令牌，再创建第三个我看得见的令牌，我就能大大缩小可能数字的范围。我可以创建 9 位数的上限和下限，这比 1，000，000，000 个可能的组合范围要小得多。

我的令牌攻击的步骤如下所示:

1.  用我自己的电子邮件地址创建一个帐户
2.  使用我不拥有但想要验证的电子邮件地址创建一个帐户
3.  用我自己的电子邮件地址创建一个帐户

# 将此付诸实践

为了证明我可以验证任何电子邮件地址，我决定在目标公司域中验证我自己的名字，例如 craighays@targetcompany.com

我打开了三个浏览器配置文件，并在所有三个浏览器上将帐户创建过程进行到最后一页。尽可能快地，(在一个接一个地释放请求之前，使用 burp intruder 来控制请求)我在所有三个浏览器上提交了“创建帐户”表单，craighays@targetcompany.com 在中间。这给我发了两封电子邮件，每封都有电子邮件验证链接。中间那封邮件发给了一个我无法访问的地址。

从两个验证链接中提取 P1 和 P2 参数，我的上限和下限如下所示:

下部 1: 000148309914
上部 1: 000148309953

下部 2: 187633910
上部 2: 187634120

P1 射程:39
P2 射程:210

可能的组合:8190。比 1，000，000，000*1，000，000，000 = 1.0e18 好多了

然后我用 python 运行了以下逻辑:

```
for P1 in range (LowerP1..UpperP1):
  for P2 in range (LowerP2..UpperP2): 
    P1 = "TEXT000" + string(P1) 
    P1 = base64encode(P1) 
    P2 = base64encode(P2) 
    url = buildURL(P1, P2) 
    getUrl(url)# Note, this is pseudo code - it won't actually run but it summaries # the script logic into a readable form
```

作为 buildURL()的一部分，我添加了 P3 和 P4 以及 URL 的其余部分。然后，我简单地发送了一个 HTTP GET 请求，包含上限和下限之间的所有 8，190 个可能的 2 部分令牌，直到我的电子邮件地址得到验证。

# 结果

有了这个，我能够验证 craighays@targetcompany.com，证明我的验证旁路工作。由于 web 应用程序的核心功能已经将电子邮件和密码创建的帐户与脸书创建的具有匹配电子邮件的帐户关联起来，所以我不需要进一步证明这一点。对这种行为的简单解释是我的臭虫奖励报告所需要的。

作为一个副产品，它不仅验证了我创建的帐户，还验证了我测试时在我的上限和下限范围内的公众成员创建的其他几个电子邮件地址…哎呀。

# 影响

我可以绕过账户验证的要求，不用绑定到真实的电子邮件地址就可以使用这个应用程序。我还能够对任何尚未注册的电子邮件地址进行预账户接管，这是毫无防备的受害者第一次登录脸书、推特或其他任何网站。

# 建议的补救措施

解决这个问题的最好方法是用一个非常长的随机字符串替换 P1 和 P2，从令牌生成算法中删除序列号。奇怪的是，密码重置方法已经做到了这一点，但出于某种原因，开发人员重新发明了验证电子邮件地址的令牌过程。

与我私人电子邮件列表中的其他人一起关注我的最新文章、视频、想法等。

*原载于 2021 年 7 月 22 日*[*【https://craighays.com】*](https://craighays.com/pre-account-takeover-by-reversing-a-weak-email-verification-token-algorithm/)*。*