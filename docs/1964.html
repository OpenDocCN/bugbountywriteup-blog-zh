<html>
<head>
<title>The toddler’s introduction to Heap exploitation, Overflows (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学走路的孩子对堆利用、溢出的介绍(第3部分)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-overflows-part-3-d3d1aa042d1e?source=collection_archive---------0-----------------------#2022-03-23">https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-overflows-part-3-d3d1aa042d1e?source=collection_archive---------0-----------------------#2022-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9ea4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这些帖子的前几部分(<a class="ae kl" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8" rel="noopener"> 1 </a>、<a class="ae kl" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-2-d1f325b74286" rel="noopener"> 2 </a>)中，我已经讨论了堆结构，并浏览了一些基本概念，以便为这篇和即将到来的帖子建立一个更好的背景。到目前为止，您可能已经意识到堆分配机制带来的广泛的攻击面，主要是由于它们的复杂性。除此之外，我们只接触了<strong class="jp ir"> ptmalloc </strong>实现(这只是众多实现中的一个)，毫不奇怪<strong class="jp ir">堆利用概念</strong>完全垄断了安全研究社区的兴趣。</p><p id="bacb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将在我的许多帖子中使用<a class="ae kl" href="https://github.com/shellphish/how2heap" rel="noopener ugc nofollow" target="_blank"> how2heap </a>存储库作为参考，因为它包含各种关于ptmalloc的更新的堆利用技术，其中许多也适用于其他实现。在这篇文章中，我们将探讨x64系统上的两个典型的<strong class="jp ir">堆溢出</strong>，以及最新的(此时我正在写这篇文章)<strong class="jp ir"> Ubuntu版本20.04.4 </strong>。</p><h1 id="b655" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">我们到目前为止所看到的…在实践中</h1><p id="27d0" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我们用一个简单的例子来实践我们到目前为止所看到的。在下面的程序中，我们分别有两个<code class="fe lp lq lr ls b">12</code>和<code class="fe lp lq lr ls b">30</code>字节的分配。随后，我们将<code class="fe lp lq lr ls b">LoremIpsum1</code>和<code class="fe lp lq lr ls b">LoremIpsum2</code>的值复制到变量<code class="fe lp lq lr ls b">val1</code>和<code class="fe lp lq lr ls b">val2</code>，最后我们使用<code class="fe lp lq lr ls b">free</code>函数释放分配的内存:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/b7efa32410c552bfb0e15d6746c1359f.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*eehFAsJDDCmFPXs6LWrUpg.png"/></div></figure><p id="af6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们编译并加载<code class="fe lp lq lr ls b">gdb</code>中的程序，在<code class="fe lp lq lr ls b">malloc</code>调用后设置一个断点，在<code class="fe lp lq lr ls b">free</code>函数调用后再设置一个断点:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/c89432aa73aff9d4599f6f2d248fd971.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aY-NAS0dDHNbfAS8IYj0Rg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">b *main+89，b *main+109</figcaption></figure><h2 id="e5cd" class="mk kn iq bd ko ml mm dn ks mn mo dp kw jy mp mq la kc mr ms le kg mt mu li mv bi translated">免费前</h2><p id="410a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我将使用<code class="fe lp lq lr ls b">gef</code>(可以按照这里的说明<a class="ae kl" href="https://github.com/hugsy/gef" rel="noopener ugc nofollow" target="_blank">安装)，以增强我的<code class="fe lp lq lr ls b">gdb</code>。所以首先使用GNU调试器运行程序，并键入<code class="fe lp lq lr ls b">heap arenas</code>，跟踪</a><a class="ae kl" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8" rel="noopener"> malloc_state </a>结构。由于我们只处理主线程(因此只是一个舞台)，您将得到类似于下面的结果:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mw"><img src="../Images/5acef941343d9dc33c1270e222049efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S0flwOfzqPPEGL9ZP-Mvwg.png"/></div></div></figure><p id="66b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们只有一个竞技场，<code class="fe lp lq lr ls b">next</code>在<code class="fe lp lq lr ls b">0x7ffff7fb9b80</code>指向主竞技场的<code class="fe lp lq lr ls b">base</code>。<code class="fe lp lq lr ls b">system_mem</code>对应于已分配堆的大小(<code class="fe lp lq lr ls b">0x21000</code>),<code class="fe lp lq lr ls b">top</code>变量指向<code class="fe lp lq lr ls b">0x5555555592e0</code>处的最后一个块。接下来，让我们通过键入<code class="fe lp lq lr ls b">gef&gt; heap chunks</code>来检查分配的块:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mx"><img src="../Images/3606310708f776a3b809cb10497e772b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*auGHhal_z-dphTeS9nrQdA.png"/></div></div></figure><p id="a114" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我们请求了</strong> <strong class="jp ir"> 12和30 </strong>字节，得到了<strong class="jp ir"> 0x21 </strong>和<strong class="jp ir"> 0x31(十六进制)，但是为什么呢？</strong>因为对齐！记住分配的大小必须在8字节(或64位上的16字节)边界上对齐<strong class="jp ir">？</strong>因此，对于12个字节，我们分配了32个(0x20十六进制)，对于30个字节，我们分配了<strong class="jp ir"> 32+16 </strong>。增加尺寸中的'<strong class="jp ir"> 1 </strong>'指的是<strong class="jp ir"> PREV_INUSE </strong>标志，因此不“计入”实际尺寸。例如，让我们检查一下<code class="fe lp lq lr ls b">0x5555555592a0</code>处的块:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi my"><img src="../Images/a0d16e23dee442d63b8b26135108f7ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*vz7UBhJjpXt8NCsSzTA9aQ.png"/></div></figure><p id="9934" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，初始请求是<code class="fe lp lq lr ls b">val1 = malloc(12)</code>，块大小是<strong class="jp ir"> 32字节</strong>，其中的<strong class="jp ir"> 8用于指示块的大小</strong>，以及块是否属于辅助竞技场，是否通过<em class="mz"> mmap </em>从堆外分配，以及先前的块是否是空闲块。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e276cc8dff12104b238dcd701d5f5f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*Huo2zkzHF89VoZ2jO6Cwaw.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">分配的块，来源:<a class="ae kl" href="https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/" rel="noopener ugc nofollow" target="_blank">https://azeria-labs . com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/</a></figcaption></figure><p id="d806" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能也注意到了我们存储在<code class="fe lp lq lr ls b">0x5555555592a0</code>和<code class="fe lp lq lr ls b">0x5555555592c0</code>的编码数据(<code class="fe lp lq lr ls b">LoremIpsum1</code>和<code class="fe lp lq lr ls b">LoremIpsum2</code>)。最后，我们在堆的开始有一个大小为<code class="fe lp lq lr ls b">0x0000000000000290</code>的块，在最后有一个大小为<code class="fe lp lq lr ls b">0x0000000000020d20</code>(顶部块)的块。</p><h2 id="e282" class="mk kn iq bd ko ml mm dn ks mn mo dp kw jy mp mq la kc mr ms le kg mt mu li mv bi translated">免费后</h2><p id="6dcb" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">为了更好地了解<code class="fe lp lq lr ls b">free</code>函数的后果，让我们修改初始程序，增加一些分配，并检查ptmalloc如何处理它们。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/88207de11a058c563b6572548b964ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*HJfokCpCRHt2km3uS-rGdw.png"/></div></figure><p id="b8de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译上面的程序并加载到gdb，在<code class="fe lp lq lr ls b">free</code>调用后设置一个断点。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nc"><img src="../Images/557fccd2ba6adf2ac2d7196320e43c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9UrBUnBwLqmQnLTZAVg_NA.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">使用tcache</figcaption></figure><blockquote class="nd ne nf"><p id="66ec" class="jn jo mz jp b jq jr js jt ju jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj kk ij bi translated"><strong class="jp ir">记住</strong>:每个线程都有一个每线程缓存(称为<em class="iq"> tcache </em>)，其中包含一个小的块集合，可以在不需要锁定竞技场的情况下访问这些块。这些块被存储为一个由<strong class="jp ir">单链表</strong>组成的数组，就像fastbins一样，但是链接指向有效载荷(用户区域)而不是块头。每个bin包含一个大小的块，所以数组是按块大小索引的(间接)。与fastbins不同，tcache受限于每个bin中允许多少块(tcache_count)。如果对于给定的请求大小，tcache bin为空，则不使用下一个更大的块(可能会导致内部碎片)，而是使用正常的malloc例程，即锁定线程的arena并从那里开始工作[1]。</p></blockquote><p id="2755" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每增加一个0x10或更少字节的分配都会被整合到Fastbins中，因为它超过了tcache中允许的最大值(在我们的示例中为7 ):</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nj"><img src="../Images/acbb7c3218a4fa240699a3bca1717175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3YqXrSq2mC3zR93Ba7bXQ.png"/></div></div></figure><p id="4a24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个堆现在看起来像下面这样:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/96cd18da7f35ad9bd3e0de9717034728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*HucYlIQp9VaWIU8NuzKNwQ.png"/></div></figure><h1 id="de75" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">基本堆溢出</h1><p id="9dee" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">看一下下面的代码片段，注意程序允许输入比分配的空间更大的大小(<code class="fe lp lq lr ls b">Lines 9,10,15</code>)。为了方便起见，<code class="fe lp lq lr ls b">system</code>函数将把由<code class="fe lp lq lr ls b">p1</code>变量指向的字符串作为参数，并作为系统命令执行。<code class="fe lp lq lr ls b">pwd</code>是将被执行的硬编码命令，这意味着<code class="fe lp lq lr ls b">system</code>函数将简单地打印当前目录:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d7b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，如果我们编译并运行该程序，我们将看到以下输出:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f9d104c7344d1935be77bf8f1ecca1e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*W1lujisDlVXuOuLNSLJoiQ.png"/></div></figure><p id="bd8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在<code class="fe lp lq lr ls b">gdb</code>中加载程序，并在<code class="fe lp lq lr ls b">scanf</code>函数后设置一个断点。通过提供有效的输入，将产生以下结果:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi no"><img src="../Images/37ad1a3c5dabf84e8aab6fa5e1dee2a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6p3YtQdBhK4XMC9oll9Vw.png"/></div></div></figure><p id="ed7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续这个项目，一切如预期进行:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi np"><img src="../Images/3b157b0925a769e225db5b15246447fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*utdH29Nu8Bowo8kSDl5puA.png"/></div></figure><p id="8316" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如下图所示，我们需要32个字节到达<code class="fe lp lq lr ls b"><strong class="jp ir">pwd</strong></code> <strong class="jp ir"> </strong>字符串并覆盖它:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nq"><img src="../Images/85e505de1ba240878ae79e0d6fa37038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jn352Yxbc_FCQ5YrtHUMSw.png"/></div></div></figure><p id="7df5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们使用下面的字符串，看看会发生什么:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/ca6ad90c4d244b05e730a85cf6e13845.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*SYukFtDnfqyQ8FfsH86fLg.png"/></div></figure><p id="2fdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看这一团糟！！<strong class="jp ir">首先在程序代码中注意，缓冲区是在一个可能溢出的缓冲区之后分配的</strong>。除此之外，大小和标志都受到了影响，但是最重要的是<code class="fe lp lq lr ls b">pwd</code>命令现在已经被<code class="fe lp lq lr ls b">/bin/sh</code>所取代:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ns"><img src="../Images/3d71a25a60750c11e2f52b0d9950e276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CbPx94iNohlNxiD2meGURg.png"/></div></div></figure><p id="b6f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行程序并给出上述输入将迫使程序返回一个shell:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/3695a6a061cfb17a201cbe604253699b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*vwqPINAEpVPi6UehqoYtyg.png"/></div></figure><h1 id="eaa6" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">从整数溢出到代码执行</h1><p id="ad50" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">现在让我们来看一个更有趣的整数溢出的例子:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3ce9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从<code class="fe lp lq lr ls b">Line 5</code>开始，我们将<code class="fe lp lq lr ls b">fp</code>定义为指向函数的<a class="ae kl" href="https://www.geeksforgeeks.org/function-pointer-in-c/" rel="noopener ugc nofollow" target="_blank">指针，该函数将<code class="fe lp lq lr ls b">const char *</code>作为参数并返回一个整数。<code class="fe lp lq lr ls b">Lines 7–13</code>处的<code class="fe lp lq lr ls b">toInt</code>函数为<code class="fe lp lq lr ls b">ti</code>变量(<code class="fe lp lq lr ls b">Line 10</code>)分配空间，并为其分配<code class="fe lp lq lr ls b">int atoi(const char *str)</code> </a><a class="ae kl" href="https://www.tutorialspoint.com/c_standard_library/c_function_atoi.htm" rel="noopener ugc nofollow" target="_blank"> C函数</a>的地址。稍后在<code class="fe lp lq lr ls b">main</code>中，我们在<code class="fe lp lq lr ls b">Line 24</code>定义了<code class="fe lp lq lr ls b">nt</code>变量，该变量可用于使用<code class="fe lp lq lr ls b">(*nt)(const char *str)</code>声明调用<code class="fe lp lq lr ls b">atoi</code>。</p><p id="b7e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，<code class="fe lp lq lr ls b">main</code>函数创建一个<strong class="jp ir">长度为argv[1] </strong>的无符号整数的<code class="fe lp lq lr ls b">array</code>，并在<code class="fe lp lq lr ls b">Lines 27–33</code>填充该数组。当用户输入数值<code class="fe lp lq lr ls b">1 </code>或<code class="fe lp lq lr ls b">i == length</code>时<code class="fe lp lq lr ls b">while loop</code>断开。最后，在<code class="fe lp lq lr ls b">Line 35</code>处，<code class="fe lp lq lr ls b">atoi</code>被<code class="fe lp lq lr ls b">argv[2]</code>参数所采用的参数调用。</p><p id="e96f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于数组<strong class="jp ir">大小</strong>已被定义为<strong class="jp ir">无符号整数</strong>，因此<strong class="jp ir">整数溢出</strong>发生，但由于在<code class="fe lp lq lr ls b">Line 21</code>赋值期间没有相对检查，用户可能会插入任意高的算术值并触发溢出。在下面的演示中，我将使用与上面略有不同的程序版本来打印一些额外的信息，作为演示的参考。</p><p id="81ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在<code class="fe lp lq lr ls b">gdb</code>中加载程序，在<code class="fe lp lq lr ls b">main</code>函数的开始和结束附近设置两个断点。现在运行程序并给出一些有效的参数(例如<code class="fe lp lq lr ls b">gef&gt; r 5 3</code>):</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nu"><img src="../Images/87a840c0ac6c909dcea8815c0197012b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fh3SE0y2hcGuuWgcmi5BJQ.png"/></div></div></figure><p id="8dc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在到达第二个断点后，堆将如下所示:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nv"><img src="../Images/af0d51343f9cb879b0da78e15b756cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjZl9AEKW1hSQaITi6B_8w.png"/></div></div></figure><p id="2b22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记下<code class="fe lp lq lr ls b">0x5555555592a0</code>处的数组指针和<code class="fe lp lq lr ls b">0x5555555592c0</code>处的函数指针。让我们检查这些地址的堆内容:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nw"><img src="../Images/73bb6e93f3723e05b72dfd9aead9e702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ib9BeyZDhIL5SIGx7bJpOw.png"/></div></div></figure><p id="2414" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于等于5的长度，请求的大小是5*4字节，因此malloc分配(最小)32字节:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d3e04f550ded22c978253994d0a8a447.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*hASXDahaMiGYoe1SlGLqFg.png"/></div></figure><p id="9839" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，对<strong class="jp ir"> malloc </strong> ( <code class="fe lp lq lr ls b">see toInt() function</code>)的第二次调用导致以下分配:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/79397652a7418f9512a4d02e511fbbfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*XWtcr71qBJIpfCE-bL-Y7w.png"/></div></figure><p id="4317" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该系统的<code class="fe lp lq lr ls b">unsigned int</code>大小为<code class="fe lp lq lr ls b">4 bytes</code>，因此最大允许值将为<code class="fe lp lq lr ls b">0xffffffff == 4294967295</code>。由于用户的输入与无符号整数的大小相乘，参见<code class="fe lp lq lr ls b">Line 21</code>，我们假设大于<code class="fe lp lq lr ls b">4294967295/4</code>的大小将触发溢出:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nz"><img src="../Images/c6e2d895c29bfdfb73681506e29e4292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4IOLqlf44N69Org9I9YuIQ.png"/></div></div></figure><p id="8070" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，请注意，在第二种情况下，分配的大小是0，但是在<code class="fe lp lq lr ls b">Line 27</code>的<code class="fe lp lq lr ls b">while</code>循环将允许我们写入超出分配的空间。让我们用gdb验证一下:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/e867322e37297ef8cd398fea2a2d2d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*7UqhNJdWTBl47B2hbQGiFg.png"/></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ob"><img src="../Images/7bffda5e0b80f6edce750a3c69471c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgV6tMjo2YX6tMwKCiPcfg.png"/></div></div></figure><p id="ca50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，对malloc的第二次调用实际上已经从堆中消失了，因为分配的空间已经被我们插入的值(2，3，4，5，..).这包括被值<code class="fe lp lq lr ls b"><strong class="jp ir">0x0000000100000000</strong></code> <strong class="jp ir">替换的<code class="fe lp lq lr ls b">atoi</code>功能的地址。</strong>继续执行，我们将得到一个<code class="fe lp lq lr ls b">SIGSEGV</code>错误，因为我们的程序将使用存储在<code class="fe lp lq lr ls b">0x00005555555592c0 // Line 35: (*nt)(argv[2])</code>的函数指针。由于这个指针已经被一个无效的地址所取代，结果将会导致程序崩溃:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b2ef32027f3d5ec278e77013cd5265b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*qjzmZBuB_GINbRjchXcV7A.png"/></div></figure><h2 id="aa94" class="mk kn iq bd ko ml mm dn ks mn mo dp kw jy mp mq la kc mr ms le kg mt mu li mv bi translated">剥削</h2><p id="f11d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">你能想出一个类似于<code class="fe lp lq lr ls b">atoi</code>的函数，以字符串为参数，执行一个命令吗？</p><blockquote class="nd ne nf"><p id="e613" class="jn jo mz jp b jq jr js jt ju jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj kk ij bi translated">我们将用对<code class="fe lp lq lr ls b">system</code>函数的调用来替换<code class="fe lp lq lr ls b">atoi</code>调用。由于我们还控制了<code class="fe lp lq lr ls b">atoi</code>的输入(因为它是由argv[2]参数获取的)，我们将实现代码执行。</p></blockquote><p id="4a36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">假设ASLR被禁用</strong>，我们必须用<code class="fe lp lq lr ls b">0x7ffff7e1f2c0</code>替换<code class="fe lp lq lr ls b">atoi</code>(在我的例子中是<code class="fe lp lq lr ls b">0x7ffff7e115e0</code>)的地址，T5是<code class="fe lp lq lr ls b">system</code>函数的地址。由于我们总共有6个字节，并且在单个输入中只能覆盖4个字节(由于无符号int定义的数组)，我们将首先覆盖<code class="fe lp lq lr ls b">f7e1f2c0</code>(十进制:<strong class="jp ir"> 4158780096 </strong>)部分，然后是<code class="fe lp lq lr ls b">7ffff</code>(十进制:<strong class="jp ir"> 32767 </strong>)部分。让我们用<code class="fe lp lq lr ls b">gef➤ r 1073741824 /bin/sh</code>运行程序，并插入以下值:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi od"><img src="../Images/81c257c1b6fa6d230c8e3a7722f208c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*J4rLGq9o5exccYMZ0ku6Ug.png"/></div></figure><p id="06c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lp lq lr ls b">atoi</code>的地址已被<code class="fe lp lq lr ls b">system </code>函数的地址覆盖，且<code class="fe lp lq lr ls b">/bin/sh</code>已作为参数给出:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/6461e312e5fd0ca833906dcabd961f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*mro4RJgkEOZnfBYpKnnWkg.png"/></div></figure><p id="fa2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，敲击<code class="fe lp lq lr ls b">gef</code>中的c，最后会弹出一个外壳:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/66bd0befbc62b05de0de1253c34feecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*IDuoDbCZ-Rp8EBh5hRIwZA.png"/></div></figure><p id="658b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这部分就讲到这里。敬请期待下期！</p><h1 id="890a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">参考</h1><p id="4af1" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">[1]<a class="ae kl" href="https://sourceware.org/glibc/wiki/MallocInternals#:~:text=Each%20thread%20has%20a%20per,area)%20not%20the%20chunk%20header" rel="noopener ugc nofollow" target="_blank">https://sourceware . org/glibc/wiki/mallocinternels #:~:text = Each % 20 thread % 20 has % 20a % 20 per，area)% 20 not % 20 the % 20 chunk % 20 header</a>。</p></div></div>    
</body>
</html>