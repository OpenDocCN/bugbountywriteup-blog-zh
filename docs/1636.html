<html>
<head>
<title>Into the art of Binary Exploitation 0x000003 [Prominence of Integer-Overflow]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">进入二进制开发的艺术0x 000003[整数溢出的突出]</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/into-the-art-of-binary-exploitation-0x000003-prominence-of-integer-overflow-cea6abd2cce4?source=collection_archive---------0-----------------------#2021-10-14">https://infosecwriteups.com/into-the-art-of-binary-exploitation-0x000003-prominence-of-integer-overflow-cea6abd2cce4?source=collection_archive---------0-----------------------#2021-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2272490fc472bac2472d0e1f18422a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8EplzPKKpgwurY7G96ehAQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">知道是容易的，但理解是一门艺术。因为只有1%的顶尖1%的人取得了成功。</figcaption></figure><p id="6e87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嘿，黑客✋✋，<br/>我又带着我们企业的另一部分——二进制开发系列回来了。以防你第一次阅读我的文章？？我谦逊地请求您在继续之前花一点时间阅读我的系列文章的前几部分。<strong class="kf ir">你可以在这里找到→</strong>PART-1:<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/into-the-art-of-binary-exploitation-0x000001-stack-based-overflow-50fe48d58f10">0x 000001</a>| PART-2:<a class="ae lb" href="https://7h3h4ckv157.medium.com/into-the-art-of-binary-exploitation-0x000002-sorcery-of-rop-b4658238ee62" rel="noopener">0x 000002</a></p><blockquote class="lc ld le"><p id="7126" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><strong class="kf ir"> <em class="iq">注</em> </strong> <em class="iq"> :- </em></p><p id="ae03" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><strong class="kf ir">这次我不是专门来剥削的。相反，我想与我的读者分享我关于整数溢出的知识，它的发生和后果。在接下来的文章中，我将完美地介绍每种开发技术&amp;策略。我不准备跳过任何主题，所以我写了关于“整数溢出”的第三部分。</strong></p></blockquote><p id="15a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有当你自信现在已经知道这些东西时，才跳过“台词”。你不是在浪费你的一点时间，而是在钻研你永远不知道的东西。趁早学习提升自己。没有任何耽搁，让我们开始吧。</p><p id="0910" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">什么是算术溢出？</strong></p><p id="1cc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当没有足够的位来描述算术运算的结果时，就会出现这种情况。即计算结果超过了指定的存储空间。从技术上讲，当加法器/减法器电路使用带符号(+/-)算术时，如果出现算术溢出，符号位中的最高有效幅度位将溢出。当需要一个4位算术结果时会发生这种情况&amp;当两个3位数字相加在一起，并且电路中的第四位已经被分配用于显示答案的符号(+/-)。洪水发生时的后果:</p><p id="4226" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.两个正数相加给出否定答案<br/> 2。两个负数的相加给出了肯定的答案</p><p id="017d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我举个例子，<br/>考虑到7FFFFFFF &amp; 6FFFFFFF，我们把这2个&amp;加起来看看会发生什么。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lj"><img src="../Images/65c649511db172fc83ad29fe005d1374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbpkQNDBUdg32I5C4PCTEQ.jpeg"/></div></div></figure><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/7341fc10132f0a5cf4a6cf16f264186c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Htk48Fq1XQ9pFj3oBItoug.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">结果</figcaption></figure><blockquote class="lc ld le"><p id="512b" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">结果是:EFFFFFFE</p></blockquote><blockquote class="lp"><p id="7fa3" class="lq lr iq bd ls lt lu lv lw lx ly la dk translated">计算值大于给定寄存器或存储单元所能存储的量。因此，我们添加了2 +ve来产生-ve结果。</p></blockquote><figure class="ma mb mc md me jr gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/9c3ec36af5aa318454b9cb7049b9982f.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*sSXf4lztbtQn1QSKZxIXkA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">结果</figcaption></figure><p id="5fbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望概念对你来说很清楚。</p><p id="14de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">但这有什么关系呢？在真实世界中，这怎么会是一个严重的问题呢？？</strong></p><blockquote class="lc ld le"><p id="1f6c" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">想想看，在互联网时代，我们运行在数字世界(悲惨的事实)。举例来说，在预算计算或其他相关工作中，接受方内部的结果可能会受到意想不到的控制。剥削的艺术打开了没有任何规则的无限入口。我不想分享“邪恶的东西”。所以我让你发现为什么这不是一个问题。</p></blockquote><p id="fcec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果一个算术运算试图得到一个超出给定位数所能表示的范围的数值呢？？</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/3d05a32515a4af4b9d4ab7c48951ffaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7MY1bruqdL7R_v-g39LRpA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">让我们开始吧…</figcaption></figure><h1 id="6f0e" class="mg mh iq bd kc mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">整数溢出</h1><p id="f070" class="pw-post-body-paragraph kd ke iq kf b kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la ij bi translated">一个<strong class="kf ir">整数溢出</strong>是一种算术溢出，当一个整数值增加到一个大到可以存储在相关表示中的值时就会发生。出现这种情况时，该值可能会绕成一个小的或负数。万一包装是不可预见的，它会产生安全后果。典型地，尤其是在可以利用用户提供的输入来激活数字洪流的情况下。这将成为一个关键的安全问题。这一弱点有时会<strong class="kf ir">触发缓冲区溢出，攻击者可利用该漏洞执行任意代码。这通常会导致未定义的行为，从而导致崩溃。在涉及循环文件因素的泛洪情况下，无限循环的概率会更高。如果地址中的值对信息至关重要(限于流)，则会发生简单的数据损坏。此外，在缓冲区溢出等其他情况下发生回绕的可能性极小，这可能会导致内存降低。</strong></p><p id="85d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发现和预测异常困难。没有错误，没有警告，你基本上得到了一个错误的操作结果。找到它们的方法是在运算前查看操作数，或者查看两个正数相加后的结果。根据语言的不同，您将能够找到帮助您避免和发现整数溢出的库或机制。</p><p id="aa32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">代码分析|示例</strong></p><p id="af74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">毫无疑问，这是我自己做的一个案例，这可能永远不会出现在现实生活中。</p><pre class="lk ll lm ln gt ni nj nk nl aw nm bi"><span id="8cdd" class="nn mh iq nj b gy no np l nq nr">#include&lt;stdio.h&gt;<br/>#include&lt;string.h&gt;<br/>#include&lt;stdlib.h&gt;</span><span id="d8a3" class="nn mh iq nj b gy ns np l nq nr">int main(int argc, char *argv[])<br/>{           <br/>           <br/>           char buffer[100];<br/>           int Integer_value;<br/>           unsigned short sixteen_bits;</span><span id="2778" class="nn mh iq nj b gy ns np l nq nr">if(argc &lt; 3)<br/>                         {<br/>                          printf("No input provided...!");<br/>                          return -1;<br/>                         }</span><span id="dda9" class="nn mh iq nj b gy ns np l nq nr">Integer_value = atoi(argv[1]);<br/>            sixteen_bits = Integer_value;</span><span id="4db2" class="nn mh iq nj b gy ns np l nq nr">if(sixteen_bits &gt;= 100)<br/>                        {<br/>                         printf("******* Oops!! *******\n");<br/>                         return -1;<br/>                         }<br/>   <br/>   printf("sixteen_bits = %d\n", sixteen_bits); <br/>   memcpy(buffer, argv[2], Integer_value);<br/>   buffer[Integer_value] = '\0';<br/>   printf("%s\n", buffer);</span><span id="84c4" class="nn mh iq nj b gy ns np l nq nr">return 0;<br/>}</span></pre><p id="9739" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将展示不同类型的输出:</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/74edcc1b5170c9b169292db6e85c3397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*bUnxZpYCdCyJOxgaiyd99Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">输出</figcaption></figure><p id="fd64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lf">案例1:* * * *未提供I/P时。*** </em></p><pre class="lk ll lm ln gt ni nj nk nl aw nm bi"><span id="7962" class="nn mh iq nj b gy no np l nq nr">if(argc &lt; 3)<br/>                         {<br/>                          printf("No input provided...!");<br/>                          return -1;<br/>                         }</span></pre><p id="54eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lf">案例二:** O/P *** </em></p><pre class="lk ll lm ln gt ni nj nk nl aw nm bi"><span id="03e2" class="nn mh iq nj b gy no np l nq nr">printf("sixteen_bits = %d\n", sixteen_bits); <br/>   memcpy(buffer, argv[2], Integer_value);<br/>   buffer[Integer_value] = '\0';<br/>   printf("%s\n", buffer);</span><span id="3d12" class="nn mh iq nj b gy ns np l nq nr">return 0;</span></pre><p id="ae09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lf">案例3:* * "</em></strong><em class="lf">&gt;= 100</em><strong class="kf ir"><em class="lf"/></strong>“* * *</p><pre class="lk ll lm ln gt ni nj nk nl aw nm bi"><span id="8dfa" class="nn mh iq nj b gy no np l nq nr">if(sixteen_bits &gt;= 100)<br/>                        {<br/>                         printf("******* Oops!! *******\n");<br/>                         return -1;<br/>                         }</span></pre><blockquote class="lp"><p id="e18c" class="lq lr iq bd ls lt lu lv lw lx ly la dk translated">目前，上述代码中的问题存在于哪里？？</p></blockquote><figure class="ma mb mc md me jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/b5b16a20208dcc15b3aba1a86745734d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*2nASWVrKlr82bWoauOmWIg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">分段故障</figcaption></figure><blockquote class="lc ld le"><p id="b3dc" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">随后，肯定了代码是易受攻击的。length参数来自命令行，保存在integer变量中。当这个值被转换成无符号短整型时，它会被截断，以防这个值不适合。</p></blockquote><pre class="lk ll lm ln gt ni nj nk nl aw nm bi"><span id="5203" class="nn mh iq nj b gy no np l nq nr">Integer_value = atoi(argv[1]);<br/>            sixteen_bits = Integer_value;</span></pre><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/5aad46625ccc94445643bf4c68f6781b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*BWHRw1KuHl5VkD-347E5hQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">short = 16位，int = 32位</figcaption></figure><blockquote class="lc ld le"><p id="2d6b" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">无符号短整型数据类型表示16位整数，不使用位来存储符号。因此，它只能保存0到65535之间的正值。所以，值被转换成无符号短整型，它会溢出。</p></blockquote><blockquote class="lp"><p id="e8ba" class="lq lr iq bd ls lt lu lv lw lx ly la dk translated">二进制的65535是<strong class="ak">111111111111111</strong>(长度= 16)</p></blockquote><figure class="ma mb mc md me jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/44f3ad08d7eaaf3aab28fe19a8d6d0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*ft3ea5KymE2N4OpRwgs_Nw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">16位:65535</figcaption></figure><blockquote class="lp"><p id="f9b4" class="lq lr iq bd ls lt lu lv lw lx ly la dk translated">二进制的65536是100000000000000(长度= 17)</p></blockquote><figure class="ma mb mc md me jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/7793b379b9b3fbecb2362def0168c380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*6etP6n9dyXLIbsSTevpJxg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">65536</figcaption></figure><p id="0099" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它按照预期的方式工作，直到输入保持在65535以下。如果输入超过65536到65635之间的值<strong class="kf ir">T3，这将是一个分段故障。</strong></p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/5155836f483de6971982bd3cab7b8e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUxrplwn53ltxeo88xdSNA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">输出</figcaption></figure><blockquote class="lp"><p id="119c" class="lq lr iq bd ls lt lu lv lw lx ly la dk translated">因此，可以绕过边界检查并溢出缓冲区。在此之后，可以利用标准堆栈粉碎策略来利用该过程。</p></blockquote><p id="6310" class="pw-post-body-paragraph kd ke iq kf b kg nz ki kj kk oa km kn ko ob kq kr ks oc ku kv kw od ky kz la ij bi translated">我放弃这个案子，让你自己找到利用它的方法。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c2bc4c884c13eb9d466b5447d39324a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*X77C3pfWxBHZUS5peW68Tg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">:)</figcaption></figure><p id="a73a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注:</strong></p><blockquote class="lc ld le"><p id="6f64" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">1)并非每个segfault都是可利用的。但它仍然是一个bug，如果您对漏洞没有任何线索，最好假设它是可利用的，并修复它。</p><p id="137f" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">2)此外，存储小于最小支持值的值称为整数下溢。</p><p id="404f" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">3)整数溢出本身不会导致任意代码执行，但是整数溢出“可能导致”堆栈溢出或堆溢出，这可能导致主观代码执行。</p></blockquote></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h2 id="40a2" class="nn mh iq bd kc om on dn ml oo op dp mp ko oq or mt ks os ot mx kw ou ov nb ow bi translated">上面的案例出现了一个与堆栈相关的问题，现在让我们检查一下堆的概要。</h2><pre class="lk ll lm ln gt ni nj nk nl aw nm bi"><span id="bb3f" class="nn mh iq nj b gy no np l nq nr">/**<!-- --> Vulnerable piece of code that I found online. **/</span><span id="b4a2" class="nn mh iq nj b gy ns np l nq nr">int myfunction(int *array, int len)<br/><br/>{<br/>    int *myarray, i;<br/><br/>    myarray = malloc(len * sizeof(int));<br/><br/><br/>    if(myarray == NULL)<br/><br/>    {<br/>      return -1;<br/>    }<br/><br/>   for(i = 0; i &lt; len; i++)<br/><br/>     {<br/>        myarray[i] = array[i];<br/>     }<br/>     return myarray;<br/>}</span></pre><blockquote class="lc ld le"><p id="93ef" class="kd ke lf kf b kg kh ki kj kk kl km kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">这段代码容易受到<strong class="kf ir">整数溢出</strong>的攻击，这会导致所分配的缓冲区大小远远小于所需的大小。如果“len”参数比预期的要大，例如:0x100000004与32位数字(max- 0x7FFFFFFF)一样大，那么这意味着malloc()将像分配4字节缓冲区一样进行分配，并且将数据复制到新分配的数组中的循环将超过该分配的缓冲区的末尾。这会导致堆溢出。</p></blockquote></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><p id="0688" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在接下来的文章中，我将带着积极的开发策略回来。但是现在，我想愉快地结束它。我想告诉你很多关于堆栈和基于堆栈的缓冲区溢出漏洞以及绕过安全缓解措施等内容。完成所有这些工作后，让我们来研究堆的世界！！保持好奇心..！😎😎</p><p id="32dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lf">在Twitter上随意连接</em> </strong> @ <a class="ae lb" href="https://twitter.com/7h3h4ckv157" rel="noopener ugc nofollow" target="_blank"> 7h3h4ckv157 </a></p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/a72c4fa88d4e1cddd5f60ac223de43ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RD1caNlq8ULOLcUjdcx6zA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">很快就会抓到你..！</figcaption></figure></div></div>    
</body>
</html>