<html>
<head>
<title>How i was able to bypass Cloudflare WAF for SQLi payload</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何绕过Cloudflare WAF实现SQLi有效负载的</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/how-i-was-able-to-bypass-cloudflare-waf-for-sqli-payload-b9e7a4260026?source=collection_archive---------1-----------------------#2021-11-30">https://infosecwriteups.com/how-i-was-able-to-bypass-cloudflare-waf-for-sqli-payload-b9e7a4260026?source=collection_archive---------1-----------------------#2021-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d6dfd159cd3809476f9769ad61b928d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CGckyCQfqUAQYAWL.png"/></div></div></figure><p id="8dbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗨，黑客和猎人们！</p><p id="87b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于许多人来说，Cloudflare是一个错误，他们希望获得关键漏洞，如:<code class="fe kw kx ky kz b">SQL injection</code>但不幸的是，它阻止了大多数/所有的有效载荷。所以我在寻找一个目标，我用我的思维方式来绕过并打破这个怪物！</p><p id="4919" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我想注入一个基于布尔的SQL注入负载，在绕过你应该知道，最重要的阶段是当你要检测WAF(网络应用防火墙)阻止坏字符的阶段。</p><p id="8871" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在我的案例中，经过大量尝试后，我发现防火墙阻止了以下内容:</p><ul class=""><li id="dfaf" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv lf lg lh li bi translated">间隔</li><li id="c5ef" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated"><code class="fe kw kx ky kz b">OR</code> / <code class="fe kw kx ky kz b">AND </code>在所有情况下</li><li id="006e" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated"><code class="fe kw kx ky kz b">-- comment</code></li><li id="59ec" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated"><code class="fe kw kx ky kz b"># comment</code></li><li id="7af6" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated"><code class="fe kw kx ky kz b">;</code></li><li id="5dd4" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated"><code class="fe kw kx ky kz b">=</code></li></ul><p id="72cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们思考一下，如何通过将这篇文章分成几个部分来绕过它们:</p><blockquote class="lo lp lq"><p id="cb52" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated"><strong class="ka ir">绕过—空格— </strong></p></blockquote><p id="545d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了绕过空格，我想绕过使用URL编码，比如使用:<code class="fe kw kx ky kz b">%20</code>但这不起作用，我也试图使用:<code class="fe kw kx ky kz b">+</code>而不是空格，但也不起作用，所以我试图通过添加多行注释而不是像这样的空格来进行创造性的思考:<code class="fe kw kx ky kz b">/**/</code>所以现在当WAF将它作为普通字符串传递时，但当它到达后端DBMS时，它将被解析为注释，如下所示:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/405fb6f0a7bf4a64fd89b413d41916ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0O2jg1SsY0-ggXjlvZzB_g.png"/></div></div></figure><p id="d690" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个带有多行注释的查询中的普通<code class="fe kw kx ky kz b">SELECT</code>语句，这也是一个活生生的例子:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/a8bb320d15362e7e67f6c2048c69b1b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*V6KDOwPsr00DKSMhAERHEw.png"/></div></figure><blockquote class="lo lp lq"><p id="9c3a" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated"><strong class="ka ir">绕过布尔限制</strong></p></blockquote><p id="9d93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在WAF阻止了所有的布尔操作符，即使它是大写或小写，所以在我的技术中，我使用了多种情况操作符来绕过它，比如:<code class="fe kw kx ky kz b">oR</code> / <code class="fe kw kx ky kz b">aNd</code>..等等。但不幸的是，在我的例子中，WAF也阻止了所有这些操作，所以我想到了标准的URL编码，所以被阻止的操作符应该是这样的:</p><p id="09d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">oR -&gt; %6fR</code></p><p id="8af4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但不幸的是，防火墙阻止了它，所以想想非标准编码，它在大多数情况下不会被WAF捕获，最后，结果是:</p><pre class="lw lx ly lz gt mb kz mc md aw me bi"><span id="ab9e" class="mf mg iq kz b gy mh mi l mj mk">oR -&gt; %256fR</span></pre><p id="d2ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我面临一个新的挑战<code class="fe kw kx ky kz b">=</code>字符被阻止，所以现在我知道了这个WAF的弱点，那就是非标准编码，所以我做了一个非标准编码，所以有效载荷是这样的:</p><pre class="lw lx ly lz gt mb kz mc md aw me bi"><span id="2607" class="mf mg iq kz b gy mh mi l mj mk">= -&gt; %253d</span></pre><p id="2073" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但不幸的是，如果你在它后面加上任何值，你就会被屏蔽，所以我想:</p><ul class=""><li id="f56e" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv lf lg lh li bi translated">现在我们想使用基于布尔的SQL注入来实现<strong class="ka ir">真正的</strong>数据类型，防火墙会阻止非标准编码<code class="fe kw kx ky kz b">=</code>之后的任何内容</li><li id="fd6a" class="la lb iq ka b kb lj kf lk kj ll kn lm kr ln kv lf lg lh li bi translated">但是我想了一会儿，为什么我没有通过另一种方法实现<strong class="ka ir">真的</strong>数据类型，例如，如果我说:<code class="fe kw kx ky kz b">50!=22</code>那么这里肯定会返回一个<strong class="ka ir">真的</strong>值，因为<code class="fe kw kx ky kz b">50</code>不等于22</li></ul><p id="1b4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我对<code class="fe kw kx ky kz b">!=</code>做了一个非标准的编码，就像这样:</p><pre class="lw lx ly lz gt mb kz mc md aw me bi"><span id="0501" class="mf mg iq kz b gy mh mi l mj mk">!= -&gt; %2521%253D</span></pre><blockquote class="lo lp lq"><p id="f5c7" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated"><strong class="ka ir">绕过有效载荷末端</strong></p></blockquote><p id="04f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我想绕过有效载荷的结尾字符，例如，引用注释的<code class="fe kw kx ky kz b">#</code>或<code class="fe kw kx ky kz b">--</code>，以及结束查询的<code class="fe kw kx ky kz b">;</code>，因为我知道我的情况中的弱点，所以我对之前的有效载荷使用了相同的编码类型，它将是:</p><pre class="lw lx ly lz gt mb kz mc md aw me bi"><span id="1b7f" class="mf mg iq kz b gy mh mi l mj mk">;# -&gt; %253B%2523</span></pre><blockquote class="lo lp lq"><p id="874c" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated"><strong class="ka ir">有效载荷的最终结果:</strong></p></blockquote><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/6d3b5012cb10dcb98911480364c4b1d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*Th_CnMqp9FAkjgDXvSQJpg.png"/></div></figure></div></div>    
</body>
</html>