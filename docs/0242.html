<html>
<head>
<title>And The King Goes Down</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">国王倒下了</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/and-the-king-goes-down-d28f23749f80?source=collection_archive---------1-----------------------#2019-01-22">https://infosecwriteups.com/and-the-king-goes-down-d28f23749f80?source=collection_archive---------1-----------------------#2019-01-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2c9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">注:以下文章发表于2016年7月24日关于</em><a class="ae km" href="https://fogmarks.com/2016/07/24/and-the-king-goes-down/" rel="noopener ugc nofollow" target="_blank"><em class="kl">【https://FogMarks.com】</em></a><em class="kl"><br/>PoC视频在本案例研究的底部。</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/8a9bd91923ccf3fa344c79a83b0a7f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HpHpn7w5eyfBr3HQCIZOng.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">国王阿哈齐亚在从一个上井口掉下来后生病躺在床上(来源:维基媒体)</figcaption></figure><p id="0d28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi ld translated">今天的案例研究将讨论拥有令牌管理机制的重要性。<br/>每个支持用户认证的web应用程序通常会使用一个令牌来验证用户发起的“关键”操作。</p><p id="15d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，脸书会自动在用户提供的任何链接的末尾添加一个标记，有时甚至会添加到脸书境内的页面。这种机制被称为<a class="ae km" href="https://www.facebook.com/10150492832835766/" rel="noopener ugc nofollow" target="_blank">‘Linkshim’</a>，这也是你很少听说脸书开放重定向、CSRFs或点击劫持漏洞的主要原因。脸书的方法非常简单——如果一个链接被添加到一个页面上——在它的末尾添加一个令牌参数。当然，令牌应该只允许同一个登录用户访问URL，并且有一个令牌验证算法来限制令牌被使用的次数和被谁使用。</p><h2 id="256c" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">但是当令牌以错误的方式被管理时会发生什么呢？</h2><p id="cabc" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">BugCrowd 允许为每个在其平台上运行bug bounty程序的公司创建团队。想法是创建一个团队，以便分类和处理不同类型的漏洞。当用户创建团队时，她自动成为团队的所有者:她拥有“最高”角色，控制整个团队的操作和选项，如更改团队名称、查看“重要/机密”文档、更改团队中其他用户的角色、邀请新人加入团队等等。</p><p id="6aa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">团队支持以下角色:所有者、管理员和其他一些次要的非重要角色。只有团队的所有者和管理员能够邀请新用户加入团队。邀请只能发送给不在团队中并且没有帐户的人。当收件人打开邮件时，他将被重定向到公司的注册页面(在BugCrowd上)，然后将被添加到团队中，其角色由所有者或管理员设置。</p><p id="98c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我第一次查看团队选项时，我注意到在所有者或管理员通过电子邮件邀请其他人加入团队后，他可以重新发送邀请，以防被邀请的用户错过或意外删除它。重发选项是每个邀请旁边的一个链接。单击该链接创建了一个对某个“邀请管理器”页面的POST请求，<strong class="jp ir">并只向其传递了一个邀请ID POST参数，</strong>，该参数是最初生成的(当此人第一次被邀请时)<strong class="jp ir">。邀请ID随后用于识别团队中的用户。</strong></p><p id="6097" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那个请求看起来像这样:</p><blockquote class="mk ml mm"><p id="dd96" class="jn jo kl jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated">POST<a class="ae km" href="https://tracker.bugcrowd.com/organizations/TEAM_ID/settings/team/TEAM_MEMBER_ID/resend" rel="noopener ugc nofollow" target="_blank">https://tracker . bug crowd . com/organizations/TEAM _ ID/settings/TEAM/TEAM _ MEMBER _ ID/resend</a>HTTP/1.1<br/>……<br/> … <br/>..<br/>。<br/>_ method = post&amp;authenticity _ TOKEN =&lt;TOKEN&gt;</p></blockquote><p id="0638" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我开始思考的地方:他们为什么要传递一个邀请ID？传一下被邀请人的邮箱就可以了。<strong class="jp ir"> </strong>他们为什么不把邀请ID和会员ID分开？最重要的是，当我在重发请求中使用所有者的id时，传递的<em class="kl">authentity _ token</em>POST参数的值是多少？</p><h2 id="82ea" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">嗯，没什么</h2><p id="9636" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated"><em class="kl">authentity _ token</em>仅用于确保发起请求的用户(从团队仪表板页面)是实际向其他团队成员发送<em class="kl"> resend </em>请求的用户。<em class="kl">authentity _ token</em>可能还确保发起者是所有者或管理员。</p><p id="bf39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的是过去的邀请id没有被删除。除此之外，他们<strong class="jp ir">仍然是</strong> <strong class="jp ir">可接近的。</strong><strong class="jp ir"/><em class="kl">authentity _ token</em>不够“智能”，无法确定正在对哪个对象(即邀请/成员ID)执行操作。<br/>通过将传递的邀请ID参数更改为所有者的“第一个”邀请ID，可以向他重新发送邀请。</p><p id="3c7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">起初，我笑着说“哦，好吧，除了给主人发一点垃圾邮件之外，它还能造成多少损失呢？”。但我错了。非常不对。</p><h2 id="39f7" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">情节扭曲</h2><p id="86ad" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">当系统检测到向所有者发送了邀请时(尽管一开始并没有邀请)，<strong class="jp ir">将所有者从其角色</strong>中移除。但是更进一步——还记得我说过发送邀请会根据收件人的电子邮件地址向其发送注册页面吗？该系统还删除了所有者的账户——他的私人信息，最重要的是——他的证书。这就造成了车主整个账号被封。经典的DoS。</p><h2 id="dd9c" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">那么，我们如何防止不必要的行为发生呢？这很简单。或者很辛苦。</h2><p id="8478" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">首先，让我们为每个动作附加一个真实性令牌。必须为每个特定用户专门和单独地生成真实性令牌。</p><p id="11cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二，像牛奶和奶酪一样——让我们为每个代币附加一个截止日期。<br/> <strong class="jp ir"> 2分钟</strong>到期时间足够公平，允许用户使用我们的令牌，即使对于互联网连接超慢的用户也是如此。</p><p id="65b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们将真实性标记与它们应该保护的对象联系起来。为登录的用户请求传递真实性令牌是没有意义的，除非真实性令牌验证了某些东西。否则，有足够的解决方案来使用cookies进行会话验证。</p><blockquote class="mk ml mm"><p id="b40e" class="jn jo kl jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated">看在上帝的份上，请从可访问令牌机制或数据库中删除用过的令牌。如果没有，至少让它们过期，并确保过期日期有效。</p></blockquote><h2 id="903d" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated"><strong class="ak">总之，</strong></h2><p id="bdd0" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">这个安全问题本来可以通过遵循三个简单的原则来防止— <br/> 1)将访问令牌附加到用户正在执行的每个动作<strong class="jp ir">和对象</strong>上，只要用户在生成时能够访问该对象。<br/> 2)为每个令牌设置一个合理的抽取时间。2m就可以了。<br/> 3)最重要的是，正确管理令牌并删除用过的令牌。</p><p id="8a1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">干杯。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div></div>    
</body>
</html>