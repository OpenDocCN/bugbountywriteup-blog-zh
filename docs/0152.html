<html>
<head>
<title>Celestial — A Node.js Deserialization HackTheBox Walk-through</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">天体——node . js反序列化HackTheBox演练</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/celestial-a-node-js-deserialization-hackthebox-walk-through-c71a4da14eaa?source=collection_archive---------0-----------------------#2018-08-27">https://infosecwriteups.com/celestial-a-node-js-deserialization-hackthebox-walk-through-c71a4da14eaa?source=collection_archive---------0-----------------------#2018-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bc461a9d5e1f35976a76fbca5927261c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5j5kFK-urpNTrVLlv9-og.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">节点. js</figcaption></figure><p id="b0a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个快速而有趣的盒子，是我完成的第一批HackTheBox机器之一。现在它已经在周末退役了，我想我应该分享一下我是如何扎根这台机器的！</p><h1 id="ba90" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="56fc" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">仙界是一台linux机器，托管Node.js Express web服务，该服务不安全地评估客户机提供的cookie参数。该漏洞被利用来获得系统上的反向外壳。由<code class="fe md me mf mg b">root</code>通过cronjob执行的可写文件被用于权限提升。</p><h1 id="a3ba" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">侦察</h1><p id="71c7" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我像往常一样用一个<code class="fe md me mf mg b">nmap -sV -sC</code>扫描来枚举服务版本并运行默认脚本:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">天体nmap -sV -sC</figcaption></figure><p id="aa84" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随后，我进行了第二次全端口扫描，查看是否有其他端口打开。但是，只返回了端口3000。此时，由于没有其他服务可以访问，我启动了一个浏览器来查看web服务器存储了什么。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/4e5fe71f43ef3240e8d1bcf87f372b46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9umNmpW3pl8iRAw9bhCbzw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">嗯…</figcaption></figure><p id="3c3e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">第一个请求返回了404 Not Found错误…所以我刷新了页面，看看是否会发生什么。果然！</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/f03f8663ba5ec8b395985232e59a92c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dqB2RNC7LRZ95aUd3JqVbQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这是一件了不起的事</figcaption></figure><p id="aa2f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我想知道为什么会发生这种情况，所以我将我的请求代理到这个服务器上，发现有一个cookie被传递到名为<code class="fe md me mf mg b">profile</code>的服务器上，这个cookie似乎是经过编码的。因为我已经在Burp Suite中，所以我将cookie发送到Decoder，并将cookie转换成明文:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/e62f86ec7ea8448063f75c8be834e8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfi3XcZn6gAc9g5EXfRDew.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">URL解码&gt; base64解码&gt;明文</figcaption></figure><p id="6de7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我能够读取cookie值了:</p><pre class="mh mi mj mk gt mq mg mr ms aw mt bi"><span id="4a44" class="mu lb iq mg b gy mv mw l mx my">{“username”:”Dummy”,”country”:”Idk Probably Somewhere Dumb”,”city”:”Lametown”,”num”:”2"}</span></pre><p id="1f45" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这解释了网络上的反应“嘿，笨蛋2+2 = 22”。如果我更改了cookie中的<code class="fe md me mf mg b">username</code>或<code class="fe md me mf mg b">num</code>值，网页会打印出名字并将数字连接两次。</p><h1 id="3738" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">剥削</h1><p id="3dc5" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在这一点上，我知道这是我最初的立足点。我开始研究在Node.js web服务上利用这个cookie的方法。我找到了<a class="ae mz" href="https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/" rel="noopener ugc nofollow" target="_blank">这篇博文</a>解释了如何利用传递给节点序列化模块中的<code class="fe md me mf mg b">unserialize()</code>函数的不可信数据，通过传递带有立即调用的函数表达式的序列化JavaScript对象来实现任意代码执行。</p><p id="7f91" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">反序列化漏洞并非Node.js独有，在很多其他语言中都存在。其他语言中常见的反序列化向量包括</p><ul class=""><li id="1f3e" class="na nb iq ke b kf kg kj kk kn nc kr nd kv ne kz nf ng nh ni bi translated"><a class="ae mz" href="https://securitycafe.ro/2015/01/05/understanding-php-object-injection/" rel="noopener ugc nofollow" target="_blank"> PHP对象注入</a></li><li id="68d0" class="na nb iq ke b kf nj kj nk kn nl kr nm kv nn kz nf ng nh ni bi translated"><a class="ae mz" href="https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet" rel="noopener ugc nofollow" target="_blank"> Java反序列化</a></li><li id="4a65" class="na nb iq ke b kf nj kj nk kn nl kr nm kv nn kz nf ng nh ni bi translated"><a class="ae mz" href="http://blog.codeclimate.com/blog/2013/01/10/rails-remote-code-execution-vulnerability-explained/" rel="noopener ugc nofollow" target="_blank"> Rails RCE漏洞(XML &amp; YAML) </a></li><li id="eee7" class="na nb iq ke b kf nj kj nk kn nl kr nm kv nn kz nf ng nh ni bi translated"><a class="ae mz" href="https://www.cs.uic.edu/~s/musings/pickle/" rel="noopener ugc nofollow" target="_blank"> Python Pickle反序列化</a></li></ul><p id="31be" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于GitHub上的<a class="ae mz" href="https://github.com/ajinabraham/Node.Js-Security-Course/blob/master/nodejsshell.py" rel="noopener ugc nofollow" target="_blank"> nodeshell.py </a>,利用Node.js中的这个反序列化漏洞获得反向shell非常容易。通过使用攻击者的IP和要连接回的本地端口运行脚本，可以非常容易地生成有效负载:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">nodeshell.py</figcaption></figure><p id="7b57" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe md me mf mg b">String.fromCharCode()</code>中编码的有效载荷可以很容易地反向返回实际的指令(或者你可以直接读取GitHub上的代码！):</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">简单解码循环</figcaption></figure><p id="4a87" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将返回:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">解码反向外壳有效负载</figcaption></figure><p id="8f8a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于这段代码运行在<code class="fe md me mf mg b">eval()</code>内部，它将在服务器上执行，并产生一个<code class="fe md me mf mg b">/bin/sh</code>的进程，并将它发送到攻击者的监听端口。</p><p id="9b6a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了将这个<code class="fe md me mf mg b">eval()</code>函数作为cookie发送回服务器，必须将它打包到一个变量中，并使用如下的<code class="fe md me mf mg b">{"name":value}</code>语法:</p><pre class="mh mi mj mk gt mq mg mr ms aw mt bi"><span id="c6ee" class="mu lb iq mg b gy mv mw l mx my">{“rce”:”_$$ND_FUNC$$_function (){ eval(String.fromCharCode(…))}()"}</span></pre><p id="8969" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦这个cookie被base64编码，它就可以被发送回服务器以获得一个反向shell！攻击者唯一要做的就是启动一个netcat监听器:</p><pre class="mh mi mj mk gt mq mg mr ms aw mt bi"><span id="cca5" class="mu lb iq mg b gy mv mw l mx my">nc -lvnp 1337</span></pre><blockquote class="no np nq"><p id="4402" class="kc kd nr ke b kf kg kh ki kj kk kl km ns ko kp kq nt ks kt ku nu kw kx ky kz ij bi translated"><code class="fe md me mf mg b">-l</code>—listen<br/><code class="fe md me mf mg b">-v</code>—verbose<br/><code class="fe md me mf mg b">-n</code>—只有数字的IP地址，没有DNS <br/> <code class="fe md me mf mg b">-p</code> —端口(本例中为1337)</p></blockquote><p id="bceb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在继续之前，值得注意的是，服务器允许接收和执行这个恶意cookie，即使cookie中没有任何原始参数！</p><p id="9472" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，有效负载也可以放在cookie的其他值中。例如在<code class="fe md me mf mg b">username</code>中:</p><pre class="mh mi mj mk gt mq mg mr ms aw mt bi"><span id="7d97" class="mu lb iq mg b gy mv mw l mx my">{“username”:”_$$ND_FUNC$$_function (){ eval(String.fromCharCode(…))}()”,”country”:”Idk Probably Somewhere Dumb”,”city”:”Lametown”,”num”:”2"}</span></pre><p id="6730" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">无论哪种方式，base64编码的字符串都会进入到对服务器的GET请求的<code class="fe md me mf mg b">profile</code>值中，侦听器将捕获一个反向shell。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/9811d67b7e41153d80b6ee94bedea40a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CUP8CdPf006Zfdw9hEHheQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这是一块大饼干</figcaption></figure><h1 id="6d79" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">权限提升</h1><p id="e343" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在服务器上，我能够运行一些快速枚举，并发现我的用户在<code class="fe md me mf mg b">adm</code>组中，这意味着用户可以从服务器上读取日志。在我的用户的主目录中有两个文件引起了我的注意:<code class="fe md me mf mg b">~/output.txt</code>和<code class="fe md me mf mg b">~/Documents/script.py</code>。</p><p id="2108" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe md me mf mg b">script.py</code>的内容只是一个打印声明，说“脚本正在运行…”而<code class="fe md me mf mg b">output.txt</code>包含完全相同的内容。我的用户拥有具有读写权限的<code class="fe md me mf mg b">script.py</code>——没有执行权限。然而，<code class="fe md me mf mg b">output.txt</code>归<code class="fe md me mf mg b">root</code>所有。这给了我一个提示，可能有某种cronjob正在为<code class="fe md me mf mg b">root</code>运行，以定期执行<code class="fe md me mf mg b">script.py</code>，并可能将其写入<code class="fe md me mf mg b">output.txt</code>。</p><p id="6db8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我的用户没有权限运行<code class="fe md me mf mg b">crontab -u root</code>来查看<code class="fe md me mf mg b">root</code>下安排的cronjobs。<em class="nr">然而</em>，该用户是<code class="fe md me mf mg b">adm</code>组的成员，因此他们可以查看<code class="fe md me mf mg b">/var/log/</code>目录中的日志。我们可以看到，每隔5分钟，<code class="fe md me mf mg b">root</code>执行<code class="fe md me mf mg b">script.py</code>并将输出写入<code class="fe md me mf mg b">output.txt</code>。</p><pre class="mh mi mj mk gt mq mg mr ms aw mt bi"><span id="f6eb" class="mu lb iq mg b gy mv mw l mx my">tail -10 /var/log/syslog | grep root</span></pre><p id="a1fd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">输出以下内容:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Root Cronjob</figcaption></figure><p id="37d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从这里简单地将<code class="fe md me mf mg b">script.py</code>改写为<a class="ae mz" href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet" rel="noopener ugc nofollow" target="_blank"> Pentestmonkey的反向shell备忘单</a>中的python反向shell，设置IP和端口，并等待5分钟用另一个<code class="fe md me mf mg b">netcat</code>监听器捕获我的根Shell！</p></div></div>    
</body>
</html>