<html>
<head>
<title>Security: Preventing Cross-site Scripting (XSS)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安全性:防止跨站点脚本(XSS)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/injection-vulnerabilities-cross-site-scripting-xss-7fd9dc28cc47?source=collection_archive---------0-----------------------#2020-04-12">https://infosecwriteups.com/injection-vulnerabilities-cross-site-scripting-xss-7fd9dc28cc47?source=collection_archive---------0-----------------------#2020-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/37c587833db4f624b418bd572a218ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0MaPOK-5Si6THvraEEI17Q.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">PortSwigger</figcaption></figure><div class=""/><p id="e458" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">跨站点脚本是最常见和最流行的web攻击之一。</p><p id="3708" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它允许攻击者将客户端代码注入web应用程序屏幕，然后被受害者查看。</p><p id="4f41" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">后果和影响可能因攻击类型和攻击发起的环境而异。</p><p id="e866" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">XSS可以归类为:</p><ul class=""><li id="80ca" class="ld le ji kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated">自体XSS /反射XSS /非持续性XSS /二型XSS</li><li id="98e0" class="ld le ji kh b ki lm km ln kq lo ku lp ky lq lc li lj lk ll bi translated">持久性XSS /储存的XSS/I型XSS</li><li id="c760" class="ld le ji kh b ki lm km ln kq lo ku lp ky lq lc li lj lk ll bi translated">基于DOM的XSS</li></ul><h1 id="e1f1" class="lr ls ji bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">自我XSS</h1><p id="6c36" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">假设我们有下面的PHP代码——PHP只是为了挑选一个(清晰的)代码:</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">自我XSS的例子</figcaption></figure><p id="01c3" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">教科书XSS:受害者打开一个链接，看起来像</p><pre class="mu mv mw mx gt na nb nc nd aw ne bi"><span id="29c9" class="nf ls ji nb b gy ng nh l ni nj">GET https://my-website.com/page.php?id=%22%3B%20alert(1)%3B%20var%20a%20%3D%20%22</span><span id="b7cd" class="nf ls ji nb b gy nk nh l ni nj">(GET https://my-website.com/page.php?id=”; alert(1); var a = “)</span></pre><p id="5209" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">神奇的是，上面的代码在被PHP渲染并发送到受害者浏览器后，看起来会像这样</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">生成的输出</figcaption></figure><p id="0a87" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这种情况下，我们只是打开一个弹出窗口，并在其中显示“1”，但攻击者可以变得更有创意:他可以进行AJAX调用，并将document.cookie发送到他的服务器(假设应用程序没有为会话cookie设置仅HTTP标志)。</p><p id="e2e4" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这叫做反射XSS，因为你发送了一个恶意的请求，得到了一些恶意的回应。请记住:受害者需要打开一个恶意制作的链接(也可以使用第三方链接缩短程序网站来缩短)</p><h1 id="653c" class="lr ls ji bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">执着的XSS</h1><p id="4818" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">类似于自我XSS，但工作流程不同:在这种情况下,$id已经存储到数据库(或其他持久存储)中，然后在稍后的时间被受害者读取。</p><p id="deaf" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一个典型的例子是一个平台，允许用户发布内容，然后显示给其他用户(即媒体):攻击者将能够在帖子中编写一些JS，任何阅读该帖子的用户都将自动(可能悄悄地)运行恶意JS代码。</p><p id="6dde" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以看到这是如何很快变得非常糟糕<em class="nl">非常</em>，使得持续的XSS成为这种攻击的一个更加危险的子类。</p><h1 id="3ec9" class="lr ls ji bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">基于DOM的XSS</h1><p id="0987" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">Amit Klein在2005年首次描述了基于DOM的XSS，这是一种鲜为人知的变体，每当修改常规客户端代码运行的DOM上下文直接导致XSS时就会出现，因此执行会导致“意外”行为。</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">基于DOM的XSS示例</figcaption></figure><p id="7d32" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通常这个HTML页面会用来欢迎用户:</p><pre class="mu mv mw mx gt na nb nc nd aw ne bi"><span id="f8d6" class="nf ls ji nb b gy ng nh l ni nj">GET <a class="ae nm" href="http://my-website.example.com/welcome.html?name=Michele" rel="noopener ugc nofollow" target="_blank">http://my-website.example.com/welcome.html?name=Michele</a></span></pre><p id="f7c5" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然而，诸如以下的请求:</p><pre class="mu mv mw mx gt na nb nc nd aw ne bi"><span id="6aec" class="nf ls ji nb b gy ng nh l ni nj">GET http://my-website.example.com/welcome.html?name=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span></pre><p id="3ddc" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">会导致XSS病。</p><p id="be66" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">同样-你可以升级这个:发送cookie到一个恶意的服务器-可能持有会话信息(即会话cookie)并接管一个帐户。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="9f4f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="nl">在核心</em>处，每当应用程序接受不可信的(应用程序从外部接收的任何东西——通常是用户输入数据)<strong class="kh jj">数据并显示它，而没有根据其上下文正确地对其进行转义</strong>时，就会出现一个XSS漏洞<strong class="kh jj">。</strong></p><p id="76b0" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上下文是这句话中的一个基本词汇，这也是为什么XSS与SQL或XML/HTML注入没有太大区别的原因。</p><h1 id="2e43" class="lr ls ji bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">攻击者能做什么？</h1><p id="d6c8" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">一般来说，如果攻击者设法执行XSS攻击，他基本上可以执行以下一项或多项操作:</p><blockquote class="nu nv nw"><p id="72d2" class="kf kg nl kh b ki kj kk kl km kn ko kp nx kr ks kt ny kv kw kx nz kz la lb lc im bi translated"><strong class="kh jj">广告劫持</strong> —将他的广告注入其中赚钱<br/> <strong class="kh jj">点击劫持</strong> —在页面上创建一个隐藏的覆盖图，劫持受害者的点击以执行恶意操作。<br/> <strong class="kh jj">会话劫持</strong> —如果cookie中没有HTTP ONLY标志，JavaScript可以访问HTTP cookies。<br/> <strong class="kh jj">内容欺骗</strong> — JavaScript可以完全访问web应用的客户端代码，因此他可以使用它来显示/修改所需的内容。<br/> <strong class="kh jj">凭证收集</strong> —他可以使用一个别致的弹出窗口来收集凭证:WiFi固件已更新，请重新输入您的凭证进行身份验证。<br/> <strong class="kh jj">强制下载</strong>——所以受害者不是从absolutely-safe.com下载他的恶意flash播放器？没问题:他可以尝试从受害者访问的可信网站强制下载。<br/> <strong class="kh jj">密码挖掘</strong> —他可以使用受害者的CPU挖掘一些比特币(或altcoin) <br/> <strong class="kh jj">绕过CSRF保护</strong> —他可以收集并提交CSRF令牌，以在网站的其他地方执行POST操作。<br/> <strong class="kh jj">键盘记录</strong> —不言自明<br/> <strong class="kh jj">录音、拍照、地理定位</strong> —需要用户授权，但他可以访问受害者的摄像头、麦克风和位置。多亏了HTML5和JavaScript。<br/> <strong class="kh jj">窃取HTML5 web存储数据</strong> —网站可以在浏览器中存储数据以备后用，当然，JavaScript可以通过window.localStorage()和window.webStorage() <br/> <strong class="kh jj">指纹识别</strong> —非常容易找到您的浏览器名称、版本、安装的插件及其版本、您的操作系统、架构、系统时间、语言和屏幕分辨率。<br/> <strong class="kh jj">网络扫描</strong> —受害者的浏览器可被滥用，用Javascript扫描端口和主机。<br/> <strong class="kh jj">崩溃浏览器</strong> —为什么不？！:-) <br/> <strong class="kh jj">窃取信息</strong> —从网页抓取信息，发送到他的恶意服务器。<br/> <strong class="kh jj">重定向</strong>—自明<br/> <strong class="kh jj"> Tabnapping </strong> —花式版重定向:当超过一分钟没有接收到键盘或鼠标事件时，这可能意味着用户是afk，他可以偷偷地用一个假的网页替换当前网页。<br/> <strong class="kh jj">截图</strong> —再次感谢HTML5，现在可以截图网页了。盲人XSS检测工具已经这样做之前，这是很酷的。<br/> <strong class="kh jj">执行动作</strong> —他在控制浏览器</p></blockquote><p id="87ec" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不是全部丢失，跨站脚本是可以防止的！</p><h1 id="d08f" class="lr ls ji bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">能做些什么？</h1><p id="2294" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">不幸的是，没有灵丹妙药。你可以是:</p><ul class=""><li id="9c1e" class="ld le ji kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated">使用Web应用程序防火墙(希望有最好的结果:他们可以阻止一些/大多数常见的攻击，但不是全部)</li><li id="1305" class="ld le ji kh b ki lm km ln kq lo ku lp ky lq lc li lj lk ll bi translated">使用<a class="ae nm" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection" rel="noopener ugc nofollow" target="_blank"> <em class="nl"> X-XSS保护</em> </a>，当浏览器检测到反射的跨站脚本时，阻止页面加载(不推荐使用IE功能)</li><li id="23d2" class="ld le ji kh b ki lm km ln kq lo ku lp ky lq lc li lj lk ll bi translated">使用<a class="ae nm" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" rel="noopener ugc nofollow" target="_blank">内容安全策略</a>、<a class="ae nm" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options" rel="noopener ugc nofollow" target="_blank"> X-FRAME-OPTIONS </a>、(等等..)标题以限制影响</li></ul><p id="a0f6" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是，以上(或组合)都不是实际问题的解决方案。如果有的话，他们可能会给你一种虚假的安全感。</p><p id="30fa" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">真正的解决方案是编写不易受攻击的代码😃。</p><p id="2b2e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如前所述:</p><blockquote class="nu nv nw"><p id="5f7e" class="kf kg nl kh b ki kj kk kl km kn ko kp nx kr ks kt ny kv kw kx nz kz la lb lc im bi translated"><em class="ji">在核心</em>处，每当应用程序接受不可信的(应用程序从外部接收的任何东西——通常是用户输入数据)<strong class="kh jj">数据并显示它，而没有根据其上下文正确地对其进行转义</strong>时，就会出现一个XSS漏洞<strong class="kh jj">。</strong></p></blockquote><p id="6f0d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，解决方案是根据内容所处的上下文来正确地对内容进行转义:在通用的HTML上下文中有特殊的含义，因此它们应该被转换成对应的HTML代码(&lt;&gt;)；相反，在HTML属性上下文中，双引号(或单引号)具有特殊的含义，因此它们应该被转换成对应的HTML代码(")等等</p><p id="900d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">相反，在Javascript中，根据注入不可信输入的具体区域，理解哪些字符有特殊含义可能会有点困难——因此，在这种情况下，用十六进制的等价字符对所有非字母数字字符进行转义更容易(例如，双引号变成\x22，＄变成\x24，等等)。</p><p id="26dc" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不要自行开发安全性:相反，您应该依赖您选择的语言/框架为此提供的任何东西。</p><p id="2c33" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我会试着列出每种语言的一些例子。</p><p id="7382" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你的语言/框架不在这个列表中吗？<br/>欢迎留下评论/建议，我会修改列表！</p><p id="1eb7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">分享就是关心，嗯？😄</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="e624" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi oa translated">由于您对安全性和常见漏洞感兴趣，您可能还想了解一下SQL注入以及如何在您的应用程序中防止它们。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="0225" class="nf ls ji bd lt oj ok dn lx ol om dp mb kq on oo mf ku op oq mj ky or os mn ot bi translated">原生—c#(ASP.NET)</h2><p id="82a6" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">MVC中使用的<a class="ae nm" href="https://docs.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-3.1#html-encoding-using-razor" rel="noopener ugc nofollow" target="_blank"> Razor引擎</a>自动编码所有来自变量的输出。您还可以使用<a class="ae nm" href="https://docs.microsoft.com/en-us/dotnet/api/system.text.encodings.web.javascriptencoder?view=netcore-3.1" rel="noopener ugc nofollow" target="_blank"> JavaScriptEncoder </a>来编码Javascript上下文中的变量。</p><h2 id="6179" class="nf ls ji bd lt oj ok dn lx ol om dp mb kq on oo mf ku op oq mj ky or os mn ot bi translated">本地语— Go (Golang)</h2><p id="55c9" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">【golang.org/pkg/html#EscapeString】将特殊字符(&lt;&gt;&amp;’”)转义为它们的HTML代码等价物</p><p id="33ba" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">golang.org/pkg/html/template给你更多的控制和更好的CSS/JS/HTML转义功能。</p><h2 id="a18e" class="nf ls ji bd lt oj ok dn lx ol om dp mb kq on oo mf ku op oq mj ky or os mn ot bi translated">本机— Java</h2><p id="25a5" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">OWASP提供了<a class="ae nm" href="https://github.com/nahsra/antisamy" rel="noopener ugc nofollow" target="_blank"> AntiSamy </a>(用于确保用户提供的HTML/CSS符合应用程序规则的API)</p><p id="c23e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">OWASP还提供了<a class="ae nm" href="https://github.com/OWASP/java-html-sanitizer" rel="noopener ugc nofollow" target="_blank"> Java-HTML-Sanitizer </a>，以不同的方式做着同样的事情。HTML-Sanitizer使用起来更快更简单，但灵活性较差。</p><p id="4fb0" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">OWASP也曾经提供ESAPI，但是现在这个项目已经不存在了。</p><h2 id="fdbd" class="nf ls ji bd lt oj ok dn lx ol om dp mb kq on oo mf ku op oq mj ky or os mn ot bi translated">本机— PHP</h2><p id="f773" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">htmlentities会将所有适用的字符转换成HTML实体，但这并不是防止XSS的最好方法。</p><p id="bd55" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae nm" href="http://htmlpurifier.org/" rel="noopener ugc nofollow" target="_blank"> HTMLPurifier </a>默认情况下会剥离恶意代码，但是您可以将其配置为避开它。</p><h2 id="dfb8" class="nf ls ji bd lt oj ok dn lx ol om dp mb kq on oo mf ku op oq mj ky or os mn ot bi translated">原生— Python</h2><p id="771d" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated"><a class="ae nm" href="https://docs.python.org/3/library/html.html" rel="noopener ugc nofollow" target="_blank"> html包</a>允许你将&amp; &lt; &gt;(如果需要的话，还有“)转换成它们的html代码等价物。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="8db4" class="nf ls ji bd lt oj ok dn lx ol om dp mb kq on oo mf ku op oq mj ky or os mn ot bi translated">角度2，3，4，5，6，7，8，9-JS</h2><p id="8f20" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">默认情况下，角度将所有值视为不受信任。当一个值通过属性、特性、样式、类绑定或插值从模板插入到DOM中时，Angular清理并转义不可信的值。</p><h2 id="c00b" class="nf ls ji bd lt oj ok dn lx ol om dp mb kq on oo mf ku op oq mj ky or os mn ot bi translated">Django — Python</h2><p id="11e9" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">如果你使用Django模板，你可以抵御大多数XSS攻击。然而，这并不是万无一失的:<a class="ae nm" href="https://docs.djangoproject.com/en/3.0/topics/security/" rel="noopener ugc nofollow" target="_blank"> Django模板</a>转义<a class="ae nm" href="https://docs.djangoproject.com/en/3.0/ref/templates/language/#automatic-html-escaping" rel="noopener ugc nofollow" target="_blank">特定字符</a>，这些字符对HTML来说尤其危险，但是它不能保护你免受基于HTML属性的攻击。</p><h2 id="7d5f" class="nf ls ji bd lt oj ok dn lx ol om dp mb kq on oo mf ku op oq mj ky or os mn ot bi translated">烧瓶——Python</h2><p id="a5c8" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">Flask <a class="ae nm" href="https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss" rel="noopener ugc nofollow" target="_blank">默认配置Jinja2自动转义所有值</a>。</p><h2 id="9f92" class="nf ls ji bd lt oj ok dn lx ol om dp mb kq on oo mf ku op oq mj ky or os mn ot bi translated">Laravel — PHP</h2><p id="8ff8" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">在Laravel ≥5时，缺省值{{ }}应该对所有输出进行转义</p><h2 id="ad3b" class="nf ls ji bd lt oj ok dn lx ol om dp mb kq on oo mf ku op oq mj ky or os mn ot bi translated">React — JS</h2><p id="2dc7" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated">React会自动为您转义变量，但是有一些问题。更多关于那个<a class="ae nm" href="https://medium.com/javascript-security/avoiding-xss-in-react-is-still-hard-d2b5c7ad9412" rel="noopener">在这里</a>。</p><h2 id="6b43" class="nf ls ji bd lt oj ok dn lx ol om dp mb kq on oo mf ku op oq mj ky or os mn ot bi translated">Symfony — PHP</h2><p id="ce76" class="pw-post-body-paragraph kf kg ji kh b ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky mt la lb lc im bi translated"><a class="ae nm" href="https://symfony.com/doc/current/templates.html" rel="noopener ugc nofollow" target="_blank"> Symfony应用程序默认是安全的，因为它们执行自动输出转义</a></p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="4449" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="nl">关注</em> <a class="ae nm" href="https://medium.com/bugbountywriteup" rel="noopener"> <em class="nl"> Infosec报道</em> </a> <em class="nl">获取更多此类精彩报道。</em></p><div class="is it gp gr iu ou"><a href="https://medium.com/bugbountywriteup" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jj gy z fp oz fr fs pa fu fw jh bi translated">信息安全报道</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">收集了世界上最好的黑客的文章，主题从bug奖金和CTF到vulnhub…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">medium.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ja ou"/></div></div></a></div></div></div>    
</body>
</html>