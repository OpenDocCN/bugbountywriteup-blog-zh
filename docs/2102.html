<html>
<head>
<title>Zero Day Vulnerability: Chromium v8 js engine issue 1303458 — Use After Free in x64 Instruction Optimization Vulnerability Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">零日漏洞:Chromium v8 js引擎问题1303458 —在x64指令优化漏洞分析中免费使用</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/zero-day-vulnerability-chromium-v8-js-engine-issue-1303458-use-after-free-in-x64-instruction-e874419436a6?source=collection_archive---------0-----------------------#2022-05-27">https://infosecwriteups.com/zero-day-vulnerability-chromium-v8-js-engine-issue-1303458-use-after-free-in-x64-instruction-e874419436a6?source=collection_archive---------0-----------------------#2022-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">简介</strong></p><p id="118b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Chromium v8的x64平台上的指令优化中发现了UAF漏洞。成功利用此漏洞可能允许攻击者在浏览器环境中执行任意代码。</p><p id="edb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此漏洞发生在指令选择阶段，在此阶段选择了错误的指令，导致内存访问异常。</p><p id="5214" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此次提交时修复的漏洞:</p><p id="de12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://chromium.googlesource.com/v8/v8/+/71a9fcc950f1b8efb27543961745ab0262cda7c4" rel="noopener ugc nofollow" target="_blank">https://chromium . Google source . com/V8/V8/+/71 a9 FCC 950 f1 b 8 efb 27543961745 ab 0262 CDA 7 c 4</a></p><p id="8066" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本报告使用提交:</p><p id="b2a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://chromium.googlesource.com/v8/v8/+/dc9ed94efdac30bdbe88e81f4cf08783c1dc952f" rel="noopener ugc nofollow" target="_blank">https://chromium . Google source . com/V8/V8/+/DC 9 ed 94 ef DAC 30 bdbe 88 e 81 f 4 cf 08783 C1 DC 952 f</a></p><p id="d303" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">概念验证</strong></p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="a658" class="kv kw iq kr b gy kx ky l kz la">function foo() {<br/> const a = new Int16Array(0x10000);//step 1. 创建一个typed array，<br/> const b = a[0]!= 0; // setp 2<br/> %DebugPrint(a);<br/> for (let i = 0; i &lt; 1; i++) {<br/> gc(); // step 3<br/> }<br/> if (b) { //step 4 ← — — — — — — BOOM<br/> print(“boom”);<br/> }<br/> }<br/> %PrepareFunctionForOptimization(foo);<br/> foo();<br/> foo();<br/> %OptimizeFunctionOnNextCall(foo);<br/> foo();</span></pre><p id="8184" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lb">清单1:概念验证</em></p><p id="f422" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面解释了清单1中所示的代码执行流程:</p><p id="10d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤1:创建一个大小为0x10000的Int16类型数组</p><p id="0906" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤2:确定<strong class="jp ir"> a[0] </strong>值是否不等于零，然后将结果赋给<strong class="jp ir"> b </strong></p><p id="9bb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤3:然后执行垃圾收集</p><p id="27be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第四步:如果<strong class="jp ir"> b </strong>变量为真，打印钻柱</p><p id="dcd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图1显示了运行PoC代码后的输出结果:</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lc"><img src="../Images/114fd37c3dea93d1c85beb692ed0cb5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmn8Tierykmtl31n-S0p4Q.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated"><em class="lo">图1:内存损坏错误</em></figcaption></figure><p id="ce52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">访问冲突的地址发生在<strong class="jp ir"> a </strong>的data_ptr中:0x7f71576a0000(图2)</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lc"><img src="../Images/d5f6cdaffc4ed92e1dd2a20c7267da72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPXnRCVULrHnRrogtm93AA.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated"><em class="lo">图2:数组</em> <strong class="bd lp"> <em class="lo">中的访问违规a</em></strong><em class="lo">0x7f 71576 a 0000</em></figcaption></figure><p id="fdb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当PoC代码第一次调用运行时函数<em class="lb"> gc()，</em>然后是<em class="lb"> cmpw [r8]，0 </em>会比较如图3所示。</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lc"><img src="../Images/17be9b4255a619b012452c984ede5c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIh0yAM_EgMLrb2bkiQrNg.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">图3:调用gc()时的汇编指令</figcaption></figure><p id="00ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">漏洞的原因</strong></p><p id="80c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前两次运行PoC代码时，v8知道数组<strong class="jp ir"> a </strong>的使用，其作用域在声明它的块的本地，并且数组<strong class="jp ir"> a </strong>随后将不会被访问。因此，在优化编译阶段，<em class="lb"> gc() </em>回收存储在v8数组中的内存，数组<strong class="jp ir"> a </strong>的内存被释放。</p><p id="5051" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，在这种情况下，v8为x64平台生成了不明确的指令:<em class="lb"> cmp [r8]，0 </em> (r8直接指向数组a的内存地址)。参考清单1，这条指令对应的语句是:if(b)，正常情况下，执行步骤2时，<strong class="jp ir"> b </strong>默认为布尔值，在步骤4不需要再次访问数组<strong class="jp ir"> a </strong>的内存，但是由于v8中为了优化的改变，为了减少地址注册表的查找，在这种情况下，直接与内存位置进行比较。</p><p id="c1cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优化流程:</p><p id="a9f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lb"> if(b)= &gt; if(a[0]！=0)= &gt; Word32Equal(a[0]，0) = &gt; [cmp [r8]，0；jnz xxxx] </em></p><p id="69b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，当执行步骤4时，它正在访问已经回收的同一个位置，导致地址0x7f6e29984162处的内存访问异常，其中已经释放的数组<strong class="jp ir"> a </strong>的内存被再次访问，导致内存损坏和崩溃。</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lq"><img src="../Images/dc8efbf364e53ffd5f00f7dd0f0ada00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6F9oDlRKnVBMDahYs6OTFg.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated"><em class="lo">图4:漏洞跳跳虎流程图</em></figcaption></figure><p id="05e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">漏洞代码修复分析</strong></p><p id="fbc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此次修复已经移除了CanCoverForCompareZero函数的使用，并恢复了CanCover函数的使用。</p><p id="8698" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们分析一下修复了该问题的代码行:</p><p id="fa5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://chromium.googlesource.com/v8/v8/+/71a9fcc950f1b8efb27543961745ab0262cda7c4%5E%21/#F0" rel="noopener ugc nofollow" target="_blank">https://chromium . Google source . com/V8/V8/+/71 a9 FCC 950 f1 b 8 efb 27543961745 ab 0262 CDA 7 C4 % 5E % 21/# F0</a></p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="db8b" class="kv kw iq kr b gy kx ky l kz la">-// Used instead of CanCover in VisitWordCompareZero: even if CanCover(user,<br/> -// node) returns false, if |node| is a comparison, then it does not require any<br/> -// registers, and can thus be covered by |user|.<br/> -bool CanCoverForCompareZero(InstructionSelector* selector, Node* user,<br/> — Node* node) {<br/> — if (selector-&gt;CanCover(user, node)) {<br/> — return true;<br/> — }<br/> — // Checking if |node| is a comparison. If so, it doesn’t required any<br/> — // registers, and, as such, it can always be covered by |user|.<br/> — switch (node-&gt;opcode()) {<br/> -#define CHECK_CMP_OP(op) \<br/> — case IrOpcode::k##op: \<br/> — return true;<br/> — MACHINE_COMPARE_BINOP_LIST(CHECK_CMP_OP)<br/> -#undef CHECK_CMP_OP<br/> — default:<br/> — break;<br/> — }<br/> — return false;<br/> -}<br/> -<br/> } // namespace<br/> <br/> // Shared routine for word comparison against zero.<br/> @@ -2516,7 +2494,7 @@<br/> cont-&gt;Negate();<br/> }<br/> <br/> — if (CanCoverForCompareZero(this, user, value)) {<br/> + if (CanCover(user, value)) {<br/> switch (value-&gt;opcode()) {<br/> case IrOpcode::kWord32Equal:<br/> cont-&gt;OverwriteAndNegateIfEqual(kEqual);<br/> @@ -2536,7 +2514,7 @@<br/> case IrOpcode::kWord64Equal: {<br/> cont-&gt;OverwriteAndNegateIfEqual(kEqual);<br/> Int64BinopMatcher m(value);<br/> — if (m.right().Is(0) &amp;&amp; CanCover(user, value)) {<br/> + if (m.right().Is(0)) {<br/> // Try to combine the branch with a comparison.<br/> Node* const eq_user = m.node();<br/> Node* const eq_value = m.left().node();<br/> @@ -2646,6 +2624,7 @@<br/> break;<br/> }<br/> }<br/> +<br/> // Branch could not be combined with a compare, emit compare against 0.<br/> VisitCompareZero(this, user, value, kX64Cmp32, cont);<br/> }</span></pre><p id="11a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多人会问为什么前面的函数没有给出正确的结果？CanCoverForCompareZero用于确定该位置是否可以生成优化的与零比较的指令序列。相当于VisitWordCompareZero函数中canCover的增强版。在VisitWordCompareZero比较操作位置中处理这种情况，v8开发者认为，如果canCover返回false，该位置用于比较操作，那么就不需要其他注册表。</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lr"><img src="../Images/a67c41e36e00be4d8964914e55ad133f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9_nqMFltZIMeMktGuo_mA.png"/></div></div></figure><p id="71ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正常情况下，这不是问题。但是，当生成的指令没有先获得比较结果，然后使用比较结果进行比较，而是再次访问数组<strong class="jp ir"> a </strong>的内存，然后执行cmp时，就会出现问题。在这种情况下，所访问的内存被gc释放，从而导致UAF问题。</p><p id="2ce4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面显示了访问<strong class="jp ir"> a </strong>的数组缓冲区的函数调用的代码片段:</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lc"><img src="../Images/ae7894817be1794e403b01ebcffd345d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3uH1SrzFd1e6bD3_ATLMzw.png"/></div></div></figure><p id="7bf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面显示了触发特定指令的代码片段:</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lc"><img src="../Images/5d07037068d768f80ca863675e5c701e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-nXdl5gv5ZJu3Qp5DeSBg.png"/></div></div></figure><p id="e375" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为易受攻击的代码采用CanCoverForCompareZero为真的路径，这导致生成不同的指令序列(易受攻击版本与固定版本)。</p><p id="0532" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">指令序列的详细分析</strong></p><p id="5753" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在分析了涡扇发动机的优化阶段后，我们知道问题发生在后两个阶段:</p><p id="bba6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在调度阶段，节点信息是完全一致的，但之后就变得不一样了，我们找到了相关的指令序列。</p><p id="48c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其实对应的js代码是const b=a[0]！=0;</p><p id="9c18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">修复前:</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lr"><img src="../Images/763002bb24a0acf4c2c12ea031a5ff20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwMmEBpFlMib62POXetAuw.png"/></div></div></figure><p id="d28c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">修复后:</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lr"><img src="../Images/c6b985c0ad63207d2a2ca0549ef04b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJSj8FmDSxv6GuUwUogEfQ.png"/></div></div></figure><p id="17a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看好像完全一样，但是由于漏洞的原因，这里生成的代码是不一样的(注意114的左侧，fix之前是一个点，fix之后是一个圆和一个点，也就是说在fix之前的114行并不是直接生成的指令，而是从33个输入中取出来生成一个优化的指令序列——指令折叠。</p><p id="1536" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在易受攻击的代码中，当调用VisitWordCompareZero时，CanCoverForCompareZero将返回true，因为Word32Equal节点是比较类型位置。由于后续访问是一条cmp指令，v8不需要在注册表中存储比较的结果，而是假设后续访问(即if(b)语句)可以再次直接访问数组<strong class="jp ir"> a </strong>的内存，最终生成包含更少指令序列的优化代码。</p><p id="9c0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是在注册表分配之前发生的情况:</p><p id="302a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">修复前:</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lr"><img src="../Images/7162aabf7405c7599033f99ec4c02d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HnASuzucfVKH8GyyNA6UA.png"/></div></div></figure><p id="ac7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">修复前生成的相关指令:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="62c0" class="kv kw iq kr b gy kx ky l kz la">· ba xorl r9,r9</span><span id="9e1f" class="kv kw iq kr b gy ls ky l kz la">· bd cmpw [r8],0x0 <em class="lb"># X64cmp16 generates cmpw instructions on x64 platforms</em></span><span id="4f36" class="kv kw iq kr b gy ls ky l kz la">· c2 setnzl r9l <em class="lb">#set flag</em></span></pre><p id="0da5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">修复后:</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lr"><img src="../Images/ffdccea108899f8a98c98161c7b665fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_IUDhTzFIrWZzJ8mDzGTg.png"/></div></div></figure><p id="24be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">修复后生成的相关说明:</p><p id="84c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生成25行指令序列:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="cc90" class="kv kw iq kr b gy kx ky l kz la">· ba cmpw [r8],0x0 # <em class="lb">X64cmp16 generates cmpw instructions on x64 platform</em></span><span id="bb90" class="kv kw iq kr b gy ls ky l kz la">· bf setzl r8l <em class="lb">#set flag</em></span><span id="3289" class="kv kw iq kr b gy ls ky l kz la">· c3 movzxbl r8,r8 <em class="lb"># the result of the comparison stored in r8</em></span></pre><p id="0cd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生成26行指令序列:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="a16f" class="kv kw iq kr b gy kx ky l kz la">· c7 xorl r9,r9</span><span id="f335" class="kv kw iq kr b gy ls ky l kz la">· ca cmpl r8,0x0 <em class="lb"># x64cmp32 generates cmpl</em></span><span id="8d6c" class="kv kw iq kr b gy ls ky l kz la">· ce setzl r9l <em class="lb">#set flag</em></span></pre><p id="b2aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对比fix前后的2组指令，条件指令的区别是相反的像so <em class="lb"> setnzl VS setzl </em>因为fix之前的代码执行了函数VisitWordCompareZero中的cont-&gt;overwritednegateifeequal(ke qual)。</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lr"><img src="../Images/1dcedcbee81287c7d252e4336c02f664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*646TkAjBeHcGjKFu0-zQYQ.png"/></div></div></figure><p id="507d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面显示了漏洞修复后的涡扇装配指令(注意，生成的代码指令序列比修复前长):</p><figure class="km kn ko kp gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lc"><img src="../Images/555570290bcff2530d87eb67c8fd165a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRVwZW_urT95u56JOmOUfA.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">图5:漏洞修补后的涡扇发动机装配说明</figcaption></figure><p id="680c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在图5中，我们可以看到，比较结果首先放在堆栈[rbp-0x28]中，然后[rbp-0x28]与0进行比较，在这种情况下，它不会访问gc中的内存，因此不会出现UAF问题。</p><h1 id="db78" class="lt kw iq bd lp lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">开发理念</h1><p id="5d79" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">此漏洞可以使用堆喷涂技术进一步利用，然后导致“类型混淆”漏洞。该漏洞允许攻击者控制函数指针或将代码写入内存中的任意位置，并最终导致代码执行。</p><h1 id="a3ee" class="lt kw iq bd lp lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">关于作者</h1><p id="e255" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">王伟波(诺兰)是一名安全研究员，目前在新加坡网络安全公司<a class="ae kl" href="https://numencyber.com/" rel="noopener ugc nofollow" target="_blank"> Numen网络技术</a>工作。他在著名的区块链项目中发现了许多关键漏洞，如ETH、EOS、Ripple、TRON以及苹果、微软、谷歌等公司的热门产品</p></div></div>    
</body>
</html>