<html>
<head>
<title>Healing blind injections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">治愈盲目注射</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/healing-blind-injections-df30b9e0e06f?source=collection_archive---------1-----------------------#2022-02-21">https://infosecwriteups.com/healing-blind-injections-df30b9e0e06f?source=collection_archive---------1-----------------------#2022-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ab50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我告诉您有一种方法可以治愈盲目的SQL注入，并将它们转变为健康的基于联合的注入，会怎么样？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/dfdef988bda94827c1da8708de92a7d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*npCGO_8SZ0DfQWY-ev6JVQ.jpeg"/></div></div></figure><p id="2fa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当易受攻击的查询返回数据时，您是否遇到过盲目的SQL注入？</p><p id="4a5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kx">……再读一遍问题……</em></p><p id="2fee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你明白了吗？<br/>我来给你介绍一下<strong class="jp ir">隐藏工会的SQL注入</strong>。<br/>想象一下这个场景，在一个web应用程序上有一个搜索功能，URL是这样的:<code class="fe ky kz la lb b">http://sub.domain.tld/search?query=abcd</code> <strong class="jp ir"> <br/> </strong>通过访问这个URL，您将看到所有名称中带有字母<code class="fe ky kz la lb b">abcd</code>的产品。<br/>经过一点测试，你意识到<code class="fe ky kz la lb b">query</code>这个参数容易受到SQL注入的攻击。<br/>你给<code class="fe ky kz la lb b">SQLMap</code>一个URL，它确认了SQLi，但是一个盲注入… <br/>现在让我再问你一个关键问题，易受攻击的查询<em class="kx">返回数据</em>但是注入是盲注入，这怎么可能呢？？？</p><p id="32f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kx">…在你继续之前考虑几分钟……</em></p><p id="8b62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第一部分:场景</strong> <br/>好了，我们来分解一下。<br/>根据我的经验，有四种可能的情况:<br/>(易受攻击的查询以<strong class="jp ir">粗体</strong>显示)</p><p id="2640" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">场景1: </strong>易受攻击的查询是父查询的子查询，父查询负责返回数据。</p><pre class="km kn ko kp gt lc lb ld le aw lf bi"><span id="5200" class="lg lh iq lb b gy li lj l lk ll">SELECT <br/>  * <br/>FROM <br/>  customers <br/>WHERE <br/>  id IN (<br/>    <strong class="lb ir">SELECT <br/>      DISTINCT customer_id <br/>    FROM <br/>      orders <br/>    WHERE <br/>      cost &gt; 200</strong><br/>  );</span><span id="b93f" class="lg lh iq lb b gy lm lj l lk ll">//source https://careerkarma.com/blog/sql-subquery/</span></pre><p id="e59d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题:</strong>向易受攻击的查询添加联合有效负载不会影响返回的数据，因为您修改的是<code class="fe ky kz la lb b">WHERE</code>部分，而不是返回数据的实际查询。<br/> <strong class="jp ir">解决方案:</strong>您需要知道正在执行的实际查询，以便相应地调整您的有效负载，这意味着正确地结束括号和/或在需要时添加正确的关键字。</p><p id="bb7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">场景二。易受攻击的查询是一个大而复杂的查询，可能包含别名或变量声明。</strong></p><pre class="km kn ko kp gt lc lb ld le aw lf bi"><span id="fd22" class="lg lh iq lb b gy li lj l lk ll">SELECT <br/>  s1.user_id, <br/>  (<br/>    CASE WHEN s2.user_id IS NOT NULL AND s2.sub_type = '<strong class="lb ir">INJECTION</strong>' THEN 1 ELSE 0 END<br/>  ) AS overlap <br/>FROM <br/>  subscriptions AS s1 <br/>  LEFT JOIN subscriptions AS s2 ON s1.user_id != s2.user_id <br/>  AND s1.start_date &lt;= s2.end_date <br/>  AND s1.end_date &gt;= s2.start_date <br/>GROUP BY <br/>  s1.user_id</span><span id="6338" class="lg lh iq lb b gy lm lj l lk ll">//source https://codingsight.com/how-to-write-complex-sql-queries/</span></pre><p id="4beb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题:</strong>在这个场景中，当您在注入的有效负载之后注释原始查询的剩余部分时，您破坏了原始查询的开始部分，因为一些别名变成了<code class="fe ky kz la lb b">undefined</code>。<br/> <strong class="jp ir">解决方案:</strong>要解决这个问题，我们需要知道原始查询，在我们的有效载荷的开头放置适当的括号、关键字和别名，以便原始查询的第一部分保持有效。</p><p id="74ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">场景三。</strong>易受攻击的查询的结果正在第二个查询中使用，并且第二个查询返回数据。</p><pre class="km kn ko kp gt lc lb ld le aw lf bi"><span id="2aac" class="lg lh iq lb b gy li lj l lk ll">&lt;?php</span><span id="69e2" class="lg lh iq lb b gy lm lj l lk ll">// retrieve product ID based on product name<br/>$query1 = "<strong class="lb ir">SELECT <br/>             id <br/>           FROM <br/>             products <br/>           WHERE <br/>             name = '$name'</strong>";</span><span id="064c" class="lg lh iq lb b gy lm lj l lk ll">$result1 = odbc_exec($conn, $query1);</span><span id="4741" class="lg lh iq lb b gy lm lj l lk ll">// retrieve product's comments based on product ID<br/>$query2 = "<strong class="lb ir">SELECT <br/>             comments <br/>           FROM <br/>             products <br/>           WHERE <br/>             id = '$result1'</strong>";</span><span id="8362" class="lg lh iq lb b gy lm lj l lk ll">$result1 = odbc_exec($conn, $query2);</span><span id="5e62" class="lg lh iq lb b gy lm lj l lk ll">?&gt;</span><span id="1ebd" class="lg lh iq lb b gy lm lj l lk ll">//source https://www.php.net/manual/en/security.database.sql-injection.php</span></pre><p id="5173" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题:</strong>您可以向第一个查询添加一个联合有效负载，但是它不会影响返回的数据，因为第一个查询不负责返回数据，而第二个查询负责。<br/> <strong class="jp ir">解决方案:</strong>将这些盲注入转变为基于联合的注入是有条件的，第二个查询也需要是易受攻击的，并且它的输入没有得到净化。如果是这样，您需要使第一个查询不返回数据，接下来，追加一个联合查询，返回您想要在第二个查询中<em class="kx">注入的有效负载。复杂？举个例子怎么样:<br/>有效负载(我们注入到第一个查询中的内容):</em></p><pre class="km kn ko kp gt lc lb ld le aw lf bi"><span id="a02a" class="lg lh iq lb b gy li lj l lk ll">' AND 1 = 2 UNION SELECT "<em class="kx">injection</em>" -- -</span></pre><p id="c83c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kx">注入</em>的值是我们想要在<em class="kx">第二个查询</em>中注入的值:</p><pre class="km kn ko kp gt lc lb ld le aw lf bi"><span id="f87c" class="lg lh iq lb b gy li lj l lk ll">' AND 1=2 UNION SELECT ...</span></pre><p id="7ce4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终有效负载(在插入第二个查询的<em class="kx">注入</em>值之后):</p><pre class="km kn ko kp gt lc lb ld le aw lf bi"><span id="015b" class="lg lh iq lb b gy li lj l lk ll">' AND 1 = 2 UNION SELECT "<strong class="lb ir"><em class="kx">' AND 1=2 UNION SELECT ...</em></strong>" -- -<br/>                          \________________________/<br/>                                      ||<br/>                                      \/<br/>                               the payload that<br/>                                get's injected<br/>                             into the second query<br/>\________________________________________________________/<br/>                            ||<br/>                            \/<br/> the actual query we inject into the vulnerable parameter</span></pre><p id="928b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注入后的第一个查询:</p><pre class="km kn ko kp gt lc lb ld le aw lf bi"><span id="68e8" class="lg lh iq lb b gy li lj l lk ll">SELECT               --\<br/>  id                   |<br/>FROM                   |----&gt; first query<br/>  products             |<br/>WHERE                  |<br/>  name = 'abcd<strong class="lb ir">'</strong> <strong class="lb ir">     </strong>--/<strong class="lb ir"><br/>  AND 1 = 2                               </strong>--\<strong class="lb ir"><br/>UNION                                       </strong>|----&gt; injected payload<strong class="lb ir"><br/>SELECT                                     </strong> |<strong class="lb ir"><br/>  "<em class="kx">' AND 1=2 UNION SELECT ... -- -</em>" -- -</strong>' --/</span></pre><p id="6616" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注入后的第二个查询:</p><pre class="km kn ko kp gt lc lb ld le aw lf bi"><span id="7226" class="lg lh iq lb b gy li lj l lk ll">SELECT            --\<br/>  comments          |<br/>FROM                |----&gt; second query<br/>  products          |<br/>WHERE               |<br/>  id = '<strong class="lb ir">'         </strong>--/<strong class="lb ir"><br/>  AND 1 = 2       </strong>--\<strong class="lb ir"> <br/>UNION               </strong>|----&gt; injected payload<strong class="lb ir"><br/>SELECT ... -- -</strong>'  --/</span></pre><p id="f5a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很酷，不是吗？😎😎</p><p id="bf26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">场景4。易受攻击的参数正在几个独立的查询中使用。</p><pre class="km kn ko kp gt lc lb ld le aw lf bi"><span id="045f" class="lg lh iq lb b gy li lj l lk ll">&lt;?php</span><span id="fa39" class="lg lh iq lb b gy lm lj l lk ll">//retriveing product details based on product ID<br/>$query1 = "<strong class="lb ir">SELECT <br/>             name, <br/>             inserted, <br/>             size <br/>           FROM <br/>             products <br/>           WHERE <br/>             id = '$id'</strong>";</span><span id="bf4a" class="lg lh iq lb b gy lm lj l lk ll">$result1 = odbc_exec($conn, $query1);</span><span id="5fdd" class="lg lh iq lb b gy lm lj l lk ll">//retriveing product's comments based on product ID, independently<br/>$query2 = "<strong class="lb ir">SELECT <br/>             comments <br/>           FROM <br/>             products <br/>           WHERE <br/>             id = '$id'</strong>";</span><span id="32e0" class="lg lh iq lb b gy lm lj l lk ll">$result2 = odbc_exec($conn, $query2);</span><span id="2b51" class="lg lh iq lb b gy lm lj l lk ll">?&gt;</span><span id="574a" class="lg lh iq lb b gy lm lj l lk ll">//source https://www.php.net/manual/en/security.database.sql-injection.php</span></pre><p id="3250" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题:</strong>虽然您可以在其中一个查询中附加一个联合查询并保持有效，但它可能会破坏另一个查询，服务器会返回500错误，而不是您想要的数据。<br/> <strong class="jp ir">解决方法:</strong>这确实要看情况，但第一步还是一如既往的了解原查询。通常，在第一步，这些类型的注入只是基于时间的，因为延迟有效负载被插入到多个查询中，并且您的延迟时间被乘以一个数字。<br/>这个事实在提取数据时混淆了<code class="fe ky kz la lb b">SQLMap</code>,打乱了输出。这意味着<code class="fe ky kz la lb b">SQLMap</code>错误地识别了查询输出的字符。在一次测试中，我执行了十次查询，手动地构建了正确的输出。我比较了不同的输出，确定了重复的字符(很可能是正确的)，并猜测了其中的一些。</p><p id="2dc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> PRO TIP </strong> <br/>这些<em class="kx">隐藏的基于联合的注入</em>之一存在的标志是:<br/>当你可以使用<code class="fe ky kz la lb b">ORDER BY</code>技术来确认漏洞时，却以一个布尔或基于时间的结束。<br/>那就当<code class="fe ky kz la lb b">SQLMap</code>说:<br/> <code class="fe ky kz la lb b">'ORDER BY' technique appeares to be usable.</code> <br/> <code class="fe ky kz la lb b">vulnerable query seems to have N columns.</code> <br/>但是到最后就糊涂了，报了个瞎注:)</p><p id="8a9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以…明白了吗？<br/>现在您可能已经意识到，要将基于布尔或基于时间的注入转换为基于联合的注入(当然，如果查询返回数据的话)，我们需要知道正在后端执行的查询。<br/>这就是为什么当我遇到盲注的时候，<br/>我做的第一件事就是提取正在执行的查询，而不是像新手一样转储<code class="fe ky kz la lb b">users</code>表。😒</p><p id="33fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是怎么做呢？<br/>几乎所有广泛使用的DBMSes都有一个默认的表，其中存储着当前正在执行的查询。要找到该表，您需要阅读目标DBMS的文档。</p><p id="af27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> PRO提示</strong><br/><code class="fe ky kz la lb b">SQLMap</code>的<code class="fe ky kz la lb b">--statement</code>标志会自动为您完成这项工作，独立于后端DBMS。</p><p id="aa39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我仍然鼓励你阅读文档，因为在某些情况下你需要手动完成，而<code class="fe ky kz la lb b">SQLMap</code>帮不上忙。</p><p id="51cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二部分:自动化<br/> </strong>如何使用<code class="fe ky kz la lb b">SQLMap</code>实现这些注射的自动化？</p><p id="f0f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述所有场景中的普遍问题是，我们需要安全地关闭原始查询，然后向其追加一个联合查询，这是<code class="fe ky kz la lb b">SQLMap</code>无法自动完成的。<br/>所以我们需要手动执行，我们首先将用于关闭原始查询的合适负载添加到易受攻击参数的值中，然后使用星号(<strong class="jp ir"> * </strong>)告诉<code class="fe ky kz la lb b">SQLMap</code>从哪里开始注入。这种方式<code class="fe ky kz la lb b">SQLMap</code>将利用正常的基于联合的注入。让我给你举个例子:</p><p id="7722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑第三种情况。<br/>我们假设DMBS是<code class="fe ky kz la lb b">mysql</code>，第一个和第二个查询只返回一列。如果我们想要提取数据库的版本，这将是我们的有效负载:</p><pre class="km kn ko kp gt lc lb ld le aw lf bi"><span id="b419" class="lg lh iq lb b gy li lj l lk ll">' AND 1=2 UNION SELECT " <strong class="lb ir">' AND 1=2 UNION SELECT @@version -- -</strong>" -- -</span></pre><p id="9b71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以URL应该是这样的:</p><pre class="km kn ko kp gt lc lb ld le aw lf bi"><span id="dd66" class="lg lh iq lb b gy li lj l lk ll">http://sub.domain.tld/search?query=abcd<!-- -->'+AND+1=2+UNION+SELECT+"+<strong class="lb ir">'AND 1=2+UNION+SELECT+@@version</strong>+--+-"+--+-</span></pre><p id="a512" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于自动化，这将是<code class="fe ky kz la lb b">SQLMap</code>的输入:</p><pre class="km kn ko kp gt lc lb ld le aw lf bi"><span id="b763" class="lg lh iq lb b gy li lj l lk ll">http://sub.domain.tld/search?query=abcd<!-- -->'AND 1=2 UNION SELECT "<strong class="lb ir">*</strong>"-- -</span></pre><p id="4cb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意标记<code class="fe ky kz la lb b">SQLMap</code>注入点的星号</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="c3c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有帮助吗？ <br/>我不要求你给我买杯咖啡，<br/>教我点什么… <br/>不和:<code class="fe ky kz la lb b"><strong class="jp ir">REDN#9702</strong></code></p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="d4fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Infosec Writeups团队刚刚完成了我们的第一次虚拟网络安全会议和网络活动。我们有16位出色的演讲者，他们主持了非常有价值和鼓舞人心的会议。要查看演讲者和主题列表，请点击此处。</p><div class="lv lw gp gr lx ly"><a href="https://iwcon.live/" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd ir gy z fp md fr fs me fu fw ip bi translated">IWCon2022 — Infosec书面报告虚拟会议</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">与世界上最优秀的信息安全专家建立联系。了解网络安全专家如何取得成功。将新技能添加到您的…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">iwcon.live</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm kv ly"/></div></div></a></div></div></div>    
</body>
</html>