<html>
<head>
<title>Towards Shorter Encryption Keys</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">走向更短的加密密钥</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/towards-shorter-encryption-keys-91fe276aeea2?source=collection_archive---------2-----------------------#2021-05-12">https://infosecwriteups.com/towards-shorter-encryption-keys-91fe276aeea2?source=collection_archive---------2-----------------------#2021-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6f33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">本文深入探讨了椭圆曲线加密的技术细节。</em></p><p id="7fd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">公钥和私钥密码术是七十年代后期的新发明，我们富有创造力的前辈们并没有想到。相反，他们依赖对称加密方案，要求双方都知道加密密钥。</p><p id="56ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最早的此类计划是Scytale，一种由希腊诗人Archilochus在公元前7世纪首次提及的装置。在这个方案中，秘密就在棍子的宽度上，一条加密的文本卷在棍子上。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/7135fece52a3eb6bdb47971770adfdc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*_-Z5O4Vt10ylTzib-s8GIw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Scytale(图片来自维基百科)</figcaption></figure><p id="306e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从那以后，在加密的复杂性方面有了一系列的创新，最终出现了加密方案，如德国人在二战中使用的Enigma。</p><p id="6f37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，对称加密方案需要由不应被拦截的人类信使物理地发送加密密钥。这种情况在70年代末发生了变化，当时几个研究人员开始研究被称为公钥密码学的东西。特别是在1978年，三位计算机科学家Rivest、Shamir和Adelman (RSA)宣布了一项发明，允许将加密密钥分成公共和私有部分。公共部分用于加密，私有部分用于解密。</p><p id="379f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创新之处在于，即使有人设法看了一眼公钥，也无法帮助他解密秘密信息。这个想法是，我会告诉我所有的朋友我的公钥，如果他们想给我发送一个机密消息，那么他们会用这个密钥来加密文本。</p><p id="0e32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看，双公钥-私钥思想似乎是私有通信的理想解决方案。但是，还存在一个如何沟通密钥的问题。</p><p id="f846" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RSA方案设计的公钥是长数字。它们可以由数字和字母的组合在一个稍短的空间中表示，但即使这样，它们仍然太长了。相比之下，信用卡号有16位，读起来已经够长的了。相比之下，RSA公钥至少要长十倍。</p><p id="362b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个保存在我的MacBook上的<code class="fe kz la lb lc b">.ssh/id_rsa.pub</code>文件中的公钥的例子:</p><pre class="kn ko kp kq gt ld lc le lf aw lg bi"><span id="a909" class="lh li iq lc b gy lj lk l ll lm">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDZdYqaK6msN2pRrr1tMioVqnqSI5P4+o+74Db2eLTenaeCXm/TJERgYBWV1c0EU8cGVfvH/tRBoJWVuPXs6ml1WnDvcgWpCrR+BZ7mga7as8t0U+264YsQe9NpdnFjpTW9RmyY+RDCAPkF7qtzdGyCQY0PmsRESsJ9tp1amrEL6vyhZvdZr/wOXpPzgQ00/9heZESuFlC4lLFsEBkPhBPdalYL2vjdEbunYjFqFlp4yuyBAV8BIfP+YTjPhyEXu03Ue0sDI/FD4ayx92Kozt7XtAI7W54iG7ycW0jiihOLag9vRCLXOSFCF1cDfHW74xdcwws8lxnJ2B2zoiCAOISH</span></pre><p id="f524" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于您无法读取公钥，也无法键入公钥，因此必须通过USB key或电子邮件、即时消息或Dropbox等电子通信方式进行物理传输。另一种方法是在你的网站、推特或脸书上发布。(这是Keybase.io采用的方法。)</p><p id="9c72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管这些是潜在的解决方案，但是仍然有一个必须被委托来传递公钥的快递员。现在快递员不是人了。“他”在互联网服务器、网站或电子邮件网关中。但是因为快递员站在你和你所有朋友之间，所以快递员处于对你进行“中间人”攻击的位置。他通过向你所有的朋友发送他自己的公钥来冒充你。</p><p id="d358" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要一种创新来允许更短的键，以便更容易传达它们。这种创新以椭圆曲线加密(ECC)方案的形式出现，该方案提供了与RSA相当的保密级别，但密钥要短得多。这是因为它不依赖于秘密的素数，而是依赖于秘密的合数。</p><p id="7167" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于质数相对较少，RSA需要非常大的质数，因此无法猜测。(最近，一名研究人员能够证明许多RSA公钥实际上是基于相同的素数，并基于此能够破解加密。)</p><p id="bcd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与交替排列在大圆上的数字的RSA不同，ECC方案交替排列在具有(x，y)表面坐标的三维圆环或圆环上的点，服从某个等式。</p><p id="1986" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，键不再是一个长数字，而是一个具有整数坐标的点(x，y)。这些坐标满足“y = x + ax + b”形式的椭圆曲线方程。请注意，所有运算都是以“mod p”计算的。</p><p id="6813" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(工作“mod p”是指如果一个数大于p，那么你可以用它除以p，用余数代替原来的数。可以证明，在这种情况下，只要p是一个素数，所有重要的代数性质都保持不变。)</p><p id="7149" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个键的长度是表示这些(x，y)坐标所需的空间。由于该方案将与参数“a”、“b”和“p”的不同选择一起工作，所以已经设计了几个标准化的参数集。名为“P-256”的已知参数集如下。系数“a”是负3的数。数字“b”是一个长整数:</p><pre class="kn ko kp kq gt ld lc le lf aw lg bi"><span id="b114" class="lh li iq lc b gy lj lk l ll lm">41058363725152142129326129780047268409114441015993725554835256314039467401291</span></pre><p id="44c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模数“p”必须是一个质数，它是一个很长的数，可以用公式2 ⁵⁶ - 2 ⁴ - 2 ⁹ - 2⁹⁶ - 1来计算。它的计算值是:</p><pre class="kn ko kp kq gt ld lc le lf aw lg bi"><span id="eaf8" class="lh li iq lc b gy lj lk l ll lm">115792089210356248762697446949407573530086143415290314195533631308867097853951</span></pre><p id="8c90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那个质数有一个特殊的性质，那就是它后面的数能被4整除。换句话说，(p+1)/4是一个整数。这个事实的重要性很快就会变得明显。(注意，因为所有的质数都是奇数，所以结果数应该是偶数，并且可以被2整除，但不一定是4)。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="1c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们继续估计公钥长度的项目。在“P-256”椭圆曲线方案中，所有坐标可以仅用32字节的空间来表示。因为每个字节可以有256个值，但是英语只有不到256个字母，所以我们需要用32个以上的字符来表示它。Base64 URL编码允许用一个字符表示64种可能性。(注意base64 <em class="kl"> URL </em>编码与base64编码不同。)</p><p id="d644" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Base64 URL字符编码，32字节的密钥可以表示为43个字符。可以导出公钥的JSON Web Key (JWK)标准就是这样做的:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/53a8616f13553467bc44f7a9c924f148.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*ZfnIzt3L8hs6Z-ztNOO-lg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">P-256椭圆曲线中的密钥(x，y ), base64-URL编码</figcaption></figure><p id="0116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为每个坐标表示为43个字符，所以完整的(x，y)坐标需要86个字符。尽管这是对RSA的一个巨大改进，但还是有可能将所需空间减半。这个技巧涉及到一个数学计算。理论上，知道其中一个坐标就可以计算出另一个坐标，因为两者都满足椭圆曲线方程y =x -3x+b。</p><p id="246b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了快速计算，我们计算出给定的<em class="kl"> x </em>的<em class="kl"> y </em>，而不是反过来。然而，将一个已知的<em class="kl"> x </em>的值代入等式计算出的是<em class="kl"> y </em>的值，而不是我们需要的<em class="kl"> y </em>。那么，我们如何得到<em class="kl"> y </em>的“平方根”？这并不简单，因为，记住，所有的计算都是“mod p”完成的。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="1b70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们花一点时间了解一下模运算的数学。模运算涉及排列在一个圆上的整数。在其中工作会让你觉得自己置身于一个怪异的世界。</p><p id="2006" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为说明，我们以一个有11个位置的圆为例，它对应于“mod 11”计算。(想象一个只有11个小时的落地钟，而不是12个小时)。</p><p id="a7fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3模11的平方根是5和6。这仅仅意味着，如果你从位置1开始，绕圆走25步，你将在位置3结束。如果你绕着圆圈走36步，也会发生同样的情况。</p><p id="90d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是“mod 11”设置中的所有“平方”数字:</p><pre class="kn ko kp kq gt ld lc le lf aw lg bi"><span id="2f85" class="lh li iq lc b gy lj lk l ll lm">p = 11   <br/>for (var i=0; i&lt;p; i++) {  <br/>  console.log(i+"x"+i, i*i % p) <br/>}</span><span id="136f" class="lh li iq lc b gy lv lk l ll lm">0x0 0<br/>1x1 1<br/>2x2 4<br/>3x3 9<br/>4x4 5<br/>5x5 3<br/>6x6 3<br/>7x7 5<br/>8x8 9<br/>9x9 4<br/>10x10 1</span></pre><p id="35cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，回到你的“mod p”计算，我们需要一个策略来从y计算y，这涉及到理解循环行为。幸运的是，一些伟大的头脑已经在这方面工作了，我们可以免费使用结果。</p><p id="891f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了方便计算y的平方根，我们使用大数学家欧拉的一个定理。这个定理被称为欧拉判据，它指出一个值的幂(p-1)/2等于1或-1 mod p。每当我们在数学中有一个公式可以将一些量减少到一个单位，我们就试图将我们拥有的任何量分成可以应用该公式的部分。</p><p id="62fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们利用我们选择的素数也满足(p+1)/4是整数这一事实。让我们来看看当你把<em class="kl"> y </em>提升到(p+1)/4次方时会发生什么。总功率变为2 (p+1)/4，简化为(p+1)/2。此外，该表达式可以用(p-1)来表示，如下所示:1 + (p-1)/2。结合欧拉判据，我们得到y，我们正在寻找的平方根。</p><p id="eadf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，求模平方根的方法是，在mod p算法中，简单地将数字提升到(p+1)/4的幂。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="5389" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据我提出的欧拉判据，上述计算将给出<em class="kl"> -y </em>的第二个解。这并不完全准确，因为我没有提到的部分是，对于具有平方根mod p的值——这种数字在模运算中被称为<em class="kl">二次剩余</em>，对应于常规非模运算中的平方数——准则公式保证给出值1，而不是-1。</p><p id="8468" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，我们在这里解一个二次方程，因式分解y确实有两个解，一个是正的，一个是负的。换句话说:-y * -y = y和y * y = y .因此，只给定x坐标和一个缺失的y坐标，我们无法确定我们缺失的是哪个y坐标。</p><p id="94c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，在模运算中，每个负数都可以表示为等价的正数。比如-5 mod 11和6 mod 11一样。(这就是为什么在前面的“mod 11”示例中，我们观察到5和6都是3 mod 11的平方根。实际上，5和-5是3的平方根。)负数只是表示绕一圈向后走；同样的位置可以向前移动一步。</p><p id="180c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正数和负数之间的二元性看似复杂，实际上对我们有利。在计算中，我们更愿意只处理正整数。</p><p id="41e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从- <em class="kl"> y </em>到它的正等值需要加上<em class="kl"> p </em>，所以它变成(-y + p)。反过来写就是补码(p-y)。有趣的是，有效解中必须有一个是偶数，另一个是奇数。比如y是奇数，那么(p-y)一定是偶数，因为p是奇数。反之，如果y是偶数，那么(p-y)是奇数。</p><p id="6c0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果我们坚持将椭圆曲线方程的两个解都作为正数，符号的不同就转化为奇偶性的不同。奇偶校验可以编码为一个布尔位，并与需要32字节空间的“x”值打包在一起。</p><p id="91eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们使用的是字节，所以需要一个额外的字节。只有x坐标的整体公钥包得到了一个“压缩椭圆曲线坐标”的标准化名称。确切的格式是第一个字节可以存储值2或3，后面是32个字节的x坐标值。</p><p id="1e29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经理解了这个理论，让我们来看一些代码。给定“压缩”的x坐标，恢复y坐标的Javascript代码示例如下所示(来自<a class="ae ky" href="https://stackoverflow.com/questions/17171542/algorithm-for-elliptic-curve-point-compression" rel="noopener ugc nofollow" target="_blank">堆栈溢出post </a>的代码):</p><pre class="kn ko kp kq gt ld lc le lf aw lg bi"><span id="95d0" class="lh li iq lc b gy lj lk l ll lm">const <br/>  two = new bigInt(2),<br/>  prime = two.pow(256).sub( two.pow(224) )<br/>         .add( two.pow(192) ).add( two.pow(96) ).sub(1),<br/>  euler_exponent = prime.add(1).divide(4);</span><span id="36e6" class="lh li iq lc b gy lv lk l ll lm">function decompress_coordinate( package ){<br/>  const <br/>    y_parity = package[0] - 2, // first byte must be 2 or 3<br/>    x_bytes = package.subarray(1),<br/>    x = new bigInt( x );<br/>  <br/>  // y^2 = x^3 - 3x + b<br/>  var y = x.pow(3).sub( x.multiply(3) ).add( b )<br/>         .modPow( euler_exponent, prime );</span><span id="7801" class="lh li iq lc b gy lv lk l ll lm">  // If the parity doesn't match it's the *other* root<br/>  if( y.mod(2) !== y_parity ) {<br/>    y = prime.sub( y ); // y = prime - y<br/>  }</span><span id="2588" class="lh li iq lc b gy lv lk l ll lm">return {<br/>    x: x_bytes,<br/>    y: y.toUint8Array()<br/>  };<br/>}</span></pre></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="ae2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，为了传递公钥，我们必须只向另一个人发送一个base64-url编码的字符串，如下所示:</p><pre class="kn ko kp kq gt ld lc le lf aw lg bi"><span id="5038" class="lh li iq lc b gy lj lk l ll lm">even,LdK0I_FQu8S3CKKzR6TuSj_BMiXyYyheMlAOvzgdbiw</span></pre><p id="10b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它仍然很神秘，并且比信用卡号长得多，但是我们已经接近解决公钥通信问题了。从这里去哪里？</p><p id="adc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一种方法是将坐标编码为单词列表，而不是使用base64 URL编码。篇幅会更长，但不会隐晦。</p><p id="b00f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">32字节长坐标值的每个字节可以有256种可能性，因此密钥可以作为32个单词来传递，每个单词来自具有256个单词的字典(或单词列表)。</p><p id="0912" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用更大的字典，这将需要更少的T2单词。一对字节可以有65，536种可能性，这将需要一个相当大的字典，其中包含不常用的单词。你可以看看<a class="ae ky" href="https://www.eff.org/deeplinks/2016/07/new-wordlists-random-passphrases" rel="noopener ugc nofollow" target="_blank">电子前沿基金会</a> (EFF)公布的这样一个词典词表，里面有66666个单词。以下是其中的几个词:</p><pre class="kn ko kp kq gt ld lc le lf aw lg bi"><span id="a254" class="lh li iq lc b gy lj lk l ll lm">angrily<br/>angriness<br/>anguished<br/>angular<br/>animal<br/>animate<br/>animating<br/>animation<br/>animator<br/>anime<br/>animosity<br/>ankle<br/>annex<br/>annotate<br/>announcer<br/>annoying<br/>annually<br/>annuity<br/>anointer<br/>another<br/>answering</span></pre><p id="4ffa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到“愤怒”、“痛苦的”和“不安的”这些词对我们的目的来说不是那么好。他们很容易记错，单词“anointer”并不常见，容易拼错。</p><p id="9283" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用更小的单词列表，只包含常用单词，我们需要将密钥分成比16位更小的组。总共我们有32*8或256位。如果我们将256位分成每组10位的组，那么我们将只需要26个字，每个字列表具有2个⁰或1024个字。</p><p id="2a7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以做得更好，通过增加位数，直到我们达到一个现实大小的字典。每个字13位，我们需要一个有8192个字的字表，我们需要从中选择20个字。</p><p id="314a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">EFF网站提供了一个包含6666个单词的词典词表，这个词表太小了。我们可以混合较长列表中的一些单词，或者我们可以寻找现有的更大的字典单词列表。因此，轻松传递公钥的挑战是创建一个包含常用单词的单词列表。</p><p id="0d4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也意味着列表必须根据用户使用的语言进行定制。对一个不说英语的人来说，英语单词是很普通的单词。例如，说俄语的人应该只使用俄语单词。</p><p id="0a51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果两个人都是以俄语为母语的人，并且知道英语是第二语言，那么他们可以使用一个适当混合了俄语和英语单词的单词列表。</p><p id="b842" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的是，双语使用者的词汇量大约是两倍，因此，他们可以用更少的单词来交流公钥。例如，具有20，000个跨语言通用单词的单词列表将允许用19个单词而不是20个单词来表示公钥。</p><p id="3090" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Peerio公司有一个在线密码生成器，可以从大约11000个单词的列表中随机选择单词。这是它随机生成的20个单词的列表:“<em class="kl">胡子电影壮举切割机群集花束标记门阶擒获咬甲啃水肺无神论者wad跺脚冲浪者雪貂广泛抓捕。”</em>你能在电话上像输入信用卡号码一样简单地交流这样的列表吗？</p><p id="6944" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，只有在双方都同意使用基本单词列表(字典)的情况下，单词才能用于对公钥进行编码。要将单词转换回密钥，接收方必须用单词列表中的索引替换每个单词。</p><p id="96c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，我们已经看到，公钥可以是x坐标和y坐标的奇偶性，它们共同可以表示为单词或Base64 URL编码的字符串。此外，用于传达y坐标奇偶性的额外比特也可以被去除。大卫·伯恩斯坦发明的<a class="ae ky" href="https://en.wikipedia.org/wiki/Curve25519" rel="noopener ugc nofollow" target="_blank">曲线25519 </a>椭圆曲线密码系统完全由x坐标决定，因此不需要对y坐标的符号进行编码。</p><p id="11c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你能想到别的方法吗？这本书还没有结束这个话题。</p></div></div>    
</body>
</html>