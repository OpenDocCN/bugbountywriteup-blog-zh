<html>
<head>
<title>Learning Linux &amp; InfoSec Principles Using OverTheWire’s Bandit — Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OverTheWire的Bandit学习Linux和InfoSec原理—第4部分</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/learning-linux-infosec-principles-using-overthewires-bandit-part-4-a202c2e44843?source=collection_archive---------6-----------------------#2022-05-25">https://infosecwriteups.com/learning-linux-infosec-principles-using-overthewires-bandit-part-4-a202c2e44843?source=collection_archive---------6-----------------------#2022-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e208" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从一个有趣的在线“战争游戏”开始学习Linux</h2></div><p id="5848" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">简介</strong></p><p id="9abf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上一篇文章(<a class="ae lb" href="https://bit.ly/3PxHGfP" rel="noopener ugc nofollow" target="_blank">https://bit.ly/3qFZACp</a>)中，我们用OverTheWire的强盗机器的10到14级继续了我们的Linux之旅。如果你还没有阅读前三篇文章，强烈推荐它们——你会有更好的介绍。</p><p id="5e74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本质上，Bandit是OverTheWire.org网站提供的最基本的机器，旨在向人们介绍基本的Linux命令和信息安全思想。</p><p id="6ec5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文的目标是使用Bandit“wargame ”,为您提供一种实用而愉快的方式来了解Linux操作系统(尤其是<em class="lc"> bash </em> shell)。如果你已经阅读了之前的帖子，或者太热衷于继续这篇文章(我完全理解:)，那么让我们开始吧。</p><h2 id="f4e6" class="ld le iq bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated">催单</h2><p id="fc9b" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">从第13级到第14级的转换并不总是向适当的用户提供密码——我们必须有一个双SSH连接，只有这样我们才能为<em class="lc"> bandit14 </em>用户检索密码。</p><p id="435f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，通过SSH连接到这个用户并提供密码，这样我们就可以继续了。</p><p id="45e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mb mc md me b">ssh -p 2220 bandit14@bandit.labs.overthewire.org</code></p><h2 id="7856" class="ld le iq bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated">14级→15级</h2><p id="dd23" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">为了进入下一个级别，我们被指示将这个密码提交到本地主机上的端口30000。但是首先，<strong class="kh ir"> localhost </strong>是什么意思？这是对当前机器本身的引用，一般与127.0.0.1 IP地址捆绑，称为<strong class="kh ir">环回接口</strong>。</p><p id="d4ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现这一目标，我们将利用一个叫做<strong class="kh ir"> netcat </strong>的工具，它经常被戏称为“瑞士军刀”来进行联网。它允许我们访问某个目标(通过指定IP地址和端口)，并建立一个可以传递消息的连接。</p><p id="6b6b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将生成消息:使用<strong class="kh ir"> nano </strong>，我们将在<em class="lc"> /tmp/ </em>目录下创建一个文件，该文件用于存储临时文件(从其名称可以推断出)，并且我们对该文件具有写权限。</p><p id="678d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mb mc md me b">nano /tmp/passwd.txt</code></p><p id="1849" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，粘贴你用来进入这一关的密码，因为这是我们要传递的信息。另一种方法是:</p><p id="cd96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mb mc md me b">touch /tmp/passwd.txt</code></p><p id="04aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将创建一个新的空文件。为了填充它，我们可以使用<strong class="kh ir"> echo </strong>命令，并应用输出重定向，如前所述。</p><p id="8bea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mb mc md me b">echo 4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e &gt; /tmp/passwd.txt</code></p><p id="6b0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> echo </strong>命令只是简单地将一些内容打印到屏幕上，但是我们指示终端重定向输出——因此它不是出现在屏幕上，而是转到指定的文件。</p><p id="67fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们终于可以运行<strong class="kh ir"> netcat </strong>命令了，我们使用<strong class="kh ir"> nc </strong>快捷方式来运行它:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/83b669ecbc7c7461f822b2771b543938.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*Cuif0qhB3Y4IfPQ5Cx9ymw.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">使用<strong class="bd lf"> netcat </strong>将之前的密码提交给<strong class="bd lf"> localhost:30000 </strong></figcaption></figure><p id="f1aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在命令本身之后，我们键入主机(IP地址，或者是一个特殊的关键字<strong class="kh ir"> localhost </strong>)、目标端口，然后我们重定向输入:我们告诉命令从我们刚刚创建的文件中读取它的输入，而不是给我们一个控制台，所以现在它的内容将被发送到指定的目标。</p><p id="b65a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所观察到的，我们已经成功完成了这一关，并获得了下一关的密码。让我们连接到它！</p><h2 id="cf57" class="ld le iq bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated">15级→16级</h2><p id="e66f" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">这个阶段的任务与上一个非常相似，但是这一次我们需要对我们的连接进行SSL加密。这是一种加密协议，旨在保护互联网上的数据传输。这意味着，如果有人“嗅出”数据包，他将无法从中推断出任何东西，而不是直接使用<strong class="kh ir"> netcat </strong>。</p><p id="bf79" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，为了应用这种加密，我们不能再次使用<strong class="kh ir"> netcat </strong>，而是使用一种叫做<strong class="kh ir"> sslclient </strong>的工具，这一点令人惊讶。必要的命令是:</p><p id="32f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mb mc md me b">openssl s_client -connect localhost:30001</code></p><p id="3488" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们解释一下其余的部分:<em class="lc"> s_client </em>指定我们希望作为一个客户端启动一个SSL连接，而不是一个监听的服务器。然后，设置<em class="lc"> -connect </em>，之后是主机和端口，以便<strong class="kh ir"> sslclient </strong>知道要连接到什么。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/a3fd28ee413d05c6a2e838af020dc37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*Bmx-B0THenCkgP0qWgqSGQ.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">使用<strong class="bd lf"> sslclient </strong>连接到端口30001上的<strong class="bd lf"> localhost </strong></figcaption></figure><p id="004d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大量的信息向我们倾倒，但是在下面我们有一个提示。将密码粘贴到此级别:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/1e973919cf8e92709525094b2cfda56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*s_WuKesJpJIZFt9T7QOv6Q.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">让密码更上一层楼</figcaption></figure><p id="af8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以继续前进。</p><h2 id="f160" class="ld le iq bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated">16级→17级</h2><p id="a419" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">这个的说明一开始看起来有点让人不知所措。为了更清楚，让我们将它们分成实际任务:</p><ol class=""><li id="72b1" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated">在指定范围内搜索监听服务器。</li><li id="5313" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated">确定使用SSL的服务器。</li><li id="5acc" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated">向所有匹配的服务器发送必要的消息，保存由不简单重复我们的服务器检索的密码。</li></ol><p id="36fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">敬第一个任务！事情变得相当有趣…最好的解决方案是使用名为<strong class="kh ir"> nmap </strong>的工具，它是<em class="lc">网络映射器</em>的简写。它帮助我们扫描主机上的各种开放端口。我们也可以调整某些参数，使扫描精确地符合我们的需要。</p><p id="d221" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mb mc md me b">nmap localhost -p 31000–32000</code></p><p id="6f76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在命令本身之后，我们输入主机地址，在我们的例子中是<strong class="kh ir"> localhost </strong>。然后，使用<em class="lc"> -p </em>参数，我们指定一定范围的端口。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi mr"><img src="../Images/f9f1331baa8111cb58e8a69e754cc6ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*mcYm5MDGQzuiYGkqI-wyNQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">使用<strong class="bd lf"> nmap </strong>扫描<strong class="bd lf">本地主机</strong></figcaption></figure><p id="fc43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到一个端口列表，其中四个是开放的。我们进入第二步——检查哪些端口构成了使用SSL的服务器。同样，<strong class="kh ir"> nmap </strong>将是我们的度量——我们将只指定四个相关端口，但添加了<em class="lc">—</em>选项，代表主动，这样我们将获得关于这些开放端口背后的服务的更多信息。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nl"><img src="../Images/7c6a30ec9a07466f88944385fa42d911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_9gr4Grq1UyqQ67hXAhEQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">使用<strong class="bd lf"> -A </strong>参数和特定端口运行<strong class="bd lf"> nmap </strong></figcaption></figure><p id="2e94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以推断只有端口31790使用SSL，所以这一次它将是<strong class="kh ir"> openssl </strong>命令的目的地。</p><p id="5a84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mb mc md me b">openssl s_client -connect localhost:31790</code></p><p id="04ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这次输出的不是简单的密码，而是SSH的私钥。为了使用它，我们需要在<em class="lc"> /tmp </em>目录下创建一个文件，命名为<em class="lc">mysh key . private</em>，并使用您选择的任何文本编辑器粘贴密钥。确保您包括了密钥的“约束”——分别是开始/结束RSA私钥。此外，更改文件的权限，使其他用户无法访问该文件:</p><p id="25a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mb mc md me b">chmod 700 /tmp/mysshkey.private</code></p><p id="a7c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">别担心，我们以后会深入探讨权限。然后，正如我们在前一篇文章中所做的那样，我们将使用SSH进行身份验证。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/4ecaea9d3ba1cba5c54926d45b4ae134.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*n1DyGLVeW2CUUt4qe7Wd0w.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">移动到第17层</figcaption></figure><h2 id="dd67" class="ld le iq bd lf lg lh dn li lj lk dp ll ko lm ln lo ks lp lq lr kw ls lt lu lv bi translated">17级→18级</h2><p id="45bd" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">万岁！我们在这篇文章的最后一层。我们现在的目标不像以前那样涉及到<strong class="kh ir"> nmap </strong>或其他组网原则，而是找到我们目录中两个文件的区别:<em class="lc"> passwords.new </em>和<em class="lc"> passwords.old </em>。当前密码是第一个文件中与第二个文件中不同的那一行。</p><p id="96d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，我们可以手动检查这两个文件，但是我相信您已经猜到有一个更好的方法——一个Bash工具来自动化这个过程:<strong class="kh ir"> diff </strong>。它允许我们检查两个文件之间的差异。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nn"><img src="../Images/f9774fabc86a9ce20f34adfe6ea59eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*H3CpvfoM54WHdPsbLfbMYQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">使用<strong class="bd lf"> diff </strong>查找密码</figcaption></figure><p id="0e68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们给<strong class="kh ir"> diff </strong>提供了两个相关的文件作为命令行参数，输出告诉我们第42行有区别:上面一行是<em class="lc"> passwords.new </em>(第一个参数)中这一行的内容，下面一行是在<em class="lc"> passwords.old </em>(第二个参数)中找到的那一行。</p><p id="9074" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个密码将用于进入18级，现在不处理。</p><p id="f323" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了下一篇文章更容易访问(我已经进步了:)，所以你要听听我的建议；))，让我们保存17级的密码—记住，我们是使用私有SSH密钥输入的。要读取原始密码，请读取<em class="lc">/etc/bandit _ pass/bandit 17</em>文件的内容，并保留到下次使用。</p><h1 id="d2fc" class="no le iq bd lf np nq nr li ns nt nu ll jw nv jx lo jz nw ka lr kc nx kd lu ny bi translated">结论</h1><p id="9118" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">我们在本文中解决的几个层次向我们介绍了一个新概念:Linux中的网络工具。事情开始变得更加有趣，这是未来信息安全相关问题的温和尝试:与<strong class="kh ir"> nmap、netcat、openssl </strong> …</p><p id="77e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望通过这篇文章，您已经学习并提高了您的Linux技能。如前所述，我祈祷你也玩得开心！请留下一些评论，让我知道你更喜欢我做什么，或者希望我报道什么。</p><p id="f6a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我必须感谢你们每一个阅读我帖子的人——你们太棒了。现在再见。祝你玩得愉快，直到我们再次见面！</p></div></div>    
</body>
</html>