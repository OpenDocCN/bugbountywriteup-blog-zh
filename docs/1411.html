<html>
<head>
<title>Directory Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">目录遍历</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/directory-traversal-a09fa86a63bd?source=collection_archive---------3-----------------------#2021-06-18">https://infosecwriteups.com/directory-traversal-a09fa86a63bd?source=collection_archive---------3-----------------------#2021-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/86d06350ea97006c3b42df9c4f0b3c97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fpV2TWP-rU00mtD-OD0sTQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:互联网安全提示</figcaption></figure><h1 id="1d3b" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">什么是目录遍历？</strong></h1><p id="1c60" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">目录遍历或有人称之为“路径遍历”是一种web安全漏洞，如果被攻击者/黑客利用，可能会导致处理应用程序的服务器上任意文件的信息泄漏。</p><p id="2e20" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">泄露的信息可能包括应用程序代码数据、敏感信息，如凭据、用户名或操作系统相关文件。如果攻击是持续的，那么攻击者可以在应用程序中写入数据，这可能导致危害系统。</p><p id="1e7f" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">所以让我们先来看看这一切是如何开始的。考虑你选择的任何显示图像的网站，在后台加载这些图像，一些HTML代码正在运行，看起来像这样</p><blockquote class="md"><p id="4667" class="me mf iq bd mg mh mi mj mk ml mm lx dk translated"><code class="fe mn mo mp mq b"><em class="mr">&lt;img src="/image?filename=1.png"&gt;</em></code></p></blockquote><p id="9a59" class="pw-post-body-paragraph la lb iq lc b ld ms lf lg lh mt lj lk ll mu ln lo lp mv lr ls lt mw lv lw lx ij bi translated">这里发生的事情是,‘image’URL接受‘filename’参数并返回指定文件的内容。默认情况下，对于Linux系统，图像本身存储在“/var/www/html”位置。为了获得指定的“1.png”图像，应用程序将使用文件系统API将请求的文件名附加到基本目录中。所以对于上面指定的例子，文件路径应该是:</p><blockquote class="md"><p id="8c56" class="me mf iq bd mg mh mi mj mk ml mm lx dk translated">/var/www/html/1.png</p></blockquote><p id="0551" class="pw-post-body-paragraph la lb iq lc b ld ms lf lg lh mt lj lk ll mu ln lo lp mv lr ls lt mw lv lw lx ij bi translated">问题是上面指定的路径如何容易受到目录遍历的攻击，如果我们仔细观察，我们可以发现没有清理来检查用户给定的路径，因此恶意用户可以请求任意路径，例如</p><p id="2840" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><a class="ae mx" href="https://insecure-website.com/loadImage?filename=../../../etc/passwd" rel="noopener ugc nofollow" target="_blank">https://www.example.com/image?filename=../../../etc/passwd</a></p><p id="1d81" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">这将导致应用程序从/etc/passwd路径读取文件../'将从当前目录后退一步，它在文件系统路径中是有效的。在Linux系统中,/etc/passwd包含在系统中注册的用户的详细信息。基于windows的系统也可以进行相同的攻击(../还有..\)都允许，等效的文件可以在“\windows\win.ini”路径中找到。</p><h1 id="a079" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">可能的利用方式</strong></h1><p id="65f7" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">有各种各样的过滤器或净化技术用于规避目录遍历的威胁，但是它们实现中的漏洞使它们易受攻击。其中一些我们将在下一节讨论。</p><ol class=""><li id="f21b" class="my mz iq lc b ld ly lh lz ll na lp nb lt nc lx nd ne nf ng bi translated">如果应用程序直接将用户提供的文件名值传递给应用程序，那么就有可能绕过防御机制，我们可以直接传递值“/etc/passwd”(绝对路径)来遍历文件内容。</li><li id="6ad9" class="my mz iq lc b ld nh lh ni ll nj lp nk lt nl lx nd ne nf ng bi translated">如果有一种防御策略可以过滤掉序列字符，例如(’../')来阻止不需要的遍历，那么可以通过使用嵌套的遍历序列来简单地绕过它，比如(…。//….//….//etc/passwd)。当它在API中实现时，内部字符将被过滤掉，剩余的将绕过字符的过滤序列运行。</li><li id="72ec" class="my mz iq lc b ld nh lh ni ll nj lp nk lt nl lx nd ne nf ng bi translated">但是，如果应用程序有一个输入过滤机制，那么它将阻塞('../')字符和上述方式都行不通。但是，如果过滤机制不检查编码的字符，各种非标准编码也可以工作。例如，如果攻击者使用Unicode编码(..%c0%af或..%252f)，那么它将很容易绕过过滤器，因为这些编码字符的行为方式与../'.</li><li id="07c3" class="my mz iq lc b ld nh lh ni ll nj lp nk lt nl lx nd ne nf ng bi translated">许多应用程序都提供了防御功能，用户提供的文件名应该以预期的基本文件夹(例如./var/www/html)开头，这很容易被绕过，因为攻击者可以简单地将路径作为(filename=/var/www/html/../../../etc/passwd)。</li><li id="4f7f" class="my mz iq lc b ld nh lh ni ll nj lp nk lt nl lx nd ne nf ng bi translated">与上面定义的相反，如果应用程序希望文件名以预期的文件扩展名(例如。png“，”。jpeg”)。然后通过使用空字节，这变得非常容易，因为空字节将有效地终止文件路径，在扩展名为eg ( <code class="fe mn mo mp mq b">filename=../../../etc/passwd%00.png</code>)之前。</li></ol><h1 id="f4c9" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">预防方法</strong></h1><p id="d52a" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">最有效和最好的方法是避免将用户提供的输入值一起传递给API，这可以通过重写一些函数来更安全地传递值来实现。</p><p id="63b1" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">对于不可避免地传递这些值的情况，可以采取一些预防措施。</p><ol class=""><li id="c64f" class="my mz iq lc b ld ly lh lz ll na lp nb lt nc lx nd ne nf ng bi translated">首先，应用程序应该在处理之前验证用户输入，这可以通过简单地对照允许值的白名单进行检查来完成。</li><li id="38e5" class="my mz iq lc b ld nh lh ni ll nj lp nk lt nl lx nd ne nf ng bi translated">出于某种原因，如果验证无法执行，那么它应该验证输入只包含允许的内容。</li><li id="6245" class="my mz iq lc b ld nh lh ni ll nj lp nk lt nl lx nd ne nf ng bi translated">验证之后，应用程序应该将用户定义的值添加到基本目录中，然后使用文件系统API<a class="ae mx" href="https://en.wikipedia.org/wiki/Canonicalization#:~:text=In%20computer%20science%2C%20canonicalization%20(sometimes,normal%22%2C%20or%20canonical%20form." rel="noopener ugc nofollow" target="_blank">规范化</a>(标准化或规范化)路径。然后应该检查规范化路径是否与基目录相同。</li></ol></div></div>    
</body>
</html>