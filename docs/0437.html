<html>
<head>
<title>Breaking Down : SHA-256 Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解:SHA-256算法</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/breaking-down-sha-256-algorithm-2ce61d86f7a3?source=collection_archive---------0-----------------------#2019-11-27">https://infosecwriteups.com/breaking-down-sha-256-algorithm-2ce61d86f7a3?source=collection_archive---------0-----------------------#2019-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ce47137189868788dffa74763c8d8b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GmXb6otuzPxWpgViCCOG5g.png"/></div></div></figure><div class=""/><div class=""><h2 id="847a" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">看看引擎盖下面，了解它是如何工作的？</h2></div><p id="84a6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">好消息，朋友们，我写的关于<a class="ae lm" href="https://medium.com/bugbountywriteup/breaking-down-sha-1-algorithm-c152ed353de2" rel="noopener">崩溃:SHA-1算法</a>的文章已经发表在PenTest杂志的<a class="ae lm" href="https://pentestmag.com/breaking-down-sha-1-algorithm/" rel="noopener ugc nofollow" target="_blank">博客</a>上。看到你的工作得到认可和赞赏总是令人高兴的。我把我的文章免费提供给大家阅读，因为我相信“知识应该是免费的”这句格言。好吧，让我们不要纠缠于此，开始新的文章。</p><p id="aa4c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，你们中可能已经关注我一段时间的人一定知道，这个月我专门写了一些文章，这些文章纯粹专注于对最著名的哈希算法如何工作以及是什么使一种算法比另一种算法更复杂进行复杂的分析。到目前为止，我在这个系列中写的文章如下。</p><blockquote class="ln lo lp"><p id="9694" class="kq kr lq ks b kt ku kc kv kw kx kf ky lr la lb lc ls le lf lg lt li lj lk ll ij bi translated"><strong class="ks jc"> <em class="jb">分解:系列</em> </strong></p><p id="c62c" class="kq kr lq ks b kt ku kc kv kw kx kf ky lr la lb lc ls le lf lg lt li lj lk ll ij bi translated"><a class="ae lm" href="https://medium.com/bugbountywriteup/breaking-down-md5-algorithm-92803c485d25" rel="noopener"> 1。分解:MD5算法</a></p><p id="cd51" class="kq kr lq ks b kt ku kc kv kw kx kf ky lr la lb lc ls le lf lg lt li lj lk ll ij bi translated"><a class="ae lm" href="https://medium.com/bugbountywriteup/breaking-down-sha-1-algorithm-c152ed353de2" rel="noopener"> 2。分解:SHA-1算法</a></p><p id="f3a1" class="kq kr lq ks b kt ku kc kv kw kx kf ky lr la lb lc ls le lf lg lt li lj lk ll ij bi translated"><a class="ae lm" href="https://medium.com/@aditya12anand/breaking-down-sha-512-algorithm-1fdb9cc9413a" rel="noopener"> 3。分解:SHA-512算法</a></p></blockquote><p id="65bc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是系列的第四部分，在这里我将分解SHA-256算法。如果你已经知道了SHA-512算法，那么理解SHA-256算法将会非常容易，因为整个过程是相同的，只是比特长度有所不同。如果你愿意，你可以在这里看一下我详细解释SHA-512的文章。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/28bc47d5ae60030f66217981d26698d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*PSMjToG-xUgqVMkPYRY91A.png"/></div></figure><h1 id="56e6" class="lz ma jb bd mb mc md me mf mg mh mi mj kh mk ki ml kk mm kl mn kn mo ko mp mq bi translated">我们开始吧！</h1><p id="8a8e" class="pw-post-body-paragraph kq kr jb ks b kt mr kc kv kw ms kf ky kz mt lb lc ld mu lf lg lh mv lj lk ll ij bi translated">因此，让我们首先从分离和定义我们需要一个接一个执行的计算部分开始。为了便于理解，我个人更喜欢把它分成五个部分。</p><h2 id="61af" class="mw ma jb bd mb mx my dn mf mz na dp mj kz nb nc ml ld nd ne mn lh nf ng mp nh bi translated">1.追加:填充位</h2><p id="947b" class="pw-post-body-paragraph kq kr jb ks b kt mr kc kv kw ms kf ky kz mt lb lc ld mu lf lg lh mv lj lk ll ij bi translated">我们的散列函数的第一步从将比特附加到我们的原始消息开始，因此它的长度将与散列函数所需的标准长度相同。为了做到这一点，我们在现有的信息上增加几个比特。我们添加的位数是这样计算的，因此在添加这些位之后，消息的长度应该正好是64位，小于512的倍数。为了更好的理解，让我用数学术语描述给你听。</p><pre class="lv lw lx ly gt ni nj nk nl aw nm bi"><span id="8415" class="mw ma jb nj b gy nn no l np nq">M + P + 64 = n x 512</span><span id="c9e9" class="mw ma jb nj b gy nr no l np nq">i.e M = length of original message<br/>    P = padded bits</span></pre><p id="2628" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们附加到消息中的比特应该以“1”开始，随后的比特必须是“0 ”,直到我们正好比512的倍数少64比特。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/080612832c7d53cfcad6bb29a98b45bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S38mUnkiBpWNnr9lepWrCw.png"/></div></div></figure><h2 id="75d0" class="mw ma jb bd mb mx my dn mf mz na dp mj kz nb nc ml ld nd ne mn lh nf ng mp nh bi translated">2.追加:长度位</h2><p id="f41d" class="pw-post-body-paragraph kq kr jb ks b kt mr kc kv kw ms kf ky kz mt lb lc ld mu lf lg lh mv lj lk ll ij bi translated">既然我们已经将填充位附加到原始消息中，我们可以进一步将长度位(相当于64位)附加到整个消息中，使整个消息正好是512的倍数。</p><p id="175b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们知道我们需要增加64位，计算这64位的方法是计算原始消息的模，即没有填充的消息，用2。我们获得的消息将这些长度附加到填充的比特上，我们得到整个消息块，它必须是512的倍数。</p><h2 id="2f8b" class="mw ma jb bd mb mx my dn mf mz na dp mj kz nb nc ml ld nd ne mn lh nf ng mp nh bi translated">3.初始化缓冲区</h2><p id="c42e" class="pw-post-body-paragraph kq kr jb ks b kt mr kc kv kw ms kf ky kz mt lb lc ld mu lf lg lh mv lj lk ll ij bi translated">我们有我们的消息块，我们将在其上开始执行我们的计算，以找出最终的散列。在我们开始之前，我应该告诉你，我们需要为将要执行的步骤初始化某些默认值。</p><pre class="lv lw lx ly gt ni nj nk nl aw nm bi"><span id="3944" class="mw ma jb nj b gy nn no l np nq">a = 0x6a09e667<br/>b = 0xbb67ae85<br/>c = 0x3c6ef372<br/>d = 0xa54ff53a<br/>e = 0x510e527f<br/>f = 0x9b05688c<br/>g = 0x1f83d9ab<br/>h = 0x5be0cd19</span></pre><p id="ef58" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">暂时把这些价值观记在心里，下一步你就会明白所有的事情了。还有64个值需要记住，它们将作为键，用单词“k”表示。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/a54cf463702fbe785b97dfff7605cef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNXx6NbFolhTKx_C7awdeg.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">礼貌- SHA-2维基百科</figcaption></figure><p id="963d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在让我们进入利用这些值来计算散列的部分。</p><h2 id="24b6" class="mw ma jb bd mb mx my dn mf mz na dp mj kz nb nc ml ld nd ne mn lh nf ng mp nh bi translated">4.压缩功能</h2><p id="3c3e" class="pw-post-body-paragraph kq kr jb ks b kt mr kc kv kw ms kf ky kz mt lb lc ld mu lf lg lh mv lj lk ll ij bi translated">所以，哈希算法的主要部分就在于这一步。我们具有“n×512”位长的整个消息块被分成“n”个512位的块，然后这512位中的每一个经过64轮运算，并且所获得的输出被馈送作为下一轮运算的输入。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/e208d09b9f0d24ad8262c56895a92351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3_IjZJxmqspko_yobe_Hw.png"/></div></div></figure><p id="6e95" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上图中，我们可以清楚地看到对512位消息执行的64轮操作。我们可以观察到，我们发送的两个输入是W(i)和K(i)，对于前16轮，我们进一步将512位消息分解为16个部分，每个部分32位，但之后我们需要在每一步计算W(i)的值。</p><pre class="lv lw lx ly gt ni nj nk nl aw nm bi"><span id="55dc" class="mw ma jb nj b gy nn no l np nq"><strong class="nj jc">W(i) = Wⁱ⁻¹⁶ + σ⁰ + Wⁱ⁻⁷ + σ¹</strong></span><span id="c1af" class="mw ma jb nj b gy nr no l np nq"><strong class="nj jc">where, <br/> σ⁰ = </strong>(Wⁱ⁻¹⁵ ROTR⁷(x)) XOR (Wⁱ⁻¹⁵ ROTR¹⁸(x)) XOR (Wⁱ⁻¹⁵ SHR³(x))<strong class="nj jc"><br/> σ¹ = </strong>(Wⁱ⁻² ROTR¹⁷(x)) XOR (Wⁱ⁻² ROTR¹⁹(x)) XOR (Wⁱ⁻² SHR¹⁰(x))<br/> <strong class="nj jc">ROTRⁿ(x)</strong> = Circular right rotation of 'x' by 'n' bits<br/> <strong class="nj jc">SHRⁿ(x)</strong>  = Circular right shift of 'x' by 'n' bits</span></pre><p id="46ba" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在我们已经有了一个很好的方法来创建64轮中任何一轮的W(i ),让我们深入了解每一轮都发生了什么。</p><figure class="lv lw lx ly gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/ea6926fec07f9fd9569d0ebdd1d2bb9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5861gLUjsYIynJMUqAgbA.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">单个“回合”的描绘</figcaption></figure><p id="dd44" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上图中，我们可以确切地看到每一轮发生了什么，现在我们已经有了每个函数的值和公式，我们可以执行整个哈希过程。</p><pre class="lv lw lx ly gt ni nj nk nl aw nm bi"><span id="74ff" class="mw ma jb nj b gy nn no l np nq">Ch(E, F, G) = (E AND F) XOR ((NOT E) AND G)<br/>Ma(A, B, C) = (A AND B) XOR (A AND C) XOR (B AND C)<br/>    ∑(A)    = (A &gt;&gt;&gt; 2) XOR (A &gt;&gt;&gt; 13) XOR (A &gt;&gt;&gt; 22)<br/>    ∑(E)    = (E &gt;&gt;&gt; 6) XOR (E &gt;&gt;&gt; 11) XOR (E &gt;&gt;&gt; 25)<br/>     +      = addition modulo 2³²</span></pre><p id="3666" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些是在64轮中的每一轮中执行的功能，它们被重复执行“n”次</p><h1 id="29b1" class="lz ma jb bd mb mc md me mf mg mh mi mj kh mk ki ml kk mm kl mn kn mo ko mp mq bi translated">5.输出</h1><p id="3374" class="pw-post-body-paragraph kq kr jb ks b kt mr kc kv kw ms kf ky kz mt lb lc ld mu lf lg lh mv lj lk ll ij bi translated">每一轮的输出充当下一轮的输入，并且该过程继续进行，直到消息的最后比特剩余，并且消息块的nᵗʰ部分的上一轮的结果将给出结果，即整个消息的散列。输出的长度为256位。</p><h1 id="f559" class="lz ma jb bd mb mc md me mf mg mh mi mj kh mk ki ml kk mm kl mn kn mo ko mp mq bi translated">结论</h1><p id="6cbc" class="pw-post-body-paragraph kq kr jb ks b kt mr kc kv kw ms kf ky kz mt lb lc ld mu lf lg lh mv lj lk ll ij bi translated">SHA-256哈希算法是目前使用最广泛的哈希算法之一，因为它尚未被破解，而且与SHA-512等其他安全哈希相比，哈希计算速度很快。它已经非常成熟，但该行业正试图慢慢转向更安全的SHA-512，因为专家声称SHA-256可能很快就会变得脆弱。</p><p id="418c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">那么，让我们再看一下SHA-256算法的整个功能，让我用一个长段落来解释整个事情。</p><blockquote class="ln lo lp"><p id="7fcf" class="kq kr lq ks b kt ku kc kv kw kx kf ky lr la lb lc ls le lf lg lt li lj lk ll ij bi translated">我们计算需要散列的消息的长度，然后我们给消息附加几个比特，从“1”开始，其余的是“0”，直到消息长度正好比512的倍数小64比特。我们通过用2计算原始消息的模来添加剩余的64位。一旦我们添加了剩余的比特，整个消息块可以表示为‘n×512’比特。现在，我们将这512位中的每一位传递给压缩函数，即64轮运算的集合，其中我们进一步将它们分成16个部分，每个部分32位。这16个部分，每部分32位，作为前16轮的每轮运算的输入，对于其余的48轮，我们有方法计算W(i)。我们也有缓冲区的默认值和所有64轮的“k”值。我们现在可以开始计算哈希值了，因为我们已经有了所有需要的值和公式。然后，散列过程反复进行64轮，然后I轮的输出作为i+1轮的输入。因此，nᵗʰ回合的64ᵗʰ运算的输出将为我们呈现输出，即整个消息的散列。</p></blockquote><p id="6fb7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这就是发生在SHA-256算法中的整个运算的简短版本。</p><p id="6b13" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你喜欢，请鼓掌让我们合作吧。获取、设置、破解！</p><p id="1003" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">网站</strong>:<a class="ae lm" href="https://www.aditya12anand.com/" rel="noopener ugc nofollow" target="_blank">aditya12anand.com</a>|<strong class="ks jc">捐款</strong>:<a class="ae lm" href="https://paypal.me/aditya12anand" rel="noopener ugc nofollow" target="_blank">paypal.me/aditya12anand</a><br/><strong class="ks jc">电报</strong>:<a class="ae lm" href="https://t.me/aditya12anand" rel="noopener ugc nofollow" target="_blank">https://t.me/aditya12anand</a><br/><strong class="ks jc">推特</strong>:<a class="ae lm" href="https://twitter.com/aditya12anand?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">twitter.com/aditya12anand</a><br/><strong class="ks jc">LinkedIn</strong>:<a class="ae lm" href="https://www.linkedin.com/in/aditya12anand/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/aditya12anand/</a><br/><strong class="ks jc">电子邮件</strong>:aditya12anand@protonmail.com</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="246b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lq">关注</em> <a class="ae lm" href="https://medium.com/bugbountywriteup" rel="noopener"> <em class="lq"> Infosec报道</em> </a> <em class="lq">获取更多此类精彩报道。</em></p><div class="ip iq gp gr ir oh"><a href="https://medium.com/bugbountywriteup" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd jc gy z fp om fr fs on fu fw ja bi translated">信息安全报道</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">收集了世界上最好的黑客的文章，主题从bug奖金和CTF到vulnhub…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ix oh"/></div></div></a></div></div></div>    
</body>
</html>