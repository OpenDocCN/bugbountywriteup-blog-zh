<html>
<head>
<title>FluxCloud Frontline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">磁通云前线</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/fluxcloud-frontline-writeup-8e2dbf095d57?source=collection_archive---------3-----------------------#2020-10-25">https://infosecwriteups.com/fluxcloud-frontline-writeup-8e2dbf095d57?source=collection_archive---------3-----------------------#2020-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b224" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Hack.lu特写</h2></div><p id="5153" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">挑战FluxCloud Frontline (web，hard)是令人惊叹的Hack的一部分。卢。我和一个朋友花了两个晚上的时间才攻克了这个巨大的挑战，他们都是浮士德队的队员。</p><p id="cb24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下文中，我描述了简单的解决方案，并省略了我们进入的许多兔子洞。</p><h1 id="fdaf" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">挑战</h1><blockquote class="lt lu lv"><p id="70c7" class="kf kg lw kh b ki kj jr kk kl km ju kn lx kp kq kr ly kt ku kv lz kx ky kz la ij bi translated">借助我们全新的FluxCloud Frontline产品，我们可以提供超安全、超快速的边缘路由。当然，我们也有一个臭虫奖励计划！如果你能绕过我们的保护，你会得到一面美味的旗帜作为奖励。<a class="ae ma" href="https://public.frontline.cloud.flu.xxx:8443/" rel="noopener ugc nofollow" target="_blank">https://public.frontline.cloud.flu.xxx:8443/</a></p></blockquote><p id="45c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们打开挑战，我们提供了该项目的源代码。该项目由各种服务器层组成，如图1所示。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mb"><img src="../Images/9b2ef4ef92ffb893c0603a5a5d9db036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X4V4vCFEM-IQ2N84eKZqew.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图1:挑战的总体设置</figcaption></figure><p id="1a6e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，对域<em class="lw"> frontline.cloud.flu.xxx </em>的请求进入防火墙。实现为haproxy的防火墙决定查看子域，请求是被转发到路由器还是被拒绝。拒绝的是除了子域<em class="lw">公共</em>以外的一切。<em class="lw"> frontline.cloud.flu.xxx. </em></p><p id="6661" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步，Nginx路由器根据子域和路径将请求转发到公共、私有或元数据服务器。路径<em class="lw"> /_meta/flag </em>，显然是给我们的标志，被拒绝。</p><p id="381b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目标是通过或越过防火墙和路由器偷偷发送请求，以调用和接收标志。</p><h1 id="07f9" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">防火墙旁路</h1><p id="6adf" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">挑战的第一阶段是绕过防火墙并将请求成功发送到秘密服务器。</p><p id="6923" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面我们可以看到<em class="lw"> haproxy.cfg的重要部分:</em></p><pre class="mc md me mf gt mw mx my mz aw na bi"><span id="cdda" class="nb lc iq mx b gy nc nd l ne nf">frontend ft_ssl_vip<br/>  bind 0.0.0.0:443<br/>  mode tcp<br/>  <br/>  <strong class="mx ir">acl app_public req_ssl_sni -i public.frontline.cloud.flu.xxx<br/>  acl app_secret req_ssl_sni -i secret.frontline.cloud.flu.xxx</strong></span><span id="d2c7" class="nb lc iq mx b gy ng nd l ne nf">  use_backend bk_ssl_app_public if app_public<br/>  use_backend bk_ssl_app_secret if app_secret</span><span id="073b" class="nb lc iq mx b gy ng nd l ne nf">  default_backend bk_ssl_default</span><span id="2846" class="nb lc iq mx b gy ng nd l ne nf">backend bk_ssl_app_public<br/>  mode tcp<br/>  server server1 router:443 check</span><span id="499b" class="nb lc iq mx b gy ng nd l ne nf">backend bk_ssl_app_secret<br/>  mode tcp<br/>  # Block access to the secret page!<br/>  tcp-request content reject<br/>  server server1 router:443 check</span></pre><p id="40e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">配置中的粗线决定服务器查看存储TLS连接主机名的服务器名称指示(SNI)。但是，Nginx路由器会查看HTTP层的服务器名称。</p><p id="170b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们可以用来将我们的流量路由到秘密服务器的缺陷。我们将SNI设置为public，但将HTTP主机设置为secret。</p><p id="3e46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在python中，我们可以在SSL上下文中设置SNI，在HTTP请求中设置HTTP主机(最终完全利用):</p><pre class="mc md me mf gt mw mx my mz aw na bi"><span id="6ac0" class="nb lc iq mx b gy nc nd l ne nf">sslContext = ssl.create_default_context()<br/>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>sock = sslContext.wrap_socket(s,<br/>       server_hostname="public.frontline.cloud.flu.xxx")</span><span id="d640" class="nb lc iq mx b gy ng nd l ne nf"># "GET / HTTP/1.1\r\n" +<br/># "Host: secret.frontline.cloud.flu.xxx\r\n"</span></pre><h1 id="f87f" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">路由器旁路</h1><p id="2a78" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">能够绕过防火墙，下一个挑战是路由器。路由器配置拒绝对标记端点的所有请求，并将流量路由到相应的服务器，查看路径位置:</p><pre class="mc md me mf gt mw mx my mz aw na bi"><span id="8a54" class="nb lc iq mx b gy nc nd l ne nf">location / {<br/>   proxy_pass <a class="ae ma" href="http://app-secret" rel="noopener ugc nofollow" target="_blank">http://app-secret</a>;<br/>}<br/>location /_meta/api/ {<br/>   rewrite ^/_meta(.*)$ $1 break;<br/>   proxy_pass <a class="ae ma" href="http://metadata" rel="noopener ugc nofollow" target="_blank">http://metadata</a>;<br/>}<br/>  <br/>location /_meta/flag {<br/>   deny all;<br/>}<br/>location /_meta/socket.io/ {<br/>  rewrite ^/_meta(.*)$ $1 break;<br/>  proxy_http_version 1.1;<br/>  proxy_set_header Upgrade $http_upgrade;<br/>  proxy_set_header Connection "Upgrade";<br/>  proxy_pass <a class="ae ma" href="http://metadata" rel="noopener ugc nofollow" target="_blank">http://metadata</a>;<br/>}</span></pre><p id="4b62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，元数据服务器使用socket.io通过WebSockets与app-secret服务器进行通信。此外，元数据服务器包含一个开放重定向端点<code class="fe nh ni nj mx b">/_meta/api/check?hostname=xy </code>,用于向主机名发送检查请求(在内部用于检查公共和秘密服务器)。</p><p id="a562" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到这一点，我们谷歌了Nginx和socket.io中的请求走私漏洞，最终找到了我们要找的东西。链接帖子中<a class="ae ma" href="https://github.com/0ang3el/websocket-smuggle" rel="noopener ugc nofollow" target="_blank">场景2描述的情况需要Nginx、socket.io、一个内部API(我们的flag API)和一个open-redirect——这正是我们面临的情况。</a></p><p id="6228" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面提到的帖子描述了我们可以使用open-redirect将请求重定向到我们的恶意服务器。恶意服务器必须用HTTP 101响应，告诉目标服务器打开一个到我们客户端的WebSocket连接。然而，通过这个WebSocket连接，我们仍然可以发送HTTP请求，例如发送到内部API并绕过路由器。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nk"><img src="../Images/dce0fb052b457fe7c03f40d9193274d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3cGQYbKueb8Wnd9YZot8sw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">图2:请求走私的请求流程</figcaption></figure><h1 id="4c17" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">最终解决方案</h1><p id="72f8" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">所以最终的解决方案看起来如下。我在一个数字海洋液滴上运行它来对开放重定向作出反应。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="20be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多田，这是旗子:</p><pre class="mc md me mf gt mw mx my mz aw na bi"><span id="9bd4" class="nb lc iq mx b gy nc nd l ne nf">('31.22.122.203', 37290) connected<br/>b'HTTP/1.1 101 Switching Protocols\r\nServer: nginx/1.19.3\r\nDate: Sat, 24 Oct 2020 18:44:08 GMT\r\nContent-Type: text/html; charset=utf-8\r\nContent-Length: 2\r\nConnection: upgrade\r\nX-Powered-By: Express\r\nETag: W/"2-eoX0dku9ba8cNUXvu/DyeabcC+s"\r\n\r\n'<br/>send payload<br/>b'HTTP/1.1 200 OK\r\nX-Powered-By: Express\r\nConnection: keep-alive\r\nContent-Type: text/html; charset=utf-8\r\nContent-Length: 58\r\nETag: W/"3a-jCTYnFrMoq94M55Ba2sPa6ZdkWU"\r\nDate: Sat, 24 Oct 2020 18:44:08 GMT\r\n\r\nflag{th1s_isnt_y0ur_f1rst_t1me_p3netr4ting_fir3walls_huh?}'</span></pre><p id="778f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">flag { th1s _ nots _ your _ f1 rst _ t1me _ p 3 net R4 ting _ fir 3 walls _ huh？} </strong></p></div></div>    
</body>
</html>