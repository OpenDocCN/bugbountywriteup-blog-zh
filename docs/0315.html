<html>
<head>
<title>Protostar stack6 ret2libc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">原恒星堆栈6 ret2libc</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/protostar-stack6-24680c38a3a8?source=collection_archive---------1-----------------------#2019-06-07">https://infosecwriteups.com/protostar-stack6-24680c38a3a8?source=collection_archive---------1-----------------------#2019-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a406" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经有一段时间没有写博客了——原因是我一直在做黑客盒子挑战。当我完成这些挑战时，它们通常仍然存在，所以我不能发表评论。然而，最近我已经进入逆向工程。我认为我的第一个ret2libc挑战是一个很好的切入点，因为其他挑战都很简单。</p><p id="5dd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从挑战的代码开始。以下是一个快照:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c338cd0d1eb76d86012cc6e23b9f3e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSbzwixArgG6P-rDCAFITg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">堆栈6.c</figcaption></figure><p id="953f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们从之前的挑战中知道会有缓冲区溢出。正如我们在代码中看到的，我们需要的所有东西都在函数getpath()中，所以让我们做一个objdump:</p><blockquote class="lb lc ld"><p id="d90a" class="jn jo le jp b jq jr js jt ju jv jw jx lf jz ka kb lg kd ke kf lh kh ki kj kk ij bi translated">objdump-S/opt/protostar/bin/stack 6</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi li"><img src="../Images/0b1cc9bc2622428f89aacbd0e3fa81ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*OHrHVhM6BrGdsqkbGb0I4A.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">stack6.c中getpath的objdump</figcaption></figure><p id="4279" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在没有看到代码的情况下，我们可以查看这个输出并确定一些事情。1)有一个我们知道易受攻击的gets。在gets的手册页中，它说“永远不要使用gets()。因为在事先不知道数据的情况下，不可能知道gets()将读取多少字符，并且因为gets() <br/>将继续存储超过缓冲区结尾的字符，所以使用它是极其危险的。它已经被用来破坏计算机安全。<br/>请改用fgets()。</p><p id="5692" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们在0x80484bd处看到一个比较，如果在0x80484c2处不相等，则看到一个跳转。这告诉我们，存在某种比较，如果不成立，则跳转。在代码片段中，我们将其视为</p><blockquote class="lb lc ld"><p id="cd91" class="jn jo le jp b jq jr js jt ju jv jw jx lf jz ka kb lg kd ke kf lh kh ki kj kk ij bi translated">if((ret &amp; 0x BF 000000)= = 0x BF 000000){</p></blockquote><p id="5873" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们溢出了我们的缓冲区，我们也许可以写入堆栈指针并指向堆栈外的另一个函数。让我们扔一大串，比如4 A，4 B，c，等等。使用gdb，我们反汇编getpath函数，并在gets和ret函数处设置断点。：</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lj"><img src="../Images/3a9297a7be84a5dd15271a387bf921a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vtUtbBJe4TzI6o4qCgmosg.png"/></div></div></figure><p id="495a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，ebp和eip已被54和55覆盖。这给了我们一个线索，我们可以用一个新地址覆盖eip。我们可以找出缓冲区溢出中的哪些值使用python成功覆盖了eip:</p><blockquote class="lb lc ld"><p id="16b6" class="jn jo le jp b jq jr js jt ju jv jw jx lf jz ka kb lg kd ke kf lh kh ki kj kk ij bi translated">&gt; &gt; &gt; chr(0x 54)<br/>' T '<br/>&gt;&gt;&gt;chr(0x 55)<br/>' U '</p></blockquote><p id="4fde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们知道我们可以在eip变量中添加一个新的地址，它将跳转到程序的末尾。我们可以使用system()函数来调用系统命令。为了找到这个地址，我们可以这样做</p><blockquote class="lb lc ld"><p id="dc8b" class="jn jo le jp b jq jr js jt ju jv jw jx lf jz ka kb lg kd ke kf lh kh ki kj kk ij bi translated">(gdb) p system <br/> $1 = { &lt;文本变量，无调试信息&gt;} 0x b 7 ecffb 0&lt;_ _ libc _ system&gt;</p></blockquote><p id="4d5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的系统地址是0xb7ecffb0。我们将它作为一个新变量添加到我们的漏洞脚本中:</p><blockquote class="lb lc ld"><p id="0072" class="jn jo le jp b jq jr js jt ju jv jw jx lf jz ka kb lg kd ke kf lh kh ki kj kk ij bi translated">system = struct.pack("I "，0xb7ecffb0)</p></blockquote><p id="8035" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要一个已知包含“/bin/sh”的字符串。libc库包含字符串“/bin/sh”，但是我们不知道它在哪里。我们可以使用工具“字符串”来找到从文件开始的偏移量:</p><blockquote class="lb lc ld"><p id="943b" class="jn jo le jp b jq jr js jt ju jv jw jx lf jz ka kb lg kd ke kf lh kh ki kj kk ij bi translated">user @ protostar:/tmp＄strings-t d/lib/libc . so . 6 | grep/bin/sh<br/>1176511/bin/sh</p></blockquote><p id="afe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，我们有了偏移。但我们需要libc开始的地址。我们可以跑</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/a00f25568785433d0816b3c42bcec117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*OSQ-0BYElbJ1ljHdgWQdwQ.png"/></div></figure><p id="b722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们走吧！现在我们知道了libc的地址和字符串“/bin/sh”存储位置的偏移量。让我们把它加入到我们的利用中:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/02cf9636f46a6584b85a3b2da27d6b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*S0YMrEMl7VcKA5qih_dAqQ.png"/></div></figure><p id="b2e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们在程序中运行它</p><blockquote class="lb lc ld"><p id="4cda" class="jn jo le jp b jq jr js jt ju jv jw jx lf jz ka kb lg kd ke kf lh kh ki kj kk ij bi translated">(python exploit.pycat) | /opt/protostar/bin/stack6</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/c2662678a4747344a3fcad85f0d50fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*fKYcYj__HmjzEoCcGqucQQ.png"/></div></figure><p id="8f49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦，太好了，一个新的分段错误。在这种情况下，我学会的最好的办法是添加填充——几个“A”就足够了。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ln"><img src="../Images/2b967601340f404048b2e4cdaff9ae58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*9EjtCuTWeYZbKD--tmHKGg.png"/></div></div></figure><p id="ea7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好，我们再跑一次</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lo"><img src="../Images/272f3e0938884ab67335145608730034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sBKcanxF8hxnV27hM3hMNg.png"/></div></div></figure><p id="d21f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘣，我们有根了！</p><p id="1819" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想更详细地了解这个漏洞，可以查看youtube上的liveoverflow。他有一个播放列表是关于利用原星上的二进制挑战的。下次见！</p></div></div>    
</body>
</html>