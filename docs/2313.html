<html>
<head>
<title>Top 10 Dockerfile Security Best Practices for a More Secure Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现更安全容器的十大docker文件安全最佳实践</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/top-10-dockerfile-security-best-practices-for-a-more-secure-container-e5426f69738b?source=collection_archive---------1-----------------------#2022-08-27">https://infosecwriteups.com/top-10-dockerfile-security-best-practices-for-a-more-secure-container-e5426f69738b?source=collection_archive---------1-----------------------#2022-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/dbe07a159d98e9f140b7c6f77ddb9688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMdhE1Z92Bc8vSEejOUFFw.jpeg"/></div></div></figure><p id="cdee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本帖中，我们将介绍Dockerfile是什么以及如何创建一个docker file，并遵循以下领先的行业安全最佳实践，包括但不限于多阶段构建、创建最少映像、使用适当的说明来最大限度地减少层数、林挺、避免什么等等。因此，让我们深入探讨Dockerfile安全性。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5f3b" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">目录</h1><p id="c441" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated"><a class="ae mj" href="#3124" rel="noopener ugc nofollow"> 1。什么是Dockerfile？</a> <br/> <a class="ae mj" href="#fe7f" rel="noopener ugc nofollow"> 2。使用用户指令</a> <br/> <a class="ae mj" href="#768b" rel="noopener ugc nofollow"> 3。使用最小Dockerfile基础映像</a> <br/> <a class="ae mj" href="#70f1" rel="noopener ugc nofollow"> 4。使用最小端口</a> <br/> <a class="ae mj" href="#4085" rel="noopener ugc nofollow"> 5。使用可信且安全的基础映像</a> <br/> ∘ <a class="ae mj" href="#5cb5" rel="noopener ugc nofollow"> 5.1。检查漏洞</a> <br/> ∘ <a class="ae mj" href="#739f" rel="noopener ugc nofollow"> 5.2。使用签名图像</a> <br/> <a class="ae mj" href="#7694" rel="noopener ugc nofollow"> 6。使用棉绒</a> <br/> <a class="ae mj" href="#3942" rel="noopener ugc nofollow"> 7。避免使用最新的标签</a> <br/> <a class="ae mj" href="#169d" rel="noopener ugc nofollow"> 8。组运行、复制和添加指令</a> <br/> <a class="ae mj" href="#f8af" rel="noopener ugc nofollow"> 9。多级建筑</a> <br/> <a class="ae mj" href="#cac1" rel="noopener ugc nofollow"> 10。避免包含机密或凭证</a> <br/> <a class="ae mj" href="#3467" rel="noopener ugc nofollow"> 11。使用。dockerignore </a> <br/> <a class="ae mj" href="#7405" rel="noopener ugc nofollow"> 12。结论</a> <br/> <a class="ae mj" href="#0c6a" rel="noopener ugc nofollow">参考文献</a></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3124" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">1.什么是Dockerfile？</h1><p id="61f5" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">最常见的Docker文件是一个文本文件，其中包含用于构建Docker映像的必要命令。如果你不熟悉Docker图像是什么，我强烈推荐你从Docker的一些文档<a class="ae mj" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank">开始你的容器之旅。也就是说，dockerfile是做什么的？dockerfile允许用户以可重复、一致的方式自动构建容器映像，而不必手动遍历每个命令，这是一个很大的好处。现在您已经知道dockerfile是什么了，接下来的部分将带您了解编写docker file的安全最佳实践。</a></p><h1 id="fe7f" class="lg lh it bd li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz mo mb mc md bi translated">2.使用用户说明</h1><p id="d907" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">为了确保容器不以root用户身份运行，应该尽可能使用用户指令。避免使用root将有助于防止主机权限提升攻击，这可能会损害系统的安全性。为了帮助用户完成这项任务，一些图像包含一个内置用户。例如，Node.js包括它们的节点用户，如下所示。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4a4d" class="my lh it mu b gy mz na l nb nc">USER node</span></pre><p id="4382" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果不需要内置用户，应该将其删除。使用上面的同一个Node.js示例，这将通过向Dockerfile文件添加以下内容来完成。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="6e64" class="my lh it mu b gy mz na l nb nc"># For debian based images use:<br/>RUN userdel -r node</span><span id="f273" class="my lh it mu b gy nd na l nb nc"># For alpine based images use:<br/>RUN deluser --remove-home node</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="768b" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">3.使用最小Dockerfile文件基础映像</h1><p id="633b" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">图像应该是最少的，并且只包括成功运行应用程序所必需的包。这样做，通过移除不必要的和潜在的易受攻击的包，攻击面将显著减少。为了帮助开发人员完成这项工作，多个来源开发了只包含核心必需品的基础映像。<a class="ae mj" href="https://github.com/GoogleContainerTools/distroless" rel="noopener ugc nofollow" target="_blank">distroles</a>和<a class="ae mj" href="https://hub.docker.com/_/alpine" rel="noopener ugc nofollow" target="_blank"> Alpine </a>是两种最常见的、推荐用于创建最小容器的基础图像。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="70f1" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">4.使用最少的端口</h1><p id="d4ca" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">除了使用最少的映像之外，应该只暴露必要的端口。使用EXPOSE指令将有助于向用户概述打算发布哪些端口。但是，需要注意的是，EXPOSE指令纯粹是为了注释和/或文档目的。因此，它不能防止在运行时暴露额外的端口。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b1d6" class="my lh it mu b gy mz na l nb nc">EXPOSE 80/tcp</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4085" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">5.使用可信且安全的基础映像</h1><p id="a565" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">Docker图像应来自可信来源，经过签名，并经过漏洞扫描，以实现适当的风险缓解级别。虽然有许多工具可以获得这样的结果，但Docker预装了docker scan命令，从而为用户扫描图像提供了一种快速简便的方法。</p><h2 id="5cb5" class="my lh it bd li ne nf dn lm ng nh dp lq km ni nj lu kq nk nl ly ku nm nn mc no bi translated">5.1.检查漏洞</h2><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="74d3" class="my lh it mu b gy mz na l nb nc">PS user&gt; docker scan node:14<br/>\ Analyzing container dependencies for node:14<br/>\ Querying vulnerabilities database...</span><span id="8ea2" class="my lh it mu b gy nd na l nb nc">...</span><span id="c2df" class="my lh it mu b gy nd na l nb nc">Package manager:   deb<br/>Project name:      docker-image|node<br/>Docker image:      node:14<br/>Platform:          linux/amd64</span><span id="dd80" class="my lh it mu b gy nd na l nb nc">Tested 413 dependencies for known vulnerabilities, found 548 vulnerabilities.</span></pre><h2 id="739f" class="my lh it bd li ne nf dn lm ng nh dp lq km ni nj lu kq nk nl ly ku nm nn mc no bi translated">5.2.使用签名图像</h2><p id="9820" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">Docker图像应该在使用前由可信来源签名。确保只使用签名图像的一种方法是强制Docker内容信任。在客户端，可以通过使用以下命令在每个会话的基础上强制执行。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="220a" class="my lh it mu b gy mz na l nb nc">$ export DOCKER_CONTENT_TRUST=1</span></pre><p id="b64e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">设置Docker内容信任后，如果客户端试图提取不受信任的图像，将会出现如下错误。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5c5c" class="my lh it mu b gy mz na l nb nc">$ docker pull node:14<br/>No valid trust data for 14</span></pre><p id="0e1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了检查已经提取的图像，Docker提供了docker trust inspect命令，如下所示。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="64a2" class="my lh it mu b gy mz na l nb nc">PS user&gt; docker trust inspect --pretty node:14</span><span id="9ae3" class="my lh it mu b gy nd na l nb nc">No signatures for node:14</span><span id="fdbf" class="my lh it mu b gy nd na l nb nc">Administrative keys for node:14</span><span id="b750" class="my lh it mu b gy nd na l nb nc">  Repository Key:       d3a0845e6d36c6c058ae6d2bc718b32ead4b51f2a6fa81b341ba2df72f1823c9<br/>  Root Key:     be46625d7c6a0afe24bbbce6a92114d691e32ae921cf14f3feb2f970e7a77337</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7694" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">6.使用棉绒</h1><p id="95c6" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">linter是一种静态分析内容的工具，可以标记编程错误、bug、风格错误等，帮助防止不良后果。<a class="ae mj" href="https://github.com/hadolint/hadolint" rel="noopener ugc nofollow" target="_blank"> Hadolint </a>是一个普遍推荐的Dockerfile linter，它可以帮助确保用户的Dockerfile遵循最佳实践，比如确认用户已经为他们的基本映像明确标记了一个版本。因此，建议在编写docker文件时尽可能使用linter。</p><p id="f7a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">图1 </strong></p><p id="82c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np"> Hadolint示例</em></p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/d929b193892f701a9cfc5a446288d054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjyB9pGzsx0PM3-Gp1c7Fg.png"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3942" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">7.避免使用最新的标签</h1><p id="2ea3" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">如第1.4节所示。使用Linter，Hadolint建议避免在docker文件中使用最新的标签。用户应避免使用最新的标记，因为如果映像更新，可能会破坏功能或在将来的环境中引入未知因素。用户应该选择指定一个明确的发布标签，而不是使用最新的标签。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8add" class="my lh it mu b gy mz na l nb nc">FROM node:14</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="169d" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">8.组运行、复制和添加指令</h1><p id="ce52" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">Dockerfiles中的RUN、COPY和ADD指令在被调用时都会创建一个新层。因此，最佳实践是尽可能将这些指令组合到一行中，以减少容器层数。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f8af" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">9.多层建筑</h1><p id="c7f6" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">Dockerfiles中的多阶段构建提供了一种进行中间构建的方法，也称为阶段。阶段允许用户复制前一阶段生成的版本，并在后续阶段使用它。使用多阶段构建将通过限制最终映像中发现的包来减少攻击面和构建的潜在漏洞。</p><p id="dc0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，用户可能希望拥有一个利用构建工具的舞台，但是在最终图像中对这些构建工具没有要求。通过多阶段构建，他们可以使用FROM“base _ image”作为“name_of_stage1”指令开始一个阶段，然后使用COPY–FROM = " name _ of _ stage 1 "指令将该阶段的结果复制到下一个FROM阶段。参见下面的docker文件，它使用Node:10作为构建环境，然后使用Google的distrolles Node:10作为最终图像。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2998" class="my lh it mu b gy mz na l nb nc">FROM node:10 as build-env<br/>COPY ./app<br/>WORKDIR /app</span><span id="70b4" class="my lh it mu b gy nd na l nb nc">RUN npm ci --only=production</span><span id="1a5a" class="my lh it mu b gy nd na l nb nc">FROM gcr.io/distroless/nodejs:10<br/>COPY --from=build-env /app /app<br/>WORKDIR /app<br/>CMD ["app.js"]</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="cac1" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">10.避免包含秘密或凭证</h1><p id="a7de" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">Docker使用层缓存，这实质上意味着所有的层仍然存在于最终的图像中。某些命令如docker history将显示图像中的图层以及它们是如何构建的。下面的图2给出了一个使用Node:14的例子。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b084" class="my lh it mu b gy mz na l nb nc">docker history node:14</span></pre><p id="b4f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">图2 </strong></p><p id="5337" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">节点的停靠历史:14 </em></p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/76e99602c2f4a294d05114c6f54c9350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rb7OPq-DGglVTJBjUkiCQ.png"/></div></div></figure><p id="5dae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当涉及到在docker文件中使用秘密或凭证时，这变得特别重要，因为任何访问图像的用户都能够看到内容。为了解决安全问题，最重要的是用户永远不要在他们的docker文件中包含秘密或凭证，无论是直接以明文形式写在docker文件中，作为文件传入，还是作为构建参数传入。</p><p id="2fdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用户应该选择使用像<a class="ae mj" href="https://docs.docker.com/develop/develop-images/build_enhancements/" rel="noopener ugc nofollow" target="_blank"> Docker BuildKit </a>这样的带有–secret命令行选项的工具来传递所需的秘密信息。</p><p id="bd9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，在docker文件中，用户将通过RUN命令访问秘密，如下所示。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="cc69" class="my lh it mu b gy mz na l nb nc">RUN --mount=type=secret,id=secret cat /run/secrets/secret</span></pre><p id="4a46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在构建过程中，秘密将通过–secret标志传递。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="68d2" class="my lh it mu b gy mz na l nb nc">docker build --no-cache --progress=plain --secret id=secret,src=secret.txt .</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3467" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">11.使用。dockerignore</h1><p id="c07d" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">答。dockerignore文件类似于. gitignore文件，开发人员可以通过它指定要从构建上下文中排除的文件或目录，从而防止它被包含在最终的映像中。。dockerignore文件对于明确排除敏感文件和目录(如凭证文件、备份、日志等)特别有用。以下示例确保. git文件夹、logs文件夹和所有以。md扩展名(README.md文件除外)被排除在生成上下文之外。见<a class="ae mj" href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" rel="noopener ugc nofollow" target="_blank">码头工人。更多信息，请查阅文档</a>。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b1d2" class="my lh it mu b gy mz na l nb nc">.git<br/>logs<br/>*.md<br/>!README.md</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7405" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">12.结论</h1><p id="7426" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">总之，Dockerfile是构建可重复且一致的容器映像的一个很好的工具，只要安全地完成了。避免最新的标签，检查漏洞并减少任何出现的漏洞，仅使用签名的图像以避免潜在的供应链问题，以及概述的其他最佳实践将保证您的开发有一个正确的安全基础，以防止任何未来的麻烦。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0c6a" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">参考</h1><p id="6908" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">互联网安全中心。(未注明)。<em class="np"> CIS Docker基准</em>。【https://www.cisecurity.org/benchmark/docker/】T4。</p><p id="9579" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">码头工人。(未注明日期)。编写Dockerfiles的最佳实践。<a class="ae mj" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/develop/develop-images/docker file _ best-practices/</a>。</p><p id="01f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">码头工人。(未注明)。<em class="np">用BuildKit </em>构建图像。<a class="ae mj" href="https://docs.docker.com/develop/develop-images/build_enhancements/" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/develop/develop-images/build _ enhancements/</a>。</p><p id="4520" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">码头工人。(未注明日期)。<em class="np">内容信任于码头工人</em><a class="ae mj" href="https://docs.docker.com/engine/security/trust/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/security/trust/</a>。</p><p id="de08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">码头工人。(未标明-未标明)。<em class="np">针对Docker本地镜像的漏洞扫描</em><a class="ae mj" href="https://docs.docker.com/engine/scan/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/scan/</a>。</p><p id="9739" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">加特曼博士(2018年7月10日)。确保您的码头集装箱安全的速赢方案<em class="np">。<a class="ae mj" href="https://www.equalexperts.com/blog/tech-focus/quick-wins-to-secure-your-docker-containers/" rel="noopener ugc nofollow" target="_blank">https://www . equal experts . com/blog/tech-focus/quick-wins-to-secure-your-docker-containers/</a>。</em></p><p id="f36c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GoogleContainerTools。(2020年7月28日)。<em class="np"> GitHub资源库</em>。</p><p id="e05b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae mj" href="https://github.com/GoogleContainerTools/distroless/blob/main/examples/nodejs/Dockerfile" rel="noopener ugc nofollow" target="_blank">https://github . com/Google container tools/distro less/blob/main/examples/nodejs/docker file</a>。</p><p id="5849" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Iradier，A. (2021年3月9日)。<em class="np">20大Dockerfile最佳实践</em>。【https://sysdig.com/blog/docker-file-best-practices/】T4。</p><p id="621b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Nodejs。(2020年11月2日)。<em class="np"> Docker和Node.js最佳实践</em>。<a class="ae mj" href="https://github.com/nodejs/docker-node/blob/main/docs/BestPractices.md" rel="noopener ugc nofollow" target="_blank">https://github . com/nodejs/docker-node/blob/main/docs/best practices . MD</a>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="42d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">准备好让您的网络安全技能更上一层楼了吗？请关注我，了解最新的行业标准最佳实践和指导。</p><h2 id="1a22" class="my lh it bd li ne nf dn lm ng nh dp lq km ni nj lu kq nk nl ly ku nm nn mc no bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae mj" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4个线程、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>