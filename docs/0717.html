<html>
<head>
<title>Android InsecureBankv2 Walkthrough: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android安全银行2演练:第1部分</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/android-insecurebankv2-walkthrough-part-1-9e0788ba5552?source=collection_archive---------0-----------------------#2020-07-28">https://infosecwriteups.com/android-insecurebankv2-walkthrough-part-1-9e0788ba5552?source=collection_archive---------0-----------------------#2020-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f7ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将看看GitHub用户<em class="ko"> dineshshetty </em>创建的<em class="ko"> InsecureBankv2 </em> Android应用程序。根据创建者的说法，这个易受攻击的Android应用程序是为了让开发人员和安全爱好者通过测试一个有目的的易受攻击的Android应用程序来了解更多关于Android不安全性的信息。我在下面的参考资料中留下了应用程序GitHub库的链接，它提供了应用程序中当前存在的所有漏洞的列表。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/986c5446f38e14fc9a30a004832033dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*-SwxVdI20TEENDs9wuGJaw.png"/></div></figure></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="74ff" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">放弃</h1><p id="71fd" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">出于学习更多关于Android移动应用程序安全性的兴趣，我写了这篇文章。这篇文章显然会包含关于<em class="ko">安全银行v2 </em> Android应用程序中存在的漏洞的剧透。我鼓励读者尽可能多地利用漏洞，如果您遇到困难或希望看到利用不安全的潜在不同方法，请稍后再来阅读本文。没有任何进一步的延误，让我们开始设置😃！</p></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="03a5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设置</h1><p id="ccb0" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">该应用程序的创建者在他们的GitHub上提供了关于如何设置应用程序及其后端服务器的详细指南(<strong class="js iu">参见参考资料</strong>)。对于本文，我使用一个<em class="ko"> Kali Linux </em>虚拟机作为我的主机设备，使用Genymotion创建的一个<em class="ko"> Samsung Galaxy S8 </em>仿真器作为我的测试设备。我还配置了两个虚拟机来使用<strong class="js iu"> NAT </strong>和<strong class="js iu">主机专用</strong>网络适配器。我的Android模拟器的规格可以在下图中看到。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/f8da848c7c518812a58637f9502412ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*ytqqxJGOhUwxpeWojecYgw.png"/></div></figure><p id="4aa4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了设置<strong class="js iu"> AndroLab </strong>服务器，我首先将应用程序的GitHub库克隆到我的Kali机器上，然后使用<strong class="js iu"> pip </strong>安装必要的需求。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="7dae" class="mn lf it mj b gy mo mp l mq mr">pip install -r requirements.txt</span></pre><p id="d7ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦安装了所有的需求，我就在默认端口8888上运行HTTP服务器。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="bf5b" class="mn lf it mj b gy mo mp l mq mr">python app.py</span></pre><p id="e4e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我使用<strong class="js iu"> Android调试桥</strong> (ADB)连接到我的仿真器，并安装了<em class="ko"> InsecureBankv2 </em> APK文件。</p><blockquote class="ms mt mu"><p id="ce56" class="jq jr ko js b jt ju jv jw jx jy jz ka mv kc kd ke mw kg kh ki mx kk kl km kn im bi translated">注意:<strong class="js iu">Android Debug Bridge(ADB)</strong>是一款多功能命令行工具，可让您与设备进行通信。adb命令有助于各种设备操作，如安装和调试应用程序，它提供了对Unix shell的访问，您可以使用该shell在设备上运行各种命令。</p></blockquote><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="8d53" class="mn lf it mj b gy mo mp l mq mr">adb connect "your-host-only-ip-address"<br/>adb install InsecureBankv2.apk</span></pre><p id="4609" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">成功安装后，应用程序图标会出现在我的模拟器上</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi my"><img src="../Images/b308df076b9fb4534a07e4b01778a127.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*MP0t_Cx6Kp-04JfCppZ2Pg.png"/></div></figure><p id="114c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装完成后，最后一步是打开应用程序，将应用程序指向运行AndroLab服务器的IP地址和端口。在我的例子中，这是我的Kali机器的唯一的网络适配器和端口的IP地址。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/36ecdd0871669e68e8ab5190d64688ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*t4GlPDPThlejfS5KBgQsUg.png"/></div></figure><p id="a8a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">单击提交后，将成功配置网络首选项设置。为了查看应用程序是否连接到服务器，我可以尝试使用一组不正确和正确的凭据登录。当我尝试登录时，会生成以下输出，显示该应用程序能够与AndroLab服务器通信。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi na"><img src="../Images/62ec19c06c38e2e74c6ecc994a4df58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*E3SeMCdfP0eWGrMKat2isg.png"/></div></figure><p id="807c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了结束我的设置，我使用了<strong class="js iu">移动安全框架</strong> ( <em class="ko"> MobSF </em>)工具来反编译<em class="ko"> InsecureBankv2.apk </em>文件。这使得反编译APK、读取清单文件、识别源代码和清单文件中的问题、提取应用程序的证书等过程自动化。让我不必手动完成这项工作。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/ad7e216eb241a266f992a8391f70f7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QbEyvuq8OK-DbWvjUYn1JQ.png"/></div></div></figure><p id="b604" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的设置到此结束，现在我可以继续测试应用程序中的漏洞了。</p></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="dab7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">登录漏洞</h1><p id="dc5c" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">当用户启动应用程序时，该应用程序为用户提供一个登录名。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a23b86ad52e90a6914e1422aff953f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*UVsw_CgBCSLuzIUxwR8y4Q.png"/></div></figure><p id="37b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此登录会发现许多不同的安全问题，下面的小节将对此进行概述。</p></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h2 id="141c" class="mn lf it bd lg nh ni dn lk nj nk dp lo kb nl nm ls kf nn no lw kj np nq ma nr bi translated">登录旁路</h2><p id="aa8d" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">利用<em class="ko"> MobSF </em>收集的信息，我决定从查看<strong class="js iu"> AndroidManifest.xml </strong>文件开始。浏览这个文件的内容，我注意到有四个活动被导出。</p><blockquote class="ms mt mu"><p id="ecb7" class="jq jr ko js b jt ju jv jw jx jy jz ka mv kc kd ke mw kg kh ki mx kk kl km kn im bi translated">注意:一个<strong class="js iu"> Android活动</strong>是<strong class="js iu"> Android </strong>应用程序用户界面的一个屏幕。在这种情况下，Android活动非常类似于桌面应用程序中的windows。一个Android应用程序可能包含一个或多个活动，即一个或多个屏幕。</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ns"><img src="../Images/a907561120ea3a6b5b9a78630ea77496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XqX8ytZoMSNc0uoLjgNzOQ.png"/></div></div></figure><p id="0ba4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我假设活动名称“<em class="ko"> PostLogin </em>”表示我登录(“post”)后显示的活动。使用ADB，我可以调用这个导出的活动。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="b4ef" class="mn lf it mj b gy mo mp l mq mr">adb shell am start -n com.android.insecurebankv2/com.android.insecurebankv2.PostLogin</span></pre><p id="db73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这让我想到了一个只有在成功登录后才可用的新活动，演示了可以完全绕过登录。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/472372a0d64586c31bb07cc6675a8eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*0fTpdBl5rvNzO18kfb4oCQ.png"/></div></figure></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h2 id="8f10" class="mn lf it bd lg nh ni dn lk nj nk dp lo kb nl nm ls kf nn no lw kj np nq ma nr bi translated">为管理员隐藏创建用户按钮</h2><p id="adc9" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我决定查看一下“<em class="ko"> LoginActivity </em>”源代码，看看是否还有其他可利用的漏洞。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/7b38ac4e4dfdc4bf919fd08a112370c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*5FFUC-zH2Hr3lK9ZZNto3A.png"/></div></figure><p id="d6b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现登录活动有一个隐藏的按钮。执行检查以确定名为“<em class="ko"> is_admin </em>”的资源字符串是否被设置为“<em class="ko"> no </em>”。如果这是真的，那么使用“<em class="ko"> setVisibility(8) </em>”方法将按钮设置为不可见，而不占用任何布局空间。我可以通过修补应用程序并将该值从“<em class="ko">否</em>”更改为“<em class="ko">是</em>”(<strong class="js iu">参见参考文献</strong>)。我使用<strong class="js iu"> apktool </strong>来反编译APK，这将创建一个新文件夹，其中包含所有反编译的资源文件。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="8c67" class="mn lf it mj b gy mo mp l mq mr">apktool d InsecureBankv2.apk</span></pre><p id="f454" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于这是一个字符串资源，我需要修改的值应该位于<strong class="js iu"> strings.xml </strong>文件中的“<em class="ko"> /res/values/ </em>”目录下。我打开这个文件，将“<em class="ko">是_管理</em>”值从“<em class="ko">否</em>”更改为“<em class="ko">是</em>”，然后保存更改。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/fe5bc939ce224b4584f36fe3ee676129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*IST70k8QTQs_lX2g-06IWQ.png"/></div></figure><p id="64ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我再次使用<strong class="js iu"> apktool </strong>用现在修改过的<strong class="js iu"> strings.xml </strong>文件重新构建应用程序。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="178a" class="mn lf it mj b gy mo mp l mq mr">apktool b -f -d InsecureBankv2/</span></pre><p id="18fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">移动应用程序不允许您在没有签名的情况下在模拟器/手机上安装重建的APK。为此，我需要使用下面的命令创建一个<strong class="js iu">密钥库</strong>。在创建密钥库时，必须指定一个<strong class="js iu">密码</strong>，稍后会用到它。创建密钥库时显示的其他字段可以简单地留空。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="e391" class="mn lf it mj b gy mo mp l mq mr">keytool -genkey -v -keystore ctf.keystore -alias ctfKeystore -keyalg RSA -keysize 2048 -validity 10000</span></pre><p id="6a98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建了密钥库之后，我现在可以使用一个名为<strong class="js iu"> jarsigner </strong>的工具对APK进行签名了。当提示输入密码时，我提供了之前创建密钥库时使用的密码。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="64f2" class="mn lf it mj b gy mo mp l mq mr">jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore ctf.keystore InsecureBankv2/dist/InsecureBankv2.apk ctfKeystore</span></pre><p id="c3a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我验证APK已经使用<strong class="js iu"> jarsigner </strong>签名了。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="0b14" class="mn lf it mj b gy mo mp l mq mr">jarsigner -verify -verbose -certs InsecureBankv2.apk</span></pre><p id="7661" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，使用名为<strong class="js iu"> zipalign </strong>的工具对准apk，以实现最佳装载。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="45ee" class="mn lf it mj b gy mo mp l mq mr">zipalign -v 4 InsecureBankv2.apk InsecureBankv2-aligned.apk</span></pre><p id="96fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在使用ADB安装我的新APK之前，我从我的模拟器中卸载了应用程序的未更改版本，其中“<em class="ko"> is_admin </em>”字符串资源设置为“<em class="ko"> yes </em>”。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="f0f2" class="mn lf it mj b gy mo mp l mq mr">adb install InsecureBankv2-aligned.apk</span></pre><p id="9724" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">成功安装后，我打开应用程序，一个名为“<em class="ko">创建用户</em>的新按钮出现了。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/03bc4767eda106d012be2364d2a4f881.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*b_iDTAxyaRsMQnWcWKOYRg.png"/></div></figure><p id="8161" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，查看"<em class="ko"> createUser() </em>"方法的源代码可以看出，该按钮实际上并不允许我们创建用户，因此这就得出该漏洞的结论。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nx"><img src="../Images/ea7eea5cd3b74eacd60b6fa970b8242d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDvYDZstbGgdS3YIYy36kw.png"/></div></div></figure></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h2 id="b486" class="mn lf it bd lg nh ni dn lk nj nk dp lo kb nl nm ls kf nn no lw kj np nq ma nr bi translated">开发者登录</h2><p id="f2f9" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我决定仔细看看当选择登录按钮时启动的“<em class="ko"> LoginActivity </em>”的“<em class="ko"> performLogin() </em>”方法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/97f2c9c21b0493ee7626e23eab74399c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*xktboT6naksG7gHpO9DX7Q.png"/></div></figure><p id="ab75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该方法创建一个新的intent，该intent启动“<em class="ko"> DoLogin </em>”活动，并将用户输入的凭证作为参数传递给该活动。查看这个活动的源代码，发现了一个有趣的方法，叫做“<em class="ko"> postData() </em>”。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nz"><img src="../Images/ca4da50024c8fdb1fb75a25db9486fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V9FpWptoO_9sC1UZQHA_-g.png"/></div></div></figure><p id="c833" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个方法用于向服务器发送登录凭证，但是我发现如果提供了用户名“<em class="ko"> devadmin </em>”，那么凭证将被发送到另一个名为“<em class="ko"> /devlogin </em>”的端点。我发现，如果我输入用户名“<em class="ko"> devadmin </em>”，然后提供任何密码，我都可以成功登录。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/9002b910cf1cccfadb6e9a481c2896c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*ETxACJ0M6Sq7N1gZfOcbYQ.png"/></div></figure><p id="db70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有趣的是，当用户登录时，使用“<em class="ko"> saveCreds() </em>”方法保存凭证。这个方法的代码可以在下面看到。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ob"><img src="../Images/ef755c3501a5769b66d24f9a31e9d3bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9P8rJ-gC7thzi1A1VaSTIg.png"/></div></div></figure><p id="737c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个方法创建一个名为“<em class="ko"> mySharedPreferences </em>的新文件，如果它还不存在的话。然后，该方法使用<strong class="js iu"> base64编码</strong>用户名，并使用<strong class="js iu"> AES加密</strong>加密密码，然后将它们存储在共享首选项文件中。每当用户使用其凭据成功登录时，该文件都会被覆盖。稍后知道这一点很重要…(伏笔)😏。</p></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h2 id="6306" class="mn lf it bd lg nh ni dn lk nj nk dp lo kb nl nm ls kf nn no lw kj np nq ma nr bi translated">凭证的不安全存储</h2><p id="cb77" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">登录活动使用户能够自动填充凭证，以避免他们每次登录时都必须输入用户名和密码。查看"<em class="ko"> LoginActivity </em>"源代码，我可以看到一个名为"<em class="ko"> fillData() </em>"的方法执行这个函数。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oc"><img src="../Images/df7f3ba758638284ecfae1633667c2ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_iTIiThDb2b4O8KS9RjojA.png"/></div></div></figure><p id="a871" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个方法的代码可以在下面看到。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi od"><img src="../Images/c0579d84570cba05f6553d0d5dca751e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*25qzwq4j8lzuTG4YouJ_BA.png"/></div></div></figure><p id="e7e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“<em class="ko"> fillData() </em>”方法正在打开一个名为“<em class="ko"> mySharedPreferences </em>”的文件，我之前在检查“DoLogin”活动源代码时看到这个文件是由“<em class="ko"> saveCreds() </em>”方法创建的。在用于填充登录输入字段之前，用户名和密码分别被解码和解密。我可以使用<strong class="js iu"> ADB </strong>来识别“<em class="ko"> mySharedPreferences </em>”文件存储在<em class="ko"> Insecurebankv2 </em>应用程序的私有目录中的什么位置</p><blockquote class="ms mt mu"><p id="a66d" class="jq jr ko js b jt ju jv jw jx jy jz ka mv kc kd ke mw kg kh ki mx kk kl km kn im bi translated">注意:除非您至少成功登录一次，否则不会创建该文件。</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oe"><img src="../Images/45ab0745c19889306328079bf47ae7f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qSTG-Simt1-i2y5Dp4vwg.png"/></div></div></figure><p id="117b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<strong class="js iu"> ADB </strong>，我可以将文件拉到我的本地机器上进行进一步检查。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="56d9" class="mn lf it mj b gy mo mp l mq mr">adb pull /data/data/com.android.insecurebankv2/shared_prefs/mySharedPreferences.xml</span></pre><p id="5a86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看文件，我可以看到用户名和密码是base64编码的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi of"><img src="../Images/e6fb70725afb2b13425e8e768e0f3be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHVoEzmZWMz-7Pu5t7KhYg.png"/></div></div></figure><p id="dce0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过查看之前的源代码，我知道用户名只进行了base64编码。使用一个在线工具，如<strong class="js iu"> CyberChef </strong>，我可以破解用户名。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi og"><img src="../Images/b9403b057b9851986ac390cfd13d7ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*nn7cPKcfNh992abGAfJK4Q.png"/></div></figure><p id="e052" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">阅读前面的源代码，我还可以看到密码是用一个名为“<em class="ko"> CryptoClass </em>”的类中的一个名为“<em class="ko">aesecuredtstring()</em>的方法加密的。查看这个类的源代码，我看到开发人员使用AES加密和<strong class="js iu">密码块链接(CBC) </strong>模式，但是使用了<strong class="js iu">静态初始化向量</strong>和<strong class="js iu">硬编码加密密钥</strong>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oh"><img src="../Images/618bf2ddad43815b60b56abaa17ec6f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9iHf-Ky28XkQSEXELZegOw.png"/></div></div></figure><p id="d4b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出于学习目的，我决定演示几种不同的方法来检索密码😃。</p><p id="f809" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一种方法是简单地使用一个在线工具，如<strong class="js iu"> CyberChef </strong>并插入所需的信息(即加密密钥、iv、密文)来解密密码。对于这种方法，我解码了base64密码，并将其编码为<strong class="js iu">十六进制</strong>，然后将其输入到<strong class="js iu">网络黑客</strong>工具中。这样就成功解密了存储在“mySharedPreferences”文件中的密码(即Jack@123$)，如下图所示。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oi"><img src="../Images/3d25d7c8d4fde567a439e76b5b83e64a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0nEyVk2u1OzB_V9o5IoNmQ.png"/></div></div></figure><p id="4c84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种方法是创建一个简单的python脚本，并使用如下所示的"<em class="ko"> pycryptodome </em>"包来解密密码。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/9d962dc5c988dd8f63d914ed23b6d3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*4_G7Wr1yHtiMsaXcEsRdAA.png"/></div></figure><p id="a270" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的最后一个方法演示了如何使用一个名为<strong class="js iu"> Frida </strong>的工具，使用应用程序自己的方法之一来解密密码。我找到了一个指南，它提供了一个有用的例子(<strong class="js iu">见参考文献</strong>)，告诉我如何用自己的参数挂钩和调用一个函数。这可以用来挂接“<em class="ko"> CryptoClass </em>”中一个名为“<em class="ko"> aesDeccryptedString() </em>”的函数，该函数取一个字符串参数，然后用我自己的参数(即加密的密码)调用它，然后解密。JavaScript代码(挂钩)如下所示:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ok"><img src="../Images/932d43d020a20967b383ce422a1cd7e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZk06alEVm-HR7xbnx8_2g.png"/></div></div></figure><p id="787e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面提供了用于加载这个钩子的python脚本。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi ol"><img src="../Images/bc0841c96319b5ccb3e6d2c3e157f2e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RWVXpfc1wYyYDUIBRwzPNA.png"/></div></div></figure><p id="db30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我确保<strong class="js iu"> Frida服务器</strong>正在我的模拟器上运行，然后执行我的python脚本来注入JavaScript代码。一旦我的脚本成功加载，我需要单击“<em class="ko">自动填充凭证</em>”按钮，这将导致“<em class="ko"> aesDeccryptedString() </em>”方法被调用，它的参数将被我的新参数(即加密的密码)覆盖。这成功地解密了密码。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi om"><img src="../Images/0b93cc0aead51eaa736abb5a2faa3805.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*1kJNyv3n-OeiC3pRS7pOmA.png"/></div></figure><p id="187b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的输出中，我首先尝试自动填充用户“<em class="ko"> jack </em>”的凭证，作为概念证明，我们已经知道了他的密码。然后，我尝试自动填充用户"<em class="ko"> dinesh </em>"的凭证，但正如上面的输出所示，我的frida脚本用用户"<em class="ko"> jack </em>"的加密密码覆盖了他的加密密码，并对其进行了解密。</p></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="9829" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结束语</h1><p id="8292" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我的“insecurebank v2”Android应用程序演练的第1部分到此结束。在第2部分中，我将会看到更多可以在应用程序中发现的漏洞，并试图展示它们是如何被利用的。感谢您阅读到最后，我们将在第2部分再见😄！</p></div><div class="ab cl kx ky hx kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="im in io ip iq"><h1 id="ed87" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参考</h1><ul class=""><li id="c976" class="on oo it js b jt mc jx md kb op kf oq kj or kn os ot ou ov bi translated"><a class="ae ow" href="https://github.com/dineshshetty/Android-InsecureBankv2" rel="noopener ugc nofollow" target="_blank">https://github.com/dineshshetty/Android-InsecureBankv2</a></li><li id="da4f" class="on oo it js b jt ox jx oy kb oz kf pa kj pb kn os ot ou ov bi translated">(<strong class="js iu">设置指南</strong>)<a class="ae ow" href="https://github.com/dineshshetty/Android-InsecureBankv2/blob/master/Usage%20Guide.pdf" rel="noopener ugc nofollow" target="_blank">https://github . com/dineshshetty/Android-insecurebank v2/blob/master/Usage % 20g uide . pdf</a></li><li id="0b84" class="on oo it js b jt ox jx oy kb oz kf pa kj pb kn os ot ou ov bi translated">(<strong class="js iu">打补丁APK</strong>)<a class="ae ow" href="https://medium.com/@sandeepcirusanagunla/decompile-and-recompile-an-android-apk-using-apktool-3d84c2055a82" rel="noopener">https://medium . com/@ sandeepcirusanagunla/decompile-and-recompile-an-Android-apk-using-apk tool-3d 84c 2055 a82</a></li><li id="5b65" class="on oo it js b jt ox jx oy kb oz kf pa kj pb kn os ot ou ov bi translated">(<strong class="js iu">弗里达代码链接</strong>)<a class="ae ow" href="https://book.hacktricks.xyz/mobile-apps-pentesting/android-app-pentesting/frida-tutorial/frida-tutorial-2" rel="noopener ugc nofollow" target="_blank">https://book . hack tricks . XYZ/mobile-apps-pentest/Android-app-pentest/Frida-tutorial/Frida-tutorial-2</a></li></ul></div></div>    
</body>
</html>