<html>
<head>
<title>HTTP Based Python Trojan for Remote System Forensics and Privilege Transfer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于远程系统取证和权限转移的基于HTTP的Python特洛伊木马</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/python-http-based-trojan-for-remote-system-forensics-and-privilege-transfer-ae128891b4de?source=collection_archive---------1-----------------------#2020-07-17">https://infosecwriteups.com/python-http-based-trojan-for-remote-system-forensics-and-privilege-transfer-ae128891b4de?source=collection_archive---------1-----------------------#2020-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/43e64dc749cfea0a31a681529c159f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*xb2tw33bnzRUJh9I4GJaaw.jpeg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">来源:<a class="ae kb" href="https://gotowebsecurity.com/ethical-hacking-course-trojans-lab-session/" rel="noopener ugc nofollow" target="_blank">https://gotowebsecurity . com/ethical-hacking-course-trojans-lab-session/</a></figcaption></figure><h1 id="201f" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">概观</h1><p id="df6e" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在本文中，我们将构建一个基于python的特洛伊木马，它具有以下功能:</p><ol class=""><li id="1a43" class="ly lz it lc b ld ma lh mb ll mc lp md lt me lx mf mg mh mi bi translated">远程下载无关代码到特洛伊木马并运行它</li><li id="870f" class="ly lz it lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">更新在(1)中下载的代码</li><li id="7f2f" class="ly lz it lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">自我更新</li><li id="a4b9" class="ly lz it lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">重新运行自身(对除SIGKILL之外的任何信号免疫)</li><li id="2155" class="ly lz it lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">获取并转移root权限(从而在目标机器上做任何事情)</li><li id="3199" class="ly lz it lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">通过HTTP向攻击者发送数据</li></ol><p id="e28b" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">我们从一个简单的假设开始:目标执行一些对它有益的代码。它可能是任何类似python包的东西，用来完成用户认为值得做的任务。</p><p id="f514" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">源代码:<a class="ae kb" href="https://github.com/NimishMishra/networking/tree/master/remote_system_forensics" rel="noopener ugc nofollow" target="_blank"> Github </a></p><h1 id="0fab" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">介绍</h1><p id="935c" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">特洛伊木马之所以强大，是因为它们看起来很漂亮，而且是逃避嫌疑的首选。一旦运行，它们就开始执行它们的恶意意图，同时在攻击者看来完全没问题。更有甚者，因为目标(尤其是开发者)是<em class="mr">通常</em>不会怀疑抓取开源/包代码并运行它。这可能是我们利用的一个很好的切入点。</p><h1 id="9aa6" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">“好”代码</h1><p id="67f0" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">好的代码很简单。它做目标想要它做的事情。它可能跨越多种事物，跨越一个完整的包；代码库越大，发现活动就越微妙。我们将跳过这一部分，写一个简单的代码打印一些东西。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">意图有点坏的好代码。</figcaption></figure><p id="6593" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">对于目标来说，这个脚本应该做它应该做的事情(在我们的例子中是打印一个简单的行),然后平静地退出。除此之外，这里主要的东西是其他的东西。该脚本构建了一个目录(在正常情况下，您可能希望工作目录隐藏在某个地方。为了简洁明了起见，我将跳过这个步骤)<code class="fe my mz na nb b">downloaded</code>`，切换到它，向<code class="fe my mz na nb b">http://192.168.43.38:9000/downloader.py</code>的某个服务器发出一个cURL请求(在这里阅读关于cURL <a class="ae kb" href="https://curl.haxx.se/docs/" rel="noopener ugc nofollow" target="_blank">的更多信息</a>，并下载返回给python脚本<code class="fe my mz na nb b">downloader.py</code>的内容。然后它发出命令<code class="fe my mz na nb b">python3 downloader.py</code>并平静地退出。由于使用了<code class="fe my mz na nb b">Popen</code>，子进程(运行<code class="fe my mz na nb b">downloader.py</code>)在父进程退出时与父进程<code class="fe my mz na nb b">good.py</code>分离，并与<code class="fe my mz na nb b">init</code>关联。所以实际上，它变成了一个独立的过程。函数<code class="fe my mz na nb b">run_command()</code>是python中外壳的等价物。它运行指定的命令，并返回来自<code class="fe my mz na nb b">STDOUT</code>的输出，或者如果使用shell，您将会收到的结果。</p><p id="01fd" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">现在是配置这个<code class="fe my mz na nb b"><a class="ae kb" href="http://192.168.43.38:9000." rel="noopener ugc nofollow" target="_blank">http://192.168.43.38:9000.</a></code>的时候了</p><h1 id="b571" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">服务器端</h1><p id="1d8e" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这个想法是建立一个自动将代码推送到远端的服务器。稍后，它将用于实时更新代码、传输文件、命令等等。我们需要做的就是配置一个能够处理<code class="fe my mz na nb b">POST</code>和<code class="fe my mz na nb b">GET</code>的HTTP服务器。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">setup_server.py中的基本HTTP服务器框架</figcaption></figure><p id="6fb5" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">python中的一个<code class="fe my mz na nb b">HTTPServer</code>依赖于两条信息:把它放在哪里和在交互中做什么。前一部分由<code class="fe my mz na nb b">('192.168.43.38', 9000)</code>处理，用于将服务器绑定到机器的端口<code class="fe my mz na nb b">9000</code>，而<code class="fe my mz na nb b">192.168.43.38</code>是本地IP。后一部分由一个单独的类处理，该类扩展了定义<code class="fe my mz na nb b">POST</code>和<code class="fe my mz na nb b">GET</code>功能的<code class="fe my mz na nb b">BaseHTTPRequestHandler</code>。<code class="fe my mz na nb b">_set_response()</code>函数用于发送强制<code class="fe my mz na nb b">HTTP</code>报头信息(报头、代表成功的代码200和代表报头结束的end报头)。因为我们将处理文本数据，所以将<code class="fe my mz na nb b">Content-type</code>设置为<code class="fe my mz na nb b">text/html</code>就可以了。现在添加两个主要功能。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">GET.py</figcaption></figure><p id="7cf3" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">一个<code class="fe my mz na nb b">GET</code>请求，其中包含一个要获取的路径。在这种情况下，它将是<code class="fe my mz na nb b">http://192.168.43.38:9000/filepath</code>中的<code class="fe my mz na nb b">filepath</code>形式。它可能是空的(类似于你访问的网站的主页)或者它包含一些东西(类似于你从主页访问的其他页面)。在我们的例子中，当对我们的<em class="mr"> home、</em>即<code class="fe my mz na nb b">http://192.168.43.38:9000/</code>进行<code class="fe my mz na nb b">GET</code>操作时，我们希望返回服务器中可用文件的列表，并在请求特定文件时返回文件的内容，如<code class="fe my mz na nb b">http://192.168.43.38:9000/downloader.py</code>所示。技术是区分两种情况，在后一种情况下打开文件，创建一个响应，然后用<code class="fe my mz na nb b">wfile.write()</code>发送响应。</p><p id="1a75" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated"><code class="fe my mz na nb b">POST</code>请求包含必须处理的数据。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">POST.py</figcaption></figure><p id="1924" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">它从HTTP头中获取长度，使用<code class="fe my mz na nb b">rfile.read()</code>提取数据，并存储到一个文件中。使用<code class="fe my mz na nb b">SPLIT</code>进行拆分只是一种方便的换行符处理方式(对我来说！我从来不能在通过网络发送的数据中保留新行。对一个文件来说，它看起来像一个巨大的单行数据。为了克服这个问题，我在目标端用一个<code class="fe my mz na nb b">SPLIT</code>替换<code class="fe my mz na nb b">\n</code>，然后在服务器端替换回来。最后，我们使用<code class="fe my mz na nb b">wfile.write().</code>发送一个<code class="fe my mz na nb b">POST OK</code></p><p id="6108" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">现在我们继续制作其他东西。第一，<code class="fe my mz na nb b">downloader.py</code></p><h1 id="2e61" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">第一阶段执行</h1><p id="5e79" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我们的好代码用于将一个简单的<code class="fe my mz na nb b">downloader.py</code>加载到指定的目录并执行它。现在主要由<code class="fe my mz na nb b">downloader.py</code>来处理其他一切。首先，我们希望<code class="fe my mz na nb b">downloader.py</code>能够处理这些事情:</p><ol class=""><li id="6355" class="ly lz it lc b ld ma lh mb ll mc lp md lt me lx mf mg mh mi bi translated">知道服务器端的文件何时被更新。</li><li id="147c" class="ly lz it lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">知道<code class="fe my mz na nb b">downloader.py</code>本身的代码何时更新。</li><li id="7387" class="ly lz it lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">回避所有可能的信号(甚至不是一个简单的<code class="fe my mz na nb b">kill PID</code>应该终止它)。</li><li id="a3e8" class="ly lz it lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">从服务器端下载更新文件并执行。</li><li id="b620" class="ly lz it lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">隐藏自身(子主题太大，因此不在此讨论)。</li><li id="c4e7" class="ly lz it lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">调度本身(与<code class="fe my mz na nb b">cron</code>相关，这里不涉及)并构建内核持久性。</li></ol><p id="6464" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">对于前两者，下面的代码就足够了。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">下载者. py</figcaption></figure><p id="8938" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">可能有几种方法来检查状态。我决定创建一个特殊的文件<code class="fe my mz na nb b">status.txt</code>，在两行上有二进制数字。第一行有一个0/1，表示服务器上的文件是否已经更新(或者攻击者是否想要重新运行某些程序)，第二行有一个0/1，表示<code class="fe my mz na nb b">downloader.py</code>本身是否需要更新。非常直观地，我们下载<code class="fe my mz na nb b">status.txt</code>并分析标志。如果我们在第一行获得1，我们继续获取和下载文件(因为更新<code class="fe my mz na nb b">downloader.py</code>也涉及相同的操作，这里不检查第二个标志)。当数据被检索时，我们删除<code class="fe my mz na nb b">status.txt</code>,因为不再需要它。</p><p id="d1e5" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">第三个要求简单地处理如下。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">处理信号和端接</figcaption></figure><p id="4de6" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">接收到的以下任何信号都会导致<code class="fe my mz na nb b">downloader.py</code>的重新下载，并作为新过程重新运行。只有不可忽略的<code class="fe my mz na nb b">SIGKILL</code>杀死进程。</p><p id="f83b" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">第四部分也是主要部分是这样的。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">获取文件</figcaption></figure><p id="3ffb" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">回想一下关于<code class="fe my mz na nb b">GET</code>的讨论，表单<code class="fe my mz na nb b">http://192.168.43.38:9000</code>的请求返回服务器中托管的文件列表。我们获取列表并运行一个循环(忽略<code class="fe my mz na nb b">status.txt</code>，因为它已经被下载并分析过了)。如果我们获得了<code class="fe my mz na nb b">downloader.py</code>(即它在服务器上可用)和<code class="fe my mz na nb b">data[1] == 1</code>(它需要更新)，我们将触发<code class="fe my mz na nb b">refresh_downloader()</code>，通过重新下载、运行一个新进程并退出当前进程来刷新<code class="fe my mz na nb b">downloader.py</code>。如果不是这样，我们只需创建一个要下载的文件列表，这些文件将在下一个代码片段中处理。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">下载文件</figcaption></figure><p id="cfc0" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">只需对相应的URL创建cURL请求并下载文件。一旦下载完毕，<code class="fe my mz na nb b">run_scripts()</code>将运行工作目录中的所有文件，除了<code class="fe my mz na nb b">downloader.py</code>(只要<code class="fe my mz na nb b">status.txt</code>的第一行有一个1，就会产生一个fork bomb:表示继续下载和刷新文件的标志)和<code class="fe my mz na nb b">setup_server.py</code>(包含前面讨论过的服务器脚本)。[你不应该把<code class="fe my mz na nb b">setup_server.py</code>放在服务器上，但是我很懒，没有修复它:]。</p><p id="a1c6" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">这里是<code class="fe my mz na nb b">downloader.py</code>的完整代码</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">添加注释行' command_list.append("sudo ")是为了稍后进行特权转移。</figcaption></figure><p id="1656" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">差不多就是这样！</p><h1 id="a9d1" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">样品运行</h1><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/c066c79e07fd52f7cf4e134d8231e748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hN6S0w-J3fO--rGB-_hdgQ.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">目标端的初始设置。</figcaption></figure><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nh"><img src="../Images/f13a4be7ed07a21c05f9dce32aa0f6a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtqqZLhmQ03ACmNjlkp5MQ.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">攻击者端的初始设置</figcaption></figure><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ni"><img src="../Images/0a9033eb404301cb21c77201742cd4e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VA7TjOqSvA4O2JFVluDlXg.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">运行good.py注意左边的ps -A输出。</figcaption></figure><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nj"><img src="../Images/09b88b0dbc43925cad01046d47330325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gGDTmAccR4nQCg04o1tjHA.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">请注意good.py退出后的ps -A输出。</figcaption></figure><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nk"><img src="../Images/dc5869d9a34ff900677a93f7f710427c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Rr8D0O2qqZ9sdcuHZXheQ.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">downloader.py对status.txt的服务器执行GET请求</figcaption></figure><p id="ef82" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated"><code class="fe my mz na nb b">status.txt</code>到现在设定为:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/ab7118200ff522df31b3e3358242da05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*5qQ-NU0BqHhksJnRjXhnUQ.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">包含0和0的简单两行文本文件。</figcaption></figure><p id="b78c" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">现在更新一下<code class="fe my mz na nb b">downloader.py.</code>的某些部分，我在<code class="fe my mz na nb b">while</code>循环中的<code class="fe my mz na nb b">check_status()</code>调用之前添加了一个简单的<code class="fe my mz na nb b">print</code>语句。然后将<code class="fe my mz na nb b">status.txt</code>设置为1和1。等待<code class="fe my mz na nb b">GET</code>请求。结果如下:</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nm"><img src="../Images/24063d2aa98dcdd1d5dcb1dfef0f8a3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cRupvMf6QQP-xTd3AW1CQ.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">当状态更改为1和1时，请注意左边是如何对downloader.py发出GET请求的。</figcaption></figure><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/0fa9fa6a1b0e3cb6b57aa0004a9ad67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*Ijh293Jk63fBIQ1h5L_Q-A.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">印刷</figcaption></figure><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi no"><img src="../Images/025a7d43ccb6dce2d1fdaeb12a7fe28a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sy3nGm2q2ECSKDAMzFQvmA.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">注意downloader.py的PID的变化</figcaption></figure><h1 id="f19a" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">第二阶段执行</h1><p id="b114" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">既然推动远程代码的通用框架已经建立并运行，现在是时候编写一些漏洞了。你可以用它来创造。我没有，我想出了两个主意:</p><ol class=""><li id="b4f2" class="ly lz it lc b ld ma lh mb ll mc lp md lt me lx mf mg mh mi bi translated">运行一组命令</li><li id="fb91" class="ly lz it lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">查询某个目录(递归读取子目录中的所有文件并返回到目标)</li></ol><p id="5123" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">我们将<code class="fe my mz na nb b">commands.txt</code>预定义为攻击者存储需要在目标机器上执行的命令的标准。同样，<code class="fe my mz na nb b">directory.txt</code>是要查询的目录的集合。</p><p id="2b2a" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">我们建立了第一个漏洞。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">命令_执行者. py</figcaption></figure><p id="c047" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">打开<code class="fe my mz na nb b">commands.txt</code>,逐行读取命令，执行它们，制作响应，并将其发送回服务器，这是非常简单的实现。</p><p id="4d8a" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">第二个漏洞如下。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">directory_enlister.py</figcaption></figure><p id="ff37" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">该漏洞打开文件<code class="fe my mz na nb b">directory.txt</code>并读取目标目录。然后它触发<code class="fe my mz na nb b">enlist_directory()</code>,分别列出文件和子目录。对于每个文件，它读取(<code class="fe my mz na nb b">cat filename</code>)并创建一个响应。对于每个子目录，它将完整的路径添加到主列表<code class="fe my mz na nb b">directory_list</code>中，这反过来确保当附加的子目录也被查询以查找其中的其他文件和子目录时，会有一个机会。</p><p id="2cb5" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">就是这样！制作<code class="fe my mz na nb b">commands.txt</code>和<code class="fe my mz na nb b">directories.txt</code>并继续执行它们。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi np"><img src="../Images/f13fb1322cf045cbfe3485d78bdd2929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*KvxnrWdI649Zy2pfgVVhsw.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">样本(关于目标的仍然相当敏感的信息)</figcaption></figure><h1 id="d6e9" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">样品运行</h1><p id="0bcb" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">当服务器启动并运行时，将两个文本文件和两个漏洞都移动到服务器，并将<code class="fe my mz na nb b">status.txt</code>更改为1和0(意味着更新文件，但<code class="fe my mz na nb b">downloader.py</code>不需要更新，这又意味着更新并运行其他文件，从而运行我们的漏洞)。</p><p id="82b2" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">根据目标的连接以及第二次攻击中的<code class="fe my mz na nb b">time.sleep(30)</code>,传输数据需要一段时间。但是一旦发生了，你就会意识到你刚刚得到了什么。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nq"><img src="../Images/648ab82861b4371d9f1bed6b4a02b726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qD2T2AQR7NX0ze_mb4pH6w.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">状态更改说明如何发出GET请求</figcaption></figure><p id="b897" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">下载了几个文件。我把它们移到不同的目录下，并对它们进行了分析。这是一张快照。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/aa9bea51dc7b63ce444b803719276301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*ToHp8iTHwc3_35I0uBtZ4Q.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">“的内容”是由directory_enlister.py在读取文件内容并存储它们以发送回服务器时添加的。这些是在各自*中包含数据的文件列表。txt文件。</figcaption></figure><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ns"><img src="../Images/2f77923df13a8e22386e5ecf33d4376f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTeSdHaGl4Tj8pvePf8Yaw.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">一个样本。的内容。bash_profile、ifconfig以及一个压缩的gz文件</figcaption></figure><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/02cd878b6a4fd3931afe13fe1ce39a79.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*kdR0-jTBB3qdrMr3OF0bjA.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">其数据被发送到服务器的一些文件</figcaption></figure><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/7839670bcb62162f2adf8dbcd244de85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*9gvxRmKAtMoq2Zq7TUPNtw.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">与目标邮箱相关的文件</figcaption></figure><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nv"><img src="../Images/601b8d015c6d6906c13ee1f864c6fae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q9GInr5XoZcKqf91SUu4sw.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">一些邮件数据。注意:未加密的邮件数据可能包含大量关于目标的信息。</figcaption></figure><p id="a09d" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">下面是一些浏览数据。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nw"><img src="../Images/8ed817ff6eb43431987e019f48c03857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nmHHZEehSFadp-xRbs_Q-A.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">Safari上的热门网站</figcaption></figure><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nx"><img src="../Images/65460b088309333dd5f183738e01fdcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwzWwJJi60YHDVcp30K6hw.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">最近关闭的选项卡</figcaption></figure><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/49aa3a47635f17d6cb3874f45944dde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*O3amCaP7W7L_49pfe-JQIQ.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">可供分析的Safari文件列表</figcaption></figure><h1 id="642d" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">特权转移</h1><p id="2baf" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">最有趣的任务需要root访问权限。虽然特权提升有复杂的机制，但我们在这里有一点优势:<em class="mr">sudo进程的子进程有根访问权。</em></p><p id="5eb8" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">你只需要说服目标以root身份运行<code class="fe my mz na nb b">good.py</code>。这应该不难；用户有时会给那些没有root权限就无法运行的代码授予root权限(就像任何Scapy代码一样)。</p><p id="6153" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">让我们构建一个简单的嗅探器，如果没有root访问权限，它将无法运行。在做任何进一步的事情之前，在<code class="fe my mz na nb b">Popen()</code>出现的任何地方将所有<code class="fe my mz na nb b">COMMAND</code>从<code class="fe my mz na nb b">python3 filename.py</code>更改为<code class="fe my mz na nb b">sudo python3 filename.py</code>(当<code class="fe my mz na nb b">good.py</code>成为<code class="fe my mz na nb b">Popen </code>下载器时也是如此)。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">sniffer.py</figcaption></figure><p id="c546" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">我们会通过服务器上传，然后下载。现在让目标运行<code class="fe my mz na nb b">good.py</code>。它从root访问权限进行提示。由于代码对目标有意义和用途，目标很可能会授予根用户访问权限。现在开始您的特权转移，其中<em class="mr">根访问被转移给所有孩子。如果嗅探器运行，我们将验证这一点。</em></p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/840f975b783d4cafdef6dd76a49e0a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*kBX-K4fHFmm8yn017zSlag.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">Scapy sniffer运行时没有进一步的提示</figcaption></figure><p id="a43e" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">Scapy需要root访问权限，这里我们只是从给予<code class="fe my mz na nb b">good.py</code>的root访问权限运行了一个scapy程序。它从<code class="fe my mz na nb b">good.py</code>转移到<code class="fe my mz na nb b">downloader.py</code>，后者转移到它产生的所有子进程。因此，嗅探器能够正常运行。此外，终止进程也需要root权限。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oa"><img src="../Images/f09e506f61385b85ae15d9c0440db3bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*klOBjHffFQ-e4aXaFQHd6w.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">终止directory_enlister.py进程的Root访问权限</figcaption></figure><h1 id="dc56" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="f2d5" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">唯一剩下的就是构建自我隐藏的功能。这是一个广泛的话题，研究rootkits可能是开始思考这个问题的好方法。</p><p id="fc61" class="pw-post-body-paragraph la lb it lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx im bi translated">祝你今天开心！玩的开心！</p></div></div>    
</body>
</html>