<html>
<head>
<title>Elliptic Curve Signatures and How to Use Them in Your Java Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">椭圆曲线签名以及如何在Java应用程序中使用它们</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/elliptic-curve-signatures-and-how-to-use-them-in-your-java-application-b88825f8e926?source=collection_archive---------0-----------------------#2020-12-23">https://infosecwriteups.com/elliptic-curve-signatures-and-how-to-use-them-in-your-java-application-b88825f8e926?source=collection_archive---------0-----------------------#2020-12-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4ef4c507eaf13d17e8d4d4337a1add05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2eAJ1eq2E7xMnqH0YQC-7Q.jpeg"/></div></div></figure><p id="607a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您想要发送一条消息，并且您想要确保a)接收者能够检测到该消息是否被修改(<strong class="kd iu">完整性</strong>)以及b)接收者能够验证您是这条消息的作者(<strong class="kd iu">消息认证</strong>)。在这种情况下，通常使用数字签名对邮件进行数字签名。</p><p id="b1cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">实际上，数字签名还提供了</em><strong class="kd iu"><em class="kz"/></strong><em class="kz">的不可否认性，即发送方不能否认对消息的签名。然而，提供完整性和消息认证是签名的两个最常见的用例。</em></p><p id="9d10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">初始步骤</strong></p><p id="642e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最初，您创建一个<strong class="kd iu">公钥</strong>和一个<strong class="kd iu">私钥</strong>。你只能做一次。当你想要签署一个信息，你使用私人钥匙。要验证签名，可以使用公钥。私钥是一个秘密密钥，不得与其他人共享，因为拥有该密钥的每个人都能够计算出有效的签名，并可以欺骗消息的接收者，使其相信该消息是由您发出的。另一方面，公钥需要分发给应该能够验证签名的每个人，即公钥是公开的。</p><p id="d724" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">签名和验证消息的步骤</strong></p><p id="8f59" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您已经创建了公钥和私钥，通常会对消息进行如下签名:</p><ol class=""><li id="5d38" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">使用诸如SHA-256的加密散列函数计算消息<em class="kz"> m </em>的散列<em class="kz"> h </em>。</li><li id="fee3" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">使用私钥计算散列的签名<em class="kz"> s </em>。</li><li id="22b8" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">将消息<em class="kz"> m </em>和签名<em class="kz"> s </em>发送给接收者。</li><li id="548a" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">接收者用发送者的公钥验证签名<em class="kz"> s </em>。</li></ol><p id="1902" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">算法</strong></p><p id="1f79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最常用的签名算法是由国家标准与技术研究所(NIST)在<a class="ae lo" href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf" rel="noopener ugc nofollow" target="_blank">FIPS 186–4</a>中标准化的算法。它们是RSA数字签名算法，2)数字签名算法(DSA)和3)椭圆曲线数字签名算法(ECDSA)。</p><p id="e0ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从这三种算法来看，DSA不应再用于生成数字签名，因为该算法将不再被NIST的<a class="ae lo" href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5-draft.pdf" rel="noopener ugc nofollow" target="_blank">FIPS 186–5</a>(FIPS-186–4的继任者)批准。相反，FIPS-186–5将只批准DSA签名的验证。但是，RSA和ECDSA签名的生成仍然被批准，此外，使用EdDSA数字签名算法(edd sa)生成签名也被批准。</p><p id="00f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ECDSA和EdDSA都基于椭圆曲线，DSA基于<a class="ae lo" href="https://en.wikipedia.org/wiki/Discrete_logarithm" rel="noopener ugc nofollow" target="_blank">离散对数问题</a>，RSA的安全性基于<a class="ae lo" href="https://en.wikipedia.org/wiki/Integer_factorization" rel="noopener ugc nofollow" target="_blank">分解大数</a>(将一个合数分解成更小的整数)的问题和<a class="ae lo" href="https://en.wikipedia.org/wiki/RSA_problem" rel="noopener ugc nofollow" target="_blank"> RSA问题</a>(取<em class="kz"> e </em>次根模一个合数n)，对于这些问题没有有效的算法存在。</p><p id="3135" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">安全级别和密钥大小</strong></p><p id="bd4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基于椭圆曲线的签名算法的巨大优势在于，与RSA相比，它们需要更小的密钥来实现相同的安全级别，从而导致更小的签名和降低的计算要求。因此，这些算法特别适合嵌入式和物联网设备，也适合需要计算或验证大量签名的应用。</p><p id="fe7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">安全级别通常以位数来衡量。例如，如果一个系统提供5位的安全性，攻击者需要执行2 ^ 2 ^ 2 ^ 2 = 32(2的5次方)次运算才能破解它。对于AES等对称密码，安全级别通常等于所用密钥的大小。对于诸如RSA、ECDSA和EdDSA之类的非对称算法，密钥大小的安全级别是根据基础数学问题的难度来估计的。每次发现新攻击时都会调整级别，这减少了解决数学问题的工作量。NIST已在<a class="ae lo" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf" rel="noopener ugc nofollow" target="_blank"> NIST特别出版物800–57第1部分第5版</a>中公布了他们对关键尺寸的建议。下表显示了不对称算法的摘要。</p><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/0594a1a82e6b7b6fcbb1a37c63613aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*3o88FGqlyl5M3bjxy8V7Gg.png"/></div></figure><p id="8730" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，在出版物800–57第1部分修订版5中，NIST不再批准安全级别低于112位的密钥大小，至少在使用加密技术保护联邦政府信息时是如此。</p><p id="931d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不同组织对密钥大小的建议可能略有不同。还可以在<a class="ae lo" href="https://www.keylength.com/" rel="noopener ugc nofollow" target="_blank">这里</a>找到建议的概述。</p><p id="06b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">签名大小</strong></p><p id="ae4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">签名的大小取决于算法和密钥大小。RSA签名的大小等于密钥的大小。例如，如果您使用3072位密钥对消息进行签名，签名的大小就是3072位(384字节)。ECDSA和EdDSA签名的大小是所用密钥的两倍。例如，如果您使用256位密钥来实现128位安全性，签名将是512位(64字节)。</p><h1 id="7d51" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">用Java计算ECDSA签名</h1><p id="3d08" class="pw-post-body-paragraph kb kc it kd b ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku mw kw kx ky im bi translated"><strong class="kd iu">选择一条曲线</strong></p><p id="ea5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从版本7开始Java支持各种椭圆曲线。如果您的机器上安装了jshell，那么通过在jshell中执行以下Java代码，您可以很容易地获得所有受支持曲线的列表:</p><pre class="lq lr ls lt gt mx my mz na aw nb bi"><span id="3d12" class="nc lv it my b gy nd ne l nf ng">jshell&gt; import java.security.*;<br/>jshell&gt; Security.getProvider("SunEC").getService(<br/>   ...&gt;   "AlgorithmParameters", "EC").getAttribute(<br/>   ...&gt;   "SupportedCurves")</span></pre><p id="d5e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该列表应至少包含以下曲线:</p><pre class="lq lr ls lt gt mx my mz na aw nb bi"><span id="0e37" class="nc lv it my b gy nd ne l nf ng">secp192r1 (NIST P-192)<br/>secp224r1 (NIST P-224)<br/>secp256r1 (NIST P-256)<br/>secp384r1 (NIST P-384)<br/>secp521r1 (NIST P-521)</span></pre><p id="313a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些曲线已经被NIST在<a class="ae lo" href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf" rel="noopener ugc nofollow" target="_blank">FIPS 186–4</a>标准化了。前缀“sec”代表“有效加密标准”，字母“p”表示该曲线在素数域上，“p”后面的数字表示密钥大小，最后，字母“r”表示曲线的参数是可验证地随机选择的。有关命名约定、曲线及其参数的更多详细信息，也可以在“<a class="ae lo" href="https://perso.univ-rennes1.fr/sylvain.duquesne/master/standards/sec2_final.pdf" rel="noopener ugc nofollow" target="_blank">第2节:推荐的椭圆曲线域参数</a>”中找到。</p><p id="81e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下面的例子中，我们使用曲线secp224r1，它提供112位的安全级别，产生小签名，并且不需要太多资源来计算签名。这条曲线非常适合大多数具有高安全性和高性能要求的应用。</p><p id="5035" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">创建公钥和私钥</strong></p><p id="ab8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在签署消息之前，我们必须创建一个公钥和私钥。我们的做法如下:</p><pre class="lq lr ls lt gt mx my mz na aw nb bi"><span id="b186" class="nc lv it my b gy nd ne l nf ng">import java.security.*;<br/>import java.security.spec.*;</span><span id="fc0c" class="nc lv it my b gy nh ne l nf ng">KeyPairGenerator g = KeyPairGenerator.getInstance("EC","SunEC");<br/>ECGenParameterSpec ecsp = new ECGenParameterSpec("secp224r1");<br/>g.initialize(ecsp);</span><span id="a2d8" class="nc lv it my b gy nh ne l nf ng">KeyPair kp = g.genKeyPair();<br/>PrivateKey privKey = kp.getPrivate();<br/>PublicKey pubKey = kp.getPublic();</span></pre><p id="aa7e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们选择签名算法。这里，我们使用ECDSA对消息的SHA-256哈希进行签名。</p><pre class="lq lr ls lt gt mx my mz na aw nb bi"><span id="5816" class="nc lv it my b gy nd ne l nf ng">Signature s = Signature.getInstance("SHA256withECDSA","SunEC");<br/>s.initSign(privKey);</span></pre><p id="1f76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们计算消息的签名。首先，我们调用<em class="kz">签名</em>实例的<em class="kz">更新</em>函数，并提供消息作为输入。然后我们调用计算并返回签名的<em class="kz"> sign </em>方法。</p><pre class="lq lr ls lt gt mx my mz na aw nb bi"><span id="d6d0" class="nc lv it my b gy nd ne l nf ng">byte[] msg = "Hello, World!".getBytes("UTF-8");<br/>byte[] sig;<br/>s.update(msg);<br/>sig = s.sign();</span></pre><p id="65ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，签名存储在字节数组“sig”中。</p><p id="7042" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">消息的接收者现在可以验证签名，如下所示:接收者创建一个<em class="kz">签名</em>的实例，并用公钥初始化这个实例。然后用消息更新这个实例，最后接收者可以通过用要验证的签名调用<em class="kz">验证</em>方法来验证签名。</p><pre class="lq lr ls lt gt mx my mz na aw nb bi"><span id="68fb" class="nc lv it my b gy nd ne l nf ng">Signature sg = Signature.getInstance("SHA256withECDSA", "SunEC");<br/>sg.initVerify(pubKey);<br/>sg.update(msg);<br/>boolean validSignature = sg.verify(sig);</span></pre><p id="10a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果提供的消息与计算签名的消息相同，那么<em class="kz">验证</em>方法将返回true，否则返回false。</p><p id="ded8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完整的源代码也可以在GitHub <a class="ae lo" href="https://gist.github.com/daniel-e/f7bae1f16ba7132c435a6d7b4a573280" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="d61a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">性能</strong></p><p id="f2e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了了解我们每秒可以计算多少个签名，我写下了“你好，世界！”消息，并测量了在一个CPU内核上运行2.3GHz的i5–5300 u所花费的时间。我重用了signature实例，即在每次迭代中，我只调用了<em class="kz"> update </em>和<em class="kz"> sign </em>方法。</p><p id="7093" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下表总结了结果。</p><figure class="lq lr ls lt gt ju gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/8298deac5eb15c5009cd04aa2b601267.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*jVYBV2_iWfIxZEy56dz_4g.png"/></div></figure><p id="814e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">结论</strong></p><p id="8e80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于存在许多不同的曲线，并且一条曲线有时以不同的名称为人所知，椭圆曲线加密可能会令人困惑。通常，由NIST标准化的曲线(即P-192 aka secp192r1、P-224 aka secp224r1等)对于大多数具有高安全性要求的应用应该是足够的。</p><p id="ba40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从Java 7开始，计算椭圆曲线签名变得非常容易，因为从那时起，Java支持最常用的曲线。不再需要外部依赖。此外，计算或验证签名所需的行数非常少，因此代码简单明了。</p><p id="ffd4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">键尺寸较小的曲线非常适合高性能应用。在具有四个核心的现代CPU上，您应该能够每秒计算超过10，000个签名。</p></div></div>    
</body>
</html>