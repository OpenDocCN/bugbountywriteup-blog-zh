<html>
<head>
<title>Linux Kernel Module Rootkit — Syscall Table Hijacking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux内核模块Rootkit —系统调用表劫持</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/linux-kernel-module-rootkit-syscall-table-hijacking-8f1bc0bd099c?source=collection_archive---------0-----------------------#2020-02-01">https://infosecwriteups.com/linux-kernel-module-rootkit-syscall-table-hijacking-8f1bc0bd099c?source=collection_archive---------0-----------------------#2020-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bd67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将讨论使用Linux内核syscall表的系统调用劫持。我将向您展示如何以两种不同的方法获得syscall表的地址，以及如何应用它们来进行系统调用以完成(几乎)您想要的一切(挂钩)。</p><h1 id="f5d6" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">LKM概述</h1><p id="824b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我假设，如果你读到这里，这意味着你已经对LKM(可加载内核模块)有了足够的了解，所以如果你有，可以跳到下一部分。</p><p id="dd5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LKM是一个目标文件，可以被插入到正在运行的内核中。这主要用于扩展内核的功能(设备驱动、文件系统等)。).它的另一个用途是创建一个将在内核内部运行的rootkit。</p><h1 id="af53" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">保护环</h1><p id="3f08" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">操作系统中有两种模式，用户模式和内核模式，它们是由保护环定义的。“保护环”是系统中特权的层次结构。有四个环(环-0，环-1等。)而且越往下，特权越多。在大多数现代系统中，实际上只有两个环，即ring-0(也称为内核模式)和ring-3(用户模式)。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/68dc8666d9f9966eed32b764b01e45da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/0*vyB9qr-XrVPMaWnv"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">保护环</figcaption></figure><p id="7711" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在内核模式下运行的进程可以访问所有系统资源，包括最“敏感”的部分，当内核模式进程访问错误的资源时，或者由于某种原因而崩溃时，这可能会导致系统崩溃。然而，用户模式进程对资源的访问非常有限，所以它不会访问任何敏感的资源。这样设计是为了保护(因此得名，保护环)用户不犯大错误。</p><h1 id="3fda" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">Rootkits</h1><blockquote class="ma mb mc"><p id="03c1" class="jn jo md jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">来自维基百科:<br/><strong class="jp ir">rootkit</strong>是一个计算机软件的集合，通常是恶意的，旨在允许访问计算机或其软件的某个区域，否则是不允许的(例如，对未经授权的用户)，并且经常掩盖其存在或其他软件的存在。</p></blockquote><p id="9401" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当谈到rootkit时，我们应该将其分为两种不同的模式，内核模式的rootkit，以内核权限运行，和用户模式的rootkit，以用户权限运行。用户模式的rootkit可以改变二进制文件，如<code class="fe mh mi mj mk b">ls</code>、<code class="fe mh mi mj mk b">ss</code>、<code class="fe mh mi mj mk b">cat</code>等。用户模式的rootkit也可以挂钩动态链接库来改变某些函数的行为。然而，内核模式的rootkit可以做更多的事情，这要归功于它所拥有的特权，比如改变内核级函数指针、改变内核代码、操纵重要的数据结构以及最重要的挂钩系统调用。</p><h1 id="859d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">系统调用</h1><p id="02ea" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">内核充当着用户和机器之间的连接，所以每次用户需要在机器上做一些事情的时候，它都会和内核“对话”，要求内核将消息传递给机器。多亏了系统调用，这种“对话”才成为可能。<br/>系统调用是内核中的一个功能，对用户也是可见的。当用户需要来自内核的服务时，它要求内核执行系统调用。例如，Linux中的<code class="fe mh mi mj mk b">cat</code>命令使用系统调用<code class="fe mh mi mj mk b">open()</code>打开文件，<code class="fe mh mi mj mk b">read()</code>读取文件，<code class="fe mh mi mj mk b">write()</code>在屏幕上打印信息，<code class="fe mh mi mj mk b">close()</code>关闭打开的文件(它还使用了一些我在这里没有提到的系统调用)。<br/>那些系统调用只在内核上下文中执行，因为它们需要访问一些只有内核才能访问的部分(保护环，还记得吗？).</p><h2 id="a74a" class="ml km iq bd kn mm mn dn kr mo mp dp kv jy mq mr kz kc ms mt ld kg mu mv lh mw bi translated">为什么它对我们很重要？</h2><p id="fd95" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">想象一下，你可以改变<code class="fe mh mi mj mk b">read()</code>系统调用的方式，每次用户试图读取一个字节流时，它将只读取你希望它读取的字节，这样你可以在每个文件中隐藏秘密数据，而用户甚至不会知道。<br/>选项只限于头脑，这是因为所有的用户模式进程，从内核请求这些服务，根据定义，它必须这样做。</p><h2 id="3578" class="ml km iq bd kn mm mn dn kr mo mp dp kv jy mq mr kz kc ms mt ld kg mu mv lh mw bi translated">系统调用表</h2><p id="7e3d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">syscall表是内核中的一个数组，它包含一个指向操作系统必须提供的所有系统调用(syscall)的指针。</p><pre class="lp lq lr ls gt mx mk my mz aw na bi"><span id="7d78" class="ml km iq mk b gy nb nc l nd ne">void *sys_call_table[NR_syscalls] = {<br/>	[0 ... NR_syscalls-1] = sys_ni_syscall,<br/>#include &lt;asm/unistd.h&gt;<br/>};</span></pre><p id="d972" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在上面看到的，<code class="fe mh mi mj mk b">sys_call_table</code>是一个大小为<code class="fe mh mi mj mk b">NR_syscalls</code>的数组，它是内核中定义的一个宏，保存了允许的最大数量的系统调用。此外，syscall表中的所有元素都被初始化为<code class="fe mh mi mj mk b">sys_ni_syscall</code>。每个尚未实现的系统调用都被重定向到<code class="fe mh mi mj mk b">sys_ni_syscall</code>。当一个新的系统调用被实现时，在<code class="fe mh mi mj mk b">sys_call_table</code>中为该系统调用保留的偏移量将被改变，以包含一个指向新实现的系统调用的指针。</p><h1 id="44ee" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">获取系统调用表地址</h1><p id="607a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">最后，有趣的部分！<br/>本文的主要尝试是教你如何劫持syscall表，也就是在内存中获取syscall表的地址，这样你就可以随心所欲地玩它，滥用它。<br/>在过去版本的Linux内核中，syscall表有一个名为<code class="fe mh mi mj mk b">SYSCALL_TABLE</code>的显式变量，但由于显而易见的原因，它被删除了，因此攻击者必须考虑新的原始方法来获取syscall表的地址。以下是实现这一目标的几种方法:</p><h2 id="6987" class="ml km iq bd kn mm mn dn kr mo mp dp kv jy mq mr kz kc ms mt ld kg mu mv lh mw bi translated">通过记忆搜索</h2><p id="4975" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">搜索任何东西的最懒惰(但不是最有效)的方法，是遍历所有可能的地方，对于你搜索的每个地方，你都要比较你当前所在的地址和你已经知道的地址(我们将使用<code class="fe mh mi mj mk b">sys_close</code>引用)。<br/>对于这个方法，我们需要一个开始的地方，一个我们确定的内存地址在内存中的<code class="fe mh mi mj mk b">sys_call_table</code>地址之前。然后，我们将遍历内存，在一个循环中，每次迭代都在内存中向上，直到我们在内存中找到一个位置，当它被加上某个偏移量时，它将指向我们搜索的地址(为了更好地理解，请参见示例)。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5de5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来分解一下:<br/>我们将<code class="fe mh mi mj mk b">i</code>初始化为<code class="fe mh mi mj mk b">sys_close()</code>函数的地址。我们可以相信该函数将位于比syscall表更低的内存地址中，因为它在启动时首先被加载到内存中。当<code class="fe mh mi mj mk b">i</code>达到无符号长整型所能达到的最大值时，循环就会停止，那是因为它是系统的最后一个内存地址。每一次迭代我们都将<code class="fe mh mi mj mk b">i</code>增加<code class="fe mh mi mj mk b">void *</code>的大小。<br/>在循环的每次迭代中，如前所述，我们将<code class="fe mh mi mj mk b">i</code>与<code class="fe mh mi mj mk b">sys_close()</code>本身的地址进行比较，T7现在是系统中的一个地址，加上了偏移量<code class="fe mh mi mj mk b">__NR_close</code>(为<code class="fe mh mi mj mk b">sys_close)</code>指定的偏移量)。如果等于，说明我们找到了syscall表；如果没有，我们继续下一次迭代。</p><h2 id="2c38" class="ml km iq bd kn mm mn dn kr mo mp dp kv jy mq mr kz kc ms mt ld kg mu mv lh mw bi translated">通过<code class="fe mh mi mj mk b">/proc/kallsyms</code>文件</h2><p id="ad29" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">您可能已经知道，Linux中的所有东西都是一个文件，有一个特定的文件可以帮助我们得到我们想要的东西，这个文件就是<code class="fe mh mi mj mk b">/proc/kallsyms</code>文件。</p><p id="cfc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">/proc/kallsyms</code>文件是一个特殊的文件，包含所有动态加载内核模块的符号和静态代码的符号。换句话说，它在一个地方有整个内核映射。所以现在的算法很简单，只需读取文件，并搜索<code class="fe mh mi mj mk b">sys_call_table</code>符号。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/21b767676884de6de959e9bb2b826ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*xYjsgJMCMQPZ5nSzWVDvcA.png"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">图1 —写入/proc/kallsyms中的sys_call_table符号</figcaption></figure><p id="5cf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">先说读一个文件。<br/>读取文件是将数据流放入缓冲区的行为，因此您将能够访问该数据。<br/>如上所述，有保护环可以防止数据被滥用。因此，如果你在内核中，你只能从内核空间读取数据，如果你在用户空间，你只能读取用户空间的数据。幸运的是，有一种方法可以将用户空间数据读入内核模块。我们要做的就是改变全局变量<code class="fe mh mi mj mk b">addr_limit</code>。<code class="fe mh mi mj mk b">addr_limit</code>是允许非特权代码访问的最高地址，如果我们改变它，我们可以从我们想要的地方读取数据，包括用户空间。<code class="fe mh mi mj mk b">set_fs()</code>是我们将要用到的函数。(<a class="ae ni" href="https://lwn.net/Articles/722267/" rel="noopener ugc nofollow" target="_blank">此处阅读更多</a>)。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e2af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分解一下:<br/>首先，我们使用<code class="fe mh mi mj mk b">set_fs()</code>来设置<code class="fe mh mi mj mk b">addr_limit</code>，这样我们就可以从用户空间读取<code class="fe mh mi mj mk b">/proc/kallsyms</code>文件。在我们读取它之后，使用<code class="fe mh mi mj mk b">vfs_read()</code>，我们将<code class="fe mh mi mj mk b">addr_limit</code>设置回原始值(这非常重要，因为如果我们不这样做，任何用户模式进程都可能操纵内核地址空间)。<br/>从此直截了当。在每次迭代中，我们检查该行是否包含“sys_call_table”字符串，如果包含，则保存该表的地址并将其返回。</p><h2 id="f1b1" class="ml km iq bd kn mm mn dn kr mo mp dp kv jy mq mr kz kc ms mt ld kg mu mv lh mw bi translated">由kallsyms_lookup_name()提供</h2><p id="fe4a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">现在是有趣的部分。<br/>到目前为止，我们为获取系统调用表的地址所做的一切都可以通过调用函数<code class="fe mh mi mj mk b">kallsyms_lookup_name()</code>来完成，该函数在<code class="fe mh mi mj mk b">linux/kallsyms.h</code>中声明。</p><pre class="lp lq lr ls gt mx mk my mz aw na bi"><span id="b9f7" class="ml km iq mk b gy nb nc l nd ne">printk("The address of sys_call_table is: %lx\n", kallsyms_lookup_name("sys_call_table"));</span></pre><p id="67c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于这个函数没有太多要讲的，除了它搜索并返回你搜索的任何符号的地址。因此，你只需要搜索名字<code class="fe mh mi mj mk b">sys_call_table</code>就有了，内核的系统调用表就在你的手中。</p><h1 id="bd31" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">挂接系统调用</h1><p id="3685" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在获得syscall表之后，我们将使用它来创建一个syscall挂钩，这将改变某个系统调用的行为。在上一节中，我们讨论了系统调用表是一个地址数组，数组包含的每个地址都是一个系统调用的地址。当用户请求syscall时，内核转到syscall表，提取syscall的地址，然后指示CPU转到那个函数。如果我们改变保存在表中的地址，内核将指示CPU进入我们的函数，在那里，我们可以做任何我们想做的事情。</p><h2 id="e1e8" class="ml km iq bd kn mm mn dn kr mo mp dp kv jy mq mr kz kc ms mt ld kg mu mv lh mw bi translated">cr0</h2><p id="e93b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">CPU中有各种各样的寄存器，其中一种是“控制寄存器”。控制寄存器是保存改变CPU行为的标志的寄存器。其中一个寄存器是<code class="fe mh mi mj mk b">cr0</code>寄存器。<code class="fe mh mi mj mk b">cr0</code>中的一个标志是<code class="fe mh mi mj mk b">WP</code>标志，该标志告诉CPU他是否可以写入存储器中的只读区(关于其他标志，请访问控制寄存器的<a class="ae ni" href="https://en.wikipedia.org/wiki/Control_register#CR0" rel="noopener ugc nofollow" target="_blank">维基百科页面)。当<code class="fe mh mi mj mk b">WP</code>设置为1时，CPU可能不会写入只读页面，但当设置为0时，CPU可能会在任何位置写入任何内容。</a></p><p id="aa9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，假设系统调用表在一个只读区，我们需要将<code class="fe mh mi mj mk b">WP</code>标志改为1来改变那里的地址。</p><pre class="lp lq lr ls gt mx mk my mz aw na bi"><span id="01b8" class="ml km iq mk b gy nb nc l nd ne">#define unprotect_memory() \<br/>({ \<br/>	orig_cr0 =  read_cr0();\<br/>	write_cr0(orig_cr0 &amp; (~ 0x10000)); /* Set WP flag to 0 */ \<br/>});</span><span id="3ef4" class="ml km iq mk b gy nj nc l nd ne">#define protect_memory() \<br/>({ \<br/>	write_cr0(orig_cr0); /* Set WP flag to 1 */ \<br/>});</span></pre><p id="70bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面有两个宏用于将<code class="fe mh mi mj mk b">cr0</code>寄存器中的<code class="fe mh mi mj mk b">WP</code>标志更改为0或1。我们将在实际挂钩时使用这些宏。</p><h2 id="3ab4" class="ml km iq bd kn mm mn dn kr mo mp dp kv jy mq mr kz kc ms mt ld kg mu mv lh mw bi translated">真正的挂钩</h2><p id="f75a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">现在是关键时刻，真正的勾搭。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="70b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在第12行和第19行中看到的，我们所做的更改系统调用的只是将保存在syscall表中的地址更改为我们选择的地址。<br/>就这样。这是Linux内核中的一个系统调用挂钩。</p><h1 id="0fd2" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">你可以用钩子做的事情</h1><p id="f3d3" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">对于如何使用钩子，有很多选择。例如，您可能会给一些系统调用添加一些功能，或者使用挂钩来创建一个内核rootkit(这可能是您在这里的原因)。rootkit最常用的挂钩是:</p><ul class=""><li id="bf4c" class="nk nl iq jp b jq jr ju jv jy nm kc nn kg no kk np nq nr ns bi translated"><code class="fe mh mi mj mk b">kill</code> —主要用于添加一些信号，可以帮助与你的rootkit进行交流。</li><li id="b39d" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated"><code class="fe mh mi mj mk b">getdirentries</code> —用于隐藏文件和进程。</li><li id="8b39" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated"><code class="fe mh mi mj mk b">read</code> —用于按键记录。</li><li id="563e" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated"><code class="fe mh mi mj mk b">shutdown</code> —改变关机顺序。</li><li id="a689" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated"><code class="fe mh mi mj mk b">ioctl</code> —更改基本<code class="fe mh mi mj mk b">ioctl</code>请求。</li></ul><p id="064e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有更多，取决于你的想象力。</p><h1 id="facc" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">参考</h1><p id="f086" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated"><a class="ae ni" href="http://www.linfo.org/kernel.html" rel="noopener ugc nofollow" target="_blank">【1】</a>关于内核—Linux信息工程<br/><a class="ae ni" href="https://elixir.bootlin.com/" rel="noopener ugc nofollow" target="_blank">【2】</a><strong class="jp ir"><em class="md">bootlin</em></strong>—内核源代码分版本<br/><a class="ae ni" href="https://github.com/m0nad/Diamorphine" rel="noopener ugc nofollow" target="_blank">【3】</a>二乙酰吗啡Rootkit —一个简单的Linux内核Rootkit</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/efc2f6720cec522dfcd97e5baef9ae81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*sRfZY44Cz7rhyS9HQ-BUCg.jpeg"/></div></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="103e" class="ml km iq bd kn mm mn dn kr mo mp dp kv jy mq mr kz kc ms mt ld kg mu mv lh mw bi translated">作者:</h2><p id="c2a1" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">@GoldenOak <br/> @TSn0w</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="1f9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="md">关注</em> <a class="ae ni" href="https://medium.com/bugbountywriteup" rel="noopener"> <em class="md"> Infosec报道</em> </a> <em class="md">获取更多此类精彩报道。</em></p><div class="og oh gp gr oi oj"><a href="https://medium.com/bugbountywriteup" rel="noopener follow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">信息安全报道</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">收集了世界上最好的黑客的文章，主题从bug奖金和CTF到vulnhub…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">medium.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox lu oj"/></div></div></a></div></div></div>    
</body>
</html>