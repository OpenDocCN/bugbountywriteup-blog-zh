<html>
<head>
<title>Bypassing Container Image Scanning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">绕过集装箱图像扫描</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/bypassing-container-image-scanning-2c50dbfa7e4c?source=collection_archive---------2-----------------------#2021-05-26">https://infosecwriteups.com/bypassing-container-image-scanning-2c50dbfa7e4c?source=collection_archive---------2-----------------------#2021-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e127d816e589344db75cf04a742d6349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S7V8ZkmmDRKVk4MB27iceg.png"/></div></div></figure><p id="dd9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">容器技术已经成为现代计算的支柱。大多数现代公司现在在生产环境中运行容器，许多公司已经成功地将容器图像扫描构建到他们的CI/CD管道中。许多公司甚至对这些映像扫描实施策略，仅允许部署低于漏洞阈值的映像。CNCF云本地安全白皮书定义了这一事实上的标准。</p><blockquote class="kw kx ky"><p id="f246" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">扫描容器映像是在整个生命周期中保护容器应用程序的一个关键组成部分…将容器映像的漏洞扫描与管道合规性规则相结合，可确保仅将修补充分的应用程序部署到生产中，从而减少潜在的攻击面。</p></blockquote><p id="2309" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是这些容器图像扫描的准确性如何，在评估容器漏洞时还应该考虑什么？<br/>让我们深入了解什么是集装箱图像扫描，以及我们如何从处理结果中获得乐趣。</p><h1 id="d371" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">什么是集装箱图像扫描？</h1><p id="05f6" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">嗯……那会变得复杂。现在有许多不同的容器图像扫描工具，每种工具都有自己的扫描方法和漏洞数据源。有些人可能会扫描文件系统(毕竟，这就是容器映像的全部内容)，寻找已知的静态易受攻击组件的签名，而其他人可能会实际运行容器并查询包管理器。这些会产生非常不同的结果。</p><p id="b91d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些流行的集装箱图像扫描工具包括但不限于:</p><ul class=""><li id="72e5" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">Snyk(由docker扫描使用)</li><li id="fc6f" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">clair(AWS ECR用？)</li><li id="0e8f" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">Trivy (aquasec)</li><li id="b9b3" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">安克雷</li></ul><p id="ed6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用高级扫描方法来分解它。我对这些高级扫描方法的理解来自于阅读文档、开源代码以及现场观察和实验。</p><h2 id="67ad" class="mu le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">静态包管理器扫描</h2><p id="7d1d" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">通过包管理器静态查询包列表似乎是最常见的方法。对于基于debian的映像，这可能只是提取<code class="fe ng nh ni nj b">/var/lib/dpkg/status</code>的内容这么简单。扫描器读取这个静态文件来获取已安装软件包的列表。</p><h2 id="9f8f" class="mu le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">运行时包扫描</h2><p id="7d1f" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">一些工具实际上会运行容器并向包管理器查询信息。对于使用高级打包工具(APT)的映像，这可能看起来很简单:</p><p id="95c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ng nh ni nj b">docker run --rm --it &lt;image&gt; apt list</code></p><p id="849d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，情况可能会更复杂一些。一个更复杂的扫描器可能会做一些事情，比如将二进制文件注入到映像中，以识别本地包管理器并相应地进行扫描。</p><p id="9c6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，Aquasec最近弃用的microscanner涉及在构建时运行和扫描图像，向docker文件添加:</p><pre class="nk nl nm nn gt no nj np nq aw nr bi"><span id="9721" class="mu le iq nj b gy ns nt l nu nv">ADD <a class="ae nw" href="https://get.aquasec.com/microscanner" rel="noopener ugc nofollow" target="_blank">https://get.aquasec.com/microscanner</a> /</span><span id="3e53" class="mu le iq nj b gy nx nt l nu nv">RUN chmod +x microscanner</span><span id="e5a6" class="mu le iq nj b gy nx nt l nu nv">RUN microscanner &lt;TOKEN&gt;</span></pre><h2 id="4fd0" class="mu le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">基于静态文件的扫描</h2><p id="a813" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">这是经典的漏洞扫描方法。这些类型的扫描可以遍历文件系统，检查已知的易受攻击的签名。基本的扫描工具可能只是检查文件散列，而更高级的工具具有分解应用程序依赖库文件甚至源代码本身的能力。</p><p id="27d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，一个包含节点应用程序的映像，扫描器可能会检查package-lock.json文件，以提取正在使用的依赖项列表。</p><h2 id="5e7c" class="mu le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">漏洞数据源</h2><p id="663f" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">每个容器图像扫描工具都会以不同的方式获取其漏洞数据。这可能包括NVD、特定于操作系统的漏洞跟踪器、专有研究等。了解您的工具的数据来源对于理解它是否真正解释了您的图像是至关重要的。</p><h1 id="2c68" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">获得黑客技术</h1><p id="7738" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">对集装箱图像扫描仪的工作原理有了基本的了解后，我们现在可以试着打破一些东西。我发现了一些绕过集装箱图像扫描仪的方法。</p><h2 id="dad9" class="mu le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">绕过静态软件包管理器扫描</h2><ul class=""><li id="d2da" class="mg mh iq ka b kb mb kf mc kj ny kn nz kr oa kv ml mm mn mo bi translated">删除软件包管理器状态文件</li></ul><p id="1a39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于一个基于debian的映像，这很简单，只需将<code class="fe ng nh ni nj b">RUN rm /var/lib/dpkg/status</code>添加到映像的Dockerfile中。让我们比较nginx:latest的一个新副本和一个用附加的RUN命令构建的副本的结果。</p><p id="0a60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之前:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/6144c77d7716d5e66553fd29ee953a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ROYTrChr12W2oKuSy263NQ.png"/></div></div></figure><p id="6c05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/5cc62ace9ceaabdbad2fbababdaf6b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c2XvEmLICM0OdqJyCkjdRg.png"/></div></div></figure><p id="1a7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种旁路方法的其他变体包括:</p><ul class=""><li id="6fb5" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">移动包裹</li><li id="5ddb" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">更改包名</li></ul><h2 id="5377" class="mu le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">绕过运行时扫描</h2><p id="749f" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">除了绕过静态包管理器检查的方法之外，还有一些巧妙的方法来绕过运行时依赖检查。</p><ul class=""><li id="13be" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">删除软件包管理器</li></ul><p id="4244" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，尝试在安装完映像的所有基本包之后，将<code class="fe ng nh ni nj b">RUN apt-get remove apt</code>构建到映像中。这些包将保留在映像上，但是运行时扫描程序将无法使用<code class="fe ng nh ni nj b">apt list</code>进行查询，因此导致0个漏洞被发现。</p><ul class=""><li id="768e" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">防止运行时扫描程序被注入</li></ul><p id="0cf8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您确切地知道运行时扫描程序二进制文件被注入的位置和方式，请找到一种方法来防止它。例如，在上面的微扫描器案例中，我们知道它将在<code class="fe ng nh ni nj b">/microscanner</code>添加扫描器二进制文件。在这种情况下，我们可以在写入微扫描器之前添加一个层，创建一个指向/dev/null的符号链接。这意味着在映像构建时，microscanner二进制文件会被丢弃，而不是写入文件系统。</p><pre class="nk nl nm nn gt no nj np nq aw nr bi"><span id="26dc" class="mu le iq nj b gy ns nt l nu nv">RUN ln -s /dev/null /microscanner</span><span id="cf86" class="mu le iq nj b gy nx nt l nu nv">ADD <a class="ae nw" href="https://get.aquasec.com/microscanner" rel="noopener ugc nofollow" target="_blank">https://get.aquasec.com/microscanner</a> /</span><span id="d2d1" class="mu le iq nj b gy nx nt l nu nv">RUN chmod +x microscanner</span><span id="76b6" class="mu le iq nj b gy nx nt l nu nv">RUN microscanner &lt;TOKEN&gt;</span></pre><h2 id="dafa" class="mu le iq bd lf mv mw dn lj mx my dp ln kj mz na lr kn nb nc lv kr nd ne lz nf bi translated">绕过基于静态文件的扫描</h2><p id="7194" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">这种更经典的依赖性扫描方法比传统的绕过方法要弱。</p><ul class=""><li id="6e76" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">更改文件签名</li><li id="9679" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">更改文件名</li><li id="a898" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">更改文件扩展名</li></ul><h1 id="96ce" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">为什么在乎？</h1><p id="adb4" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">了解这些缺陷可以让我们看到更多的潜在威胁，这样安全工程师和开发人员就可以做好最好的准备。</p><p id="6d55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些威胁可能包括:</p><ul class=""><li id="e308" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">报告0个漏洞的公共映像(例如Docker Hub ),但实际上包含已知的恶意软件和易受攻击的软件包。</li><li id="daeb" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">受损的CI/CD管道现在可以部署带有漏洞和恶意软件的映像。</li><li id="3782" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">意外。开发人员有时会做一些有趣的事情。</li></ul><h1 id="6ea8" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">接下来是什么？</h1><p id="0367" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">有了对集装箱图像扫描的这种理解，考虑集装箱安全的下一个级别就很重要了。更多博客文章即将发布。</p><ul class=""><li id="a879" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">容器应用程序清单扫描</li><li id="e512" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">容器运行时安全实施</li><li id="49b9" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">构建安全的无发行版映像</li></ul><h1 id="74ae" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">关键要点</h1><ul class=""><li id="2753" class="mg mh iq ka b kb mb kf mc kj ny kn nz kr oa kv ml mm mn mo bi translated">了解您的集装箱图像扫描工具</li><li id="0607" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">了解您的映像清单—确保您的基本映像发行版在扫描过程中得到考虑</li><li id="4f23" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">永远不要相信公众形象</li></ul></div></div>    
</body>
</html>