<html>
<head>
<title>Dive into assembler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入汇编程序</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/dive-into-assembler-ad96321df6fe?source=collection_archive---------5-----------------------#2021-09-29">https://infosecwriteups.com/dive-into-assembler-ad96321df6fe?source=collection_archive---------5-----------------------#2021-09-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="926a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">您将学习算术运算，并从sckratch创建一个游戏</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/d1f14b6a59fe0c1eaf9345c2d7d7dccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*xFiqb89oZAgTNjx-065etA.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">vk.com</figcaption></figure><p id="f703" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">读完这篇文章，你将学会如何使用算术和逻辑指令，以及移位指令。在这个过程中，您将学习如何创建子例程。最后你会写一个简单的玩具“猜数字”。</p><h1 id="275c" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">编写助手例程</h1><p id="00d0" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们现在要写的所有程序都有一个重复的动作:在屏幕上显示结果。为了不每次都重新编写这个动作的代码，让我们为它写一个子程序。<br/>什么是子程序？这是一段完成一些小任务的代码。子程序通常通过调用指令来访问。所有子程序都以ret(返回)指令结束。现在，这就是你需要知道的关于子程序的全部内容。当然，从好的方面来说，当你使用子程序时，你需要了解更多的东西，特别是，什么是堆栈指针，以及当访问子程序时它是如何变化的。但是现在，作为当前课程的一部分，让我们同意，如果你需要在屏幕上画一个字母，只需将这个指令插入到你的代码中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/745281dc9323578d46c128ae1b0615cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e42k4tTHyVqlW05w.png"/></div></div></figure><p id="009a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mp">调用display_letter </em>子程序实现如下。保存到<em class="mp"> library.asm </em>文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/abd21cea9ff2e5202fdc9828af9f64cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GEm54v42O6yWjiZ6.png"/></div></div></figure><p id="f862" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重要！</p><p id="fefe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们编写的所有程序的末尾，您将需要粘贴library.asm中的代码。它指向哪里？所有的程序都会以命令行的退出来结束，它们会有子程序把一个字符打印到屏幕上(从AL寄存器)和从键盘上读取一个字符(结果放在AL寄存器中)。</p><h1 id="31f2" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi">Учимся складывать и вычитать</h1><p id="5a0f" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">让我们使用<em class="mp"> AL </em>寄存器和常量作为加法指令的参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/bf477ce5ecb18ca43596e8f89f370411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RaolbRU05NmhDOke.png"/></div></div></figure><p id="b493" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个程序显示数字7。因为4 + 3 = 7。</p><p id="f574" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们将AL寄存器和常数作为减法指令的参数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/fc0d7ede00b1648440dd679f0689f4c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Uoyu-EQdPL-fygdN.png"/></div></div></figure><p id="758f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个程序显示数字1。因为4–3 = 1。</p><h1 id="eef8" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">掌握乘法</h1><p id="decf" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">乘法指令可以处理字节(8位数)和字(16位数)。被乘的始终是<strong class="kt ir"> AL / AX </strong>寄存器。该因子可以是一个寄存器(any)，也可以是内存中的一个变量。<br/>只要记住，如果你的乘数在<strong class="kt ir"> AL </strong>中，那么乘数必须是8位，如果在<strong class="kt ir"> AX </strong>中，那么乘数必须是16位。乘法的结果要么在<strong class="kt ir"> AX </strong>中结束(当我们将两个8位数字相乘时)，要么在DX: AX中结束(当我们将两个16位数字相乘时)。<br/>在下面的例子中，我们使用了两个8位寄存器<strong class="kt ir"> AL </strong>(乘法器)和<strong class="kt ir"> CL </strong>(乘法器)。结果进入16位<strong class="kt ir"> AX </strong>寄存器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/484c6ff3bec5e2f3b7b1c00d967e3d0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iONgSo3RvUIaekzY.png"/></div></div></figure><p id="ddcb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个程序显示数字6。因为3 × 2 = 6。要将两个16位数字相乘，将乘数放在AX，将乘数放在CX。然后，将mul cl改为mul cx。<br/>注意，mul语句对无符号整数进行操作。如果需要将带符号的数相乘，请使用imul。</p><h1 id="db97" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">了解分工</h1><p id="203e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">除法指令可以处理字(16位数)和双字(32位数)。被除数总是AX寄存器或DX: AX。除数可以是寄存器(any)，也可以是内存中的变量。</p><p id="82e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只要记住，如果你的被除数在AX中，那么除数必须是8位，如果在DX: AX中，它必须是16位。</p><p id="f911" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你把一个16位的数除以一个8位的数时，结果归AL，余数归AH。如果你把一个32位的数除以一个16位的数，结果归AX，其余的归DX。</p><p id="2cbd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下面的例子中，我们使用16位和8位寄存器。结果归AL，其余归AH。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/0353dc6648157c4897374c00d5e1c3f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MlOIKuWnsujmVMqV.png"/></div></div></figure><p id="5c0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个程序显示数字3。因为100/33 = 3。如果您想知道余数是多少，请在编写div指令的那一行之后添加这一行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/b37a7bf43f02d2e33976ca7a33a56796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WZ0SnplrQfVVBUfD.png"/></div></div></figure><p id="c458" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">小心！除法指令会破坏你的程序。如果除以零，那么将会出现系统错误，程序将会飞到命令行。<br/>注意div语句对无符号整数进行操作。如果您需要拆分有符号的数字，请使用idiv。</p><h1 id="7268" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">逻辑和算术移位、循环移位</h1><p id="481d" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">移位指令(高级语言中的操作符&lt;&lt; and &gt;)是处理器最原始的指令。它们比大多数其他指令都快。因此，如果计算的某些部分可以在它们上面实现——特别是如果它允许您避免乘法和除法的指令——请随意使用它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/bd787aa5df5a09ddca40199d2701e90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rx7mZ2jS9BDZyfm8.png"/></div></div></figure><p id="cd27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我将解释shift指令是如何工作的。假设AL寄存器的值是一个二进制数。shl指令只是将二进制1的每一位向左移位，并向右加一个0。并且从左边被抢占的位落入CF(进位标志；携带旗帜)。</p><p id="3306" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">shr指令以类似的方式工作，只是它将寄存器位向右移动，而不是向左移动。<br/>还有sar指令，它的工作方式几乎和shr一样，但不像shr，它不是逻辑移位，而是算术移位。这是什么意思？当sar将二进制数向右移动一位时，它不会添加零，而是复制移动前的位。有时可以为零，但不总是如此。</p><p id="0fd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如此巧妙的替代通常的右移有什么用？sar允许你移动带符号的数字。Shr也可以移动它们，但是在寄存器中，这将导致垃圾。</p><p id="ae4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能已经知道，所有移位指令的第二个参数表示寄存器位应该移位的位数。注意:如果你用数字表示这个金额，那么它只能是一个。如果您想一次移位若干位，请使用CL寄存器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/a06d78d7bba52c7650d5b9db84835325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZfF9qsuoby8Fknbq.png"/></div></div></figure><p id="c519" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有循环移位的指令:ror、rcr、rol和rcl。他们的特点是什么？从一端滑出的比特出现在另一端。循环向右移位由ror指令执行，循环向左移位由rol指令执行。rcr / rcl的功能与ror / rol相同，只是它们使用了一个额外的位，参见CF。增加的位取自CF，而扩展的位则进入CF。</p><h1 id="a0bf" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">信息</h1><p id="76ec" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated"><strong class="kt ir"> Shl </strong>(逻辑左移)有一个同义词——<strong class="kt ir">sal</strong>。这两条指令完全相同——在某种程度上，它们是用相同的机器代码生成的。</p><h1 id="1a50" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">三条逻辑指令加一条无用指令</h1><p id="e386" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">8088上有三种逻辑指令:与、或和异或。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/588afa5debc0b4a74f0bc44e68e62c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Drfcbm_cyRgBAWC8.png"/></div></div></figure><p id="6aea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">and语句相当于C和JavaScript中的&amp;运算符；或用于|运算符，xor用于^运算符。<br/>还有一个not指令，它只有一个参数。它反转指定寄存器的所有位。(not al相当于C和JavaScript中的~运算符)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/300a6a403002569ae83f82f090208a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QVYNYqTMKciIJ43S.png"/></div></div></figure><p id="af98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，8088有一个neg指令，它与not非常相似，但它不是一个逻辑反转，而是一个算术反转:它改变一个给定数字的符号。</p><p id="2d8c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在汇编程序中也有一条指令什么也不做。您可以将它插入到程序中的任何地方，它不会以任何方式影响执行流程。当然，除了程序运行的稍微慢一点。这是nop指令。你可以尝试一下。将它插入org指令后的任意位置，您将看到您的程序如何恰好增长一个字节(这是No OPeration指令的大小)，但它将工作不变。</p><h1 id="7cb7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">增量和减量指令介绍</h1><p id="d520" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">递增和递减指令允许您将寄存器值或内存中的变量值递增或递减1。这些指令适用于字节(8位)和字(16位)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/3d88d9bcfccb4a0a67acabf0010b2a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y058pjb2L1YWI_Yd.png"/></div></div></figure><p id="bc73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们到了:<br/> 1。将数字零的ASCII码装入AL，即0x30<br/> 2。在屏幕上显示号码；<br/> 3。给AL加一；<br/> 4。重复步骤2–3，直到AL为0x39<br/> 5。显示当前符号，所有操作都和之前一样，但顺序相反；<br/> 6。从AL中减去1；<br/> 7。我们展示发生了什么；<br/> 8。重复直到AL为0x30。</p><p id="cfca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果，程序在屏幕上显示下面一行:<strong class="kt ir"> 012345678987654321。</strong></p><p id="43d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个程序为你提供了另一个新的指令——CMP(比较)。它的工作方式与减法指令相同，但有一个显著的区别:cmp不改变寄存器值。它只改变标志寄存器位。</p><p id="14de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常，cmp与诸如je(如果相等则跳转)、jne(如果不相等则跳转)等条件跳转指令结合使用。</p><p id="30c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，现在你已经知道了足够的汇编指令来编写一个简单的猜数字游戏。</p><p id="b86a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它将如何工作？游戏开始后，电脑猜测一个数字，屏幕上显示一个问号，等待玩家的回答。如果玩家输入的数字与电脑猜测的数字不同，游戏会再次显示一个问号。当玩家最终猜出数字时，程序会将其打印在屏幕上，并添加一个表情符号(冒号和右括号)。下面是实现所描述思想的汇编代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/a15218f46c218cbe73c1ac0dfcff05c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KlzQoa03vehTMPXr.png"/></div></div></figure><p id="c095" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">电脑是怎么猜出数字的？它从端口0x40读取一个伪随机数。这个端口连接到一个定时器芯片。计时器不间断地倒计时处理器周期。当从其端口读取一个值时，每次都会获得一个范围从0x00到0xFF的伪随机数。这就是全部的秘密。现在是一个小小的组织时刻。直到现在，当你和我需要一个字母时，我们用ASCII十六进制代码设置它。但是NASM编译器有一个很好的特性:你可以输入任何字符，用撇号括起来，NASM会把它转换成ASCII码。<br/>让我们用这个NASM特性重写我们的游戏。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/93d3613c632236a8c4ca8ea2f44faccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mxrehovjroSTIlvq.png"/></div></div></figure><p id="0983" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同意，这使得源代码可读性更好。Выводы</p><p id="69a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">恭喜你，你已经向学习汇编语言迈出了一小步！现在你可以在上面制作小玩具。你我做的那个只要70字节。</p><h1 id="8930" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">说明和运算符</h1><p id="5700" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如果你懂C、Java或JavaScript，那么这里有一个小表格，是你今天掌握的汇编指令和这些语言的操作符之间的对应关系。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/5daf5c8240c495cef4c4814345ae4bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/0*dGK00tBvdx1V1PP7.png"/></div></figure></div></div>    
</body>
</html>