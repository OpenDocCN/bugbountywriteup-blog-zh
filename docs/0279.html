<html>
<head>
<title>Linux Reverse Engineering CTFs for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的Linux逆向工程CTFs</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/linux-reverse-engineering-ctfs-for-beginners-4cf03ff2cfb4?source=collection_archive---------0-----------------------#2019-03-14">https://infosecwriteups.com/linux-reverse-engineering-ctfs-for-beginners-4cf03ff2cfb4?source=collection_archive---------0-----------------------#2019-03-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7053" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">过了一会儿，我决定写一篇关于Linux二进制反转CTFs的简短博文。初学者如何处理二进制数和求解？总的来说，我个人并不喜欢Linux逆向工程挑战，因为我更多的时间是在Windows逆向工程上。我更喜欢windows逆向工程挑战。我喜欢Windows的一个原因是，作为一个测试者，我每天都会遇到Windows机器，很少会遇到整个网络都运行Linux的情况。即使是在漏洞开发方面，你也很少会在测试时手动为Linux软件开发漏洞。但是当涉及到物联网时，这些知识真的很有用，因为几乎许多设备都基于Linux embedded。如果你想开始逆向工程和开发，从Linux开始将是一个好主意。很多年前我也是从Linux开始的。他说，因为有些人在看到逆向工程的挑战时会试图逃避。因此，如果你是一个新手，我希望这些内容可能对你有用。</p><h1 id="a84e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">ELF格式</h1><p id="ae2a" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们先来看看精灵头。详细了解这一点的最好方法是查看ELF的手册页。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/f3034175c2ecc8a27562b261ed1f0793.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/0*ZGvcsPdvOD3_eJyY"/></div></figure><p id="8b40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是更详细的内容。“e_shoff”成员保存节标题表的偏移量。“sh_offset”成员保存段的第一个字节的地址。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="8bd4" class="me kp it ma b gy mf mg l mh mi">            +-------------------+<br/>            | ELF header        |---+<br/>+---------&gt; +-------------------+   | e_shoff<br/>|           |                   |&lt;--+<br/>| Section   | Section header 0  |<br/>|           |                   |---+ sh_offset<br/>| Header    +-------------------+   |<br/>|           | Section header 1  |---|--+ sh_offset<br/>| Table     +-------------------+   |  |<br/>|           | Section header 2  |---|--|--+<br/>+---------&gt; +-------------------+   |  |  |<br/>            | Section 0         |&lt;--+  |  |<br/>            +-------------------+      |  | sh_offset<br/>            | Section 1         |&lt;-----+  |<br/>            +-------------------+         |<br/>            | Section 2         |&lt;--------+<br/>            +-------------------+</span></pre><h1 id="2dba" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">可执行文件头</h1><p id="1fa2" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">任何ELF文件都以可执行文件头开始。这包含了关于ELF文件类型的信息，不同文件头的偏移量。你看看评论就明白了。对于这个例子，我使用32位结构。对于x86_64，大小可能会改变，命名约定将以“Elf64_”开头。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="b4ec" class="me kp it ma b gy mf mg l mh mi">#define EI_NIDENT (16)<br/> <br/>typedef struct {<br/>  unsigned char e_ident[EI_NIDENT];     /* Magic number and other info */<br/>  Elf32_Half    e_type;                 /* Object file type */<br/>  Elf32_Half    e_machine;              /* Architecture */<br/>  Elf32_Word    e_version;              /* Object file version */<br/>  Elf32_Addr    e_entry;                /* Entry point virtual address */<br/>  Elf32_Off     e_phoff;                /* Program header table file offset */<br/>  Elf32_Off     e_shoff;                /* Section header table file offset */<br/>  Elf32_Word    e_flags;                /* Processor-specific flags */<br/>  Elf32_Half    e_ehsize;               /* ELF header size in bytes */<br/>  Elf32_Half    e_phentsize;            /* Program header table entry size */<br/>  Elf32_Half    e_phnum;                /* Program header table entry count */<br/>  Elf32_Half    e_shentsize;            /* Section header table entry size */<br/>  Elf32_Half    e_shnum;                /* Section header table entry count */<br/>  Elf32_Half    e_shstrndx;             /* Section header string table index */<br/>} Elf32_Ehdr;</span></pre><p id="49e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个使用readelf的例子。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="fca6" class="me kp it ma b gy mf mg l mh mi"># readelf -h /bin/ls<br/>ELF Header:<br/>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 <br/>  Class:                             ELF64<br/>  Data:                              2's complement, little endian<br/>  Version:                           1 (current)<br/>  OS/ABI:                            UNIX - System V<br/>  ABI Version:                       0<br/>  Type:                              DYN (Shared object file)<br/>  Machine:                           Advanced Micro Devices X86-64<br/>  Version:                           0x1<br/>  Entry point address:               0x6130<br/>  Start of program headers:          64 (bytes into file)<br/>  Start of section headers:          137000 (bytes into file)<br/>  Flags:                             0x0<br/>  Size of this header:               64 (bytes)<br/>  Size of program headers:           56 (bytes)<br/>  Number of program headers:         11<br/>  Size of section headers:           64 (bytes)<br/>  Number of section headers:         29<br/>  Section header string table index: 28</span></pre><p id="c695" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要计算整个二进制文件的大小，我们可以使用下面的计算方法</p><p id="b7df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml ma b">size = e_shoff + (e_shnum * e_shentsize)<br/>size = Start of section headers + (Number of section headers * Size of section headers)<br/>size = 137000 + (29*64) = 138856</code></p><p id="3eef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如你所见，我们的计算是正确的。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="7c61" class="me kp it ma b gy mf mg l mh mi"># ls -l /bin/ls<br/>-rwxr-xr-x 1 root root 138856 Aug 29 21:20 /bin/ls</span></pre><h1 id="2b68" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">程序标题</h1><p id="1c74" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这些头文件描述了二进制文件中对于加载二进制文件很重要的部分。这些信息对于内核将段从磁盘映射到内存非常有用。结构的成员是不言自明的。我不会在这篇文章中深入解释这一点，因为我试图保持事情的基本性。然而，在ELF中用逆向工程做很酷的事情时，理解每一部分都很重要:)</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="9188" class="me kp it ma b gy mf mg l mh mi">typedef struct {<br/>  Elf32_Word    sh_name;                /* Section name (string tbl index) */<br/>  Elf32_Word    sh_type;                /* Section type */<br/>  Elf32_Word    sh_flags;               /* Section flags */<br/>  Elf32_Addr    sh_addr;                /* Section virtual addr at execution */<br/>  Elf32_Off     sh_offset;              /* Section file offset */<br/>  Elf32_Word    sh_size;                /* Section size in bytes */<br/>  Elf32_Word    sh_link;                /* Link to another section */<br/>  Elf32_Word    sh_info;                /* Additional section information */<br/>  Elf32_Word    sh_addralign;           /* Section alignment */<br/>  Elf32_Word    sh_entsize;             /* Entry size if section holds table */<br/>} Elf32_Shdr;</span></pre><h1 id="53c7" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">部分</h1><p id="7f2e" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">与任何二进制文件一样，这些是部分。有些部分熟悉PE的头。然而，我不会讨论所有的部分，因为我尽量保持它的基本性。</p><h1 id="2d1f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">。bss部分</h1><p id="aeac" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这个部分包含程序未初始化的全局数据。</p><h1 id="77bc" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">。数据部分</h1><p id="05b3" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这个部分包含程序初始化的全局变量。</p><h1 id="c5c3" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">。rodata部分</h1><p id="46bd" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">此部分包含只读数据，如所用程序的字符串。</p><h1 id="7fb6" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">。文本部分</h1><p id="1f35" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这一部分包含程序的实际代码，即逻辑流程。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="51b2" class="me kp it ma b gy mf mg l mh mi"># readelf -S --wide /bin/ls<br/>There are 29 section headers, starting at offset 0x21728:</span><span id="dfca" class="me kp it ma b gy mm mg l mh mi">Section Headers:<br/>  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al<br/>  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0<br/>  [ 1] .interp           PROGBITS        00000000000002a8 0002a8 00001c 00   A  0   0  1<br/>  [ 2] .note.ABI-tag     NOTE            00000000000002c4 0002c4 000020 00   A  0   0  4<br/>  [ 3] .note.gnu.build-id NOTE            00000000000002e4 0002e4 000024 00   A  0   0  4<br/>  [ 4] .gnu.hash         GNU_HASH        0000000000000308 000308 0000c0 00   A  5   0  8<br/>  [ 5] .dynsym           DYNSYM          00000000000003c8 0003c8 000c90 18   A  6   1  8<br/>  [ 6] .dynstr           STRTAB          0000000000001058 001058 0005d8 00   A  0   0  1<br/>  [ 7] .gnu.version      VERSYM          0000000000001630 001630 00010c 02   A  5   0  2<br/>  [ 8] .gnu.version_r    VERNEED         0000000000001740 001740 000070 00   A  6   1  8<br/>  [ 9] .rela.dyn         RELA            00000000000017b0 0017b0 001350 18   A  5   0  8<br/>  [10] .rela.plt         RELA            0000000000002b00 002b00 0009f0 18  AI  5  24  8<br/>  [11] .init             PROGBITS        0000000000004000 004000 000017 00  AX  0   0  4<br/>  [12] .plt              PROGBITS        0000000000004020 004020 0006b0 10  AX  0   0 16<br/>  [13] .plt.got          PROGBITS        00000000000046d0 0046d0 000018 08  AX  0   0  8<br/>  [14] .text             PROGBITS        00000000000046f0 0046f0 01253e 00  AX  0   0 16<br/>  [15] .fini             PROGBITS        0000000000016c30 016c30 000009 00  AX  0   0  4<br/>  [16] .rodata           PROGBITS        0000000000017000 017000 005129 00   A  0   0 32<br/>  [17] .eh_frame_hdr     PROGBITS        000000000001c12c 01c12c 0008fc 00   A  0   0  4<br/>  [18] .eh_frame         PROGBITS        000000000001ca28 01ca28 002ed0 00   A  0   0  8<br/>  [19] .init_array       INIT_ARRAY      0000000000021390 020390 000008 08  WA  0   0  8<br/>  [20] .fini_array       FINI_ARRAY      0000000000021398 020398 000008 08  WA  0   0  8<br/>  [21] .data.rel.ro      PROGBITS        00000000000213a0 0203a0 000a38 00  WA  0   0 32<br/>  [22] .dynamic          DYNAMIC         0000000000021dd8 020dd8 0001f0 10  WA  6   0  8<br/>  [23] .got              PROGBITS        0000000000021fc8 020fc8 000038 08  WA  0   0  8<br/>  [24] .got.plt          PROGBITS        0000000000022000 021000 000368 08  WA  0   0  8<br/>  [25] .data             PROGBITS        0000000000022380 021380 000268 00  WA  0   0 32<br/>  [26] .bss              NOBITS          0000000000022600 0215e8 0012d8 00  WA  0   0 32<br/>  [27] .gnu_debuglink    PROGBITS        0000000000000000 0215e8 000034 00      0   0  4<br/>  [28] .shstrtab         STRTAB          0000000000000000 02161c 00010a 00      0   0  1<br/>Key to Flags:<br/>  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br/>  L (link order), O (extra OS processing required), G (group), T (TLS),<br/>  C (compressed), x (unknown), o (OS specific), E (exclude),<br/>  l (large), p (processor specific)</span></pre><h1 id="281f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">解决一个基本的CTF挑战</h1><p id="0462" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">现在你对标题有了一个基本的了解，让我们选择一个随机的挑战CTF和爆炸。从<a class="ae mn" href="https://ufile.io/blvpm" rel="noopener ugc nofollow" target="_blank">这里</a>下载二进制文件。</p><p id="6350" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们传入一些随机的字符串时，就会显示出<code class="fe mj mk ml ma b">[+] No flag for you. [+]</code>文本。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="43dc" class="me kp it ma b gy mf mg l mh mi"># ./nix_5744af788e6cbdb29bb41e8b0e5f3cd5 aaaa</span><span id="4885" class="me kp it ma b gy mm mg l mh mi">[+] No flag for you. [+]</span></pre><h1 id="624e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">用线串</h1><p id="94a7" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">让我们从字符串开始，看看有什么有趣的字符串。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="c92e" class="me kp it ma b gy mf mg l mh mi"># strings nix_5744af788e6cbdb29bb41e8b0e5f3cd5 <br/>/lib/ld-linux.so.2<br/>Mw1i#'0<br/>libc.so.6<br/>_IO_stdin_used<br/>exit<br/>sprintf<br/>puts<br/>strlen<br/>__cxa_finalize<br/>__libc_start_main<br/>GLIBC_2.1.3<br/>Y[^]<br/>[^_]<br/>UWVS<br/>[^_]<br/>Usage: script.exe &lt;key&gt;<br/>Length of argv[1] too long.<br/>[+] The flag is: SAYCURE{%s} [+]<br/>[+] No flag for you. [+]<br/>%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c<br/>;*2$"<br/>GCC: (Debian 8.2.0-8) 8.2.0<br/>crtstuff.c</span></pre><p id="d116" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们找到了从二进制文件中打印出来的所有字符串。“%c”是打印我们的标志的格式字符串，我们可以确定标志必须是15个字符。</p><p id="e118" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml ma b">Usage: script.exe<br/>Length of argv[1] too long.<br/>[+] The flag is: SAYCURE{%s} [+]<br/>[+] No flag for you. [+]<br/>%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c</code></p><p id="3ba0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以更好地了解这些字符串，如果我们看看。带有偏移量的“rodata”部分。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="544f" class="me kp it ma b gy mf mg l mh mi"># readelf -x .rodata nix_5744af788e6cbdb29bb41e8b0e5f3cd5 </span><span id="a6a1" class="me kp it ma b gy mm mg l mh mi">Hex dump of section '.rodata':<br/>  0x00002000 03000000 01000200 55736167 653a2073 ........Usage: s<br/>  0x00002010 63726970 742e6578 65203c6b 65793e00 cript.exe &lt;key&gt;.<br/>  0x00002020 4c656e67 7468206f 66206172 67765b31 Length of argv[1<br/>  0x00002030 5d20746f 6f206c6f 6e672e00 5b2b5d20 ] too long..[+] <br/>  0x00002040 54686520 666c6167 2069733a 20534159 The flag is: SAY<br/>  0x00002050 43555245 7b25737d 205b2b5d 0a000a5b CURE{%s} [+]...[<br/>  0x00002060 2b5d204e 6f20666c 61672066 6f722079 +] No flag for y<br/>  0x00002070 6f752e20 5b2b5d00 25632563 25632563 ou. [+].%c%c%c%c<br/>  0x00002080 25632563 25632563 25632563 25632563 %c%c%c%c%c%c%c%c<br/>  0x00002090 25632563 256300                     %c%c%c.</span></pre><h1 id="f381" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">检查符号</h1><p id="eb3d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">通过检查二进制的符号，我们可以意识到它使用了<code class="fe mj mk ml ma b">printf, puts, sprintf, strlen</code>函数。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="cbf3" class="me kp it ma b gy mf mg l mh mi"># nm -D nix_5744af788e6cbdb29bb41e8b0e5f3cd5 <br/>         w __cxa_finalize<br/>         U exit<br/>         w __gmon_start__<br/>00002004 R _IO_stdin_used<br/>         w _ITM_deregisterTMCloneTable<br/>         w _ITM_registerTMCloneTable<br/>         U __libc_start_main<br/>         U printf<br/>         U puts<br/>         U sprintf<br/>         U strlen</span></pre><h1 id="04c7" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">跟踪系统调用</h1><p id="a872" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们可以使用strace之类的工具来跟踪程序使用的系统调用。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="3a03" class="me kp it ma b gy mf mg l mh mi"># strace ./nix_5744af788e6cbdb29bb41e8b0e5f3cd5 aaaa<br/>execve("./nix_5744af788e6cbdb29bb41e8b0e5f3cd5", ["./nix_5744af788e6cbdb29bb41e8b0e"..., "aaaa"], 0x7ffd5ff92d18 /* 46 vars */) = 0<br/>strace: [ Process PID=59965 runs in 32 bit mode. ]<br/>brk(NULL)                               = 0x56f14000<br/>access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)<br/>mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xf7ef0000<br/>access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)<br/>openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3<br/>fstat64(3, {st_mode=S_IFREG|0644, st_size=220471, ...}) = 0<br/>mmap2(NULL, 220471, PROT_READ, MAP_PRIVATE, 3, 0) = 0xf7eba000<br/>close(3)                                = 0<br/>access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)<br/>openat(AT_FDCWD, "/lib/i386-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3<br/>read(3, "\177ELF\1\1\1\3\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \233\1\0004\0\0\0"..., 512) = 512<br/>fstat64(3, {st_mode=S_IFREG|0755, st_size=1930924, ...}) = 0<br/>mmap2(NULL, 1940000, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xf7ce0000<br/>mprotect(0xf7cf9000, 1814528, PROT_NONE) = 0<br/>mmap2(0xf7cf9000, 1359872, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19000) = 0xf7cf9000<br/>mmap2(0xf7e45000, 450560, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x165000) = 0xf7e45000<br/>mmap2(0xf7eb4000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1d3000) = 0xf7eb4000<br/>mmap2(0xf7eb7000, 10784, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xf7eb7000<br/>close(3)                                = 0<br/>set_thread_area({entry_number=-1, base_addr=0xf7ef10c0, limit=0x0fffff, seg_32bit=1, contents=0, read_exec_only=0, limit_in_pages=1, seg_not_present=0, useable=1}) = 0 (entry_number=12)<br/>mprotect(0xf7eb4000, 8192, PROT_READ)   = 0<br/>mprotect(0x5664d000, 4096, PROT_READ)   = 0<br/>mprotect(0xf7f1e000, 4096, PROT_READ)   = 0<br/>munmap(0xf7eba000, 220471)              = 0<br/>fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x2), ...}) = 0<br/>brk(NULL)                               = 0x56f14000<br/>brk(0x56f35000)                         = 0x56f35000<br/>brk(0x56f36000)                         = 0x56f36000<br/>write(1, "\n", 1<br/>)                       = 1<br/>write(1, "[+] No flag for you. [+]\n", 25[+] No flag for you. [+]<br/>) = 25<br/>exit_group(26)                          = ?<br/>+++ exited with 26 +++</span></pre><p id="2fdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了更好地理解，我们可以使用ltrace来跟踪通过解混C++函数名进行的库调用。我们可以看到正在进行字符串长度检查。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="67ad" class="me kp it ma b gy mf mg l mh mi"># ltrace -i -C ./nix_5744af788e6cbdb29bb41e8b0e5f3cd5 aaaaaaaa<br/>[0x565570e1] __libc_start_main(0x565571e9, 2, 0xffe3a584, 0x56557400 &lt;unfinished ...&gt;<br/>[0x56557249] strlen("aaaaaaaa")                                                                                      = 8<br/>[0x565572ca] puts("\n[+] No flag for you. [+]"<br/>[+] No flag for you. [+]<br/>)                                                                      = 26<br/>[0xffffffffffffffff] +++ exited (status 26) +++</span></pre><h1 id="7423" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">分解文本部分</h1><p id="7cc2" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">让我们来看看。正文部分的反汇编和试理解。在这个二进制代码中，符号没有被去掉，所以我们可以看到函数名，这样更容易理解。如果你现在能读懂汇编，你就会明白发生了什么。如果没有，让我们做一些现场调试，并试图更好地理解。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="b142" class="me kp it ma b gy mf mg l mh mi">root@Omega:/mnt/hgfs/shared/Linux RE# objdump -D -M intel -j .text nix_5744af788e6cbdb29bb41e8b0e5f3cd5 </span><span id="aec0" class="me kp it ma b gy mm mg l mh mi">nix_5744af788e6cbdb29bb41e8b0e5f3cd5:     file format elf32-i386<br/></span><span id="0bc9" class="me kp it ma b gy mm mg l mh mi">Disassembly of section .text:</span><span id="d119" class="me kp it ma b gy mm mg l mh mi">000010b0 &lt;_start&gt;:<br/>    10b0:	31 ed                	xor    ebp,ebp<br/>    10b2:	5e                   	pop    esi<br/>    10b3:	89 e1                	mov    ecx,esp<br/>    10b5:	83 e4 f0             	and    esp,0xfffffff0<br/>    10b8:	50                   	push   eax<br/>    10b9:	54                   	push   esp<br/>    10ba:	52                   	push   edx<br/>    10bb:	e8 22 00 00 00       	call   10e2 &lt;_start+0x32&gt;<br/>    10c0:	81 c3 40 2f 00 00    	add    ebx,0x2f40<br/>    10c6:	8d 83 60 d4 ff ff    	lea    eax,[ebx-0x2ba0]<br/>    10cc:	50                   	push   eax<br/>    10cd:	8d 83 00 d4 ff ff    	lea    eax,[ebx-0x2c00]<br/>    10d3:	50                   	push   eax<br/>    10d4:	51                   	push   ecx<br/>    10d5:	56                   	push   esi<br/>    10d6:	ff b3 f8 ff ff ff    	push   DWORD PTR [ebx-0x8]<br/>    10dc:	e8 9f ff ff ff       	call   1080 &lt;__libc_start_main@plt&gt;<br/>    10e1:	f4                   	hlt    <br/>    10e2:	8b 1c 24             	mov    ebx,DWORD PTR [esp]<br/>    10e5:	c3                   	ret    <br/>    10e6:	66 90                	xchg   ax,ax<br/>    10e8:	66 90                	xchg   ax,ax<br/>    10ea:	66 90                	xchg   ax,ax<br/>    10ec:	66 90                	xchg   ax,ax<br/>    10ee:	66 90                	xchg   ax,ax</span><span id="0904" class="me kp it ma b gy mm mg l mh mi">... Output Omitted ...</span><span id="6a49" class="me kp it ma b gy mm mg l mh mi">000011e9 &lt;main&gt;:<br/>    11e9:	8d 4c 24 04          	lea    ecx,[esp+0x4]<br/>    11ed:	83 e4 f0             	and    esp,0xfffffff0<br/>    11f0:	ff 71 fc             	push   DWORD PTR [ecx-0x4]<br/>    11f3:	55                   	push   ebp<br/>    11f4:	89 e5                	mov    ebp,esp<br/>    11f6:	56                   	push   esi<br/>    11f7:	53                   	push   ebx<br/>    11f8:	51                   	push   ecx<br/>    11f9:	83 ec 1c             	sub    esp,0x1c<br/>    11fc:	e8 ef fe ff ff       	call   10f0 &lt;__x86.get_pc_thunk.bx&gt;<br/>    1201:	81 c3 ff 2d 00 00    	add    ebx,0x2dff<br/>    1207:	89 ce                	mov    esi,ecx<br/>    1209:	c7 45 e4 00 00 00 00 	mov    DWORD PTR [ebp-0x1c],0x0<br/>    1210:	c7 45 dc 07 00 00 00 	mov    DWORD PTR [ebp-0x24],0x7<br/>    1217:	83 3e 02             	cmp    DWORD PTR [esi],0x2<br/>    121a:	74 1c                	je     1238 &lt;main+0x4f&gt;<br/>    121c:	83 ec 0c             	sub    esp,0xc<br/>    121f:	8d 83 08 e0 ff ff    	lea    eax,[ebx-0x1ff8]<br/>    1225:	50                   	push   eax<br/>    1226:	e8 15 fe ff ff       	call   1040 &lt;printf@plt&gt;<br/>    122b:	83 c4 10             	add    esp,0x10<br/>    122e:	83 ec 0c             	sub    esp,0xc<br/>    1231:	6a 01                	push   0x1<br/>    1233:	e8 28 fe ff ff       	call   1060 &lt;exit@plt&gt;<br/>    1238:	8b 46 04             	mov    eax,DWORD PTR [esi+0x4]<br/>    123b:	83 c0 04             	add    eax,0x4<br/>    123e:	8b 00                	mov    eax,DWORD PTR [eax]<br/>    1240:	83 ec 0c             	sub    esp,0xc<br/>    1243:	50                   	push   eax<br/>    1244:	e8 27 fe ff ff       	call   1070 &lt;strlen@plt&gt;<br/>    1249:	83 c4 10             	add    esp,0x10<br/>    124c:	83 f8 0f             	cmp    eax,0xf<br/>    124f:	76 1c                	jbe    126d &lt;main+0x84&gt;<br/>    1251:	83 ec 0c             	sub    esp,0xc<br/>    1254:	8d 83 20 e0 ff ff    	lea    eax,[ebx-0x1fe0]<br/>    125a:	50                   	push   eax<br/>    125b:	e8 f0 fd ff ff       	call   1050 &lt;puts@plt&gt;<br/>    1260:	83 c4 10             	add    esp,0x10<br/>    1263:	83 ec 0c             	sub    esp,0xc<br/>    1266:	6a 01                	push   0x1<br/>    1268:	e8 f3 fd ff ff       	call   1060 &lt;exit@plt&gt;<br/>    126d:	c7 45 e0 00 00 00 00 	mov    DWORD PTR [ebp-0x20],0x0<br/>    1274:	eb 1a                	jmp    1290 &lt;main+0xa7&gt;<br/>    1276:	8b 46 04             	mov    eax,DWORD PTR [esi+0x4]<br/>    1279:	83 c0 04             	add    eax,0x4<br/>    127c:	8b 10                	mov    edx,DWORD PTR [eax]<br/>    127e:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]<br/>    1281:	01 d0                	add    eax,edx<br/>    1283:	0f b6 00             	movzx  eax,BYTE PTR [eax]<br/>    1286:	0f be c0             	movsx  eax,al<br/>    1289:	01 45 e4             	add    DWORD PTR [ebp-0x1c],eax<br/>    128c:	83 45 e0 01          	add    DWORD PTR [ebp-0x20],0x1<br/>    1290:	8b 45 e0             	mov    eax,DWORD PTR [ebp-0x20]<br/>    1293:	3b 45 dc             	cmp    eax,DWORD PTR [ebp-0x24]<br/>    1296:	7c de                	jl     1276 &lt;main+0x8d&gt;<br/>    1298:	81 7d e4 21 03 00 00 	cmp    DWORD PTR [ebp-0x1c],0x321<br/>    129f:	75 1a                	jne    12bb &lt;main+0xd2&gt;<br/>    12a1:	e8 33 00 00 00       	call   12d9 &lt;comp_key&gt;<br/>    12a6:	83 ec 08             	sub    esp,0x8<br/>    12a9:	50                   	push   eax<br/>    12aa:	8d 83 3c e0 ff ff    	lea    eax,[ebx-0x1fc4]<br/>    12b0:	50                   	push   eax<br/>    12b1:	e8 8a fd ff ff       	call   1040 &lt;printf@plt&gt;<br/>    12b6:	83 c4 10             	add    esp,0x10<br/>    12b9:	eb 12                	jmp    12cd &lt;main+0xe4&gt;<br/>    12bb:	83 ec 0c             	sub    esp,0xc<br/>    12be:	8d 83 5e e0 ff ff    	lea    eax,[ebx-0x1fa2]<br/>    12c4:	50                   	push   eax<br/>    12c5:	e8 86 fd ff ff       	call   1050 &lt;puts@plt&gt;<br/>    12ca:	83 c4 10             	add    esp,0x10<br/>    12cd:	90                   	nop<br/>    12ce:	8d 65 f4             	lea    esp,[ebp-0xc]<br/>    12d1:	59                   	pop    ecx<br/>    12d2:	5b                   	pop    ebx<br/>    12d3:	5e                   	pop    esi<br/>    12d4:	5d                   	pop    ebp<br/>    12d5:	8d 61 fc             	lea    esp,[ecx-0x4]<br/>    12d8:	c3                   	ret    </span><span id="8b0b" class="me kp it ma b gy mm mg l mh mi">000012d9 &lt;comp_key&gt;:<br/>    12d9:	55                   	push   ebp<br/>    12da:	89 e5                	mov    ebp,esp<br/>    12dc:	57                   	push   edi<br/>    12dd:	56                   	push   esi<br/>    12de:	53                   	push   ebx<br/>    12df:	83 ec 7c             	sub    esp,0x7c<br/>    12e2:	e8 09 fe ff ff       	call   10f0 &lt;__x86.get_pc_thunk.bx&gt;<br/>    12e7:	81 c3 19 2d 00 00    	add    ebx,0x2d19<br/>    12ed:	c7 45 e4 00 00 00 00 	mov    DWORD PTR [ebp-0x1c],0x0<br/>    12f4:	c7 45 a8 4c 00 00 00 	mov    DWORD PTR [ebp-0x58],0x4c<br/>    12fb:	c7 45 ac 33 00 00 00 	mov    DWORD PTR [ebp-0x54],0x33<br/>    1302:	c7 45 b0 74 00 00 00 	mov    DWORD PTR [ebp-0x50],0x74<br/>    1309:	c7 45 b4 73 00 00 00 	mov    DWORD PTR [ebp-0x4c],0x73<br/>    1310:	c7 45 b8 5f 00 00 00 	mov    DWORD PTR [ebp-0x48],0x5f<br/>    1317:	c7 45 bc 67 00 00 00 	mov    DWORD PTR [ebp-0x44],0x67<br/>    131e:	c7 45 c0 33 00 00 00 	mov    DWORD PTR [ebp-0x40],0x33<br/>    1325:	c7 45 c4 74 00 00 00 	mov    DWORD PTR [ebp-0x3c],0x74<br/>    132c:	c7 45 c8 5f 00 00 00 	mov    DWORD PTR [ebp-0x38],0x5f<br/>    1333:	c7 45 cc 69 00 00 00 	mov    DWORD PTR [ebp-0x34],0x69<br/>    133a:	c7 45 d0 6e 00 00 00 	mov    DWORD PTR [ebp-0x30],0x6e<br/>    1341:	c7 45 d4 32 00 00 00 	mov    DWORD PTR [ebp-0x2c],0x32<br/>    1348:	c7 45 d8 5f 00 00 00 	mov    DWORD PTR [ebp-0x28],0x5f<br/>    134f:	c7 45 dc 52 00 00 00 	mov    DWORD PTR [ebp-0x24],0x52<br/>    1356:	c7 45 e0 33 00 00 00 	mov    DWORD PTR [ebp-0x20],0x33<br/>    135d:	8b 55 e0             	mov    edx,DWORD PTR [ebp-0x20]<br/>    1360:	8b 75 dc             	mov    esi,DWORD PTR [ebp-0x24]<br/>    1363:	8b 45 d8             	mov    eax,DWORD PTR [ebp-0x28]<br/>    1366:	89 45 a4             	mov    DWORD PTR [ebp-0x5c],eax<br/>    1369:	8b 4d d4             	mov    ecx,DWORD PTR [ebp-0x2c]<br/>    136c:	89 4d a0             	mov    DWORD PTR [ebp-0x60],ecx<br/>    136f:	8b 7d d0             	mov    edi,DWORD PTR [ebp-0x30]<br/>    1372:	89 7d 9c             	mov    DWORD PTR [ebp-0x64],edi<br/>    1375:	8b 45 cc             	mov    eax,DWORD PTR [ebp-0x34]<br/>    1378:	89 45 98             	mov    DWORD PTR [ebp-0x68],eax<br/>    137b:	8b 4d c8             	mov    ecx,DWORD PTR [ebp-0x38]<br/>    137e:	89 4d 94             	mov    DWORD PTR [ebp-0x6c],ecx<br/>    1381:	8b 7d c4             	mov    edi,DWORD PTR [ebp-0x3c]<br/>    1384:	89 7d 90             	mov    DWORD PTR [ebp-0x70],edi<br/>    1387:	8b 45 c0             	mov    eax,DWORD PTR [ebp-0x40]<br/>    138a:	89 45 8c             	mov    DWORD PTR [ebp-0x74],eax<br/>    138d:	8b 4d bc             	mov    ecx,DWORD PTR [ebp-0x44]<br/>    1390:	89 4d 88             	mov    DWORD PTR [ebp-0x78],ecx<br/>    1393:	8b 7d b8             	mov    edi,DWORD PTR [ebp-0x48]<br/>    1396:	89 7d 84             	mov    DWORD PTR [ebp-0x7c],edi<br/>    1399:	8b 45 b4             	mov    eax,DWORD PTR [ebp-0x4c]<br/>    139c:	89 45 80             	mov    DWORD PTR [ebp-0x80],eax<br/>    139f:	8b 7d b0             	mov    edi,DWORD PTR [ebp-0x50]<br/>    13a2:	8b 4d ac             	mov    ecx,DWORD PTR [ebp-0x54]<br/>    13a5:	8b 45 a8             	mov    eax,DWORD PTR [ebp-0x58]<br/>    13a8:	83 ec 0c             	sub    esp,0xc<br/>    13ab:	52                   	push   edx<br/>    13ac:	56                   	push   esi<br/>    13ad:	ff 75 a4             	push   DWORD PTR [ebp-0x5c]<br/>    13b0:	ff 75 a0             	push   DWORD PTR [ebp-0x60]<br/>    13b3:	ff 75 9c             	push   DWORD PTR [ebp-0x64]<br/>    13b6:	ff 75 98             	push   DWORD PTR [ebp-0x68]<br/>    13b9:	ff 75 94             	push   DWORD PTR [ebp-0x6c]<br/>    13bc:	ff 75 90             	push   DWORD PTR [ebp-0x70]<br/>    13bf:	ff 75 8c             	push   DWORD PTR [ebp-0x74]<br/>    13c2:	ff 75 88             	push   DWORD PTR [ebp-0x78]<br/>    13c5:	ff 75 84             	push   DWORD PTR [ebp-0x7c]<br/>    13c8:	ff 75 80             	push   DWORD PTR [ebp-0x80]<br/>    13cb:	57                   	push   edi<br/>    13cc:	51                   	push   ecx<br/>    13cd:	50                   	push   eax<br/>    13ce:	8d 83 78 e0 ff ff    	lea    eax,[ebx-0x1f88]<br/>    13d4:	50                   	push   eax<br/>    13d5:	8d 83 30 00 00 00    	lea    eax,[ebx+0x30]<br/>    13db:	50                   	push   eax<br/>    13dc:	e8 af fc ff ff       	call   1090 &lt;sprintf@plt&gt;<br/>    13e1:	83 c4 50             	add    esp,0x50<br/>    13e4:	8d 83 30 00 00 00    	lea    eax,[ebx+0x30]<br/>    13ea:	8d 65 f4             	lea    esp,[ebp-0xc]<br/>    13ed:	5b                   	pop    ebx<br/>    13ee:	5e                   	pop    esi<br/>    13ef:	5f                   	pop    edi<br/>    13f0:	5d                   	pop    ebp<br/>    13f1:	c3                   	ret    <br/>    13f2:	66 90                	xchg   ax,ax<br/>    13f4:	66 90                	xchg   ax,ax<br/>    13f6:	66 90                	xchg   ax,ax<br/>    13f8:	66 90                	xchg   ax,ax<br/>    13fa:	66 90                	xchg   ax,ax<br/>    13fc:	66 90                	xchg   ax,ax<br/>    13fe:	66 90                	xchg   ax,ax</span><span id="f6cc" class="me kp it ma b gy mm mg l mh mi">... Output Omitted ...</span></pre><h1 id="1546" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">实时调试</h1><p id="225e" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">为此，我将使用GDB-佩达，这样更容易理解。让我们首先检查二进制文件中的函数。我们可以看到<code class="fe mj mk ml ma b">main, comp_key</code>等功能</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="5676" class="me kp it ma b gy mf mg l mh mi">gdb-peda$ info functions <br/>All defined functions:</span><span id="3304" class="me kp it ma b gy mm mg l mh mi">Non-debugging symbols:<br/>0x00001000  _init<br/>0x00001040  printf@plt<br/>0x00001050  puts@plt<br/>0x00001060  exit@plt<br/>0x00001070  strlen@plt<br/>0x00001080  __libc_start_main@plt<br/>0x00001090  sprintf@plt<br/>0x000010a0  __cxa_finalize@plt<br/>0x000010a8  __gmon_start__@plt<br/>0x000010b0  _start<br/>0x000010f0  __x86.get_pc_thunk.bx<br/>0x00001100  deregister_tm_clones<br/>0x00001140  register_tm_clones<br/>0x00001190  __do_global_dtors_aux<br/>0x000011e0  frame_dummy<br/>0x000011e5  __x86.get_pc_thunk.dx<br/>0x000011e9  main<br/>0x000012d9  comp_key<br/>0x00001400  __libc_csu_init<br/>0x00001460  __libc_csu_fini<br/>0x00001464  _fini</span></pre><p id="33d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是你调试程序的方法。我们将在主函数中找到一个断点。使用<code class="fe mj mk ml ma b">n</code>步进，使用<code class="fe mj mk ml ma b">ni</code>步进每个指令。如果你不懂汇编，在像这样的基本挑战中，寻找跳转，比较指令。试着理解检查程序做什么，并在头脑中建立逻辑。有许多很好的汇编速成课程，我建议少读一些。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="4933" class="me kp it ma b gy mf mg l mh mi">gdb-peda$ break main<br/>Breakpoint 1 at 0x11f9<br/>gdb-peda$ run aaaaaaaa<br/>Starting program: /mnt/hgfs/shared/Linux RE/nix_5744af788e6cbdb29bb41e8b0e5f3cd5 aaaaaaaa</span><span id="d1fa" class="me kp it ma b gy mm mg l mh mi">[----------------------------------registers-----------------------------------]<br/>EAX: 0xf7f95dd8 --&gt; 0xffffd2f0 --&gt; 0xffffd4d1 ("NVM_DIR=/root/.nvm")<br/>EBX: 0x0 <br/>ECX: 0xffffd250 --&gt; 0x2 <br/>EDX: 0xffffd274 --&gt; 0x0 <br/>ESI: 0xf7f94000 --&gt; 0x1d5d8c <br/>EDI: 0x0 <br/>EBP: 0xffffd238 --&gt; 0x0 <br/>ESP: 0xffffd22c --&gt; 0xffffd250 --&gt; 0x2 <br/>EIP: 0x565561f9 (&lt;main+16&gt;:	sub    esp,0x1c)<br/>EFLAGS: 0x282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)<br/>[-------------------------------------code-------------------------------------]<br/>   0x565561f6 &lt;main+13&gt;:	push   esi<br/>   0x565561f7 &lt;main+14&gt;:	push   ebx<br/>   0x565561f8 &lt;main+15&gt;:	push   ecx<br/>=&gt; 0x565561f9 &lt;main+16&gt;:	sub    esp,0x1c<br/>   0x565561fc &lt;main+19&gt;:	call   0x565560f0 &lt;__x86.get_pc_thunk.bx&gt;<br/>   0x56556201 &lt;main+24&gt;:	add    ebx,0x2dff<br/>   0x56556207 &lt;main+30&gt;:	mov    esi,ecx<br/>   0x56556209 &lt;main+32&gt;:	mov    DWORD PTR [ebp-0x1c],0x0<br/>[------------------------------------stack-------------------------------------]<br/>0000| 0xffffd22c --&gt; 0xffffd250 --&gt; 0x2 <br/>0004| 0xffffd230 --&gt; 0x0 <br/>0008| 0xffffd234 --&gt; 0xf7f94000 --&gt; 0x1d5d8c <br/>0012| 0xffffd238 --&gt; 0x0 <br/>0016| 0xffffd23c --&gt; 0xf7dd79a1 (&lt;__libc_start_main+241&gt;:	add    esp,0x10)<br/>0020| 0xffffd240 --&gt; 0xf7f94000 --&gt; 0x1d5d8c <br/>0024| 0xffffd244 --&gt; 0xf7f94000 --&gt; 0x1d5d8c <br/>0028| 0xffffd248 --&gt; 0x0 <br/>[------------------------------------------------------------------------------]<br/>Legend: code, data, rodata, value</span><span id="5870" class="me kp it ma b gy mm mg l mh mi">Breakpoint 1, 0x565561f9 in main ()<br/>1: main = {&lt;text variable, no debug info&gt;} 0x565561e9 &lt;main&gt;<br/>2: puts = {&lt;text variable, no debug info&gt;} 0xf7e25e40 &lt;puts&gt;<br/>gdb-peda$</span></pre><p id="e95f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你玩一下gdb，你就会明白它是如何工作的。让我们试着一部分一部分去理解其中的逻辑。</p><p id="2a68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">程序首先尝试比较参数的数量。它存储在ecx寄存器中，并移至esi，用于将该值与0x2进行比较。你可以用gdb来过一遍汇编指令，更好的理解。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="f535" class="me kp it ma b gy mf mg l mh mi">0x56556207 &lt;+30&gt;:	mov    esi,ecx<br/>   0x56556209 &lt;+32&gt;:	mov    DWORD PTR [ebp-0x1c],0x0<br/>   0x56556210 &lt;+39&gt;:	mov    DWORD PTR [ebp-0x24],0x7<br/>   0x56556217 &lt;+46&gt;:	cmp    DWORD PTR [esi],0x2<br/>   0x5655621a &lt;+49&gt;:	je     0x56556238 &lt;main+79&gt;<br/>   0x5655621c &lt;+51&gt;:	sub    esp,0xc<br/>   0x5655621f &lt;+54&gt;:	lea    eax,[ebx-0x1ff8]<br/>   0x56556225 &lt;+60&gt;:	push   eax<br/>   0x56556226 &lt;+61&gt;:	call   0x56556040 &lt;printf@plt&gt;<br/>   0x5655622b &lt;+66&gt;:	add    esp,0x10<br/>   0x5655622e &lt;+69&gt;:	sub    esp,0xc<br/>   0x56556231 &lt;+72&gt;:	push   0x1<br/>   0x56556233 &lt;+74&gt;:	call   0x56556060 &lt;exit@plt&gt;</span></pre><p id="4cef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以这样写伪代码。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="6d2f" class="me kp it ma b gy mf mg l mh mi">if(argc != 2) {<br/>  printf("Usage: script.exe &lt;key&gt;");<br/>  exit(1);<br/>}</span><span id="440e" class="me kp it ma b gy mm mg l mh mi">0x56556238 &lt;+79&gt;:	mov    eax,DWORD PTR [esi+0x4]<br/>   0x5655623b &lt;+82&gt;:	add    eax,0x4<br/>   0x5655623e &lt;+85&gt;:	mov    eax,DWORD PTR [eax]<br/>   0x56556240 &lt;+87&gt;:	sub    esp,0xc<br/>   0x56556243 &lt;+90&gt;:	push   eax<br/>   0x56556244 &lt;+91&gt;:	call   0x56556070 &lt;strlen@plt&gt;<br/>   0x56556249 &lt;+96&gt;:	add    esp,0x10<br/>   0x5655624c &lt;+99&gt;:	cmp    eax,0xf<br/>   0x5655624f &lt;+102&gt;:	jbe    0x5655626d &lt;main+132&gt;<br/>   0x56556251 &lt;+104&gt;:	sub    esp,0xc<br/>   0x56556254 &lt;+107&gt;:	lea    eax,[ebx-0x1fe0]<br/>   0x5655625a &lt;+113&gt;:	push   eax<br/>   0x5655625b &lt;+114&gt;:	call   0x56556050 &lt;puts@plt&gt;<br/>   0x56556260 &lt;+119&gt;:	add    esp,0x10<br/>   0x56556263 &lt;+122&gt;:	sub    esp,0xc<br/>   0x56556266 &lt;+125&gt;:	push   0x1<br/>   0x56556268 &lt;+127&gt;:	call   0x56556060 &lt;exit@plt&gt;</span></pre><p id="3490" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">翻译后:</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="ae5c" class="me kp it ma b gy mf mg l mh mi">if(strlen(argv[1]) &gt; 15) {<br/>  puts("Length of argv[1] too long.");<br/>  exit(1);<br/>}</span></pre><p id="f280" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你检查这段代码，我们可以看到有一个循环遍历我们提供的字符串的每个字符。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="7453" class="me kp it ma b gy mf mg l mh mi">0x5655626d &lt;+132&gt;:	mov    DWORD PTR [ebp-0x20],0x0<br/>   0x56556274 &lt;+139&gt;:	jmp    0x56556290 &lt;main+167&gt;<br/>   0x56556276 &lt;+141&gt;:	mov    eax,DWORD PTR [esi+0x4]<br/>   0x56556279 &lt;+144&gt;:	add    eax,0x4<br/>   0x5655627c &lt;+147&gt;:	mov    edx,DWORD PTR [eax]<br/>   0x5655627e &lt;+149&gt;:	mov    eax,DWORD PTR [ebp-0x20]<br/>   0x56556281 &lt;+152&gt;:	add    eax,edx<br/>   0x56556283 &lt;+154&gt;:	movzx  eax,BYTE PTR [eax]<br/>   0x56556286 &lt;+157&gt;:	movsx  eax,al<br/>   0x56556289 &lt;+160&gt;:	add    DWORD PTR [ebp-0x1c],eax<br/>   0x5655628c &lt;+163&gt;:	add    DWORD PTR [ebp-0x20],0x1<br/>   0x56556290 &lt;+167&gt;:	mov    eax,DWORD PTR [ebp-0x20]<br/>   0x56556293 &lt;+170&gt;:	cmp    eax,DWORD PTR [ebp-0x24]<br/>   0x56556296 &lt;+173&gt;:	jl     0x56556276 &lt;main+141&gt;<br/>   0x56556298 &lt;+175&gt;:	cmp    DWORD PTR [ebp-0x1c],0x321<br/>   0x5655629f &lt;+182&gt;:	jne    0x565562bb &lt;main+210&gt;<br/>   0x565562a1 &lt;+184&gt;:	call   0x565562d9 &lt;comp_key&gt;<br/>   0x565562a6 &lt;+189&gt;:	sub    esp,0x8<br/>   0x565562a9 &lt;+192&gt;:	push   eax<br/>   0x565562aa &lt;+193&gt;:	lea    eax,[ebx-0x1fc4]<br/>   0x565562b0 &lt;+199&gt;:	push   eax<br/>   0x565562b1 &lt;+200&gt;:	call   0x56556040 &lt;printf@plt&gt;<br/>   0x565562b6 &lt;+205&gt;:	add    esp,0x10<br/>   0x565562b9 &lt;+208&gt;:	jmp    0x565562cd &lt;main+228&gt;<br/>   0x565562bb &lt;+210&gt;:	sub    esp,0xc<br/>   0x565562be &lt;+213&gt;:	lea    eax,[ebx-0x1fa2]<br/>   0x565562c4 &lt;+219&gt;:	push   eax<br/>   0x565562c5 &lt;+220&gt;:	call   0x56556050 &lt;puts@plt&gt;<br/>   0x565562ca &lt;+225&gt;:	add    esp,0x10<br/>   0x565562cd &lt;+228&gt;:	nop<br/>   0x565562ce &lt;+229&gt;:	lea    esp,[ebp-0xc]<br/>   0x565562d1 &lt;+232&gt;:	pop    ecx<br/>   0x565562d2 &lt;+233&gt;:	pop    ebx<br/>   0x565562d3 &lt;+234&gt;:	pop    esi<br/>   0x565562d4 &lt;+235&gt;:	pop    ebp<br/>   0x565562d5 &lt;+236&gt;:	lea    esp,[ecx-0x4]<br/>   0x565562d8 &lt;+239&gt;:	ret</span></pre><p id="a6a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它最多循环多少个字符？我是这样找到的。基本上，我们的密码长度必须是7个字符。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="2343" class="me kp it ma b gy mf mg l mh mi">[----------------------------------registers-----------------------------------]<br/>EAX: 0x6 <br/>EBX: 0x56559000 --&gt; 0x3efc <br/>ECX: 0x6 <br/>EDX: 0xffffd4c6 ("1234567890")<br/>ESI: 0xffffd250 --&gt; 0x2 <br/>EDI: 0x0 <br/>EBP: 0xffffd238 --&gt; 0x0 <br/>ESP: 0xffffd210 --&gt; 0xf7f943fc --&gt; 0xf7f95200 --&gt; 0x0 <br/>EIP: 0x56556293 (&lt;main+170&gt;:	cmp    eax,DWORD PTR [ebp-0x24])<br/>EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)<br/>[-------------------------------------code-------------------------------------]<br/>   0x56556289 &lt;main+160&gt;:	add    DWORD PTR [ebp-0x1c],eax<br/>   0x5655628c &lt;main+163&gt;:	add    DWORD PTR [ebp-0x20],0x1<br/>   0x56556290 &lt;main+167&gt;:	mov    eax,DWORD PTR [ebp-0x20]<br/>=&gt; 0x56556293 &lt;main+170&gt;:	cmp    eax,DWORD PTR [ebp-0x24]<br/>   0x56556296 &lt;main+173&gt;:	jl     0x56556276 &lt;main+141&gt;<br/>   0x56556298 &lt;main+175&gt;:	cmp    DWORD PTR [ebp-0x1c],0x321<br/>   0x5655629f &lt;main+182&gt;:	jne    0x565562bb &lt;main+210&gt;<br/>   0x565562a1 &lt;main+184&gt;:	call   0x565562d9 &lt;comp_key&gt;<br/>[------------------------------------stack-------------------------------------]<br/>0000| 0xffffd210 --&gt; 0xf7f943fc --&gt; 0xf7f95200 --&gt; 0x0 <br/>0004| 0xffffd214 --&gt; 0x7 <br/>0008| 0xffffd218 --&gt; 0x6 <br/>0012| 0xffffd21c --&gt; 0x135 <br/>0016| 0xffffd220 --&gt; 0x2 <br/>0020| 0xffffd224 --&gt; 0xffffd2e4 --&gt; 0xffffd487 ("/mnt/hgfs/shared/Linux RE/nix_5744af788e6cbdb29bb41e8b0e5f3cd5")<br/>0024| 0xffffd228 --&gt; 0xffffd2f0 --&gt; 0xffffd4d1 ("NVM_DIR=/root/.nvm")<br/>0028| 0xffffd22c --&gt; 0xffffd250 --&gt; 0x2 <br/>[------------------------------------------------------------------------------]<br/>Legend: code, data, rodata, value<br/>0x56556293 in main ()<br/>gdb-peda$ print $ebp-0x24<br/>$24 = (void *) 0xffffd214<br/>gdb-peda$ x/x 0xffffd214<br/>0xffffd214:	0x00000007</span></pre><p id="839c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在翻译成高级代码后，它看起来会像这样。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="2047" class="me kp it ma b gy mf mg l mh mi">for (i = 0; i &lt; 7; i++) value += argv[1][i];<br/>if (value != 801) return puts("\n[+] No flag for you. [+]");<br/>return printf("[+] The flag is: SAYCURE{%s} [+]\n", comp_key());</span></pre><p id="142b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上，我们的密码的每个字节的总和必须等于801。给我们7个字，我们可以这样概括。你可以使用任何加起来等于801的计算方法。检查完成后，它调用comp_key函数并打印出标志。我们并不真的需要挖掘com_key函数，因为它直接给了我们标志。</p><p id="94db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mj mk ml ma b">114 * 6 + 117 = 801</code></p><p id="d680" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们检查一下ASCII表中的那些字符。114是‘r’，117是‘u’。</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="d043" class="me kp it ma b gy mf mg l mh mi">Dec Hex    Dec Hex    Dec Hex  Dec Hex  Dec Hex  Dec Hex   Dec Hex   Dec Hex  <br/>  0 00 NUL  16 10 DLE  32 20    48 30 0  64 40 @  80 50 P   96 60 `  112 70 p<br/>  1 01 SOH  17 11 DC1  33 21 !  49 31 1  65 41 A  81 51 Q   97 61 a  113 71 q<br/>  2 02 STX  18 12 DC2  34 22 "  50 32 2  66 42 B  82 52 R   98 62 b  114 72 r<br/>  3 03 ETX  19 13 DC3  35 23 #  51 33 3  67 43 C  83 53 S   99 63 c  115 73 s<br/>  4 04 EOT  20 14 DC4  36 24 $  52 34 4  68 44 D  84 54 T  100 64 d  116 74 t<br/>  5 05 ENQ  21 15 NAK  37 25 %  53 35 5  69 45 E  85 55 U  101 65 e  117 75 u<br/>  6 06 ACK  22 16 SYN  38 26 &amp;  54 36 6  70 46 F  86 56 V  102 66 f  118 76 v<br/>  7 07 BEL  23 17 ETB  39 27 '  55 37 7  71 47 G  87 57 W  103 67 g  119 77 w<br/>  8 08 BS   24 18 CAN  40 28 (  56 38 8  72 48 H  88 58 X  104 68 h  120 78 x<br/>  9 09 HT   25 19 EM   41 29 )  57 39 9  73 49 I  89 59 Y  105 69 i  121 79 y<br/> 10 0A LF   26 1A SUB  42 2A *  58 3A :  74 4A J  90 5A Z  106 6A j  122 7A z<br/> 11 0B VT   27 1B ESC  43 2B +  59 3B ;  75 4B K  91 5B [  107 6B k  123 7B {<br/> 12 0C FF   28 1C FS   44 2C ,  60 3C &lt;  76 4C L  92 5C \  108 6C l  124 7C |<br/> 13 0D CR   29 1D GS   45 2D -  61 3D =  77 4D M  93 5D ]  109 6D m  125 7D }<br/> 14 0E SO   30 1E RS   46 2E .  62 3E &gt;  78 4E N  94 5E ^  110 6E n  126 7E ~<br/> 15 0F SI   31 1F US   47 2F /  63 3F ?  79 4F O  95 5F _  111 6F o  127 7F DEL</span></pre><p id="2925" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！我们刚刚解决了一个非常简单的二元问题</p><pre class="ls lt lu lv gt lz ma mb mc aw md bi"><span id="f592" class="me kp it ma b gy mf mg l mh mi"># ./nix_5744af788e6cbdb29bb41e8b0e5f3cd5 rrrrrru<br/>[+] The flag is: SAYCURE{L3ts_g3t_in2_R3} [+]</span></pre><h1 id="96b0" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">参考</h1><p id="c46a" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><a class="ae mn" href="http://www.cirosantilli.com/elf-hello-world/" rel="noopener ugc nofollow" target="_blank">http://www.cirosantilli.com/elf-hello-world/</a></p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="b8b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mv">关注</em> <a class="ae mn" href="https://medium.com/bugbountywriteup" rel="noopener"> <em class="mv"> Infosec报道</em> </a> <em class="mv">获取更多此类精彩报道。</em></p><div class="mw mx gp gr my mz"><a href="https://medium.com/bugbountywriteup" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">信息安全报道</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">收集了世界上最好的黑客的文章，主题从bug奖金和CTF到vulnhub…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn lx mz"/></div></div></a></div></div></div>    
</body>
</html>