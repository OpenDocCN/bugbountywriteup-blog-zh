<html>
<head>
<title>BOLO: Reverse Engineering — Part 1 (Basic Programming Concepts)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BOLO:逆向工程—第1部分(基本编程概念)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/bolo-reverse-engineering-part-1-basic-programming-concepts-f88b233c63b7?source=collection_archive---------1-----------------------#2018-04-16">https://infosecwriteups.com/bolo-reverse-engineering-part-1-basic-programming-concepts-f88b233c63b7?source=collection_archive---------1-----------------------#2018-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/976e52e3080f5f1715200d3406de9320.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*BfGy7hidzSoMSrXMGk86XQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">逆向工程</figcaption></figure><p id="24ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">在逆向工程的学习过程中，我发现自己需要一个简单的指南来指导我在浏览汇编代码时应该寻找什么。虽然我是阅读源代码和信息手册的忠实信徒，但我完全理解在一个地方拥有简明、易于理解的信息的愿望。这个《BOLO:逆向工程》系列正是如此！在这一系列文章中，我将向你展示关于逆向工程代码时的<strong class="ka ir">B</strong>e<strong class="ka ir">O</strong>n<strong class="ka ir">L</strong>ook<strong class="ka ir">O</strong>ut的事情。理想情况下，这一系列文章将使初级逆向工程师更容易掌握许多不同的概念！</p><h1 id="8a2a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">前言</h1><p id="5228" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在整篇文章中，你会看到C++代码和汇编代码的截图，以及一些关于你所看到的和为什么事情看起来是这样的解释。此外，本系列文章<strong class="ka ir">将不会涵盖汇编</strong>的基础知识，它将只展示模式和反编译代码，以便您可以大致了解应该寻找什么/如何解释汇编代码。</p><p id="bb6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将涵盖:</p><ol class=""><li id="b6ad" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">可变引发</li><li id="ad05" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">基本输出</li><li id="5f14" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">数学运算</li><li id="0e0b" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">功能</li><li id="6cb6" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">循环(用于循环/ While循环)</li><li id="d382" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">条件语句(IF语句/ Switch语句)</li><li id="5b62" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">用户输入</li></ol><p id="2c1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mw">请注意:本教程是在微软Visual Studio 2015(我知道，过时版本)中用visual C++做的。一些汇编代码(即cin的用户输入)将反映这一点。此外，我使用IDA Pro作为我的反汇编程序。</em></p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="4b19" class="lf lg iq bd lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly ni ma mb mc bi translated">可变引发</h1><p id="225c" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">变量在编程时极其重要，这里我们可以看到几个重要的变量:</p><ol class=""><li id="f167" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">一根绳子</li><li id="b3f0" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">int</li><li id="f470" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">布尔型</li><li id="dcca" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">一个char</li><li id="b3ea" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">双份</li><li id="1c96" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">一辆花车</li><li id="105b" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">char数组</li></ol><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/6d603ca233dd4fb82a12209f7690a57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*oGm2_DK1IOyMcx2P6HCOBQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">基本变量</figcaption></figure><p id="b88a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mw">请注意:在C++中,‘string’不是一个原始变量，但我认为向您展示它是很重要的。</em></p><p id="9099" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们来看看装配:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/35132201ac96ce2f5300ce614fed1e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abyyFCjrOmZxxTDICAJOEw.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">初始变量</figcaption></figure><p id="dfb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们可以看到IDA是如何表示变量的空间分配的。如你所见，我们在实际初始化变量之前，为每个变量分配了空间。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/171bbf1905856cdbc5107d0c79821715.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*uk93KBPWqaWVr5AsyhX70Q.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">初始化变量</figcaption></figure><p id="53ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦分配了空间，我们就把我们想要为每个变量设置的值移动到我们为该变量分配的空间中。尽管大多数变量在这里被初始化，下面你会看到C++字符串初始化。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nu"><img src="../Images/ee3556480d65b3e79394aa88ddf571af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crsobKMpIl5XGpqGmsK5Nw.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">C++字符串初始化</figcaption></figure><p id="4c2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，初始化一个字符串需要调用一个内置函数来初始化。</p><h1 id="8865" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">基本输出</h1><p id="3009" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated"><em class="mw">前言信息:在这一节中，我将讨论被压入堆栈并用作printf函数参数的项目。函数参数的概念将在本文后面更详细地解释。</em></p><p id="0655" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然本教程是用visual C++编写的，但我选择使用<em class="mw"> printf </em>而不是<em class="mw"> cout </em>进行输出。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/06ddc99307bc46369c7db7b0e579b9d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*gPyOhqYs0zpku8gAyxXNgQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">基本输出</figcaption></figure><p id="b8a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们来看看组件:</p><p id="684a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，字符串文字:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/c529614e3423b69d81073c96015abb48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*Xzi7OPpeIfbbY7eHVq2edA.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">字符串文字输出</figcaption></figure><p id="4f26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，字符串被压入堆栈，作为<em class="mw"> printf </em>函数的参数被调用。</p><p id="3483" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们来看看其中一个变量输出:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/fec7d277a61298ae79f4340e0a0dd41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*FgUDPM7PmhZvRYba3XrCnw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">可变输出</figcaption></figure><p id="3e4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，首先将<em class="mw"> intvar </em>变量移入EAX寄存器，然后将其与用于指示整数输出的“%i”字符串一起推入堆栈。然后从堆栈中取出这些变量，并在调用<em class="mw"> printf </em>函数时用作参数。</p><h1 id="f9a8" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">数学函数</h1><p id="2d4f" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在本节中，我们将讨论以下数学函数:</p><ol class=""><li id="beb1" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">添加</li><li id="c4fc" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">减法</li><li id="fbbf" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">增加</li><li id="b22d" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">分开</li><li id="74a3" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">按位AND</li><li id="d800" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">按位或</li><li id="5cdc" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">按位异或</li><li id="e8eb" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">按位非</li><li id="5cf9" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">按位右移</li><li id="5743" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">按位左移</li></ol><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/230c3ec0d60ccd02a8fcea781fbc8f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*DBHbOtx0oaUTTK1ogGs7Dw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">数学函数代码</figcaption></figure><p id="f50d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将每个功能分解成程序集:</p><p id="dcf8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先我们将<em class="mw"> A </em>设置为十六进制0A，代表十进制10，将<em class="mw"> B </em>设置为十六进制0F，代表十进制15。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/adea7b1d97421ad6ee37274960fc9d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*6u99sEu_dR8fVuPvqU8yww.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">可变设置</figcaption></figure><p id="9043" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用“add”操作码添加:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/37a6fba6190694eed32891bc9de986bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*O7onnSVlb-rid_l9mYglLw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">添加</figcaption></figure><p id="1bf8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用“sub”操作码进行减法运算:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/a3d21a3099f75b1d5434c5e6a07cd1f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*dLJNO4lVZwwrBlHjARB6zA.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">减法</figcaption></figure><p id="fb01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用“imul”操作码相乘:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/29ab35c8dccab2cb78d3ee96abb4cfea.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*7Em7jv3r46gdvGNlgy61oA.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">增加</figcaption></figure><p id="01eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用“idiv”操作码进行除法运算。在这种情况下，我们还使用“cdq”将EAX的大小加倍，以便我们可以适应除法运算的输出。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/568fc4e1b8c9a7b2026248168192d51d.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*9xMddHJDKpddQINo5DnbAw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">分开</figcaption></figure><p id="368e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用“and”操作码执行按位AND运算:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/512d6e0b6bd6a03850cc9a6e0c9d6181.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*8hbg8_NbnM6H65UX3D9BPw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">按位AND</figcaption></figure><p id="85ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用“OR”操作码执行按位“或”运算:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d35872799ca2c2138f995ae05c3148f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*jtkrIrqVd2ihFE7mkl-tdA.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">按位或</figcaption></figure><p id="7a9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用“异或”操作码执行按位异或运算:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/5e600cea554a25bb7abf6939cdaaf72c.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*uYjMih_xX0PiwarRjPuoIw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">按位异或</figcaption></figure><p id="2d3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用“NOT”操作码执行按位非运算:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/29bcaacfe84f91eca9d2396f351c7a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*TS-x6tGX21yb78zEtmWmbQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">按位非</figcaption></figure><p id="85fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用“sar”操作码执行按位右移:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/5850f7083452a37a454729466ff62f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*ivB8dOLmfqDeiZhZdmjIJQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">按位右移</figcaption></figure><p id="aa9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用“shl”操作码执行按位左移:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/9fe40557c81555eea260ebf7ad5524c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*Xe79X4Lu0Xz5LJedMwTlkg.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">按位左移</figcaption></figure><h1 id="f2ac" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">函数调用</h1><p id="5417" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在本节中，我们将了解3种不同类型的函数:</p><ol class=""><li id="b627" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">一个基本的空函数</li><li id="f9e5" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">返回整数的函数</li><li id="662b" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">接受参数的函数</li></ol><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/ee580a6e9a9089c2f3e082a922edb105.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*lYpSbTeaTqq-Y3h2P4FBtw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">调用函数</figcaption></figure><p id="9835" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们看一下调用<em class="mw"> newfunc() </em>和<em class="mw"> newfuncret() </em>的情况，因为这两个函数实际上都不接受任何参数。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/3c3f65da38de828647eb4a803e4169a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*7RLw35vI0L2yaZQIIGS10w.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">调用不带参数的函数</figcaption></figure><p id="bbf4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们跟踪对<em class="mw"> newfunc() </em>函数的调用，我们可以看到它真正做的只是打印出“Hello！我是新功能！”：</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/8b84affc5b7d48bc096171ecf259ac50.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*j4cVfgpxixmCxjb8oxe-6w.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">newfunc()函数代码</figcaption></figure><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/e243480cbb2fb927297e07fa79433d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*5lqiQo0ANCSzvTW2jf9QFA.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">newfunc()函数</figcaption></figure><p id="b0b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，这个函数确实使用了<em class="mw"> retn </em>操作码，但只是返回到先前的位置(这样程序可以在函数完成后继续运行)。)现在，让我们来看看<em class="mw"> newfuncret() </em>函数，它使用C++ <em class="mw"> rand() </em>函数生成一个随机整数，然后返回该整数。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/62de55fb7c1130bfe3fc1eeaedacb77c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*33NhJbsvnKV1q6evo2v84w.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">newfuncret()函数代码</figcaption></figure><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi ok"><img src="../Images/043d9cd3c6aed48ff1cfb356ee269e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tFFoqFLGN24D9pdetwm8g.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">newfuncret()函数</figcaption></figure><p id="8f45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，为变量<em class="mw">分配空间。然后，调用<em class="mw"> rand() </em>函数，将一个值返回到EAX寄存器中。接下来，将EAX变量移入<em class="mw"> A </em>变量空间，有效地将<em class="mw"> A </em>设置为<em class="mw"> rand() </em>的结果。最后，<em class="mw">一个</em>变量被移入EAX，这样函数就可以用它作为返回值。</em></p><p id="12b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经了解了如何调用函数，以及函数返回某个值时是什么样子，让我们来讨论用参数调用函数:</p><p id="c462" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们再看一看call语句:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/0f4103bce53023835e1c6e4948e0c721.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*SNwQlb_23v38k4Zfum--XQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">在C++中调用带参数的函数</figcaption></figure><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/6cc55fa2222b8f2a9a7da809acd21796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*gPBif4pRvAFEqwrfhBHF8A.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">调用带参数的函数</figcaption></figure><p id="e74c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管C++中的字符串需要调用一个<em class="mw"> basic_string </em>函数，但调用带参数的函数的概念是相同的，与数据类型无关。首先，将变量移入寄存器，然后将寄存器压入堆栈，然后调用函数。</p><p id="477e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看这个函数的代码:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi on"><img src="../Images/764b38e125625876198eb19aaec13f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oU6ctCGFtOk8ZgyYZVyZLw.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">funcparams()函数代码</figcaption></figure><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/04a2fb9306fcd67bb931aa7c42f3bf9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*z1HpDLbuzgKi9M_QkxVE0g.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">funcparams()函数</figcaption></figure><p id="5a27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数所做的就是接收一个字符串、一个整数和一个字符，并使用<em class="mw"> printf </em>将它们打印出来。正如你所看到的，首先3个变量被分配在函数的顶部，然后这些变量作为<em class="mw"> printf </em>函数的参数被压入堆栈。很简单。</p><h1 id="700b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">环</h1><p id="a499" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">现在我们已经有了函数调用、输出、变量和数学，让我们继续到流控制。首先，我们将从for循环开始:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/e2182240aef18a8b4d9b644f9c6c343a.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*JxJvEDbqYVbJY6MnUgl6PQ.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">For循环代码</figcaption></figure><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/0f803513cc3874fd8df6b4e9e8df62c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*LAGf6DTTlK6msIlqQ8k5lg.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">For循环的图形概述</figcaption></figure><p id="f37a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们将汇编代码分解成更小的部分之前，让我们看一下总体布局。如您所见，当for循环开始时，它有两个选项；它可以转到右边的框(绿色箭头)并返回，也可以转到左边的框(红色箭头)并返回到for循环的起点。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi or"><img src="../Images/592dd827354d0de385eb13b7121b1624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ahdtawksu505ZPletSor1g.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">详细For循环</figcaption></figure><p id="6a7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们通过比较变量<em class="mw"> i </em>和变量<em class="mw"> max </em>来检查我们是否达到了最大值。如果<em class="mw"> i </em>变量不大于或等于<em class="mw"> max </em>变量，我们继续向左下方打印出<em class="mw"> i </em>变量，然后将<em class="mw"> i </em>加1，继续返回到循环的起点。如果<em class="mw"> i </em>变量实际上大于或等于<em class="mw"> max </em>，我们简单地退出for循环并返回。</p><p id="3c3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们来看看while循环:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi os"><img src="../Images/8958925df548b00fe42fc37a96f92b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*QC_UPfwUKMJuNLW1U70n-w.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">While循环代码</figcaption></figure><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi ot"><img src="../Images/d4653e934d89a668c280973ac82f475b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SfocuPGm_ZPg8wCh_KyAWw.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">While循环</figcaption></figure><p id="d673" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个循环中，我们所做的就是生成一个0到20之间的随机数。如果数字大于10，我们退出循环并打印“我出来了！”否则，我们继续循环。</p><p id="4f2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在汇编中，<em class="mw"> A </em>变量被生成并最初设置为0，然后我们通过比较<em class="mw"> A </em>和代表十进制10的十六进制数0A来初始化循环。如果<em class="mw"> A </em>不大于或等于10，我们生成一个新的随机数，然后将其设置为A，我们继续返回到比较。如果<em class="mw"> A </em>大于等于10，我们就跳出循环，打印出“我出来了”然后返回。</p><h1 id="1d1a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">If语句</h1><p id="258e" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">接下来，我们将讨论<em class="mw"> if语句</em>。首先，让我们看一下代码:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/8f0610f17dd84edede6fb1e485109fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*rGQGknNHvN75z1LIYj1Ypw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">IF语句代码</figcaption></figure><p id="9b4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数生成一个0到20之间的随机数，并将该数存储在变量<em class="mw"> A </em>中。如果<em class="mw"> A </em>大于15，程序将打印出“大于15”。如果<em class="mw"> A </em>小于15但大于10，程序会打印出“小于15，大于10”。这种模式将持续到<em class="mw"> A </em>小于5，在这种情况下，程序将打印出“小于5”。</p><p id="9d76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们来看看装配图:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi ov"><img src="../Images/ee39674c09f3a2245413c84682537cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*7zAB7BvIgCo2dRw1PlJMuw.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">IF语句汇编图</figcaption></figure><p id="fc10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，程序集的结构与实际代码相似。这是因为IF语句就是“If X Then Y Else Z”。如果我们观察从顶部出来的第一组箭头，我们可以看到变量<em class="mw"> A </em>和代表十进制15的十六进制0F之间的比较。如果<em class="mw"> A </em>大于等于15，程序会打印出“大于15”然后返回。否则，程序会将<em class="mw"> A </em>与代表十进制10的十六进制0A进行比较。这种模式将持续到程序打印并返回。</p><h1 id="bd87" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Switch语句</h1><p id="fa25" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">Switch语句与IF语句非常相似，只是在Switch语句中，一个变量或语句与多个“cases”(或可能的等价关系)相比较。让我们看一下我们的代码:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/96caa5ba43bb2b9072689a0075f0e555.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*EdZWUKerZnKYHydHdGzUww.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">开关语句代码</figcaption></figure><p id="d17b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个函数中，我们将变量<em class="mw"> A </em>设置为0到10之间的一个随机数。然后，我们使用Switch语句将<em class="mw">和</em>进行比较。如果<em class="mw"> A </em>等于任何一个可能的案例，那么案例号将被打印出来，然后程序将跳出Switch语句，函数将返回。</p><p id="dc09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们来看看装配图:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/3bb040ebc1232f8b81fd8faaa313304b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*6auHBVzochXTCvvhPrX9FA.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">开关盒装配图</figcaption></figure><p id="c88a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与IF语句不同，switch语句不遵循“If X Then Y Else Z”规则，相反，程序只是将条件语句与case进行比较，并且只执行与条件语句等价的case。让我们先来看看最初的两个盒子:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/ecb860bcb7ed47d1f30fa7ccb8fc307e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*LDoMThpqJ_KSxc8G04RVjw.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">前两个图形部分</figcaption></figure><p id="3e95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，程序生成一个随机数，并将其设置为<em class="mw"> A </em>。然后，程序初始化switch语句，首先设置一个临时变量(<em class="mw"> var_D0 </em>)等于<em class="mw"> A </em>，然后确保<em class="mw"> var_D0 </em>满足至少一种可能的情况。如果<em class="mw"> var_D0 </em>需要缺省，程序沿着绿色箭头向下到最终返回部分(见下文)。否则，程序启动一个切换跳转到等效案例的部分:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/b706df25d0abd048f39de99ac7f50220.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*tkDeDg4rG9caXB8dhEy5Sg.jpeg"/></div></figure><p id="251e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="mw"> var_D0 </em> ( <em class="mw"> A </em>)等于5的情况下，代码会跳转到上面的case段，打印出“5”，然后跳转到return段。</p><h1 id="07bf" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">用户输入</h1><p id="4c7c" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在这一节中，我们将讨论使用C++ <em class="mw"> cin </em>函数的用户输入。首先，让我们看看代码:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9f791c9fe8a3fccbb346d471bb3f2673.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*8AN7ZPmh6VRbtX-24d6aQg.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">用户输入代码</figcaption></figure><p id="7698" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个函数中，我们简单地使用C++ <em class="mw"> cin </em>函数向变量<em class="mw">句子</em>中输入一个字符串，然后通过<em class="mw"> printf </em>语句打印出<em class="mw">句子</em>。</p><p id="8c14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把它分解成组件。第一，C++ <em class="mw"> cin </em>部分:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi pa"><img src="../Images/baea935ab4ad4e72f93788938c37b115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WWi1L7WYuekqAfYoPAs2Zg.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">C++ cin</figcaption></figure><p id="35c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码简单地初始化字符串<em class="mw">语句</em>，然后调用<em class="mw"> cin </em>函数，并将输入设置为<em class="mw">语句</em>变量。让我们来看看<em class="mw"> cin </em>叫得更近一点:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/2c3d89faf67ec07ccd11c337b49c1290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*ftjpKAXT8ORZPzfz7JY_fg.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">C++ cin函数特写</figcaption></figure><p id="2a50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，程序将<em class="mw">语句</em>变量的内容设置为EAX，然后将EAX推送到堆栈上，用作<em class="mw"> cin </em>函数的参数，然后调用该函数，并将其输出移入ECX，然后将其放在堆栈上用于<em class="mw"> printf </em>语句:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi pc"><img src="../Images/7827835d4209fedda559650c6aee798d.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*w1oN2Ebt7QobaGbnXLTpDA.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">用户输入printf语句</figcaption></figure></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h1 id="db46" class="lf lg iq bd lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly ni ma mb mc bi translated">谢谢！</h1><p id="b314" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">希望这篇文章能让你对汇编语言中的基本编程概念有一个很好的理解。请关注本系列的下一部分，<em class="mw"> BOLO:逆向工程—第2部分(高级编程概念)</em>！</p><blockquote class="pd pe pf"><p id="8634" class="jy jz mw ka b kb kc kd ke kf kg kh ki pg kk kl km ph ko kp kq pi ks kt ku kv ij bi translated"><strong class="ka ir"> lea eax，【ebp+阅读】；【阅读】<br/>推送eax <br/> lea ecx，【ebp+For】；【For】<br/>推送ecx <br/> mov edx，【ebp+感谢】；【感谢】<br/>推送edx <br/>推送offset _ Format" %s %s %s" <br/>调用j_printf </strong></p></blockquote></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="6ee0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">逆向工程无疑是信息安全领域的一个利基话题，虽然它是最难学习的利基之一，但也是最有趣的。如果你想了解更多，你可以在Guided Hacking的<a class="ae pj" href="https://guidedhacking.com/threads/ghb2-beginners-guide-to-reverse-engineering.13446/" rel="noopener ugc nofollow" target="_blank">逆向工程</a>教程部分找到很多很棒的视频指南。</p></div></div>    
</body>
</html>