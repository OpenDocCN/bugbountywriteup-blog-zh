<html>
<head>
<title>Common C Vulnerabilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见的C漏洞</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/common-c-vulnerabilities-b84777e071b9?source=collection_archive---------0-----------------------#2022-05-10">https://infosecwriteups.com/common-c-vulnerabilities-b84777e071b9?source=collection_archive---------0-----------------------#2022-05-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4847dc630c071ace0e2502bde6cc5a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0KiOvYYHbaIQAxdX"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">克里斯里德在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="e4f8" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">简介</strong></h1><p id="fbf8" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">众所周知，C编程语言在很多方面都非常敏感。即使在今天，当本科生学习编程时，他们首先接触的是C或Java编程语言。Python、Ruby和其他编程语言将在稍后添加。但是，更重要的是，他们在学习时是否考虑了最佳实践？不幸的是，事实并非如此。他们实践和实现相同的危险功能，他们的努力成果在他们生产的项目中是显而易见的。结果是永无止境的错误和补丁循环。</p><p id="9cf6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">作为这篇博客文章的一部分，我们想展示一些最常用和最易受攻击的函数，以及C编程语言固有的一些漏洞。</p><h1 id="3135" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak"> gets() </strong></h1><p id="735d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">gets()函数用于接受用户的输入。但是接受用户的输入会有什么问题呢？程序确实需要用户与之交互。示例包括登录提示、简单的计算器等。</p><p id="3d71" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">问题的出现是因为gets()不执行边界检查，这意味着用户可以让程序接受无限大小的字符串。这会通过覆盖内存区域导致缓冲区溢出攻击，还会导致代码执行。</p><p id="3a92" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">不安全的C代码:</strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1dd5" class="mq kh it mm b gy mr ms l mt mu">#include &lt;stdio.h&gt;</span><span id="dd24" class="mq kh it mm b gy mv ms l mt mu">int main () <br/>{</span><span id="4f67" class="mq kh it mm b gy mv ms l mt mu"> char str[50];</span><span id="5e0b" class="mq kh it mm b gy mv ms l mt mu"> printf("Enter a string : ");</span><span id="986a" class="mq kh it mm b gy mv ms l mt mu"> gets(str);</span><span id="f9de" class="mq kh it mm b gy mv ms l mt mu"> printf("You entered: %s", str);<br/> return(0);<br/>}</span></pre><p id="94c3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">缓解:</strong>不用gets()，可以使用f gets()函数。fgets()执行边界检查，使用该函数可以消除缓冲区溢出。</p><h1 id="a5e9" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak"> strcpy() </strong></h1><p id="c426" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">strcpy代表字符串复制，用于将字符串从源位置复制到目标位置。</p><p id="57ce" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">语法是strcpy(dest，src)。src中的字符串将被复制到dest变量中。</p><p id="f3fb" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果向src提供足够大的字符串，就可能导致缓冲区溢出攻击。</p><p id="fb9a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">不安全的C代码:</strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="531f" class="mq kh it mm b gy mr ms l mt mu">#include &lt;stdio.h&gt;</span><span id="8db8" class="mq kh it mm b gy mv ms l mt mu">#include &lt;string.h&gt;</span><span id="802f" class="mq kh it mm b gy mv ms l mt mu">int main() {<br/>char src[20] = "C programming";</span><span id="7852" class="mq kh it mm b gy mv ms l mt mu">char dest[20];</span><span id="0672" class="mq kh it mm b gy mv ms l mt mu">// copying src to dest</span><span id="52f6" class="mq kh it mm b gy mv ms l mt mu">strcpy(dest, src);</span><span id="0ebd" class="mq kh it mm b gy mv ms l mt mu">puts(dest); // C programming</span><span id="784c" class="mq kh it mm b gy mv ms l mt mu">return 0;<br/>}</span></pre><p id="cdda" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">缓解:</strong>您可以使用strcpy()函数来代替strcpy()。</p><h1 id="5dc7" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak"> strcat() </strong></h1><p id="7177" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">strcat()函数用于将源字符串追加到目标字符串中。但是，就像上面提到的函数一样，它不检查长度/边界。这很容易导致分段错误或缓冲区溢出攻击。</p><p id="f2d5" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">不安全的C程序:</strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2c93" class="mq kh it mm b gy mr ms l mt mu">#include &lt;stdio.h&gt;</span><span id="c86d" class="mq kh it mm b gy mv ms l mt mu">#include &lt;string.h&gt;</span><span id="b2aa" class="mq kh it mm b gy mv ms l mt mu">int main() {</span><span id="9f9b" class="mq kh it mm b gy mv ms l mt mu">char s1[100] = "This is an ", s2[] = "insecure implementation";</span><span id="ffc9" class="mq kh it mm b gy mv ms l mt mu">// strcat concatenates str1 and str2</span><span id="24c6" class="mq kh it mm b gy mv ms l mt mu">// the resultant string is stored in str1.</span><span id="6723" class="mq kh it mm b gy mv ms l mt mu">strcat(s1, s2);</span><span id="df48" class="mq kh it mm b gy mv ms l mt mu">return 0;</span><span id="fabe" class="mq kh it mm b gy mv ms l mt mu">}</span></pre><p id="c6ba" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">缓解:</strong>可以用strcat()函数代替strcat()。</p><h1 id="795d" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak"> strcmp() </strong></h1><p id="7036" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">strcmp代表字符串比较。这个函数比较两个字符串，并根据比较结果返回一个整数。如果第一个值小于、等于或大于第二个值，则该整数将小于、等于或大于0。</p><p id="c28e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">strcmp()很容易被用来造成缓冲区溢出攻击。一个恶意的参与者所要做的就是提供一个比变量实际能容纳的足够大的字符串。</p><p id="c38d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">易受攻击的C程序</strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1a67" class="mq kh it mm b gy mr ms l mt mu">#include &lt;stdio.h&gt;</span><span id="2737" class="mq kh it mm b gy mv ms l mt mu">#include &lt;string.h&gt;</span><span id="4b91" class="mq kh it mm b gy mv ms l mt mu">int main() {</span><span id="cf83" class="mq kh it mm b gy mv ms l mt mu"> char str1[20], str2[] = "abCd", str3[] = "abcd";</span><span id="f6f1" class="mq kh it mm b gy mv ms l mt mu"> int result;</span><span id="021f" class="mq kh it mm b gy mv ms l mt mu"> gets(str1);</span><span id="3867" class="mq kh it mm b gy mv ms l mt mu"> // comparing strings str1 and str2</span><span id="7b6e" class="mq kh it mm b gy mv ms l mt mu"> result = <strong class="mm iu">strcmp(str1, str2);</strong></span><span id="7e2f" class="mq kh it mm b gy mv ms l mt mu"> printf("<strong class="mm iu">strcmp(str1, str2) = %d</strong>\n", result);</span><span id="e069" class="mq kh it mm b gy mv ms l mt mu"> // comparing strings str1 and str3</span><span id="d261" class="mq kh it mm b gy mv ms l mt mu"> result = <strong class="mm iu">strcmp(str1, str3);</strong></span><span id="923b" class="mq kh it mm b gy mv ms l mt mu"> printf("<strong class="mm iu">strcmp(str1, str3) = %d</strong>\n", result);</span><span id="4c45" class="mq kh it mm b gy mv ms l mt mu">return 0;<br/>}</span></pre><p id="761c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">缓解:</strong>要缓解strcmp()导致的缓冲区溢出，可以使用strcmp()函数，或者在比较字符串之前先计算值的长度。</p><h1 id="1407" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">格式字符串漏洞</strong></h1><p id="92f2" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">C语言利用格式说明符来接受和打印用户的输入。</p><p id="e708" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">例如，要打印整数日期类型值，可以使用%d格式说明符，%s表示字符串，等等。</p><p id="2cee" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">例如</strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="db6f" class="mq kh it mm b gy mr ms l mt mu">int x;</span><span id="5908" class="mq kh it mm b gy mv ms l mt mu">scanf(“%d”, x);</span><span id="a1ac" class="mq kh it mm b gy mv ms l mt mu">printf(“%d”,x);</span></pre><p id="e9ef" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><em class="mw">当程序需要一个值，但用户输入了一个格式说明符时，就会出现格式字符串漏洞。</em></p><p id="c37f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">这会导致数据泄露，程序崩溃，将任意数据写入任意位置。</strong>(可能通过指定%n格式说明符)。</p><p id="e833" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">易受攻击的C程序:</strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fce7" class="mq kh it mm b gy mr ms l mt mu">#include&lt;stdio.h&gt;</span><span id="88b2" class="mq kh it mm b gy mv ms l mt mu">int main(int argc, char* argv[])</span><span id="df2f" class="mq kh it mm b gy mv ms l mt mu">{</span><span id="b4d6" class="mq kh it mm b gy mv ms l mt mu">printf(argv[1]);</span><span id="cafe" class="mq kh it mm b gy mv ms l mt mu">return 0;</span><span id="93bd" class="mq kh it mm b gy mv ms l mt mu">}</span></pre><p id="371b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">缓解:</strong>始终对格式字符串进行硬编码。</p><p id="546c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">比如printf("%s "，argv[1])；</p><h1 id="f8fc" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">整数溢出和下溢</strong></h1><p id="0748" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">包括C在内的大多数编程语言中的数据类型都有固定的大小。C #中的int数据类型的大小为4个字节。声明为整数类型的变量可以存储的值的范围是–2，147，483，648到2，417，483，647。</p><p id="5d75" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">但是，有没有想过，如果存储一个大于2，417，483，647或小于-2，417，483，648的值，或者对整数执行运算，结果大于2，417，483，647或小于-2，417，483，648，会发生什么情况？</p><p id="a9fa" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">让我们来看看，<strong class="lg iu">易受攻击的C程序</strong>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7d92" class="mq kh it mm b gy mr ms l mt mu">#include &lt;stdio.h&gt;</span><span id="93d0" class="mq kh it mm b gy mv ms l mt mu">int main()</span><span id="d327" class="mq kh it mm b gy mv ms l mt mu">{</span><span id="1911" class="mq kh it mm b gy mv ms l mt mu">int x = 2147483649;    //2147483647 + 2</span><span id="6f76" class="mq kh it mm b gy mv ms l mt mu">printf(“%d”,x);</span><span id="fa42" class="mq kh it mm b gy mv ms l mt mu">return 0;</span><span id="9e40" class="mq kh it mm b gy mv ms l mt mu">}</span></pre><p id="7314" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">输出:-2147483647 </strong></p><p id="60d3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">您可能期望输出为2147483649，但是由于它超出了整数数据类型的最大范围，所以它到达了–ve的末尾，并在<strong class="lg iu">–2，147，483，648 </strong>上加1。</p><p id="66ea" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">缓解</strong>:使用检查确保数值不超过上限。</p><p id="0c80" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">结论:</strong></p><p id="ff3c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这篇博客文章涵盖了C编程语言中的一些漏洞。当然，开发人员可以通过使用错误的逻辑来添加漏洞，但是这些是在提到的函数中总是存在的一些漏洞。您必须确保您的程序尽可能远离这些函数。</p></div></div>    
</body>
</html>