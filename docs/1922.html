<html>
<head>
<title>The toddler’s introduction to Dynamic Memory Allocation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">幼儿动态内存分配入门</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-toddlers-introduction-to-dynamic-memory-allocation-300f312cd2db?source=collection_archive---------0-----------------------#2022-03-03">https://infosecwriteups.com/the-toddlers-introduction-to-dynamic-memory-allocation-300f312cd2db?source=collection_archive---------0-----------------------#2022-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ec01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">堆漏洞很长一段时间以来一直是安全研究社区的兴趣所在，因为它们有可能找到创新的利用方式。从2001年开始，随着<a class="ae kl" href="http://phrack.org/issues/57/8.html" rel="noopener ugc nofollow" target="_blank"> Vudo Malloc Tricks </a>和<a class="ae kl" href="http://phrack.org/issues/57/9.html" rel="noopener ugc nofollow" target="_blank">Once Once A free()</a>的出现，接着是<a class="ae kl" href="http://phrack.org/issues/61/6.html" rel="noopener ugc nofollow" target="_blank"> Advanced Doug Lea的malloc exploits </a>、<a class="ae kl" href="https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt" rel="noopener ugc nofollow" target="_blank"> Malloc Maleficarum </a>等等，堆类型开发技术的清单很长，概念似乎很难掌握。</p><p id="e2f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">寻找这样的技巧通常被认为是一种黑暗艺术，没有坚实背景就一头扎进这些领域的读者常常会迷失，然后沮丧……最后放弃。虽然在这篇文章中保持这种令人费解的黑暗艺术精神很有诱惑力，但我最终决定用一种更轻松的语气，因为我讨厌我们这个领域中那些故意试图用更简单的方式解释复杂概念的人。这篇文章将试图揭示heap领域的一些情况，并回答通常你不好意思问的问题。</p><h1 id="d130" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">基本概念和定义</h1><p id="9005" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我们从一些基本定义开始:</p><blockquote class="lp lq lr"><p id="11fc" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated"><strong class="jp ir">内存分配:</strong>是在程序中留出部分内存用于存储变量、结构和类的实例的过程[1]。</p></blockquote><p id="d0b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内存分配有两种类型:</p><blockquote class="lp lq lr"><p id="3bb5" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated"><strong class="jp ir">静态分配:</strong></p></blockquote><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/3522d1ceed0ca88bb225f8dac943f511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*3ReuMnV_jmDBl94ROvj9Bg.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated"><a class="ae kl" href="https://www.cs.uah.edu/~rcoleman/Common/C_Reference/MemoryAlloc.html" rel="noopener ugc nofollow" target="_blank">https://www . cs . uah . edu/~ rcoleman/Common/C _ Reference/memory alloc . html</a></figcaption></figure><p id="5adf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">特性:</strong>分配是永久性的，发生在程序执行之前，使用一个叫做<strong class="jp ir">堆栈的内存空间，</strong>没有内存可重用性。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><blockquote class="lp lq lr"><p id="0df3" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated"><strong class="jp ir">动态分配:</strong></p></blockquote><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/40fb45e34ffa8b8ed6d2464f3d7ceee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRYmDdLqYaCxI2TJ_LFDFg.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated"><a class="ae kl" href="https://www.cs.uah.edu/~rcoleman/Common/C_Reference/MemoryAlloc.html" rel="noopener ugc nofollow" target="_blank">https://www . cs . uah . edu/~ rcoleman/Common/C _ Reference/memory alloc . html</a></figcaption></figure><p id="f338" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">特性:</strong>分配发生在运行时，只有当程序单元(变量声明发生的地方)被激活时，才使用称为<strong class="jp ir">堆的内存空间，</strong>内存可以在不需要时被重用和释放。</p><blockquote class="lp lq lr"><p id="aadb" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated"><strong class="jp ir">堆:</strong>程序内存空间的一个子区域，在这里“绘图”可以被动态地绑定或释放。这些图中的每一个都可以使用一个唯一的算术地址来引用，该地址被分配给称为指针的特殊变量。</p></blockquote><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mu"><img src="../Images/3201a178ab324f3e1fd011e572707ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZOgk5nO--VJkddiZlH-xw.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated"><strong class="bd ko"> ptr </strong>是保存在@ <strong class="bd ko"> 0x006FFA64 </strong>的变量，其值为<strong class="bd ko"> 0x009B54EB </strong>，是堆区的内存地址。</figcaption></figure><h2 id="7528" class="mv kn iq bd ko mw mx dn ks my mz dp kw jy na nb la kc nc nd le kg ne nf li ng bi translated">真实生活的例子</h2><p id="0034" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">把这个堆想象成一个巨大的停车场，汽车在这里进进出出。在那里工作的爱丽丝必须跟踪空闲的位置，以便将新来的人引导到正确的位置。此外，由于一些汽车可能占用不止一个车位，她必须以最大化利润的方式使用可用空间。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nh"><img src="../Images/4652ef486c32f9c7f3c7acd2d0949def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jUfJL6UT_xKCuRbfDUCcQ.png"/></div></div></figure><p id="7c16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显而易见，假设维护分配或未分配槽位的完整记录是将轿厢发送到正确方向并避免所谓的<strong class="jp ir">分段的基本要求:</strong></p><blockquote class="lp lq lr"><p id="883d" class="jn jo ls jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated"><strong class="jp ir">碎片</strong>是一个不想要的问题，由于内存块很小，所以无法分配给进程，并且这些内存块仍未使用。也可以理解为，当进程被加载并从内存中移除时，它们会在内存中产生空闲空间或空洞，这些小块无法分配给新的即将到来的进程，从而导致内存使用效率低下[2]。</p></blockquote><p id="5c15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，堆分配需要这样一个记录，记录哪些内存被分配，哪些没有被分配。此外，内存分配器将执行维护任务，例如通过移动分配的内存来整理内存碎片，或者进行垃圾收集——在运行时识别内存何时不再在范围内并将其释放。</p><h1 id="60d9" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">实际分配</h1><p id="9e61" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在程序初始化期间，<a class="ae kl" href="https://man7.org/linux/man-pages/man2/mmap.2.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> mmap </strong> </a>和<a class="ae kl" href="https://man7.org/linux/man-pages/man2/brk.2.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> brk </strong> </a>系统调用用于设置程序的存储器。<strong class="jp ir">堆</strong>区域由<a class="ae kl" href="https://github.com/torvalds/linux/blob/master/include/linux/mm_types.h" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">mm _ struct</strong></a><strong class="jp ir">:</strong>的<strong class="jp ir"> start_brk </strong>和<strong class="jp ir"> brk </strong>变量界定</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ni"><img src="../Images/097708f7fbb69faefb474177aed92dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V65JGYUcmzyzGYyjvLLEKQ.png"/></div></div></figure><ul class=""><li id="f8a8" class="nj nk iq jp b jq jr ju jv jy nl kc nm kg nn kk no np nq nr bi translated">当<a class="ae kl" href="http://en.wikipedia.org/wiki/Address_space_layout_randomization" rel="noopener ugc nofollow" target="_blank"> ASLR </a>关闭时，由于堆为空，start_brk和brk变量都将指向bss段的结尾(由<a class="ae kl" href="https://github.com/torvalds/linux/blob/master/include/linux/mm_types.h" rel="noopener ugc nofollow" target="_blank"> end_data </a>变量表示)。</li><li id="b655" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated">当ASLR开启时，start_brk和brk将等于end_data+x，其中x是随机偏移。</li></ul><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nx"><img src="../Images/61da70549e8d7c7228f3ae8eb3283f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2KKqMaL1OH-uc4jWugrzCQ.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated"><a class="ae kl" href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/" rel="noopener ugc nofollow" target="_blank">https://sploitfun . WordPress . com/2015/02/11/sys calls-used-by-malloc/</a></figcaption></figure><p id="b581" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进程可以使用以下C库函数来请求和释放动态内存[3]:</p><ul class=""><li id="a6b8" class="nj nk iq jp b jq jr ju jv jy nl kc nm kg nn kk no np nq nr bi translated"><code class="fe ny nz oa ob b">malloc(size)</code>:请求<code class="fe ny nz oa ob b">size</code>字节的动态内存；如果分配成功，它返回第一个内存位置的线性地址。</li><li id="4832" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated"><code class="fe ny nz oa ob b">calloc(n,size)</code>:请求一个由大小为<code class="fe ny nz oa ob b">size</code>的<code class="fe ny nz oa ob b">n</code>个元素组成的数组；如果分配成功，它将数组元素初始化为0，并返回第一个元素的线性地址。</li><li id="ac3d" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated"><code class="fe ny nz oa ob b">free(addr)</code>:释放<code class="fe ny nz oa ob b">malloc( )</code>或<code class="fe ny nz oa ob b">calloc( )</code>分配的初始地址为<code class="fe ny nz oa ob b">addr</code>的内存区域。</li><li id="ada9" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated"><code class="fe ny nz oa ob b">brk(addr)</code>:直接修改堆的大小；<code class="fe ny nz oa ob b">addr</code>参数指定了<code class="fe ny nz oa ob b">current-&gt;mm-&gt;brk</code>的新值，返回值是内存区域新的结束地址。</li><li id="f2e6" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated"><code class="fe ny nz oa ob b">sbrk(incr)</code>:类似于<code class="fe ny nz oa ob b">brk( )</code>，除了<code class="fe ny nz oa ob b">incr</code>参数以字节为单位指定堆大小的增量或减量。</li></ul><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi oc"><img src="../Images/0e7d04cffd2ebcbd601e2f36e92f862e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5vovRPhiul2_6WREt35Jg.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">sbrk、brk在行动</figcaption></figure><h1 id="a13f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">履行</h1><p id="4902" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">以一种有效的方式分配内存是至关重要的，因此许多<a class="ae kl" href="https://github.com/emeryberger/Malloc-Implementations/tree/master/allocators" rel="noopener ugc nofollow" target="_blank">实现</a>不时被用来解决这个问题:</p><ul class=""><li id="1377" class="nj nk iq jp b jq jr ju jv jy nl kc nm kg nn kk no np nq nr bi translated">从1987年开始，<a class="ae kl" href="https://en.wikipedia.org/wiki/Doug_Lea" rel="noopener ugc nofollow" target="_blank"> Doug Lea </a>开发了<a class="ae kl" href="https://en.wikipedia.org/wiki/Public_domain" rel="noopener ugc nofollow" target="_blank">公共域</a><strong class="jp ir">dlmalloc</strong>(“Doug Lea的malloc”)作为通用分配器。</li><li id="d7cc" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/GNU_C_library" rel="noopener ugc nofollow" target="_blank"> GNU C库</a> (glibc)源自Wolfram Gloger的<strong class="jp ir">ptmalloc</strong>(“pthreads malloc”)，dlmalloc的一个分支，有线程相关的改进。</li><li id="ab97" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated">从<a class="ae kl" href="https://en.wikipedia.org/wiki/FreeBSD" rel="noopener ugc nofollow" target="_blank"> FreeBSD </a> 7.0和<a class="ae kl" href="https://en.wikipedia.org/wiki/NetBSD" rel="noopener ugc nofollow" target="_blank"> NetBSD </a> 5.0开始，旧的<code class="fe ny nz oa ob b">malloc</code>实现(phkmalloc)被Jason Evans编写的<a class="ae kl" href="http://jemalloc.net/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">jemalloc</strong></a><strong class="jp ir"/>(用于Android)所取代</li><li id="31f8" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/OpenBSD" rel="noopener ugc nofollow" target="_blank"> OpenBSD </a>对利用<a class="ae kl" href="https://en.wikipedia.org/wiki/Mmap" rel="noopener ugc nofollow" target="_blank"> mmap </a>的<code class="fe ny nz oa ob b">malloc</code>函数的实现。</li></ul><p id="0ab8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其他实现包括hoard malloc、mimalloc、tcmalloc DFWMalloc等等…在接下来的文章中，我们将重点讨论ptmalloc实现，并探索一些堆利用技术。</p><h1 id="4fdd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">参考资料:</h1><p id="22fc" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">[1]<a class="ae kl" href="https://www.cs.uah.edu/~rcoleman/Common/C_Reference/MemoryAlloc.html" rel="noopener ugc nofollow" target="_blank">https://www . cs . uah . edu/~ rcoleman/Common/C _ Reference/memory alloc . html</a></p><p id="1dd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2]<a class="ae kl" href="https://afteracademy.com/blog/what-is-fragmentation-and-what-are-its-types" rel="noopener ugc nofollow" target="_blank">https://after academy . com/blog/what-is-fragmentation-and-what-is-its-types</a></p><p id="8a33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[3]<a class="ae kl" href="https://www.oreilly.com/library/view/understanding-the-linux/0596002130/ch08s06.html" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/library/view/understanding-the-Linux/0596002130/ch08s 06 . html</a></p><p id="5e04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/C_dynamic_memory_allocation" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/C_dynamic_memory_allocation</a></p><p id="a541" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[5]<a class="ae kl" href="https://github.com/emeryberger/Malloc-Implementations/tree/master/allocators" rel="noopener ugc nofollow" target="_blank">https://github . com/emeryberger/Malloc-Implementations/tree/master/allocators</a></p><div class="od oe gp gr of og"><a href="https://github.com/emeryberger/Malloc-Implementations" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">GitHub-emeryberger/Malloc-实现:内存分配器的集合</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="oq l or os ot op ou mc og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://heap-exploitation.dhavalkapil.com/heap_memory" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">堆内存</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">与使用局部变量(在堆栈上)相比，性能下降。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">heap-exploitation.dhavalkapil.com</p></div></div><div class="op l"><div class="ov l or os ot op ou mc og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://github.com/shellphish/how2heap" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">GitHub - shellphish/how2heap:学习各种堆利用技术的资源库。</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">这个报告是为了学习各种堆利用技术。我们使用Ubuntu的Libc版本作为黄金标准…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="ow l or os ot op ou mc og"/></div></div></a></div><p id="58cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.cs.uah.edu/~rcoleman/Common/C_Reference/MemoryAlloc.html" rel="noopener ugc nofollow" target="_blank">https://www . cs . uah . edu/~ rcoleman/Common/C _ Reference/memory alloc . html</a></p></div></div>    
</body>
</html>