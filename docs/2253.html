<html>
<head>
<title>Phoenix Challenges — Stack Zero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">凤凰挑战—零堆栈</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/phoenix-challenges-stack-zero-f8743cc871ed?source=collection_archive---------2-----------------------#2022-08-07">https://infosecwriteups.com/phoenix-challenges-stack-zero-f8743cc871ed?source=collection_archive---------2-----------------------#2022-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="0736" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">挑战</h1><p id="09f4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">挑战的描述和源代码位于<a class="ae lj" href="https://exploit.education/phoenix/stack-zero/" rel="noopener ugc nofollow" target="_blank">这里</a>。它和所有其他Phoenix二进制文件都位于<strong class="kn ir"> /opt/phoenix/amd64 </strong>目录中。一篇<a class="ae lj" href="https://secnate.medium.com/phoenix-challenges-getting-set-up-a2783e0616c6" rel="noopener">以前的帖子</a>描述了如何为<em class="lk"> Exploit Education的凤凰城</em>挑战设置虚拟机，如果还没有这样做的话。</p><h1 id="808f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">目标</h1><p id="46ce" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">查看<em class="lk">堆栈零的</em> C代码，我们看到存储在初始化为0的<em class="lk">局部变量</em>结构中的<em class="lk"> changeme </em>变量。目标是篡改它的值，使其为非零，以打印所需的语句。</p><h1 id="446e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">相关概念</h1><p id="f1ac" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在计算机内存中执行的程序看起来像这样:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/75947959ca2ee9082b15e07db89e7e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/0*SAleAesS8T3Vc836.png"/></div></figure><p id="3a08" class="pw-post-body-paragraph kl km iq kn b ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li ij bi translated">堆栈和堆是两种主要的内存结构。长话短说:</p><ul class=""><li id="e6b5" class="ly lz iq kn b ko lt ks lu kw ma la mb le mc li md me mf mg bi translated"><strong class="kn ir">堆栈</strong>用于存储关于被调用函数及其局部变量的信息。当一个新的函数被调用时，机器向下扩展堆栈的大小，为存储它的局部变量和关于这个函数调用的信息提供更多的空间。相反，当一个函数退出时，机器释放堆栈内存并向上减小其大小。<strong class="kn ir">堆栈内存管理在执行过程中自动执行。</strong></li><li id="010c" class="ly lz iq kn b ko mh ks mi kw mj la mk le ml li md me mf mg bi translated"><strong class="kn ir">堆</strong>被程序用来在执行过程中动态分配内存。如果需要的内存量是不可预测的，这就特别有用。例如，接收可变长度消息的浏览器可能会获取大量堆内存，将传入消息放入其中进行处理。</li></ul><p id="fffd" class="pw-post-body-paragraph kl km iq kn b ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li ij bi translated">在低级语言执行期间，程序员显式地管理堆的内存。在C中使用了<strong class="kn ir"> malloc()、calloc()、free()和realloc() </strong>函数，在C++中使用了<strong class="kn ir"> new </strong>和<strong class="kn ir"> delete </strong>运算符。Python和Java等更高级的内存安全语言使用内存管理器在看不见的地方安全地处理堆。</p><p id="edc1" class="pw-post-body-paragraph kl km iq kn b ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li ij bi translated">那些希望进一步了解堆栈和堆如何工作的人会发现这个解释很有帮助。</p><h1 id="ebb1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">虫子</h1><p id="1cca" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Stack Zero的所有数据都存储在堆栈上，其中<em class="lk">局部变量</em>结构的<em class="lk">缓冲区</em>和<em class="lk"> changeme </em>变量是相邻的邻居。存入<em class="lk">缓冲区</em>的多余数据将溢出到<em class="lk"> changeme </em>变量并影响其值。这种溢出是由<strong class="kn ir"> gets() </strong>函数造成的，该函数用于将控制台输入的输入写入<em class="lk"> locals.buffer </em>中，而不执行任何边界检查。</p><h1 id="511a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">利用</h1><p id="51a8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">输入写入的<em class="lk"> locals.buffer </em>有64个字符的空间。由于<em class="lk"> locals.changeme </em>变量最初为0，因此漏洞需要篡改其内存位置，使其具有非零值。这是通过输入一个65个字符的输入字符串来完成的，最后一个字符直接溢出到<em class="lk"> locals.changeme </em>变量的内存中，并使其非零。</p><p id="435a" class="pw-post-body-paragraph kl km iq kn b ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li ij bi translated">漏洞利用是用<em class="lk"> pwntools </em>编写的，这是一个用于漏洞利用开发的Python框架。该代码有大量解释性注释，因为它是本系列的第一篇。它可以在我的<a class="ae lj" href="https://github.com/secnate/Exploit-Education-CTFs" rel="noopener ugc nofollow" target="_blank"> Github知识库</a>中找到。</p><p id="6c01" class="pw-post-body-paragraph kl km iq kn b ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li ij bi translated">结果呢？</p><pre class="lm ln lo lp gt mm mn mo mp aw mq bi"><span id="9635" class="mr jo iq mn b gy ms mt l mu mv">nathan@nathan-VirtualBox:~/Desktop/Exploit-Education- CTFs/Phoenix/stack-zero$ ./stack-zero-exploit.py<br/>Launching The Phoenix Stack Zero Exploit!<br/>[!] Could not find executable 'stack-zero' in $PATH, using '/opt/phoenix/amd64/stack-zero' instead<br/>[+] Starting local process '/opt/phoenix/amd64/stack-zero': pid 12739<br/>[*] Switching to interactive mode<br/>[*] Process '/opt/phoenix/amd64/stack-zero' stopped with exit code 0 (pid 12739)<br/>Welcome to phoenix/stack-zero, brought to you by https://exploit.education<br/>Well done, the 'changeme' variable has been changed!<br/>[*] Got EOF while reading in interactive<br/>$</span></pre><h1 id="9791" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">补救</h1><p id="8d1f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了防止这样的内存崩溃错误，我会鼓励开发人员不要用C编写，转而使用Python或Rust等内存安全的语言。</p><p id="597d" class="pw-post-body-paragraph kl km iq kn b ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li ij bi translated">如果除了使用C别无选择，我会警告不要使用<a class="ae lj" href="https://www.tutorialspoint.com/c_standard_library/c_function_gets.htm" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir"> gets() </strong> </a>函数从命令行提取输入。正如刚才看到的，它读取输入，直到到达换行符或文件尾字符，而不管目的缓冲区的大小。</p><p id="1b39" class="pw-post-body-paragraph kl km iq kn b ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li ij bi translated">应该改用<a class="ae lj" href="https://cplusplus.com/reference/cstdio/fgets/" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir"> fgets() </strong> </a>函数。它解析命令行输入并将其放入目标缓冲区，同时执行适当的边界检查。源代码的<code class="fe mw mx my mn b">gets(locals.buffer);</code>行将是<code class="fe mw mx my mn b">fgets(locals.buffer, 64, stdin);</code></p><p id="cfa8" class="pw-post-body-paragraph kl km iq kn b ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li ij bi translated">使用<strong class="kn ir"> fgets </strong>的一个额外好处是，它自动用终止<em class="lk"> null </em>字符(" \0 ")终止缓冲区。程序员可能会忘记手动插入这样的字符。因此，在这个挑战中，只有63个字符从命令行读入缓冲区，第64个字符是“\0”。</p><p id="d562" class="pw-post-body-paragraph kl km iq kn b ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li ij bi translated">用空字符终止缓冲区对于防止缓冲区过度读取漏洞至关重要。这些包括数据泄漏，因为读取缓冲区的函数没有遇到终止字符，并继续越过缓冲区的末端进入相邻的内存。</p><p id="42ca" class="pw-post-body-paragraph kl km iq kn b ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li ij bi translated">我想到的最臭名昭著的例子是2014年的OpenSSL Heartbleed bug。对于那些不熟悉的人来说，OpenSSL是一种广泛使用的SSL和TLS加密协议的开源实现，网站和系统使用它来建立安全和经过验证的连接。安全专家Bruce Schneier在谈到安全问题的影响时一直非常保守，<a class="ae lj" href="https://www.schneier.com/blog/archives/2014/04/heartbleed.html" rel="noopener ugc nofollow" target="_blank">称之为灾难性的</a>:</p><blockquote class="mz"><p id="14c4" class="na nb iq bd nc nd ne nf ng nh ni li dk translated"><em class="nj">从1到10，这是11。</em></p></blockquote><p id="76a4" class="pw-post-body-paragraph kl km iq kn b ko nk kq kr ks nl ku kv kw nm ky kz la nn lc ld le no lg lh li ij bi translated">这一轮就到此为止。请继续关注<em class="lk"> Stack One </em>挑战赛，这是<em class="lk"> Stack Zero </em>挑战赛的延伸，不过有点难度！</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="8adb" class="pw-post-body-paragraph kl km iq kn b ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li ij bi translated">这篇文章最初发表在内森·帕夫洛夫斯基的个人博客上:<a class="ae lj" href="http://secnate.github.io" rel="noopener ugc nofollow" target="_blank"> secnate.github.io </a></p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="260e" class="pw-post-body-paragraph kl km iq kn b ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li ij bi translated"><em class="lk">来自Infosec的报道:Infosec上每天都会出现很多难以跟上的内容。</em> <a class="ae lj" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir"> <em class="lk">加入我们的每周简讯</em> </strong> </a> <em class="lk">以5篇文章、4个线程、3个视频、2个Github Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</em></p></div></div>    
</body>
</html>