<html>
<head>
<title>GOT OVERWRITE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">被覆盖</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/got-overwrite-bb9ff5414628?source=collection_archive---------3-----------------------#2021-04-16">https://infosecwriteups.com/got-overwrite-bb9ff5414628?source=collection_archive---------3-----------------------#2021-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="beab" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用简单的get覆盖生成SHELL</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b8d932bf55a97987113b4d4a4f232758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S3vxaq4i_EqwotXd.png"/></div></div></figure><h1 id="2c0f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">了解基础知识:</h1><h1 id="2cbf" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">过程链接表</h1><p id="9dfe" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">过程链接表(PLT)是一个“只读”部分</p><p id="ec4c" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">它负责在程序运行期间和之后调用动态链接器，以解析所请求函数的地址</p><p id="937d" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">在编译过程中，我们不能提及这些地址，因为每个系统的函数地址都是未知的，共享对象也是不可用的</p><p id="e80a" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">因此，PLT在运行时解析这些函数地址时起着至关重要的作用</p><p id="1c98" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">PLT表比GOT表大得多</p><p id="4e8f" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">每个程序/二进制文件都有自己的PLT表，只对自己有用</p><p id="318e" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">当请求符号解析时，调用函数向PLT发出请求，并将GOT的地址推入处理器寄存器</p><p id="9533" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这就是如何通过二进制文件调用共享库函数来执行它们想要的功能</p><h1 id="b2d6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">全局偏移表(GOT)</h1><p id="ee4b" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在编程运行时，动态链接器弹出全局偏移表(GOT)</p><p id="b31d" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">动态链接器获得被请求函数的绝对地址，并根据请求更新得到的地址</p><p id="7b0d" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">文件不需要重定位，因为GOT从过程链接表(PLT)中获取位置请求</p><p id="718d" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">许多函数在运行时不会被解析，只有在第一次调用被请求的函数时才会被解析</p><p id="f0a7" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这是一个被称为“惰性链接”的过程，可以节省资源</p><p id="b9d4" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">一旦函数的PLT地址与程序中函数的GOT地址链接，程序就可以借助PLT-GOT翻译直接从库中调用特定的函数</p><h1 id="1df8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">PLT-GOT的工作</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ma"><img src="../Images/fa701843b2ea378e4fe226705d3512b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JF3jXmlIGuZWP7wP.png"/></div></div></figure><h1 id="8494" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">被覆盖</h1><p id="f0a9" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">GOT重写是一种二进制开发技术，其中函数的GOT地址被替换为我们想要的函数的地址</p><p id="82a1" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">假设我们将在程序中调用“printf()”</p><p id="5cdd" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">当程序中的“printf()”被调用时，它首先检查PLT表</p><p id="a268" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">在检查“printf()”函数的PLT表时，它寻找“printf()”的get地址来运行该函数，以便可以从库中直接调用“printf()”</p><p id="7356" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">如果我们用另一个期望的函数的地址重写了“printf()”的get地址</p><p id="c377" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">当“printf()”被调用时，它转到PLT，获取被操纵的get地址，并执行我们想要的函数</p><p id="333e" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">“printf()”所需的参数也将传递给我们想要的函数</p><p id="b588" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这就是我们如何覆盖得到的值来执行我们想要的功能</p><h1 id="6998" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">剥削</h1><p id="6a41" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们用这个源代码执行GOT覆盖</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mb"><img src="../Images/3dba4e32313b42ff5215b77b67c01805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yFmnSw_TZ3H9Wm0G.png"/></div></div></figure><p id="3569" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这里使用了简单的函数，如gets()、puts()、strlen()</p><p id="cf36" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这个程序不做任何复杂的运算，只是一个简单的程序</p><p id="7f08" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">让我们编译这个程序</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mc"><img src="../Images/7f5f2721aad2e960a766fc7d28a9b016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V5yO0d8MIAfgR1OQ.png"/></div></div></figure><p id="8cb6" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">现在，让我们试着正常执行这个程序</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi md"><img src="../Images/0c39bbfbe4d520b3bf2e1d2421ee5239.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b9QMvO4EN4wkV-dR.png"/></div></div></figure><p id="3fd5" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">用GDB-PEDA反汇编程序</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi me"><img src="../Images/f4de46f77486ee7625e8e514b11940c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_58h8eRPUz7_4t9P.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mf"><img src="../Images/5018582a31a2229c5aa5faf5744fbd67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yeWVBSe2QM04LGXO.png"/></div></div></figure><p id="f550" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这里我们可以看到许多函数都是使用PLT表调用的</p><p id="8f57" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">现在让我们检查“puts()”的PLT地址</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mg"><img src="../Images/63e14702128adf66755fc51cb4a3b047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BNoWEfip-Af5hTdO.png"/></div></div></figure><p id="3d81" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这里0x80490d0是“puts()”的PLT地址值</p><p id="26f3" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">要获得“puts()”的get地址，让我们检查“puts()”的PLT</p><p id="982d" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">每个get都需要从PLT调用</p><p id="1335" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">查看JMP指令</p><p id="4183" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">“puts()”的get地址是0x804c018</p><p id="512e" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">现在让我们将“puts()”重定向到“system()”</p><p id="8cab" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">要查找“system()”地址</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mh"><img src="../Images/6fa9b89b791a02c58a2b6eea26a1bc40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hs_Y4ZNpTg07j_SX.png"/></div></div></figure><p id="6506" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">是时候用“system()”的地址设置“puts()”的get了</p><p id="f25c" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">如果我们重写，每当“puts()”被调用时，“system()”就会执行</p><p id="d188" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">在操作了get地址之后，我们将使用“gets()”将数据传递到“buffer”中</p><p id="3473" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">在我们的实际程序中“puts(buffer)”是被传递的，所以它将打印来自“buffer”的数据</p><p id="2e2d" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">来自“buffer”的数据作为参数传递给“puts()”</p><p id="b6bf" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">因为我们用“system()”重写了“puts()”，所以来自“buffer”的参数将被传递到“system()”</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ma"><img src="../Images/5d69ab4ecee846f43c2191e1d41afca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Xx1SUHWQ8v_YPEi7.png"/></div></div></figure><p id="7e75" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这是一个潜在的RCE</p><p id="12a2" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">因此，如果我们将“/bin/sh”作为参数从“buffer”传递到“system()”</p><p id="9790" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">它的工作原理是</p><pre class="km kn ko kp gt mi mj mk ml aw mm bi"><span id="9a65" class="mn jo iq mj b gy mo mp l mq mr">system("/bin/sh");</span></pre><p id="a843" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">为我们打开外壳</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ms"><img src="../Images/f5b579fa3a01f2eb8af6e645c0762cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kZ7kYYt1eT1RtZXw.png"/></div></div></figure><p id="399c" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">因此，在这个简单的程序中，执行get覆盖来生成shell</p><h2 id="ce79" class="mn jo iq bd jp mt mu dn jt mv mw dp jx li mx my kb lm mz na kf lq nb nc kj nd bi translated">GitHub Repo中提供了漏洞利用示例</h2><h2 id="69c0" class="mn jo iq bd jp mt mu dn jt mv mw dp jx li mx my kb lm mz na kf lq nb nc kj nd bi translated"><a class="ae ne" href="https://github.com/AidenPearce369/ExploitDev" rel="noopener ugc nofollow" target="_blank">aiden peace 369</a></h2></div></div>    
</body>
</html>