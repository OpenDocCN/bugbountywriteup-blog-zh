<html>
<head>
<title>Hunting for Prototype Pollution and it’s vulnerable code on JS libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻找JS库上的原型污染及其易受攻击的代码</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746?source=collection_archive---------1-----------------------#2021-10-11">https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746?source=collection_archive---------1-----------------------#2021-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9d6cefe3a1acfd81bd0044f3a18caf10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-G7_0G_C7y9C0Z0pFCAJZg.jpeg"/></div></div></figure><p id="65d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">距离我发布<a class="ae kw" href="https://github.com/kleiton0x00/ppmap" rel="noopener ugc nofollow" target="_blank"> ppmap </a>已经过去几个月了，因为原型污染漏洞实际上是多么疯狂和流行，所以这个工具并没有很快流行起来。</p><p id="40c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我不会向你介绍什么是原型污染，因为有很多文章/视频比我解释得更好。这篇文章是关于这个主题的几个星期的研究工作，给你带来了新的和创新的想法(当然不是全部)，关于如何大规模扫描Javascript包(<a class="ae kw" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm包</a>也是)，以及如何手动调试(对于复杂的Javascript代码)来找到客户端原型污染的根本原因。</p><h1 id="c926" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">搜索客户端原型污染</h1><p id="2e82" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">对于这种类型的搜索，我们将使用Chrome/Chromium，因为他们有开发者工具，肯定更适合调试。</p><p id="6cb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该利用从首先发现网站是否易受客户端原型污染开始。我们将使用<a class="ae kw" href="https://github.com/kleiton0x00/ppmap" rel="noopener ugc nofollow" target="_blank"> ppmap </a>，它将自动尝试不同的有效载荷来污染全球环境中的变量。将该工具下载到您的本地计算机后，只需使用以下命令在目标网站上运行它，就这么简单:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6b2e" class="mj ky iq mf b gy mk ml l mm mn">echo '<a class="ae kw" href="https://grey-acoustics.surge.sh" rel="noopener ugc nofollow" target="_blank">https://grey-acoustics.surge.sh</a>' | ./ppmap</span></pre><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/d5d5c42581237196d189528ea2e7b321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTPFbvCDDCufj-_kff5Q4Q.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">ppmap发现原型污染</figcaption></figure><p id="e0d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，让我们打开网站，有效载荷<a class="ae kw" href="https://github.com/kleiton0x00/ppmap" rel="noopener ugc nofollow" target="_blank"> ppmap </a>显示为易受攻击(<a class="ae kw" href="https://grey-acoustics.surge.sh/?constructor%5Bprototype%5D%5Bppmap%5D=reserved" rel="noopener ugc nofollow" target="_blank">https://grey-acoustics.surge.sh/?)构造函数% 5b prototype % 5D % 5b pmap % 5D =保留的</a>)并打开控制台(在开发者工具上)确认我们是否成功地污染了它。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/5dee12b782dac5fdf0d1836237de791a.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*I4GivnOTXkXkcV9bklApKg.png"/></div></figure><h1 id="c174" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">设置断点</h1><p id="eceb" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">是时候找到易受攻击的代码了，为此我们需要转到<strong class="ka ir"> Source </strong>并在页面的第一个脚本上设置一个断点。这样做的原因是我们不想执行整个Javascript，因为这样我们就不知道ppmap gadget什么时候会被污染。设置断点后，点击“恢复脚本执行”按钮。只需刷新网站即可应用更改，网站应在调试器上<strong class="ka ir">暂停。</strong></p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/4ac6f3f532f4fd5c65db157073088f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*052-ZnY-JWy6wiVfX_UGVQ.jpeg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">设置断点，然后恢复脚本执行</figcaption></figure><p id="a00b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，第7行将是第一个执行的javascript代码，因此我们将在那一行放置一个断点。如果我们在控制台上输入<strong class="ka ir"> ppmap </strong>，会显示为未定义，因为网站卡在断点上，ppmap还没有被污染。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/d3fbdbf1a72feb99d9cb1f8abbe750bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qERXAJFeF7xwuSjsdFCSpg.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">网站在调试器上暂停</figcaption></figure><h1 id="a626" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在代码片段的帮助下检查何时属性被污染</h1><p id="22d0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在我们必须运行一个片段，你可以从<a class="ae kw" href="https://gist.githubusercontent.com/dmethvin/1676346/raw/24cde96c341e524dc8706104afbd0748752c7432/gistfile1.txt" rel="noopener ugc nofollow" target="_blank">这里</a>得到它。一旦属性被污染，脚本将设置一个断点(在本例中为ppmap属性)。为此，只需转到<strong class="ka ir">源</strong>，然后点击<strong class="ka ir">片段</strong>，通过添加如下图所示的代码创建一个新的:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/5df2fa7ec14f69436ae5812864ad80cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mjbBiLpC4YSjcTlOjg5pBw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">执行代码片段</figcaption></figure><p id="79ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行代码片段，您将在控制台上看到一个“未定义”的输出，这意味着代码片段已经成功运行。</p><p id="4b42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">返回<strong class="ka ir">控制台</strong>选项卡，执行以下代码，一旦“ppmap”属性发生污染，将自动设置一个断点。这意味着它会将我们重定向到发生污染的易受攻击的代码:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a6b4" class="mj ky iq mf b gy mk ml l mm mn">debugAccess(Object.prototype, 'ppmap')</span></pre><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/d94b4e53a6930cb6f0b9c35965f3d9fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*qHi2lRA_At_cwZCqMSq-2A.jpeg"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">在控制台上执行的命令</figcaption></figure><p id="f36f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没有输出，但那完全没问题。</p><h1 id="5530" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">寻找原型污染的根本原因</h1><p id="576a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">返回到<strong class="ka ir">源</strong>并点击“恢复脚本执行”。这样做之后，整个javascript将被执行，ppmap将如预期的那样再次被污染。在该代码片段的帮助下，我们可以找到ppmap属性被污染的确切位置。我们可以点击调用堆栈，您将看到发生污染的不同堆栈。</p><p id="a873" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是选哪个呢？大多数情况下，原型污染发生在Javascript库上，所以应该把目标放在附加到。js库文件(看右边，就像图片中一样，以了解堆栈附加到哪个端点)。在这种情况下，我们在第4行和第6行有2个堆栈，逻辑上我们将选择第4行，因为该行是第一次发生污染的地方，这意味着该行是漏洞的原因。单击堆栈会将我们重定向到易受攻击的代码。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/a4199b282230b3bb6bda686211e2a76e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg"/></div></div></figure><p id="9259" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">借助Beautifier，我们可以看到JS库易受攻击的代码:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5b5e" class="mj ky iq mf b gy mk ml l mm mn">params.replace(/\+/g, ' ').split('&amp;').forEach(function(v) {<br/>            var param = v.split('='),<br/>                key = decodeURIComponent(param[0]),<br/>                val, cur = obj,<br/>                i = 0,<br/>                keys = key.split(']['),<br/>                keys_last = keys.length - 1;<br/>            if (/\[/.test(keys[0]) &amp;&amp; /\]$/.test(keys[keys_last])) {<br/>                keys[keys_last] = keys[keys_last].replace(/\]$/, '');<br/>                keys = keys.shift().split('[').concat(keys);<br/>                keys_last = keys.length - 1;<br/>            } else {<br/>                keys_last = 0;<br/>            }</span></pre><p id="a1d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是网站易受攻击的唯一原因，如果我们仔细查看堆栈，会发现还有一个端点ppmap受到污染(位于索引HTML页面):</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/ad56de8350c708ac5bf28d5d3b48d897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_lq15EhvZRqb8GrF4_UEQ.jpeg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">HTML代码的另一个堆栈</figcaption></figure><p id="d53c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是索引HTML页面的易受攻击代码:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7aed" class="mj ky iq mf b gy mk ml l mm mn">var query = deparam(<strong class="mf ir">location.search</strong>.slice(1));</span></pre><p id="15ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有一些Javascript的经验，你会直接发现这里的问题。该漏洞利用始于将有效负载注入到用于构建客户端逻辑或呈现应用程序的输入(本例中是URL解析)中。最常见的输入来源是URL及其不同的属性，如<strong class="ka ir"> location.search </strong></p></div></div>    
</body>
</html>