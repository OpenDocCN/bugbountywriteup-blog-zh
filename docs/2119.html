<html>
<head>
<title>Hacking Nginx: Best ways</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解Nginx:最佳方法</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/hacking-nginx-best-ways-7c576cc17ccc?source=collection_archive---------0-----------------------#2022-06-06">https://infosecwriteups.com/hacking-nginx-best-ways-7c576cc17ccc?source=collection_archive---------0-----------------------#2022-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/745d62ccf34845a9ddb29fd04068b0a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vgr4dyEiRLDDe-SAbpw5Xg.png"/></div></div></figure><p id="1516" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Nginx在野外使用已经有一段时间了。我们在编码/黑客时都在某个地方见过NGINX的名字。由于NGINX中的许多错误配置，它一直是黑客/bug赏金猎人的目标，作为一名安全研究员/bug赏金猎人，黑客攻击web服务器总是让我们着迷。今天，我们将看看如何在NGINX易受攻击的情况下真正破解它，并尝试从中获利。</p><p id="b367" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，如果你是这个话题的新手，不知道NGINX作为一个服务器是如何工作的，这里有一个来自互联网的描述:- " <strong class="ka ir"> <em class="kw"> Nginx是为了提供低内存使用和高并发性而构建的。Nginx没有为每个web请求创建新的进程，而是使用一种异步的、事件驱动的方法，在单线程中处理请求。使用Nginx，一个主进程可以控制多个工作进程。主进程维护工作进程，而工作进程执行实际的处理。因为Nginx是异步的，每个请求都可以被工人并发执行，而不会阻塞其他请求</em>。</strong>“在NGINX的帮助下，你显然可以做很多事情</p><ul class=""><li id="b744" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">带缓存的反向代理</li><li id="2286" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">IPv6</li><li id="43a9" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">负载平衡</li><li id="8160" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">FastCGI支持缓存</li><li id="5843" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">WebSockets</li><li id="0855" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">静态文件、索引文件和自动索引的处理</li></ul><p id="7185" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以一旦我们清楚了它是如何工作的，我们的话题就开始了..关键是错误配置发生在哪个阶段？嗯，如果我们没有正确地配置它，有许多事情可能会以其他方式进行。如果你回顾历史，<strong class="ka ir"> NGINX SPDY堆缓冲区溢出</strong>在2014年被利用。为了利用这一点，攻击者可以通过特制的请求来执行任意代码，从而导致堆内存缓冲区溢出。这将严重影响网络服务器。同样在2020年，NGINX中发现了PHP远程代码执行漏洞，该漏洞非常严重，被认为是该产品有史以来最重要的发现之一。你可以在网上读到更多关于他们的信息。我把它留给你。</p><p id="c61f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于NGINX是目前最常用的网络服务器，所以也存在很多安全问题。我们今天正在谈论这些:-</p><ul class=""><li id="492a" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">缺少根位置</strong></li><li id="85fb" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">别名LFI配置错误</strong></li><li id="770d" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">原始后端响应读数</strong></li><li id="4646" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">不安全变量的使用</strong></li></ul><ol class=""><li id="7753" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv ll ld le lf bi translated"><strong class="ka ir">缺少根位置:- </strong></li></ol><p id="c920" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查下面的代码片段:-</p><blockquote class="lm ln lo"><p id="b78d" class="jy jz kw ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">server {<br/>root/etc/nginx；</p><p id="de13" class="jy jz kw ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">location/hack . txt {<br/>try _ files $ uri $ uri/= 404；<br/>proxy _ pass<a class="ae ls" href="http://127.0.0.1:8080/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:1212/</a>；<br/> } <br/> }</p></blockquote><p id="9fbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在NGINX中，root指令指定根文件夹。在这个例子中，根文件被定义为/etc/nginx，这意味着我们可以继续查找nginx和其中的文件。所以在这里，如果你发送一个简单的请求，比如GET /nginx.conf，就会暴露一些敏感信息，比如nginx的配置和其他东西。因为“/”可以处理任何请求，所以我们可以通过它发送一个敏感的端点。在某些情况下，可以访问其他配置文件和日志。</p><p id="64b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.<strong class="ka ir">别名LFI误配置:- </strong></p><p id="3f24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总是建议在NGINX配置下检查“位置”语句。如果您发现类似以下的内容</p><blockquote class="lm ln lo"><p id="e774" class="jy jz kw ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">位置/imgs { <br/>别名/路径/图像/ <br/> }</p></blockquote><p id="8653" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里表演LFI。怎么会？扩展到<strong class="ka ir"> /imgs../secret.txt </strong>和<strong class="ka ir"> </strong>它会转换为<strong class="ka ir"> /path/images/../secret.txt. </strong>你可以在这里了解更多:-<a class="ae ls" href="https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">LFI/路径遍历</strong> </a> <strong class="ka ir">。</strong></p><p id="59aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.<strong class="ka ir">原始后端响应读数:- </strong></p><p id="eabf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了Nginx的<code class="fe lt lu lv lw b">proxy_pass</code>，就有可能拦截后端创建的错误和HTTP头。如果您想隐藏内部错误消息和消息头，让它们由Nginx处理，这非常有用。Nginx会自动提供一个定制的错误页面，如果后端有一个回答的话。</p><p id="9671" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想象有这样一个应用程序</p><blockquote class="lx"><p id="b66e" class="ly lz iq bd ma mb mc md me mf mg kv dk translated">def application(environ，start _ response):<br/>start _ response(' 500 Error '，[('Content-Type '，' text/html '，(' Secret-Header '，' Secret '))<br/>return[b]Secret info，应该是不可见的！"]</p></blockquote><p id="b9f2" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">它在NGINX中有以下指令:-</p><blockquote class="lm ln lo"><p id="8d36" class="jy jz kw ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">http {<br/>error _ page 500/html/error . html；<br/>proxy _ intercept _ errors on；<br/>proxy _ hide _ Header Secret-Header；<br/> }</p></blockquote><p id="6ee7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果我们发送一个简单的GET请求，我们的响应将如下所示</p><blockquote class="lm ln lo"><p id="87f6" class="jy jz kw ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">HTTP/1.1 500内部服务器错误<br/>服务器:nginx/1.10.3 <br/>内容类型:text/html <br/>内容长度:15 <br/>连接:关闭</p></blockquote><p id="e4a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果我们试图发送一个无效的请求并检查接下来会发生什么呢？像这样:—</p><blockquote class="lm ln lo"><p id="af06" class="jy jz kw ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">GET /？XTTP/1.1 <br/>主机:127.0.0.1 <br/>连接:关闭</p></blockquote><p id="46a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果它易受攻击，我们应该得到一个秘密信息的响应:-</p><blockquote class="lm ln lo"><p id="30e0" class="jy jz kw ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">XTTP/1.1 500错误<br/>内容类型:文本/html <br/>机密-标头:机密</p><p id="d1aa" class="jy jz kw ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">在这里我们应该得到我们的秘密信息</p></blockquote><p id="aabd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.<strong class="ka ir">不安全变量的使用:- </strong></p><p id="03a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">易受攻击的NGINX配置如下所示</p><blockquote class="lm ln lo"><p id="fca3" class="jy jz kw ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">location/{<br/>return 302<a class="ae ls" href="https://example.com$uri" rel="noopener ugc nofollow" target="_blank">https://ABCD . com $ uri</a>；<br/> }</p></blockquote><p id="3e66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">HTTP请求的新行字符是\r(回车)和\n(换行符)。对新行字符进行URL编码会产生以下字符表示形式<code class="fe lt lu lv lw b">%0d%0a</code>。当这些字符包含在像<code class="fe lt lu lv lw b">http://localhost/%0d%0aHacker:%20test</code>这样的错误配置的服务器请求中时，服务器将用一个名为HACKER的新头来响应，因为$uri变量包含URL解码的新行字符</p><blockquote class="lm ln lo"><p id="7916" class="jy jz kw ka b kb kc kd ke kf kg kh ki lp kk kl km lq ko kp kq lr ks kt ku kv ij bi translated">HTTP/1.1 302临时移动<br/>服务器:nginx/1.19.3 <br/>内容类型:text/html <br/>内容长度:200 <br/>连接:保活<br/>地点:<a class="ae ls" href="https://example.com/" rel="noopener ugc nofollow" target="_blank">https://abcd.com/</a><br/>黑客:测试</p></blockquote><ul class=""><li id="ee5c" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir"> proxy_pass和内部指令:- </strong></li></ul><p id="e76e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> proxy_pass </strong>指令可用于<strong class="ka ir">将内部请求重定向到其他服务器</strong>内部或外部。<strong class="ka ir"> internal </strong>指令用于向Nginx表明该位置只能在内部访问。</p><p id="321d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些是NGINX中出现的一些常见攻击场景。很明显，该产品中报告了很多缓冲区溢出，并且总是建议检查您在特定服务器上可以做的一切。由于NGINX也用作负载均衡器，DOS也是可能的。然而，他们越是更新产品，旧的vulns就越是消失。由于它被大量使用，新的漏洞可能会出现。</p><p id="9632" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你能从这篇博客中有所收获。老年人知道很多东西，在这个博客中提到的，在这个博客中已经可以得到，所以对那些人来说不是很多。但是如果你是新手，你肯定会从中获得一些好的知识。我希望它能帮助你学到一些东西。</p><p id="e893" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">继续学习，❤快乐黑客</p><p id="f92e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">资源:- </strong></p><ul class=""><li id="108e" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><a class="ae ls" href="https://blog.detectify.com/2020/11/10/common-nginx-misconfigurations/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Detectify博客促使我添加自己的话</strong> </a></li><li id="b15d" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">查看此实验室以增强您的知识:- <a class="ae ls" href="https://github.com/detectify/vulnerable-nginx" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">检测实验室</strong> </a></li></ul></div></div>    
</body>
</html>