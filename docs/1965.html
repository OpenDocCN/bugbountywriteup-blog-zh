<html>
<head>
<title>Serialization&amp;Deserialization Attacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">序列化和反序列化攻击</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/serialization-deserialization-attacks-on-php-d5fb02e29248?source=collection_archive---------0-----------------------#2022-03-24">https://infosecwriteups.com/serialization-deserialization-attacks-on-php-d5fb02e29248?source=collection_archive---------0-----------------------#2022-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a0a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大家好，今天我将尝试解释序列化漏洞是如何工作的。</p><p id="8486" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们摧毁金字塔之前，我们需要了解他们是如何建造的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/381fa2c4610230649c0f164bc0542cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lJVW5qs99vknfdavWv2sWg.png"/></div></div></figure><p id="aed0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以第一个问题是什么是序列化和反序列化？</p><p id="90fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">连载:</strong></p><p id="2a07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">序列化是一种将对象状态转换为字节流的机制。</p><p id="afb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以基本上，它是这样工作的:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/49a556494d873b5e6951c65effeef266.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/0*UuEQr17OjQ1yGAnT.png"/></div></figure><p id="34b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">串行化意味着将某物(例如狗雷克斯)转换成一系列的1和0，这些1和0可以通过电话线传输，并存储在存储器中。我在海外的朋友可以将这些1和0翻译回小狗的完美表示(反序列化)，这样他们就可以享受Rex的陪伴了。</p><p id="b43d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我们为什么需要它？</strong></p><p id="3401" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个简单的类比来理解为什么我们需要在某些情况下序列化数据:假设你有一个想法，你想把它描述给你的朋友。不幸的是，你在家，而你的朋友在别处，所以你决定写一封邮件，描述你的想法。看到你刚才做了什么吗？你把脑子里的东西序列化成邮件，可以传输、存储、渲染，最终被你的朋友阅读。阅读这封邮件并在大脑中建立该想法的内部模型是令人惊讶的，然后是反序列化过程。所以，计算机实际上只是自然过程的模仿者；)</p><p id="3867" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要了解更多信息，您可以查看下面的链接:</p><div class="ky kz gp gr la lb"><a href="https://en.wikipedia.org/wiki/Serialization" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd ir gy z fp lg fr fs lh fu fw ip bi translated">序列化-维基百科</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">在计算中，串行化(美国拼写)或串行化(英国拼写)是翻译数据结构的过程…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">en.wikipedia.org</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp kv lb"/></div></div></a></div><p id="ed89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">反序列化:</strong></p><p id="2897" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反序列化是相反的过程，其中字节流用于在内存中重新创建实际的对象。</p><p id="06a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上是:D</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/641e1aea59de87af9d171e0c044d685a.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*oRanmHEpZ6dKOXYujC_eFQ.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">英雄联盟</figcaption></figure><p id="157c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像传说中说的，让我们跳到实际的事情上来。</p><p id="8ed0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在PHP上序列化数据:</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lv"><img src="../Images/f6054ba83f4dc869960ca39d3a84cf7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmOfPMw_Hih__1jFbulRzg.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">序列化</figcaption></figure><p id="5da8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">左窗格(代码描述):</strong></p><p id="8098" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在左窗格中，</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="b28a" class="mb mc iq lx b gy md me l mf mg">class User{</span><span id="4302" class="mb mc iq lx b gy mh me l mf mg">public $username;<br/> public $password;<br/>}</span></pre><p id="d126" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建一个用户类，并在这个类中分配$username和$password。</p><p id="9ac1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mi mj mk lx b"><em class="ml">$obj = new User();</em></code></p><p id="84cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们为我们的对象设置了一个新用户，我们基本上说:</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="a224" class="mb mc iq lx b gy md me l mf mg"><em class="ml">$obj-&gt;username=’zer0d’;<br/>$obj-&gt;password=’mypass123';</em></span></pre><p id="8519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">$obj的这个$username成员</p><p id="13c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">$obj的这个$password成员</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="b7b3" class="mb mc iq lx b gy md me l mf mg"><em class="ml">echo serialize($obj);</em></span></pre><p id="94fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们用$obj调用序列化函数来序列化我们的对象。</p><p id="e1ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">右窗格(运行时):</strong></p><p id="3592" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在右窗格中，我们看到我们的对象是序列化版本。</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="e2c2" class="mb mc iq lx b gy md me l mf mg"><em class="ml">O:4:”User”:2:{s:8:”username”;s:5:”zer0d”;s:8:”password”;s:9:”mypass123";}</em></span></pre><p id="d4ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是什么意思？</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="5c5e" class="mb mc iq lx b gy md me l mf mg">Ex: (Type:object):(4 character):( “It is User”): (it has 2 variable)</span></pre><p id="ac0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在PHP上反序列化数据:</strong></p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="0896" class="mb mc iq lx b gy md me l mf mg"><em class="ml">$obj = unserialize($_POST[‘cmd’]);</em></span></pre><p id="e40e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在服务器端，像上面这样运行的代码反序列化接收到的序列化对象。我知道这有点令人困惑。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/1dbe06714e46a4996b15675b19f7bb4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*7yq23yLFX2sZa-2h.jpg"/></div></figure><p id="6e9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试着理解这个过程。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/e0b093d79b368233150d03f02f8bbf15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZL-5seEOuGERN35Fg8H-ZA.png"/></div></div></figure><p id="2a21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1-应用程序服务器序列化要发送的对象，然后将其发送到客户端浏览器。</p><p id="444b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2-攻击者找到序列化的对象，假设它是一个cookie。</p><p id="431c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3-如果cookie编码为base64，首先，攻击者需要解码它才能看到字符串。然后它是一个序列化的对象，所以他需要反序列化它来查看对象中有什么。此时，该对象可能会存储username、isAdmin等变量。</p><p id="c0da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在进行序列化攻击时，有两件事需要注意。</p><ul class=""><li id="d7c3" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">非字符串值:</li></ul><p id="f273" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所知，字符创建字符串。一些语言把它们分开，如果有有意义的字符，这些是字符串，如果有一个接一个的字符，它们是字符。但是当我们在攻击的时候，我们会发送一个对象(这种攻击就是对象注入)，如果我们用变化的字符串发送，PHP语言就不能在里面把字符串转换成对象。所以我们需要将恶意对象注入到非字符串值中，如boolean等。</p><p id="fb49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们注入我们的有效载荷之后，我们可以序列化它并把它发送回来。</p><ul class=""><li id="0412" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">神奇的方法:</li></ul><p id="c40f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PHP魔法方法是一个<a class="ae mx" href="https://www.phptutorial.net/php-oop/php-objects/" rel="noopener ugc nofollow" target="_blank">类</a>中的特殊方法。当对象执行动作时，魔术方法覆盖默认动作。</p><p id="2c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照惯例，神奇方法的名称以双下划线(<code class="fe mi mj mk lx b">__</code>)开头。PHP为神奇的方法保留了名称以双下划线(<code class="fe mi mj mk lx b">__</code>)开头的方法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi my"><img src="../Images/136bad209216aae7ac5054540275f9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*t-pt74rZxqgmElcjTV-GzA.png"/></div></figure><p id="69bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个魔法方法都遵循一定的规则:</p><p id="6ad8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-每个神奇的方法都以双下划线(__)开头。</p><p id="23cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-它们是预定义的，既不能创建也不能删除。</p><p id="b90b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-魔法方法有保留名称，它们的名称不应用于其他目的。</p><p id="c45f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-当满足特定标准时，自动调用神奇的方法。</p><p id="6806" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如:</p><p id="1ad2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">_ _构造()</p><p id="50de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次创建特定类的对象时，都会自动调用该方法。</p><p id="e560" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个神奇方法的作用和任何OOP语言中的构造函数是一样的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/5e58ed52ff7361eea505ca1ced2b305f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKXO_mH3ay1STZbsVB98qQ.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">例子</figcaption></figure><p id="a997" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在攻击中，序列化部分就像一扇门，所以如果他们在序列化时没有检查我们的输入，这意味着门是开着的。但是为了偷金子，你需要打开抽屉。在密码中，抽屉有神奇的功能。</p><p id="9b98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，问题是序列化实际上并不危险，我们需要跳转到魔法方法来用序列化损害系统。否则，我们的有效负载将被反序列化，但该有效负载无法在系统上执行。</p><p id="b97a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">综上所述，诀窍在于你需要找到不是字符串的值，你需要通过使用非字符串值跳转到易受攻击的函数(魔术方法)来成功进行序列化攻击。您将在攻击模拟中看到更多细节。</strong></p><p id="3f1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4-浏览器将此请求发送到后端服务器。</p><p id="71ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5-应用程序将其反序列化，以查看序列化数据中的内容。在这一步中，我们的有效载荷带着有害的愿望调用函数:)。</p><p id="ee81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6- Shell已执行。</p><p id="4c59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">攻击模拟:</strong></p><p id="28e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们看看服务器端代码:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/6354abc6e29570fdae352199eb3907b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*cT_MdR8fBKcb8AAFSLlmoQ.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">server.php</figcaption></figure><p id="cc26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为这是一个模拟，所以代码实际上是不起作用的，但是让我们假设开发人员试图通过post方法从客户端获取用户名，然后对其进行反序列化。此外，在代码的不同部分，他们使用了一个神奇的方法__tostring来获取文件内容。在这一点上，如果我们反序列化对象，并以恶意的方式序列化它，我们可以通过跳转到magic方法来运行我们的危险愿望。</p><p id="8e44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">攻击者方面:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/5cb1b0c45bc6ddd415d0b437f1c533a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*_0lrHKE476OXN-Sp3l10RA.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">attacker.php</figcaption></figure><p id="59bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在编写PHP脚本，用<strong class="jp ir"> __construct </strong>函数序列化相同的数据表单，以便从系统中读取文件。该脚本创建恶意的序列化数据。</p><p id="5c47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/9e8d1112dd48e45874122fe8faf5946e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HMck1mSNWJJpZgCc6N7fag.png"/></div></div></figure><p id="30cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在输出中看到的，s:8:username是一个指向对象ReadFile的字符串值，因此有了这些数据，我们可以通过浏览器将其发送到服务器，并在服务器端使用我们的输入运行神奇的方法。所以让我们复制它通过curl发送。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nd"><img src="../Images/3b6cae0dbfaf4f1a33d9eca6663d90f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MSE0f8VPfZAxN-cB_hn3g.png"/></div></div></figure><p id="c759" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经向服务器发送了一个post请求，其中包含了我们序列化的恶意数据。</p><p id="6fbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘣！我们可以读取proof.txt，在上图中高亮显示。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/34d807238d3b6e0f82bf3fadcb52816e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06YjHJPfmOYV4cqrOgNsRg.png"/></div></div></figure></div></div>    
</body>
</html>