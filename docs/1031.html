<html>
<head>
<title>Hack crypto secrets from heap memory to exploit Android application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从堆内存中窃取加密秘密以利用Android应用程序</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/hack-crypto-secrets-from-heap-memory-to-exploit-android-application-728097fcda3?source=collection_archive---------0-----------------------#2020-12-22">https://infosecwriteups.com/hack-crypto-secrets-from-heap-memory-to-exploit-android-application-728097fcda3?source=collection_archive---------0-----------------------#2020-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq jr js"><p id="19fe" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">通常情况下，android应用程序中的<strong class="jw iu">加密漏洞</strong>不会产生重大影响(<strong class="jw iu">一般来说，严重性较低</strong>)。除非在应用程序工作流和加密功能之间有很强的依赖性。</p></blockquote><p id="7b02" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">在最近的私人bugbounty项目中，我面临了一个挑战。其中应用程序请求主体用某种加密机制加密。所以我必须找到加密机制来进一步评估应用程序。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kv"><img src="../Images/fa99122e5bc9e0aa76f738fc192ff09f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FIXbv9820wu5HB0hkY8f8g.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">加密身体挑战</figcaption></figure><p id="afd3" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi ll translated"><span class="l lm ln lo bm lp lq lr ls lt di">为了</span>理解加密逻辑，我使用<strong class="jw iu"> Android逆向工程工具</strong>集对APK进行了反编译，然后我分析了加密机制和敏感密钥信息的代码。但是我还没有在反向源代码中发现任何硬编码的秘密。</p><h2 id="0f9d" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kt mg mh mi ku mj mk ml mm bi translated"><strong class="ak">到了</strong>检查<strong class="ak">应用堆内存</strong>的时候了</h2><h2 id="2221" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kt mg mh mi ku mj mk ml mm bi translated"><strong class="ak">堆内存</strong></h2><p id="05dc" class="pw-post-body-paragraph jt ju it jw b jx mn jz ka kb mo kd ke ks mp kh ki kt mq kl km ku mr kp kq kr im bi translated">堆<strong class="jw iu"> </strong>用于<strong class="jw iu"> </strong>进行动态内存分配。为了提供流畅的用户体验，<strong class="jw iu"> Android为每个正在运行的应用</strong> <em class="jv">设置了一个堆大小的硬性限制。</em>堆大小限制因设备而异，并且基于设备拥有的RAM大小。<strong class="jw iu">堆内存用于分配对象。每当你创建一个对象，它总是在堆中被创建。</strong></p><h2 id="433a" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kt mg mh mi ku mj mk ml mm bi translated">为什么我们需要分析</h2><p id="0698" class="pw-post-body-paragraph jt ju it jw b jx mn jz ka kb mo kd ke ks mp kh ki kt mq kl km ku mr kp kq kr im bi translated">由于开发时间短，开发人员只专注于构建特性、功能和UI组件。但是他们可能会忘记用<strong class="jw iu">内存分析器</strong>检查应用程序的内存使用情况。因此我们可能有机会在<strong class="jw iu">内存泄漏时获得这些<strong class="jw iu">密码密钥</strong>。</strong></p><h2 id="d0a4" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kt mg mh mi ku mj mk ml mm bi translated">如何分析android应用程序内存泄漏</h2><p id="0974" class="pw-post-body-paragraph jt ju it jw b jx mn jz ka kb mo kd ke ks mp kh ki kt mq kl km ku mr kp kq kr im bi translated">第一步</p><p id="f010" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">首先我们必须用<code class="fe ms mt mu mv b">android:debuggable="true”</code>重新编译目标应用程序。为了用调试标志重新构建目标应用程序，我使用了<strong class="jw iu"> apk-mitm。</strong></p><div class="mw mx gp gr my mz"><a href="https://github.com/shroudedcode/apk-mitm" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">shroudedcode/apk-mitm</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">一个CLI应用程序，自动准备Android APK文件的HTTPS检查检查移动应用程序的HTTPS…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn lf mz"/></div></div></a></div><p id="09f3" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">卸载原始应用程序，安装目标应用程序的重新编译版本，导航到应用程序的所有功能，并作为普通应用程序使用几分钟。</p><p id="6c22" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">第二步</p><p id="800f" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">现在使用adb获取应用程序内存配置文件。为此，请使用以下命令。</p><pre class="kw kx ky kz gt no mv np nq aw nr bi"><span id="08e5" class="lu lv it mv b gy ns nt l nu nv">adb shell am dumpheap &lt;PID of target app&gt; /path/to/store/heap-dump.hprof</span><span id="8f79" class="lu lv it mv b gy nw nt l nu nv">#get the heapdump file to PC<br/>adb pull /path/to/the/hprof .</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi nx"><img src="../Images/b46fd96d128463de00097cac1f89028a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ee4zqJ09rGSoBrXsmXQFhw.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">通过adb堆配置文件转储</figcaption></figure><p id="2505" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">第三步</p><p id="893b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">要在MAT Analyzer工具中分析<strong class="jw iu"> hprof </strong>文件，请将hprof文件转换为<strong class="jw iu"> MAT支持格式</strong>。为此需要使用位于<strong class="jw iu">【Android-SDK】\平台-工具中的<strong class="jw iu"> hprof-conv </strong>工具。</strong></p><pre class="kw kx ky kz gt no mv np nq aw nr bi"><span id="a694" class="lu lv it mv b gy ns nt l nu nv">cd "C:\android-sdk\platform-tools"</span><span id="f14e" class="lu lv it mv b gy nw nt l nu nv">hprof-conv.exe "heapdump.hprof" "MAT-format-heapdump.hprof"</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi ny"><img src="../Images/15899c70e79337510be979e8a896acc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nog1VUYOMhNXlj4LbqEgKA.png"/></div></div></figure><p id="20d3" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">第四步</p><p id="92f8" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">现在我们有了目标应用程序的MAT支持hprof文件。让我们分析文件中的敏感字符串。</p><p id="c7d8" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">使用<a class="ae nz" href="https://www.eclipse.org/mat/" rel="noopener ugc nofollow" target="_blank">链接</a>下载Eclipse MAT</p><p id="53ec" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">使用MAT analyzer打开转换后的hprof文件。从反编译的源代码中，我观察到AES秘密是以“<strong class="jw iu"> TbTS </strong>开始的。这是通过分析字节数组函数得到的。所以我在Eclipse MAT中用OQL ( <strong class="jw iu">对象查询语言</strong>)特性搜索了这个字符串模式。</p><pre class="kw kx ky kz gt no mv np nq aw nr bi"><span id="9f2c" class="lu lv it mv b gy ns nt l nu nv">SELECT s.count, toString(s) FROM java.lang.String s WHERE (toString(s) LIKE "TbTS.*")</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi oa"><img src="../Images/385ce35016eb0a3f8d14144845c05fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iodaLk8kmoTKaMhkXkSZUg.png"/></div></div></figure><p id="479a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">最后拿到了AES密钥，但是需要<strong class="jw iu"> IV random </strong>密钥来解密或者加密数据。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi ob"><img src="../Images/b0770bbfdc14c179e01f9a7dbbe601b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dn0yrwIWqCu6yC9kP3d14g.png"/></div></div></figure><p id="3eac" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">经过一番分析，我的目光集中在'<strong class="jw iu"> X-Security-Param </strong>'头上。当我解码这个头值时，我得到了一个值，我坚信这是摘要的IV键。</p><p id="dee1" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">最后，使用识别出的值，我解密并修改了加密的请求体。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi oc"><img src="../Images/a3fb297886d312c101014c55f4572d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0UyTY_JMrYZe72a2GFKdQ.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">使用AES密码和IV加密的正文请求</figcaption></figure><h2 id="2596" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kt mg mh mi ku mj mk ml mm bi translated">参考资料:</h2><p id="c15b" class="pw-post-body-paragraph jt ju it jw b jx mn jz ka kb mo kd ke ks mp kh ki kt mq kl km ku mr kp kq kr im bi translated"><a class="ae nz" href="https://developer.android.com/studio/profile/memory-profiler" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/studio/profile/memory-profiler</a></p><p id="40b4" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated"><a class="ae nz" href="https://proandroiddev.com/everything-you-need-to-know-about-memory-leaks-in-android-d7a59faaf46a" rel="noopener ugc nofollow" target="_blank">https://proandroiddev . com/everything-you-need-know-on-memory-leaks-in-Android-d 7 a 59 faaf 46a</a></p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="8f23" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">感谢你花时间阅读这篇博客。如果你想学习android黑客技术，请关注我，关注有趣的<strong class="jw iu">黑客技术</strong>并查看<a class="ae nz" href="https://medium.com/@secureITmania" rel="noopener"> <strong class="jw iu">我的简介</strong> </a>阅读有趣的<strong class="jw iu"> BugBounty </strong>文章。</p></div></div>    
</body>
</html>