<html>
<head>
<title>Advanced Docker Security</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级Docker安全性</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/advanced-docker-security-2ef31ac7547f?source=collection_archive---------0-----------------------#2022-04-02">https://infosecwriteups.com/advanced-docker-security-2ef31ac7547f?source=collection_archive---------0-----------------------#2022-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/341e125aa353acabd01c0321e5cfef50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pztXG5vcUql4YwXv"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@carrier_lost?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊恩·泰勒</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="4bca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在当今世界，开发应用程序不仅仅需要编写代码。多种语言、框架和架构的使用，以及开发生命周期每个阶段的工具之间不连续的接口，导致了巨大的复杂性。Docker简化并加速了您的过程，同时让开发人员有机会根据自己的需求，利用自己喜欢的工具、应用程序堆栈和每个项目的部署环境进行创作。</p><p id="9033" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">简介</strong></p><p id="12d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Docker让运营团队可以轻松地直接部署应用和网站，而不必担心依赖性、配置设置或服务器上安装的软件包版本。因为它简单到只需从注册表中获取图像并用一个命令执行它(docker run ),我们经常没有意识到它需要与任何其他实体相同的安全级别。</p><p id="8bf4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经写了几篇关于docker安全最佳实践的文章，可以在<a class="ae kf" href="https://medium.com/codex/docker-essentials-security-2ecf07e80966" rel="noopener">这里</a>和<a class="ae kf" href="https://medium.com/codex/everything-about-docker-security-ba2e46afd0e2" rel="noopener">这里</a>找到。</p><p id="6d33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇博文中，我们将介绍一些关于Docker安全性的更高级的概念，如果您正在使用多个容器、想要防止权限提升等，这些概念肯定会有所帮助。</p><p id="9831" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">诺登录外壳</strong></p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/e6db57470593eaa26a6311d82de45290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FsWwQ09Bs2uyaLKrGqLtEQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">诺洛金壳</figcaption></figure><p id="3fca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Docker容器可以容纳多个用户帐户。Root帐户是用户在容器中可以获得的最高权限，一旦他拥有root权限，他就可以实际执行root命令，或者在容器中执行更多操作。为了确保恶意用户不会升级到root帐户，即使他可以访问root帐户的密码，您也可以将shell更改为<strong class="ki iu"> nologin </strong>。或者，您也可以为用户使用受限的shells。要禁用root登录(在容器内部)，您所要做的就是修改docker文件并添加以下行。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="b638" class="lo lp it lk b gy lq lr l ls lt"><strong class="lk iu">RUN chsh –s /usr/bin/nologin root</strong></span></pre><p id="7951" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">nologin shells用于<strong class="ki iu"> </strong>拒绝对帐户的登录访问。这一行将确保即使恶意用户获得了根用户的帐户，他也无法登录，因为它在nologin文件中被拒绝，因此没有用户，甚至根用户都无法登录到他的帐户。</p><p id="9dc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">使用SUID禁用权限提升</strong></p><p id="ddbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们谈论缓解技术之前，我们应该理解什么是SUID。SUID代表<strong class="ki iu">在执行时设置所有者用户ID</strong>是给予文件的一种特殊类型的文件权限。如果根用户将此权限授予可执行文件，则该权限可用于提升根用户的权限。根用户设置SUID位所要做的就是键入</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="96a8" class="lo lp it lk b gy lq lr l ls lt">chmod +x &lt;binary_name&gt;</span></pre><p id="7db2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些在野外被利用来提升docker容器中的特权。为了防止这种情况，您可以在旋转docker容器时使用一个特殊的标签<strong class="ki iu">—security-opt = " no-new-privileges</strong>。</p><p id="77d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个标记确保进程和子进程(由父进程产生)不会因为使用SUID或SGID位而获得任何额外的特权。</p><p id="633a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">举个例子，</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="bcf9" class="lo lp it lk b gy lq lr l ls lt">docker run –it &lt;image_id&gt; --security-opt=”no-new-privileges" /bin/bash</span></pre><p id="5ee8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">注意</strong>:这里image_id是你的docker容器的图片的id。要找到容器的图像id，只需输入<strong class="ki iu"> docker图像ls </strong></p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lu"><img src="../Images/9cfbe618497fbc2778c95bc85021cd02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QqAF_4jCwJumU70AgVwyZg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">docker图像ls</figcaption></figure><p id="f79d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">创建只读文件系统</strong></p><p id="1f4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只读文件系统确保用户不能在系统中创建任何文件。这将防止他们在docker容器中下载和安装恶意文件，这些文件可进一步用于其他恶意目的，如恶意软件、键盘记录器或back connect shell。因此，通过创建一个只读文件系统来保护docker免受未经授权的访问是非常重要的。</p><p id="6033" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要创建只读文件系统，我们可以使用以下命令</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="92f4" class="lo lp it lk b gy lq lr l ls lt">docker run --read-only –it &lt;image_id&gt; /bin/bash</span></pre><p id="8c4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以理解，没有写权限的容器可能会给用户带来一些不便。所以，你能做的就是建立一个临时文件系统。在这个例子中，我为临时文件系统选择了我的<strong class="ki iu"> /opt </strong>目录。因此，用户将只能下载指定目录中的文件，而不能将它们移动到主目录或任何其他目录。这可以通过运行以下命令来实现。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="6976" class="lo lp it lk b gy lq lr l ls lt">docker run --read-only --tmps /opt -it &lt;image_id&gt; /bin/bash</span></pre><p id="90ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">阻止集装箱间通信</strong></p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lv"><img src="../Images/511c89adc670bf70470b67325357ef39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vHJUr2Ocd6Eepopa3e6Jw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://maximorlov.com/4-reasons-why-your-docker-containers-cant-talk-to-each-other/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="e991" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦在生产环境中设置了Docker，安装多个容器是很正常的，因为它们负责不同的活动。例如，您可能在一个容器中使用MongoDB，而在另一个容器中托管应用程序。但是，您知道跨容器通信是可能的吗？以下场景:运行通过端口暴露的应用程序的易受攻击实例的docker容器暴露给外部世界。坐在另一个docker容器上的恶意用户有可能危及整个应用程序的安全。</p><p id="e0a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，除非需要，否则您可以阻止容器间的通信。</p><p id="8ea8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以从查看docker内置的默认网络开始。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="7903" class="lo lp it lk b gy lq lr l ls lt">docker network ls</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lw"><img src="../Images/36ad2354ba8c5e86da18247b7f6b1066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQfQxPO9Dp3bEkCtnmtnHw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">网络列表</figcaption></figure><p id="e38f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我们将检查一种网络类型。在这个例子中，我们来看看桥接网络类型。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="da75" class="lo lp it lk b gy lq lr l ls lt">docker network inspect bridge</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lx"><img src="../Images/9c398853a3dbd6b02f8492c9e4344289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pm4kXQ3h3pndP2k0sYxlUQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">检查桥梁</figcaption></figure><p id="1080" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你向下滚动，你会看到它将<strong class="ki iu">com . docker . network . bridge . enable-ICC</strong>设置为<strong class="ki iu"> true。</strong></p><p id="6f2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为多个设备和容器可以被加入到一个桥连接中以便它们进行通信，所以桥连接被用来互连容器并使它们更容易被访问。</p><p id="5fda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个新的网络并将其设置为false是我们阻止容器间通信所需要做的全部工作。然后，当我们建立一个新的容器时，我们可以将它包含在我们已经建立的新建立的网络中。结果，集装箱将被分开，并且将只能容纳一个集装箱。</p><p id="fa52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从创建一个新网络开始</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="08fe" class="lo lp it lk b gy lq lr l ls lt">docker network create  --driver bridge –o “com.docker.network.bridge.enable-icc”:”false” testnet1</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ly"><img src="../Images/c8a987c135748dc69c9a71c297e9e1df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TXQ0dTHulM3TY4BikPa1Gg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">创建新网络</figcaption></figure><p id="2c07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我们创建了一个类型为<strong class="ki iu">桥</strong>的网络，并将容器间的通信设置为false。我们创建的网络名称被设置为<strong class="ki iu"> testnet1 </strong></p><p id="c37f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成所有这些后，我们可以运行一个docker容器，将网络设置为testnet1。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lz"><img src="../Images/4b2bda2e87cb38d239711474a618a40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsZCjBMS6udMUxfjQZ3VfA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">列出网络</figcaption></figure><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="5f9e" class="lo lp it lk b gy lq lr l ls lt">docker run –it –network testnet1 &lt;image_id&gt; /bin/bash</span></pre><p id="7261" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:这里image_id是docker容器的图像的id。要找到容器的图像id，只需输入<strong class="ki iu"> docker图像ls </strong></p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lu"><img src="../Images/9cfbe618497fbc2778c95bc85021cd02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QqAF_4jCwJumU70AgVwyZg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">列出Docker图像</figcaption></figure><p id="4a16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">结论</strong></p><p id="7a17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇博客文章中，我们讨论了Docker安全的一些最重要的特性。尽管用户可以访问root密码，我们还是学习了如何阻止root登录。在接下来的课程中，我们学习了如何通过使用<strong class="ki iu"> SUID </strong>或<strong class="ki iu"> SGID </strong>文件来避免权限提升。在课程结束时，我们学习了如何构建只读文件系统，以及如何通过创建不同的网络来阻止容器间的通信。这些步骤对于保护docker安装至关重要。随着我们对docker安全性的了解越来越多，我们将在本系列中添加更多的文章。</p></div></div>    
</body>
</html>