<html>
<head>
<title>Arming the Use-After-Free()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">启用释放后使用()</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/arming-the-use-after-free-bc174a26c5f4?source=collection_archive---------1-----------------------#2022-01-17">https://infosecwriteups.com/arming-the-use-after-free-bc174a26c5f4?source=collection_archive---------1-----------------------#2022-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5d93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好黑客们，</p><p id="8190" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们继续我们的堆利用系列。如果你对此不熟悉，请阅读上一篇文章。</p><p id="a8f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://medium.com/@ad2001/heap-exploitation-for-homo-sapiens-f166cd6a59fe" rel="noopener">https://medium . com/@ ad 2001/heap-exploitation-for-homo-sapiens-f 166 CD 6a 59 Fe</a></p><p id="f247" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你已经熟悉了一些堆的基础知识，那么可以跳过它。所以今天我们就来看看<strong class="jp ir">免后使用()</strong>。这是一个常见的堆错误，甚至在今天仍然存在。</p><p id="71c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你们大多数人可能都知道这个bug。其实很常见，也很好理解。所以让我们深入研究一下。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><h1 id="a351" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">揭示分配和取消分配</h1><p id="7bdd" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">让我们看看当我们执行malloc()时，堆管理器是如何分配内存的。</p><p id="afa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，最初，堆管理器检查是否有与分配的块大小相同的其他空闲块。如果有，它会将该块返回给用户。那么什么是自由块呢？</p><p id="e4dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它只是一个由free()函数释放的块(内存块)。当我们释放一个块时，它将被添加到一个叫做“bin”的特殊链表中。</p><p id="d3a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以基本上bin是一个自由块的链表。当内存块空闲时，它被存储在列表中。它们根据块的大小进行排序。</p><p id="f483" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要有两种类型的箱子。</p><ol class=""><li id="840a" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">快速箱</li><li id="9efc" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">常规箱</li></ol><p id="e0a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">常规仓</strong>又分为未分拣仓、小仓、大仓。我们将主要处理快速箱。所以现在让我们忽略常规的垃圾箱。</p><p id="e441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速箱存储小尺寸的自由块。正如我上面所说的，这些快速容器的列表存储在一个单链表中。添加和删除从列表的前面开始(LIFO方式)。有10个容器，每个容器具有相同大小的块。例如，用于保存16字节大小的块的bin应该只有16字节大小的块，它不应该包含任何其他大小的块。所以尺码有16、24、32、40、48、56、64、72、80和88。</p><p id="0638" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将只关注对<strong class="jp ir"> fastbin块</strong>的利用。</p><p id="1805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我说到哪里了？</p><p id="60cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，所以如果在容器中有任何请求大小的空闲块，它由堆管理器返回。</p><p id="593f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有空闲块。堆管理器将检查堆顶部(顶部块)是否有足够的可用空间。如果有，堆管理器将从可用空间中分配一个新的块并使用它。</p><p id="aa53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顶层块是一个大的堆块，用于保存未分配的空间。如果没有空闲的块，堆管理器将从中创建一个新的块。这将随着每次分配而变得越来越小(如果没有空闲块)</p><p id="efb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让你看看最上面的那块。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/bbcc76b1ca333a6c2a419d7e05588e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H8ZzveM0whcjD482wnY_ug.png"/></div></div></figure><p id="b5d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果顶部块中没有空间，那么堆管理器将请求内核向堆的末尾添加新的内存，然后从这个分配的空间中分配一个新的块。</p><p id="a18d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这都失败了，那么这意味着堆管理器分配内存失败，它将返回null。</p><p id="5796" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们来看看被释放的块的结构。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/3c6bfefabff20f800da5693929c605f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*Whsz6SdxRQ23Sr4-.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">取自azerialabs.com</figcaption></figure><p id="be4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">前进</strong>指针:指向列表中下一个块的前进指针。<br/>T3】BCK指针:返回指针指向列表中的前一个块。</p><p id="7aff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们检查一下这个<strong class="jp ir"> C程序</strong>来理解其行为，并看看一些自由程序块的运行情况。</p><blockquote class="mw mx my"><p id="162e" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated"># include<stdio.h><br/># include&lt;stdlib . h&gt;</stdio.h></p><p id="db2d" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">void main(){<br/>int * a = malloc(2)；<br/>int * b = malloc(3)；<br/>int * c = malloc(10)；</p><p id="0a97" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">免费(a)；<br/>免费(b)；<br/>免费(c)；</p><p id="bdcc" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi">}</p></blockquote><p id="8c83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译这个并在gdb中运行它。</p><p id="aeca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反汇编主函数，在函数末尾放一个断点(pop{r11，pc})。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nd"><img src="../Images/108615adb3d368f32c5ae8f4a9c47aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Efx8C2_5KZx-qpwCGOfCJA.png"/></div></div></figure><p id="9494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行程序。</p><p id="2477" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当它到达我们的断点时，使用heap bins命令来检查堆。我们知道我们释放了()三个块，所以将有3个空闲的()d个块。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ne"><img src="../Images/b79e7ca73b77b57e3bb34c0cad0018a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dn_QRRsqtqeGDDPxDqZiTg.png"/></div></div></figure><p id="80a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们讲过的链表。头部指向新添加的块。这里我们可以看到头指向最后一个free()d chunk ie，0x21028。</p><p id="c523" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些空闲()d块被添加到0x10 (16字节)大小的容器中。但是当我们查看free()d块所在的快速bin的大小时，它显示size=0x8。这是gef的一个bug，在最新版本中已经修复。所以不用担心。它应该被添加到0x10(16字节)大小的bin中。没有bin存储0x8大小的块，因为我们已经知道最小大小的块是16字节大小。如果我们再次尝试malloc()，它将返回相应大小的fast bin开头的块。</p><p id="24ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们尝试malloc一个大小为16的块(最小大小的块:16字节)，堆管理器将查看存储16字节大小的块的fast bin，如果有可用的块，它将由堆管理器返回给用户。</p><p id="eb59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们编辑源代码并添加一个malloc()调用，验证我们的理论是否正确。</p><blockquote class="mw mx my"><p id="b212" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated"># include<stdio.h>T15】# include&lt;stdlib . h&gt;</stdio.h></p><p id="95dd" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">void main(){<br/>int * a = malloc(2)；<br/>int * b = malloc(3)；<br/>int * c = malloc(10)；</p><p id="4caa" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">免费(a)；<br/>免费(b)；<br/>游离(c)；</p><p id="9802" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">int * d = malloc(2)；</p><p id="9a1b" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi">}</p></blockquote><p id="a894" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在这里应用我们的理论。下面经过编辑的代码包含一个对malloc的新调用，它将分配一个16字节大小的新块，并将在<strong class="jp ir">指针‘d’</strong>中返回。因此，根据我们的理论，将返回到<strong class="jp ir">指针‘d’</strong>的新块将是我们释放()d的最后一个相同大小的块。该块将被添加到相应大小的bin的头部。我们只分配和释放了()d个16字节大小的块，所以只有一个快速bin (16字节大小)。因此，新添加的malloc()调用将返回我们释放的最后一个16字节大小的块()d，它由<strong class="jp ir">‘c’</strong>指向<strong class="jp ir">指针‘d’</strong>。</p><p id="1824" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用调试器来检查我们的论文。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nf"><img src="../Images/c1eb7a9646f26f4ea6aed0214df6b8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2I4mZJThBSs11vFTWU-vA.png"/></div></div></figure><p id="1fa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是在我们最后一次调用malloc()之前。我们可以在fast bin中看到我们所有的空闲()d块。如果您查看快速bin的头部，它包含地址为“0x21028”的块。这是将返回给下一个malloc调用()的块。</p><p id="5fba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们跳过malloc调用()来看看。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ng"><img src="../Images/7bc424689fed95aadbaf7550f8b42d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YmZz_Hz1u6uX7dYK7HWS7g.png"/></div></div></figure><p id="a519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们现在看，指向地址“0x21028”的块从快速箱中丢失。</p><p id="5b1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们也检查一下r0。(r0将包含分配给我们malloc的块的地址)</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nh"><img src="../Images/e9b8f26740f366860a36cca5ecb23ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1R8i8ppVz8A_b8T0bgKT2Q.png"/></div></div></figure><p id="2e07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如所料，它包含的地址与我们的fast bin中最后一个free()d块的地址相同。这证实了我们的理论。</p><p id="bc53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是如何利用容器来存储空闲的()块。现在我们来看看释放后使用漏洞。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ni ks l"/></div></figure><h1 id="cc23" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">免费后使用</h1><p id="9776" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我已经在前一篇文章中简要地写了这个。所以要释放()一个块，我们使用free()函数，对吗？。但是即使我们释放了()这个，我们仍然需要将指针赋值为“NULL ”,因为即使释放了指针，它仍然会指向那个特定的位置。所以在释放后仍然使用内存()d叫做<strong class="jp ir">释放后使用。</strong>这就是我们bug starts的由来。</p><p id="d102" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你看看<a class="ae kl" href="https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=use+after+free" rel="noopener ugc nofollow" target="_blank"> cve mitre </a>，我们可以看到它今天仍然是相关和常见的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nj"><img src="../Images/82c4494aed0e8eeb6a7d9b182af4d39b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZdY7wORogSTdl7nO1o2Mg.png"/></div></div></figure><p id="1751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想了解更多，可以看看下面的文章。</p><div class="nk nl gp gr nm nn"><a href="https://pure.security/introduction-to-use-after-free-vulnerabilities/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">释放漏洞后的使用介绍</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">释放后使用(UAF)漏洞是一类在世界上非常成功的内存损坏错误…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">纯粹。安全</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob mp nn"/></div></div></a></div><p id="3e07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjemd3Ng-30AhVCSWwGHfoZBl8QFnoECAgQAw&amp;url=https%3A%2F%2Fwww.blackhat.com%2Fdocs%2Feu-16%2Fmaterials%2Feu-16-Wen-Use-After-Use-After-Free-Exploit-UAF-By-Generating-Your-Own-wp.pdf&amp;usg=AOvVaw01DzaZqA91ZqSVKeBkR13V" rel="noopener ugc nofollow" target="_blank">www . black hat . com % 2f docs % 2Feu-16% 2f materials % 2Feu-16-Wen-Use-After-Use-After-Free-Exploit-UAF-By-Generating-Your-Own-WP . pdf&amp;usg = aovvaw 01 dzazqa 91 zqsvkebkr 13v</a></p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="0ea1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用下面的示例程序来理解这一点，以便更加清楚。</p><blockquote class="mw mx my"><p id="99f3" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated"># include<malloc.h><br/># include&lt;stdio . h&gt;</malloc.h></p><p id="05c7" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">typedef结构函数{<br/>void(* funct _ ptr)()；<br/>} ptr；</p><p id="47f4" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">void one(){ <br/> printf("这是函数一\ n ")；<br/> }</p><p id="7f5e" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">void two(){ <br/> printf("这是函数二\ n ")；<br/> }</p><p id="fc73" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">void main(){<br/>ptr * malloc 1 = malloc(sizeof(ptr))；//First malloc<br/>malloc 1-&gt;funct _ ptr = one；<br/> printf("调用malloc 1-&gt;funct _ ptr \ n ")；<br/>malloc 1-&gt;funct _ ptr()；<br/> printf("释放malloc 1 \ n ")；<br/>免费(malloc 1)；<br/>ptr * malloc 2 = malloc(sizeof(ptr))；//第二个malloc<br/>malloc 2-&gt;funct _ ptr = two；<br/> printf("调用malloc 2-&gt;funct _ ptr \ n ")；<br/>malloc 2-&gt;funct _ ptr()；<br/> printf("尝试调用malloc 1 \ n ")；<br/>malloc 1-&gt;funct _ ptr()；</p><p id="06cd" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi">}</p></blockquote><p id="ae6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有两个函数和一个名为“function”的结构，其中包含一个<strong class="jp ir">函数指针</strong>。我们将使用这些函数指针来存储程序中的两个函数(函数‘一’和函数‘二’)。</p><p id="ddfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在源代码中看到的，我们使用malloc()并保留空间来存储结构中的函数指针。这将分配一个块用于存储函数“一”的地址。后来<em class="mz"> malloc1 </em>被赋予<em class="mz">功能一</em>并被调用。</p><blockquote class="mw mx my"><p id="5561" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">malloc 1-&gt; funct _ ptr = one；//分配函数一</p><p id="e307" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">printf("调用malloc 1-&gt; funct _ ptr \ n ")；</p><p id="a97f" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">malloc 1-&gt; funct _ ptr()；//调用函数</p></blockquote><p id="dcb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用该函数后，它使用free()释放这个块。</p><blockquote class="mw mx my"><p id="4e6c" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">免费(malloc 1)；</p></blockquote><p id="0fe3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但问题是，即使在释放这个块之后，指针“malloc1”仍然指向从第一个malloc返回的块。更糟糕的是，它仍在被使用，这是它成为实际漏洞的地方。释放后使用，对吗？</p><p id="f617" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们能做些什么来解决这个问题呢？</p><p id="3b8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该简单地将“NULL”赋给这个指针，这样它就不会指向任何地方。</p><p id="72cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但问题是，即使在释放这个块之后，指针“malloc1”仍然指向从第一个malloc返回的块。更糟糕的是，它在被释放后仍在被使用。(源代码的最后一行)</p><blockquote class="mw mx my"><p id="01b4" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">malloc 1-&gt; funct _ ptr()；</p></blockquote><p id="fd47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是它成为实际漏洞的地方。释放后使用，对吗？</p><p id="7e26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这之后，还有另一个函数指针，它有第二个函数“two”的地址。所以“malloc2”包含了第二个函数的地址，函数二稍后被调用。</p><blockquote class="mw mx my"><p id="ac41" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">ptr * malloc 2 = malloc(sizeof(ptr))；//Second malloc<br/>malloc 2-&gt;funct _ ptr = two；<br/>malloc 2-&gt;funct _ ptr()；</p></blockquote><p id="1214" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们编译并运行这个程序，看看漏洞在起什么作用。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi oj"><img src="../Images/11345c018d238b8442d5e4e27e09a97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*swsxVkqL4GN65dhqpUFwMQ.png"/></div></div></figure><p id="f76a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来分解输出。</p><p id="4236" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，它的调用函数one使用了函数指针“malloc1”。我们可以从函数一“这是函数一”看到printf函数的输出。之后，用于保存函数一的函数指针的块被释放()。正如我们所知，这个空闲的()块将被放入垃圾箱。<br/>即使它是空闲的()，指针仍然指向包含函数一的函数指针的第一个块。</p><p id="33f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，它使用函数指针“malloc2”调用第二个函数。我们也可以在这个函数中看到printf函数的输出“这是函数二”。</p><p id="da7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们使用函数指针“malloc1”调用函数1。但是如果你看看输出，它是函数2的printf()函数的输出。但是我们从来没有把函数二赋给“malloc1”。那这是怎么发生的？？</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ok ks l"/></div></figure><p id="7f9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以当我们释放第一个块(malloc1)时。它将被添加到与其大小相对应的媒体夹的头部。因此，当我们尝试分配下一个块时，它会查看这些块中是否有确切大小的空闲()d块。如果有这样大小的块，堆管理器将返回它。这里我们的第二个malloc分配了相同的大小，所以它将返回我们释放的第一个块，这个块用于存储函数一的函数指针。</p><p id="c6c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当这个被返回时，我们用这个来存储“函数二”的函数指针。当我们将“函数二”赋给返回的块时，块内的内容，即指向“函数一”的指针，将被函数二的指针替换。不要忘记“malloc1”仍然指向这个块，即使在它被释放之后也是如此。现在在块内部，<em class="mz">函数一</em>的函数指针被函数二所取代。所以当我们试图使用<em class="mz"> malloc1 </em>来执行函数指针内的函数时。它将执行第二个函数，因为它现在有了指向“函数二”的指针，因为使用“malloc2”存储“函数二”的函数指针的是同一个块。</p><p id="b0c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ptr * malloc 2 = malloc(sizeof(ptr))；//第二个malloc</p><p id="cdb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">malloc 2-&gt; funct _ ptr = two；</p><p id="d0a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">malloc 2-&gt; funct _ ptr()；</p><p id="2f6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是为什么我们看到函数二被执行，而不是函数一被首先分配给<em class="mz"> malloc1 </em>。</p><p id="d7a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们做一个简单的挑战来更好地理解这一点。</p><h2 id="1230" class="ol ku iq bd kv om on dn kz oo op dp ld jy oq or lh kc os ot ll kg ou ov lp ow bi translated">挑战UAF</h2><p id="cb86" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">编译下面的源代码。</p><blockquote class="mw mx my"><p id="d14e" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated"># include<stdio.h><br/># include&lt;stdlib . h&gt;<br/># include&lt;string . h&gt;<br/>T12】int main()<br/>{<br/>char * name = 0；<br/>char * pass = 0；<br/>while(1)<br/>{<br/>if(name)printf(" name address:% x \ n name:% s \ n "，name，name)；<br/> if(pass) printf("pass地址:%x\npass: %s\n "，pass，pass)；<br/> printf("1:用户名\ n ")；<br/>printf(" 2:Password \ n ")；<br/>printf(" 3:Reset \ n ")；<br/>printf(" 4:log in \ n ")；<br/>printf(" 5:Exit \ n ")；<br/> printf("选择？");<br/>int num = 0；<br/> scanf("%d "，&amp;num)；<br/>switch(num)<br/>{<br/>case 1:<br/>name = malloc(20 * sizeof(char))；<br/> printf("插入用户名:")；<br/> scanf("%254s "，名称)；<br/> if(strcmp(name，" root") == 0) <br/> { <br/> printf("不允许root。\ n ")；<br/> strcpy(名称，“”)；<br/> } <br/>破；<br/>案例二:<br/>pass = malloc(20 * sizeof(char))；<br/> printf("插入密码:")；<br/> scanf("%254s "，通过)；<br/>破；<br/>案例三:<br/>免费(通过)；<br/>自由(名字)；<br/>破；<br/>案例四:<br/> if(strcmp(name，" root") == 0) <br/> { <br/> printf("免费后你随便用！\ n ")；<br/>系统("/bin/sh ")；<br/>退出(0)；</stdio.h></p><p id="9dae" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi translated">} <br/>破；<br/>情况五:<br/>出口(0)；<br/> } <br/> }</p><p id="00be" class="jn jo mz jp b jq jr js jt ju jv jw jx na jz ka kb nb kd ke kf nc kh ki kj kk ij bi">}</p></blockquote><p id="893b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链接:<a class="ae kl" href="https://pastebin.com/LKfaUK6v" rel="noopener ugc nofollow" target="_blank">https://pastebin.com/LKfaUK6v</a></p><p id="e5d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我从一个浆糊里得到这个消息。所以一切归功于原主人。我只是编辑了一下，添加了对系统函数的调用</p><p id="651d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以不管怎样，我们的任务是拿到贝壳。我们只有作为root用户才能获得shell。但是我们不能将用户名设置为“root”。我们可以输入除root之外的任何其他名称。</p><p id="b7af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们来分解程序选项</p><p id="3131" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1 →将分配一些块用于存储用户名<br/> 2 →将分配一些块用于存储密码(与用户名大小相同)<br/> 3 →使用自由函数<br/>释放用户名和密码4 →如果用户是根用户，则尝试生成一个shell。</p><p id="125e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在让我们检查一下漏洞在哪里。</p><p id="6922" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">试着看看第三个选项。它用于使用免费功能重置用户名和密码。但问题是，即使在这些指针被释放后，它们仍然指向同一个位置，因为它们没有失效。</p><p id="d487" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于尺寸相同，它们将进入相同的<strong class="jp ir">快速箱。</strong></p><p id="bd61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们将如何利用它呢？试着想一个方法，通过利用这个漏洞，我们可以将用户名指向包含文本“root”的位置。</p><p id="6157" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我强烈建议你自己尝试一段时间。</p><p id="d8a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们讨论一下解决这个问题的简单方法。</p><p id="9074" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们可以使用选项1分配一个块来存储用户名。然后，让我们使用选项2来分配一个块用于存储密码。这将分配两个大小相同的区块。</p><p id="cdd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过使用选项3重置用户名和密码来触发漏洞。这将解放他们两个。因为它们的大小相同，所以它们将进入相同大小的<strong class="jp ir">垃圾箱。</strong></p><p id="47f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果查看选项3的代码，首先释放用于保存密码的“pass”指针()，然后释放用于保存名称的“name”指针。因此，用于密码的块将首先进入bin，然后是用于保存用户名的块。所以fastbin的头将指向用于保存用户名的块。</p><p id="8010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看实际情况。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ox"><img src="../Images/ce27c44d36bd91a435f057b451f212d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElBlgyR-6n0ljcu5Vn-zeA.png"/></div></div></figure><p id="5467" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些块大小相同，我们可以在输出中看到地址。接下来，我们可以使用reset选项释放()用户名和密码。</p><p id="8aa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为它们具有相同的大小，所以它们将属于相同大小的容器。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi oy"><img src="../Images/bdef4d7f2d3d5e49a8a88923b61c86ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wN9-VkKJsdKBzKcDHuabA.png"/></div></div></figure><p id="5cff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，即使这是免费的()d，它仍然指向同一个位置。<br/>我们还在那个位置看到一些乱码字符，这是因为当块是空闲的()d时，包含了额外的元数据。此元数据将覆盖区块中的数据。你不需要介意那个。</p><p id="49f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用gdb确认它们是否在同一个bin中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi oz"><img src="../Images/276f29e45fa930908e1ba866b7cfbf43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c6i-1PCzhw3m4m0D0ZE5nA.png"/></div></div></figure><p id="d95a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(你不需要担心垃圾箱中显示的块大小是错误的。这主要是由于gdb中的bug)</p><p id="fe9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，bin的头包含指向最后一个空闲()d块的<em class="mz">“用户块”</em>，后面是“<em class="mz">密码块</em>”。</p><p id="b806" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果我们尝试分配任何块来存储密码和用户名，将返回位于bin头部的free()d块(先前用于用户名的块)。</p><p id="2d10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想现在你有了利用这一点的想法。</p><p id="1b26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们现在要做的是使用选项2请求一个块来存储密码。这将返回bin开头的free()d块，它仍然指向用户名。</p><p id="6e4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们试图在这个块中添加新内容，之前空闲的()d用户名指针将指向这个，因为有相同的块。正如我们现在已经知道的，如果我们是根用户，我们只能得到shell，我们不能直接设置用户名为根，程序不会接受。这里的技巧是，如果我们将新请求的密码块的内容设置为“root ”,那么之前空闲的()d用户名块将指向该内容，因为有相同的块。</p><p id="0a29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，先前空闲的()d用户名块的内容将被替换，并指向新设置的密码。</p><p id="f09c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们如果设置新密码为“root”。那么用户名也会指向“root”。</p><p id="a6e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，如果我们尝试登录，我们将很容易获得外壳，因为我们是根用户。</p><p id="fabd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们就这么做吧，战胜这个挑战。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pa ks l"/></div></figure><p id="c1d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我最后一次总结一下利用这一点的步骤。</p><p id="6e67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1→使用选项1分配一个块用于存储用户名。<br/>2→使用选项2分配一个块用于存储密码。<br/>3→使用选项3释放块。<br/>4→使用选项2分配一个密码块，以便它可以重写先前分配的用户名块的内容。<br/>5→使用选项4登录获取外壳。</p><p id="e1ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们这样做是为了得到外壳</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi pb"><img src="../Images/e82f79fe8b89e18507735303cfa9cc9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n3Sw-x08qpsuJJmxC-zA6w.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi pc"><img src="../Images/6dd795f91c3ade69ef11b1375bb7baa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QM2UoYpWmF6ufT9PCnUgJQ.png"/></div></div></figure><p id="be1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">最后，我们得到了我们美丽的外壳:)</strong></p><p id="846b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我想是时候收工了。我希望您对释放后使用漏洞有所了解。</p><p id="328a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试做其他的“免费后使用”CTF挑战，并尝试自己利用它们。</p><p id="87f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝您愉快:)</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="a907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提到的文章和链接:<a class="ae kl" href="https://azeria-labs.com/" rel="noopener ugc nofollow" target="_blank">https://azeria-labs.com/</a></p><p id="787c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如有任何疑问，您可以联系我</p><p id="ce61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">https://www.facebook.com/i.am.ultralegend脸书<a class="ae kl" href="https://www.facebook.com/i.am.ultralegend" rel="noopener ugc nofollow" target="_blank"/></p><p id="11d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">insta gram:<a class="ae kl" href="https://www.instagram.com/hagane_no_rekinjutsushi/" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/hagane_no_rekinjutsushi/</a></p><p id="cf3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想支持我或者学习<strong class="jp ir"> ARM开发</strong>请查看我的课程:<a class="ae kl" href="https://www.udemy.com/course/reverse-engineering-and-binary-exploitation-in-arm/?referralCode=8C725D513E77420A0CBF" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/course/reverse-engineering-and-binary-exploitation-in-ARM/？referral code = 8c 725d 513 e 77420 a0cb</a></p></div></div>    
</body>
</html>