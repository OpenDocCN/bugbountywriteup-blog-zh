<html>
<head>
<title>The toddler’s introduction to Heap Exploitation, House of Spirit(Part 4.4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学走路的孩子对堆利用的介绍，精神之家(第4.4部分)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-house-of-spirit-part-4-4-252cd8928f84?source=collection_archive---------0-----------------------#2022-05-20">https://infosecwriteups.com/the-toddlers-introduction-to-heap-exploitation-house-of-spirit-part-4-4-252cd8928f84?source=collection_archive---------0-----------------------#2022-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><blockquote class="ju jv jw"><p id="3df8" class="jx jy jz ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请让我知道，如果我开始听起来很奇怪…</p></blockquote><p id="0241" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated"><em class="jz">作者</em></p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="97ef" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">精神之家</h1><p id="5d41" class="pw-post-body-paragraph jx jy iq ka b kb lx kd ke kf ly kh ki kw lz kl km kx ma kp kq ky mb kt ku kv ij bi translated">具体的攻击最初是在2005年10月11日<strong class="ka ir">由<a class="ae mc" href="https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt" rel="noopener ugc nofollow" target="_blank"> <em class="jz">幻影幻影、</em>在bugtraq邮件列表上以标题<em class="jz">Malloc male ficarum</em></a><em class="jz">介绍的。</em>这个想法非常简单，而且随着<a class="ae mc" href="https://sourceware.org/glibc/wiki/MallocInternals#Thread_Local_Cache_.28tcache.29" rel="noopener ugc nofollow" target="_blank">线程本地缓存</a> (tcache)的引入变得更加简单:</strong></p><blockquote class="ju jv jw"><p id="7254" class="jx jy jz ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一般的想法是覆盖一个指针，这个指针先前是通过调用malloc()返回的，随后被传递给free()。这可能导致将任意地址链接到fastbin。进一步调用malloc()会导致这个任意地址被应用程序用作内存块。如果设计者可以控制应用程序对假块的使用，那么就有可能覆盖执行控制数据[1]。</p></blockquote><p id="954a" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">简单地说，假设你有一个指向一个块的指针，你可以重写这个块，以便指向一个你控制其内容的任意地址。那么就有可能“欺骗”分配器使用你的地址作为一个空闲块的指针，并把它添加到fastbins列表中。当malloc再次被调用并且您的块符合要求时，返回的内存地址将指向您的受控内存区域。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi md"><img src="../Images/bb106d109150cb573539662b0a91fc4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*3oPL5NF_5nR5ldFfCgnEpQ.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">免费前</figcaption></figure><p id="e0f9" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated"><strong class="ka ir">免费后:</strong></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/67726fb9e175f6e13bccec608c768a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*eaY-W5fnsKdraUdaA5zOMg.png"/></div></figure><p id="ebd1" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated"><strong class="ka ir">最后，在malloc之后:</strong></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/b9a2f0285e7d00c7b18f5ab9506c4a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJoM5RKRQs7BVhv6NKvfWQ.png"/></div></div></figure><p id="d508" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">在引入tcache bin之前，攻击者必须使用适当的大小值(由于特定bin的双重链接)来创建<strong class="ka ir">相邻的假块，以便通过分配器的有效性检查。tcache bin(单链接)使事情变得更简单，因此制作一个假的块将通过有效性检查。</strong></p><p id="410f" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated"><strong class="ka ir">一如既往，请在下面找到我之前关于堆开发的帖子的参考:</strong></p><ul class=""><li id="dd0c" class="mv mw iq ka b kb kc kf kg kw mx kx my ky mz kv na nb nc nd bi translated"><a class="ae mc" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-1-515b3621e0e8" rel="noopener">蹒跚学步，堆剥削，<strong class="ka ir">简介</strong>(上篇)</a></li><li id="bd0d" class="mv mw iq ka b kb ne kf nf kw ng kx nh ky ni kv na nb nc nd bi translated"><a class="ae mc" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-part-2-d1f325b74286" rel="noopener">蹒跚学步，堆剥削，<strong class="ka ir">简介</strong>(第二部分)</a></li><li id="c443" class="mv mw iq ka b kb ne kf nf kw ng kx nh ky ni kv na nb nc nd bi translated"><a class="ae mc" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-overflows-part-3-d3d1aa042d1e" rel="noopener">蹒跚学步，堆剥削，<strong class="ka ir">溢出</strong>(第三部分)</a></li><li id="bad5" class="mv mw iq ka b kb ne kf nf kw ng kx nh ky ni kv na nb nc nd bi translated"><a class="ae mc" href="https://valsamaras.medium.com/use-after-free-13544be5a921" rel="noopener">学步的，<strong class="ka ir">使用后免费&amp;双免费</strong>(第四部分)</a></li><li id="90eb" class="mv mw iq ka b kb ne kf nf kw ng kx nh ky ni kv na nb nc nd bi translated"><a class="ae mc" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-to-stack-part-4-1-425592a2870b" rel="noopener">学步的，<strong class="ka ir"> FastBin Dup to Stack </strong>(第4.1部分)</a></li><li id="4810" class="mv mw iq ka b kb ne kf nf kw ng kx nh ky ni kv na nb nc nd bi translated"><a class="ae mc" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8" rel="noopener">学步的，<strong class="ka ir"> FastBin Dup巩固</strong>(第4.2部分)</a></li><li id="466d" class="mv mw iq ka b kb ne kf nf kw ng kx nh ky ni kv na nb nc nd bi translated"><a class="ae mc" href="https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-unsafe-unlink-part-4-3-75e00e1b0c68" rel="noopener">幼儿的，<strong class="ka ir">不安全的解除链接</strong>(第4.3部分)</a></li></ul><h1 id="9c06" class="kz la iq bd lb lc nj le lf lg nk li lj lk nl lm ln lo nm lq lr ls nn lu lv lw bi translated">使用tcache的精神之家</h1><p id="adff" class="pw-post-body-paragraph jx jy iq ka b kb lx kd ke kf ly kh ki kw lz kl km kx ma kp kq ky mb kt ku kv ij bi translated">早在2017年，glibc 2.26就引入了Tcache，以加快堆管理。关于<strong class="ka ir">精神攻击之屋</strong>，这个增加使得事情变得更容易，因为这个箱子是单列表的。</p><p id="ea5c" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">让我们看一个简单的例子:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="43e0" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">我们在<strong class="ka ir">第6行</strong>调用malloc来初始化堆，随后(在<strong class="ka ir">第7行</strong>)我们声明一个指向<strong class="ka ir">无符号长整型</strong> (ull)的指针。在<strong class="ka ir">第8行，</strong>我们声明一个由<strong class="ka ir">满</strong>的数组，并让编译器在一个16字节的边界上分配它的成员(类似于块边界)。这个数组将模仿一个chunk，它的头从地址<strong class="ka ir"> fake_chunk[0]开始。</strong>更具体地说，我们有以下对应关系:</p><p id="d535" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated"><strong class="ka ir">fake _ chunk</strong>[0]→mchunk _ prev _ size，<strong class="ka ir">fake _ chunk</strong>[1]→mchunk _ size(回忆一下chunk结构，以便更好地理解这个概念):</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nq"><img src="../Images/493dc08ac89d27e099036726a7a2128e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*20NFlbcCPjnnmOaS.png"/></div></div></figure><p id="2eb8" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated"><strong class="ka ir">第10行</strong>的语句<code class="fe nr ns nt nu b">fake_chunks[1] = 0x40;</code>将把假块的大小设置为<strong class="ka ir"> 0x40 </strong>。如果到目前为止一切顺利，假设攻击者能够重写<strong class="ka ir"> a </strong>指向的地址。这个假设由第12行的<code class="fe nr ns nt nu b">a = &amp;fake_chunks[2]; </code>语句表示。最后，<strong class="ka ir">行14 </strong>处的<code class="fe nr ns nt nu b">free(a)</code>将把假块添加到<strong class="ka ir"> tcache bin </strong>中，因此下一次调用malloc(大小为0x30)时，将返回一个指向攻击者控制的块的指针。请记住，假块的大小也是由攻击者控制的，因此请求的malloc大小不会成为攻击的问题。让我们将程序加载到gdb，以便更深入地了解:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/51445267601a23a2e42e6d430d15dc4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*E2w5EGv6xYjCpvFE0-FqNw.png"/></div></figure><p id="ff07" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">在<code class="fe nr ns nt nu b">main+57</code>处，我们将在<code class="fe nr ns nt nu b"><strong class="ka ir">$rbp-0x30</strong></code>处获得以下值:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/4a5bd8290013347362ca25a14928f757.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*2Syo2P0rA3EQh815IPD6rw.png"/></div></figure><p id="d101" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated"><code class="fe nr ns nt nu b">main+57</code>后的<code class="fe nr ns nt nu b"><strong class="ka ir">$rax</strong></code>将指向假块的数据段:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/73afd8ff1d93054ee63b6da35c92f067.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*ekKAGImgX0TfnJ-nxMoGdg.png"/></div></figure><p id="c971" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">对地址为$rdi中的$rax的<strong class="ka ir"> free </strong>的调用将把假块移动到tcache:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ny"><img src="../Images/dd50c1330d6f3eea66237d04faa81746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YBhHv9O1Ndl9SjHKHQjMQ.png"/></div></div></figure><p id="2fbb" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">此时，假块将被分配给下一个malloc(0x30)。为了让事情变得更有趣，在我们的初始程序中添加以下行(从第16行开始):</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nz"><img src="../Images/bc9e408c9866b80ccfc0e60c78fa11cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nULaaNo-mjY-qMr6J3Hhzw.png"/></div></div></figure><p id="8628" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">strcpy等同于攻击者控制fake_chunk的能力，因此str指向:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oa"><img src="../Images/883bdd6465c3e8b3690875075119b880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCF5Mb_6IATICbvV0r2RPQ.png"/></div></div></figure><p id="6c08" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">暂时就这样了…下一篇文章再见。</p><p id="d4bd" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kw kk kl km kx ko kp kq ky ks kt ku kv ij bi translated">[1]<a class="ae mc" href="https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt" rel="noopener ugc nofollow" target="_blank">https://dl . packets storm security . net/papers/attack/mallocmaleficarum . txt</a></p></div></div>    
</body>
</html>