<html>
<head>
<title>JNDI Injection Series: RMI Vector - Fundamentals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JNDI注射系列:RMI向量-基础</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/jndi-injection-series-rmi-vector-1-31044f782daa?source=collection_archive---------2-----------------------#2022-12-27">https://infosecwriteups.com/jndi-injection-series-rmi-vector-1-31044f782daa?source=collection_archive---------2-----------------------#2022-12-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/72ba828c08ff3ac6b2a0cf1aa04bd053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NMt_nD_n33XrI3wa"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="https://awsimages.detik.net.id/community/media/visual/2022/01/13/ilustrasi-jalan_169.jpeg" rel="noopener ugc nofollow" target="_blank">https://AWS images . detik . net . id/community/media/visual/2022/01/13/ilustrasi-jalan _ 169 . JPEG</a></figcaption></figure><p id="1eeb" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">JNDI (Java命名和目录接口)是一个Java API，允许客户端通过名称发现和查找数据和对象。它用于从存储这些对象的几个服务提供者那里获得命名和目录服务:LDAP(轻量级目录访问协议)和Java RMI registry(远程方法调用)等。</p><p id="4439" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">JNDI是一个简单的Java API，只接受一个字符串参数，但是如果该参数被攻击者破坏，受害者应用程序将连接到恶意的LDAP/RMI服务器并执行任意命令。</p><p id="6059" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这篇博文将带你了解什么是RMI的基本知识，在下一篇博文的<a class="ae jy" href="https://medium.com/@yany.dong/jndi-injection-series-rmi-vector-dynamic-class-loading-from-remote-url-28dcbf9cee27" rel="noopener">中，你将看到如何利用RMI系统获得RCE。在以后，更多关于JNDI注入攻击的主题将在本系列中讨论。</a></p><p id="358b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">RMI是一种被滥用来实现RCE的技术，考虑到RMI操作受到一个<a class="ae jy" href="https://docs.oracle.com/javase/7/docs/api/java/lang/SecurityManager.html" rel="noopener ugc nofollow" target="_blank"> Java安全管理器</a>的额外检查和约束，表面上看起来似乎是反直觉的。但是情况并不总是这样，因为一些JVM版本不应用相同的限制和策略，因此，与其他通道(如LDAP)相比，RMI有时可能是一个更容易的通道，LDAP受到防御者更严密的监控。</p><h1 id="6abc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.Java RMI简介</h1><p id="1063" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">Java RMI附带了Java JDK 1.1和更高版本。它是一个真正的Java分布式计算应用程序接口。</p><p id="37db" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">Java RMI是一种机制，它允许存在于一个Java虚拟机(RMI客户机)中的对象调用在另一个Java虚拟机(RMI服务器)中定义的方法。在RMI系统中，从RMI服务器导出一个对象，并从RMI客户机调用它的方法。为了促进这种交互，本地JVM可能需要与远程对象相关的Java字节码。这一特性导致了下一篇博文中涉及的攻击媒介。</p><p id="ea58" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">RMI注册表是RMI系统的一个关键组成部分，它提供了一个集中的目录。RMI分布式应用程序使用RMI注册表来获取对远程对象的引用。每当RMI服务器创建一个对象时，它就向RMI注册中心注册这个对象。为了调用远程对象，RMI客户机在RMI注册表中通过远程对象的名称查找并获取远程对象引用，然后在RMI服务器上调用远程对象的方法。这个过程如图1所示。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/29c35282da4581920fa25f05165abc55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1JCsQaMsEXOoYQSMJPslpA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图1—<a class="ae jy" href="http://www.cs.cmu.edu/afs/cs.cmu.edu/user/pzheng/www/KDI-IIM/RMI_Image1.jpg" rel="noopener ugc nofollow" target="_blank">http://www . cs . CMU . edu/AFS/cs . CMU . edu/user/pzheng/www/KDI-IIM/RMI _ image1 . jpg</a></figcaption></figure><p id="8d09" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">最初的RMI解决方案包括两个关键的中间对象:存根和框架。RMI使用存根和框架对象与远程服务器对象进行通信。远程服务器对象是驻留在RMI服务器虚拟机上的对象，它的方法可以从RMI客户端调用。</p><p id="30ee" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">存根是一个驻留在客户端的对象，代表RMI服务器上的远程对象。存根启动与远程虚拟机的连接，并将消息从RMI客户机调用者传输到RMI服务器，等待响应。在得到响应后，存根负责处理它并将结果返回给调用者。</p><p id="8a70" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">框架是RMI服务器端的一个对象。当框架收到来自存根的传入消息时，它从消息中提取方法名和参数，调用RMI服务器上实际对象的相应方法，整理结果并将响应发送给存根。</p><p id="7638" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">将所有元素放在一起，创建如图2所示的经典RMI架构:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mj"><img src="../Images/98077f0a3a78ec0a055911c5264a1bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KvbSKGDy0ZNT8n6q0kOsXw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图2</figcaption></figure><ol class=""><li id="1226" class="mk ml iq kb b kc kd kg kh kk mm ko mn ks mo kw mp mq mr ms bi translated">RMI服务器创建一个实现服务器对象接口的远程对象，并在RMI注册中心注册它(使用<strong class="kb ir"> bind() </strong>或<strong class="kb ir"> reBind() </strong>方法)。</li><li id="1f89" class="mk ml iq kb b kc mt kg mu kk mv ko mw ks mx kw mp mq mr ms bi translated">RMI客户机在RMI注册中心寻找服务器对象(使用<strong class="kb ir"> lookup() </strong>方法)。</li><li id="3afe" class="mk ml iq kb b kc mt kg mu kk mv ko mw ks mx kw mp mq mr ms bi translated">RMI客户机获得存储在注册表中的服务器存根，该存根引用服务器对象。</li><li id="affd" class="mk ml iq kb b kc mt kg mu kk mv ko mw ks mx kw mp mq mr ms bi translated">RMI客户机调用者调用远程对象上的方法，该方法实际上是在服务器存根上调用的。</li><li id="cf07" class="mk ml iq kb b kc mt kg mu kk mv ko mw ks mx kw mp mq mr ms bi translated">方法参数被捆绑到一条消息中。如果参数是对象，它们将被序列化。这个过程被称为编组。服务器存根将消息发送给驻留在RMI服务器中的服务器框架对象。</li><li id="fcb3" class="mk ml iq kb b kc mt kg mu kk mv ko mw ks mx kw mp mq mr ms bi translated">框架对象从消息中解编方法名和参数，并使用与服务器存根相关联的服务器对象上的参数调用方法。</li><li id="12dd" class="mk ml iq kb b kc mt kg mu kk mv ko mw ks mx kw mp mq mr ms bi translated">服务器对象执行该方法并将结果返回给框架。</li><li id="199f" class="mk ml iq kb b kc mt kg mu kk mv ko mw ks mx kw mp mq mr ms bi translated">框架在消息中整理结果，并将消息发送到存根。</li><li id="db0f" class="mk ml iq kb b kc mt kg mu kk mv ko mw ks mx kw mp mq mr ms bi translated">存根对返回的消息进行解组，以提取结果并将其传输给RMI客户机调用者。</li></ol><p id="acbf" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">值得注意的是，开发RMI应用程序必须做的一件事是定义服务器对象接口。该接口定义了将从远程服务器对象中导出哪些远程方法/变量。</p><p id="af22" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">RMI已经摆脱了骨架文件的使用。在JDK 1.2(1998年发布)中，上述RMI体系结构中的框架被通用服务器端调度代码所取代。同样，在2004年发布)中，静态生成的存根被动态代理所取代。RMI系统以更轻量级的方式运行。</p><h1 id="af01" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.创建Java RMI应用程序</h1><p id="b91c" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">为了更好地理解RMI的工作原理，我们使用了两台CentOS 7.9服务器来建立一个演示环境。CentOS服务器使用Java SE Runtime Environment 1 . 6 . 0 _ 29(6u 29)作为RMI服务器和RMI客户端，因为旧版本的JDK部署了宽松的远程方法调用安全策略，并且它可以在下一篇博文中的<a class="ae jy" href="https://medium.com/@yany.dong/jndi-injection-series-rmi-vector-dynamic-class-loading-from-remote-url-28dcbf9cee27" rel="noopener">中的未来RMI利用演示中重用。为了简单起见，演示将RMI服务器和RMI注册中心放在同一个Linux机器上。</a></p><h1 id="e5a7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.1准备Java环境</h1><p id="1c16" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">要安装JDK的具体历史版本，可以在登录oracle官方网站后进入<a class="ae jy" href="https://www.oracle.com/java/technologies/javase-java-archive-javase6-downloads.html" rel="noopener ugc nofollow" target="_blank">https://www . Oracle . com/Java/technologies/javase-Java-archive-javase 6-downloads . html</a>获取目标JDK的下载地址(我是进入“开发者工具”模式后从浏览器的网络选项卡中获取带有AuthParam的下载网址的)。</p><p id="ad21" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在CentOs服务器上执行wget。下面提供了一个执行示例:</p><pre class="mb mc md me gt my mz na bn nb nc bi"><span id="04b6" class="nd ky iq mz b be ne nf l ng nh">[root@demo ~]# wget -O jdk-6u29.bin https://download.oracle.com/otn/java/jdk/6u29-b11/jdk-6u29-linux-x64-rpm.bin?AuthParam=1671893419_f213a470eff1bb72f9921ec7b5087375</span></pre><p id="d80a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">AuthParam因您的情况而异，或者您可以用自己的方式获得JDK bin文件。</p><p id="1cf3" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">通过执行以下命令安装bin:</p><pre class="mb mc md me gt my mz na bn nb nc bi"><span id="b059" class="nd ky iq mz b be ne nf l ng nh">[root@demo ~]# chmod +x ./jdk-6u29.bin<br/>[root@demo ~]# ./jdk-6u29.bin</span></pre><p id="3044" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">检查java版本，确保它是1.6.0_29。</p><pre class="mb mc md me gt my mz na bn nb nc bi"><span id="be69" class="nd ky iq mz b be ne nf l ng nh">[root@demo ~]# java -version<br/>java version "1.6.0_29"<br/>Java(TM) SE Runtime Environment (build 1.6.0_29-b11)<br/>Java HotSpot(TM) 64-Bit Server VM (build 20.4-b02, mixed mode)</span></pre><h1 id="8758" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.2开发RMI服务器程序</h1><p id="eaa4" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated"><strong class="kb ir">定义远程接口</strong></p><p id="c2b7" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">RMI应用程序应该从扩展RMI定义的远程接口的远程接口开始。可以远程调用的远程对象的方法必须在接口中指定。接口中的每个方法都必须声明为抛出RemoteException，以解决远程方法调用期间的错误。</p><p id="6d2a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在这种情况下，HelloService接口是在HelloService定义的。</p><p id="dd43" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">HelloService.java</p><pre class="mb mc md me gt my mz na bn nb nc bi"><span id="773e" class="nd ky iq mz b be ne nf l ng nh">package rmi.api;<br/>import java.rmi.*;<br/>​<br/>public interface HelloService extends Remote{<br/>  public String sayHello(String message) throws RemoteException;<br/>}</span></pre><p id="8355" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">RMI服务器和RMI客户机应用程序都包含相同的接口，作为这两方之间通信的契约。</p><p id="2986" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">开发实现类(服务器对象)</strong></p><p id="dd21" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">远程接口提供了特定远程对象的所有方法的描述，接下来的事情是创建该接口的实现，并提供该接口的所有抽象方法的实现。</p><p id="acf2" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">HelloServiceImpl.java</p><pre class="mb mc md me gt my mz na bn nb nc bi"><span id="308e" class="nd ky iq mz b be ne nf l ng nh">package rmi.api.imp;<br/>import java.io.Serializable;<br/>import java.rmi.*;<br/>import java.rmi.server.UnicastRemoteObject;<br/>import rmi.api.HelloService;<br/>​<br/>public class HelloServiceImpl extends UnicastRemoteObject implements HelloService{<br/>​<br/>    private static final long serialVersionUID = 1L;<br/>    public HelloServiceImpl()  throws RemoteException {<br/>      super();<br/>    }<br/>​<br/>    public String sayHello(String message) throws RemoteException {<br/>      System.out.println("It is from serve, the message received from the client is " + message);<br/>      return message;<br/>    }<br/>}</span></pre><p id="083e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">HelloServiceImpl扩展了<code class="fe ni nj nk mz b">java.rmi.server.UnicastRemoteObject</code>，这意味着当你的对象被构造时，会调用<code class="fe ni nj nk mz b">UnicastRemoteObject</code>构造函数。这将对象挂接到处理套接字监听和远程方法调度的RMI内部基础设施。换句话说，它“导出”了HelloServiceImpl对象。</p><p id="a3a9" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">创建RMI服务器</strong></p><p id="4cb2" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在RMI服务器上，RMI server是在RmiServer.java中实现的。</p><p id="2c7a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">RmiServer.java</p><pre class="mb mc md me gt my mz na bn nb nc bi"><span id="0c53" class="nd ky iq mz b be ne nf l ng nh">package rmi.server;<br/>import java.rmi.*;<br/>import java.rmi.registry.LocateRegistry;<br/>import rmi.api.imp.HelloServiceImpl;<br/><br/>public class RmiServer {<br/>  public static void main(String[] args) {<br/>    try {<br/>      System.out.println("RMI Server Starts...");<br/>        //This creates a registry local to the RMI server.<br/>      LocateRegistry.createRegistry(8888);<br/>      <br/>        //create a stub of the remote object<br/>      HelloServiceImpl hImpl = new HelloServiceImpl();<br/>      System.out.println("Bind the hImpl to helloService");<br/>        <br/>       //This command bind our stub to a unique key helloService, As a result, the remote object is now available to any client that can locate the registry.<br/>      Naming.bind("rmi://localhost:8888/helloService", hImpl);<br/>​<br/>      System.out.println("Waiting to be invoked by Client...");<br/>      Thread.sleep(10000000);<br/>      System.out.println("RMI Server Stops");<br/>    } catch (Exception e) {<br/>      System.out.println("error: " + e);<br/>    }<br/>  }<br/>}</span></pre><p id="b4e6" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">编译代码</strong></p><p id="0d41" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">上述源代码文件放在下面的布局中，供您参考。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/98c6e818f8409c685234b1dfc17fda59.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*9q65uWzwxlptFCSLYU5-mQ.png"/></div></figure><p id="0d27" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在RMI服务器上，编译java文件并在rmi-server目录下执行。</p><pre class="mb mc md me gt my mz na bn nb nc bi"><span id="58f6" class="nd ky iq mz b be ne nf l ng nh">[root@demo rmi-server]# javac rmi/server/RmiServer.java <br/>​<br/>[root@demo rmi-server]# java rmi/server/RmiServer<br/>RMI Server Starts...<br/>Bind the hImpl to helloService<br/>Waiting to be invoked by Client...</span></pre><p id="f4ce" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在，RMI服务器正在等待来自RMI客户机的任何远程调用请求。</p><h1 id="4335" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.3开发RMI客户端程序</h1><p id="8f75" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">假设您已经按照2.1中的说明在客户机服务器上安装了Java SE Runtime Environment 1 . 6 . 0 _ 29(6u 29)，唯一需要做的就是定义与RMI服务器上相同的远程接口，并创建RMI客户机程序。</p><p id="8431" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">定义远程接口</strong></p><p id="3f12" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">该接口应该与RMI服务器中指定的包路径相同，否则当RMI客户机试图调用远程服务器对象上的方法时，您将遇到“no security manager:RMI class loader disabled”错误。</p><p id="8b33" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">HelloService.java</p><pre class="mb mc md me gt my mz na bn nb nc bi"><span id="f1a9" class="nd ky iq mz b be ne nf l ng nh">package rmi.api;<br/>import java.rmi.*;<br/>​<br/>public interface HelloService extends Remote{<br/>  public String sayHello(String message) throws RemoteException;<br/>}</span></pre><p id="c2d2" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><strong class="kb ir">创建RMI客户端</strong></p><p id="1848" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在RMI客户机上，RMI客户机是通过RmiServer.java创建的。</p><p id="5824" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">RmiClient.java</p><pre class="mb mc md me gt my mz na bn nb nc bi"><span id="bb54" class="nd ky iq mz b be ne nf l ng nh">package rmi.client;<br/>import java.rmi.*;<br/>import java.util.Arrays;<br/>import rmi.api.HelloService;<br/>​<br/>public class RmiClient {<br/>  public static void main(String[] args) {<br/>    String host = "localhost:8888";<br/>    if (args.length &gt; 0)<br/>      host = args[0];<br/>    try {<br/>      String names[]=Naming.list("rmi://" + host + "/helloService");<br/>      System.out.println("I am client, it is service list: "+Arrays.asList(names));<br/>​<br/>      HelloService h = (HelloService) Naming.lookup("rmi://" + host + "/helloService");<br/>​<br/>      System.out.println("It is on client, the result from server is "+h.sayHello("John"));<br/>    } catch (Exception ex) {<br/>      System.out.println("error: " + ex);<br/>    }<br/>  }<br/>}</span></pre><p id="fedb" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">以上源代码文件存储在以下结构中，供您参考。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/84c80c1172d48269727a0cb4af759c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*ssWX0oQFoH7q_gD4THGggQ.png"/></div></figure><p id="16f8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在RMI客户机服务器上，编译java文件并在rmi-client目录下执行它。</p><p id="ea84" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">因为您已经将RMI服务器和客户机放在不同的服务器上，所以当启动RMI客户机时，RMI服务器的IP(在本演示中，192.168.0.95是RMI服务器的IP)应该作为一个参数提供。</p><pre class="mb mc md me gt my mz na bn nb nc bi"><span id="d932" class="nd ky iq mz b be ne nf l ng nh">[root@demo rmi-client]# javac rmi/client/RmiClient.java <br/>​<br/>[root@demo rmi-client]# java rmi/client/RmiClient 192.168.0.95:8888<br/>I am client, it is service list: [//192.168.0.95:8888/helloService]<br/>It is on client, the result from server is John<br/>[root@demo rmi-client]#</span></pre><p id="d2c7" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">RMI服务器接收来自RMI客户端的方法调用，控制台如下所示:</p><pre class="mb mc md me gt my mz na bn nb nc bi"><span id="f468" class="nd ky iq mz b be ne nf l ng nh">[root@demo rmi-server]# java rmi/server/RmiServer<br/>RMI Server Starts...<br/>Bind the hImpl to helloService<br/>Waiting to be invoked by Client...<br/>It is from serve, the message received from the client is John</span></pre><p id="9eb5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">观察到在RMI服务器上执行了<strong class="kb ir"> sayHello </strong>方法，结果被发送到客户端。</p><p id="8078" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">源代码可以从<a class="ae jy" href="https://github.com/zer0-map/JNDI-Injection-Series/tree/main/RMIVector" rel="noopener ugc nofollow" target="_blank"> github </a>获得。</p><p id="30be" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">参考:</p><p id="1eb7" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><a class="ae jy" href="https://www.baeldung.com/java-rmi" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-rmi</a></p><p id="0082" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">https://paper.seebug.org/1091/</p><h1 id="0938" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">最后的想法</h1><p id="6c3a" class="pw-post-body-paragraph jz ka iq kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ij bi translated">如果您有任何问题或反馈，请随时发表评论。如果你认为这篇博文有帮助，请点击拍手👏按钮下面几下，以示支持！</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h2 id="1ec0" class="nu ky iq bd kz nv nw dn ld nx ny dp lh kk nz oa ll ko ob oc lp ks od oe lt of bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae jy" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4条线索、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>