<html>
<head>
<title>Hacking HTTP CORS from inside out: a theory to practice approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从内向外入侵HTTP CORS:从理论到实践的方法</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/hacking-http-cors-from-inside-out-512cb125c528?source=collection_archive---------0-----------------------#2020-10-14">https://infosecwriteups.com/hacking-http-cors-from-inside-out-512cb125c528?source=collection_archive---------0-----------------------#2020-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="365d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">序</h1><p id="9b2e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">嗨，你好。希望你们都很好。今天，我们将剖析一些web应用程序安全控制。</p><p id="6a39" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">所以，如果你曾经想知道HTTP <strong class="kn ir"> CORS ( <em class="lo">跨源资源共享</em> ) </strong>的内部工作原理，或者以前从未听说过它，但觉得它像一个至关重要的web应用程序概念需要掌握。不管是哪种情况，喝杯咖啡，就像在自己家一样。</p><p id="6090" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在下一节中，我们将深入探讨浏览器和服务器如何处理CORS规则。通过使用理论和实践的方法，我希望为您带来一些启示，让您了解应该如何安全地配置web资源以使其可信。</p><p id="3286" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">概括地说，我们将涵盖以下主题:</p><ul class=""><li id="cd06" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated">HTTP CORS基础考虑<em class="lo">简单与预检</em> HTTP请求、同源策略、CORS标准报头、错误配置等。；</li><li id="5deb" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">深入到一个基于Docker的容器化环境中，您可以分析应用程序源代码，并将其与预期行为进行比较；</li><li id="9ccc" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">CORS规则如何应用于不同的JavaScript API实现(XHR和Fetch)；</li><li id="d08c" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">通过练习示例场景理解HTTP请求-响应循环；</li><li id="5ddd" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">如何使用手动代理拦截工具绕过CORS保护的资源；</li><li id="d352" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">介绍API automation CORS相关项目和其他有用的信息来源。</li></ul><h1 id="c434" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">重要的事情先来</h1><h1 id="4321" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">同源政策(SOP)</h1><p id="0cff" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在讨论CORS事件之前，有必要理解网络资源访问保护的基本概念。我说的是<strong class="kn ir"> <em class="lo">同源政策</em> </strong>，也就是俗称的SOP的缩写。</p><p id="210f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">早在1995年由Netscape建立的SOP概念现在已经在所有主流的web浏览器中发布。</p><p id="1d59" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">为了避免外部方对资源的未授权使用，浏览器依靠基于来源的限制策略。形式上，所述外部方通过它们的来源(域)来识别，并通过URL来访问。</p><p id="7938" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">由给定的<strong class="kn ir">来源A </strong>持有的文档只能被来自相同<strong class="kn ir">来源A </strong>的其他文档访问。如果SOP有效到位，则此规则有效(取决于浏览器实现)。该策略旨在减少潜在攻击媒介的机会。</p><p id="9c8d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">但是让我们来描述一下起源是什么样子的。一个原点可以理解为元组:</p><ul class=""><li id="5dd4" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated"><strong class="kn ir"> &lt;模式(或协议)&gt; </strong> — <strong class="kn ir"> &lt;主机名&gt; </strong> — <strong class="kn ir"> &lt;端口&gt; </strong></li></ul><p id="a666" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">因此，只有当两个URL共享相同的元组时，它们才表示相同的来源。URL`<strong class="kn ir"><em class="lo">http://hacking.cors.com/mr_robots.txt</em></strong>的来源变化和类别的示例:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi me"><img src="../Images/0a7469a392a4562fa42bc13b8df79d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*zj6HKCKg3YRlF8k7vvnA9g.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">领域类型分化</figcaption></figure><p id="d413" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">此外，请记住，SOP允许使用GET和POST方法的跨来源HTTP请求。但是它禁止起源间的上传和删除。除此之外，只允许在跨源请求的上下文中发送自定义HTTP头，拒绝外国人<a class="ae md" href="https://www.w3.org/Security/wiki/Same_Origin_Policy#Details" rel="noopener ugc nofollow" target="_blank">【2】</a>。</p><h1 id="1fa9" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">SOP差异</h1><p id="ad1f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有一些不同类型的<em class="lo">同源政策</em>。在实践中，如果技术到位，它们是在特定规则下应用的。</p><p id="b07c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">制定的主要SOP政策是针对<strong class="kn ir"> DOM(文档对象模型)访问</strong>。它是一种处理JavaScript和其他脚本语言跨域访问DOM属性和方法的能力的机制。</p><p id="f5d1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir"> DOM访问</strong>主要基于`<em class="lo">document . domain</em>`<strong class="kn ir">DOM</strong>的属性状态。但是对于不考虑`<em class="lo"> document.domain </em>`属性的<strong class="kn ir"> JavaScript的XMLHttpRequest API，</strong>来说，这是无效的。目前，不要太担心这些细节。我们应该很快回到这个话题。</p><p id="08f1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">因此，如果我们把SOP作为一个沙箱概念，那么为其他web技术提供相同来源的实现就变得合理了。<strong class="kn ir"> <em class="lo"> cookies、Java、old-R.I.P Flash </em> </strong>的情况，以及它们各自的SOP策略特性。</p><h1 id="0bd1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">HTTP CORS基础</h1><p id="7494" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">SOP技术无疑是朝着更安全的web应用程序迈出的一大步。但是默认情况下，它会应用拒绝规则。</p><p id="d8a9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">万维网的真正本质是网页可以通过网络与其他资源进行交流。Web应用程序意味着访问外部资源。</p><p id="57cf" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">那么我们如何在保持受限资源安全访问的同时，放宽同源规则呢？你猜对了:<strong class="kn ir"> CORS </strong>。</p><p id="deca" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">简单来说，<strong class="kn ir"> <em class="lo">跨源资源共享</em> </strong>允许特定域/源的页面消耗另一个域/源的资源。同意谁可以访问资源是资源所有者(服务器)的责任。</p><p id="795b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">浏览器-服务器信任关系通过一系列<em class="lo"> CORS HTTP报头</em><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS" rel="noopener ugc nofollow" target="_blank"><em class="lo">【3】</em></a>形成。在一般情况下，它们被资源的web服务器(如Nginx、Apache、IIS等)添加到HTTP请求和响应中。)，通过应用程序或浏览器。然后，CORS报头指示请求浏览器是否信任来源，并继续进行响应处理。</p><p id="9f6a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">让我们在这里喘口气。请注意，浏览器完全信任从服务器返回的响应。请记住这一点。</p><h1 id="5965" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">简单的请求</h1><p id="70bf" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">与飞行前请求相比，有一些简单的请求。<strong class="kn ir"> <em class="lo">简单要求</em> </strong>是尊重以下条件的人:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi me"><img src="../Images/f9fdce23e86408fc2a70d0e7c770acc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*9EzxYcrn8c9ZiHEfPjWNSQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">简单请求组合</figcaption></figure><p id="09fa" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在进行异步HTTP请求时，我们经常使用已经呈现的<strong class="kn ir">XMLHttpRequest</strong><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank">【5】</a>或者新的<strong class="kn ir">Fetch</strong><a class="ae md" href="https://fetch.spec.whatwg.org/" rel="noopener ugc nofollow" target="_blank">【6】</a>JavaScript API。</p><h1 id="ec8c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">飞行前HTTP请求</h1><p id="4cea" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有时浏览器会发出一个<strong class="kn ir"> <em class="lo">预检HTTP请求</em> </strong>。它打算向服务器查询它授权和支持哪些CORS属性。然而，这并没有改变服务器和浏览器之间的信任关系。</p><p id="8564" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">预检HTTP请求(采用<strong class="kn ir"> <em class="lo"> HTTP选项请求</em> </strong>的形式)产生同样可信的HTTP响应。唯一的区别在于头，它指示浏览器如何继续获取预期的跨源资源。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/068554d58f3793705f12ecf531629f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9CZmsSo4w5VBzBFt"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><em class="mv">从</em><strong class="bd jp"><em class="mv">api.domain.org</em></strong>中删除<strong class="bd jp"><em class="mv">avatar.org</em></strong><em class="mv">资源的预请求航班流程</em></figcaption></figure><p id="7175" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">当我们转到本文的实践部分时，这将变得更加令人愉快。</p><h1 id="625d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">CORS基本标题</h1><p id="5d14" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">通过CORS实现原产地控制涉及以下标题系列:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/254396a1bc00e2ef960e15f40641f7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*tgLKBLQ6XAtcLIFREtZmZw.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">CORS标头系列及其各自的HTTP类型</figcaption></figure><p id="4858" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在用于预检的HTTP<strong class="kn ir"><em class="lo">栏标有<strong class="kn ir">是</strong>的标题起到重要的预检功能。</em></strong></p><p id="c8aa" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">它从指明允许哪些特定的头(<strong class="kn ir"> <em class="lo">访问控制允许头</em> </strong>)和HTTP方法(<strong class="kn ir"> <em class="lo">访问控制允许方法</em> </strong>)，浏览器应该缓存预检请求的最大秒数(<strong class="kn ir"> <em class="lo">访问控制最大年龄</em> </strong>)，请求源(<strong class="kn ir"> <em class="lo">来源</em> </strong>)，到允许量(<strong class="kn ir"> <em class="lo">访问</em></strong></p><p id="b5f4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在整个上下文中，<strong class="kn ir">访问控制允许起源(ACAO) </strong>是关于跨起源授权的最相关的报头。通过这个头，服务器能够告诉浏览器它应该信任哪些域。</p><p id="e9f4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">然而，这种强大的力量伴随着重大的责任。</p><h1 id="98df" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">允许太多一点也不酷</h1><p id="2944" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们很清楚，CORS是推广SOP政策的有效途径。然而，我们应该考虑完全非限制性规则的影响。让我们以下面的陈述为例:</p><ul class=""><li id="b44b" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated"><strong class="kn ir">访问控制允许来源:* </strong></li></ul><p id="3452" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">上面的头意味着每个源都可以访问所需的资源。这相当于在SOP出现之前旧浏览器的早期配置。但是要注意故事的另一面，正如应用程序安全文献所谨慎描述的那样。</p><blockquote class="mx my mz"><p id="8179" class="kl km lo kn b ko lj kq kr ks lk ku kv na ll ky kz nb lm lc ld nc ln lg lh li ij bi translated"><em class="iq">“显然，在某些情况下，访问控制允许来源</em> <strong class="kn ir"> <em class="iq">的通配符值不是不安全的</em> </strong> <em class="iq">。例如，如果许可策略仅用于提供</em> <strong class="kn ir"> <em class="iq">不包含</em> </strong> <em class="iq">敏感信息的内容。”</em></p><p id="84ca" class="kl km lo kn b ko lj kq kr ks lk ku kv na ll ky kz nb lm lc ld nc ln lg lh li ij bi translated"><em class="iq">浏览器黑客手册第二版。—第四章绕过同源政策</em></p></blockquote><p id="ad1c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">但是，您应该小心使用通配符。事实上，推荐的方法是明确授权来源的访问权限。如果服务器不提供任何CORS报头，浏览器将采取<strong class="kn ir"> <em class="lo">同源策略(SOP) </em> </strong>的姿态。</p><h1 id="a96f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">基于Docker的提议场景</h1><p id="6f50" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，让我们克隆`<strong class="kn ir">hacking-CORS</strong>`<a class="ae md" href="https://github.com/lvrosa/hacking-cors" rel="noopener ugc nofollow" target="_blank">【7】</a>库，这样我们就可以开始这个聚会了！</p><ul class=""><li id="fc2d" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated">$ git clone git @ github . com:LV Rosa/hacking-CORS . git</li></ul><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/99ebd213854b2ff4b10604bdc6750da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/0*KvTctQkLweLQfYTj"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><em class="mv">hacking-CORS docker项目的树形目录表示</em></figcaption></figure><p id="bade" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">上面的结构分解了组成服务器映像的docker容器和文件。</p><p id="26ae" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">`<strong class="kn ir"> node_modules </strong>目录(从上面的`<strong class="kn ir">树</strong>命令输出中省略)也被推送到`<strong class="kn ir"> hacking-cors </strong>库。它的尺寸很小。但是，如果您有任何关于JavaScript依赖的问题，请运行项目根目录下的“NPM”<a class="ae md" href="https://www.npmjs.com/get-npm" rel="noopener ugc nofollow" target="_blank">【8】</a>工具。</p><ul class=""><li id="b4ec" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated">$ CD hacking-CORS；npm安装</li></ul><p id="f6b4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在你的系统上安装`<strong class="kn ir">docker</strong>`<a class="ae md" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">【9】</a>和`<strong class="kn ir">docker-compose</strong>`<a class="ae md" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank">【10】</a>也是至关重要的。docker-compose文件使用版本3格式。我的两个依赖项的当前版本是:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/64293692b23989e6b851a238d46e0562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/0*Qvcgo-fa95YjVp_G"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><em class="mv"> Docker和Docker组成版本</em></figcaption></figure><h1 id="f9d6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">项目结构</h1><p id="5d1d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们有两个不同的docker项目。它们由根目录下各自的配置文件<strong class="kn ir">表示。</strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/45d2b74d988336f44885d64706cfd24e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*rhLfU0SXzYidnD81P_7MaQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">每个web服务器各自的Docker文件</figcaption></figure><p id="a74d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">有趣的文件在`<strong class="kn ir">静态`</strong>和`<strong class="kn ir"> img` </strong>目录下。它们拥有最终会被其他网页请求的资源。JavaScript文件在`<strong class="kn ir"> static` </strong>目录下。您可以在您最喜欢的代码编辑器中打开它们并进行试验。</p><p id="8cb6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">来自<strong class="kn ir"> <em class="lo">可信站点</em> </strong>的`<strong class="kn ir"> img` </strong>目录存储了`<strong class="kn ir"> owasp_bug.png` </strong>资源。在我们的实验中，这个图像资源将由<strong class="kn ir"> <em class="lo">邪恶站点、</em> </strong>请求，然后尝试加载它。这同样适用于`<strong class="kn ir">static/hello _ script . js `</strong>文件，但是要执行/评估脚本内容，而不是加载图像。</p><h1 id="bbff" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Docker图像和网络设置概述</h1><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/d1574914010c8ce5b26fe6b7b09d5bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/0*UsBn9vTzlncv6ZI9"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><em class="mv"> docker-compose.yml内容</em></figcaption></figure><p id="fc2f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">看看上面的`<strong class="kn ir"> docker-compose.yml` </strong>文件。我们可以识别关于环境的重要事物，例如:</p><ul class=""><li id="8d60" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated">我们将创建两个容器(即`<strong class="kn ir"> evil_site` </strong>和`<strong class="kn ir"> trusted_site` </strong>)</li><li id="9b98" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">容器被附加到“<strong class="kn ir"> cors_hack_net </strong>”桥接网络接口</li><li id="7363" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">“<strong class="kn ir"> cors_hack_net </strong>”接口通过<strong class="kn ir"> CIDR 10.5.0.0/16 </strong>确定子网</li></ul><p id="59d0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">作为到容器网络地址的有用链接，我建议将主机名文件 (` <strong class="kn ir"> /etc/hosts </strong>`)的<em class="lo">静态查找表设置为以下设置:</em></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/226f494382b4bd00e842f4462ea452e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/0*Rojj1rJ_tasNTWqg"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><em class="mv"> /etc/hosts文件映射</em></figcaption></figure><h1 id="de41" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Apache服务器CORS规则一瞥</h1><p id="c8a7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">★识别<strong class="kn ir">可信站点</strong>容器的名称:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ni"><img src="../Images/e15175b082c720819a393b3cc9344960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/0*8H637WHubCaU4JBs"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">docker-撰写ps输出</figcaption></figure><p id="c80a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★登录容器:</p><ul class=""><li id="7a7e" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated">$ docker exec-it<strong class="kn ir">trusted _ site</strong>/bin/bash</li></ul><p id="4373" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★甩掉阿帕奇`。<strong class="kn ir"> htaccess` </strong>配置文件到屏幕:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/7ff20240744decdb02e87b6b61a6eb21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/0*MPIsycKL6vIaYlO9"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><em class="mv">。htaccess Apache CORS扩展规则</em></figcaption></figure><p id="09f1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如上图中突出显示的，当文件匹配规则适用时，<em class="lo"> Apache Web服务器</em>将提供<strong class="kn ir"> ACAO(访问控制允许来源)</strong>头。换句话说，如果网络浏览器请求图像(<strong class="kn ir">)。gif，。png，。ico </strong>等。)甚至一个JavaScript <strong class="kn ir">。js </strong>文件，资源的内容只有在来源与`<a class="ae md" href="http://trustedsite.com" rel="noopener ugc nofollow" target="_blank">http://trustedsite.com</a>匹配的情况下才被授权由页面加载/使用。</p><p id="5dec" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">注意`<strong class="kn ir">。htaccess </strong>文件来源于`<strong class="kn ir"> htdocs </strong>目录，因此影响其子结构下的所有文件。</p><h1 id="0294" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">运行集装箱化环境</h1><p id="f90d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要激活这些环境，请执行以下步骤:</p><p id="4d96" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★从根项目目录构建容器</p><ul class=""><li id="1c85" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated">$ docker-compose build —无缓存；(注意无缓存参数前的双减号)</li></ul><p id="d8da" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★通过“docker-compose”整理容器</p><ul class=""><li id="5dcc" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated">$ docker-撰写</li></ul><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nk"><img src="../Images/3fad76b779bdc177420833b842b0f6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UQgjrrZ2_-DdLbxj"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">docker-合成输出</figcaption></figure><p id="af00" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果您在docker环境中遇到任何问题，我建议您通过杀死和删除当前活动的docker映像来清理它。只要确保没有其他容器应该在被杀死之前保存它们的状态。</p><ul class=""><li id="6ab1" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated">$ docker kill $(docker ps -a -q)</li><li id="1409" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">$ docker rm $(docker ps -a -q)</li></ul><p id="e72b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">嗯，我希望到目前为止一切都好。让我们看一下创建的两个web服务器。打开浏览器，驱车前往`【http://trustedsite.com】的`<a class="ae md" href="http://trustedsite.com" rel="noopener ugc nofollow" target="_blank">和`</a><a class="ae md" href="http://evilsite.com" rel="noopener ugc nofollow" target="_blank">的http://evilsite.com</a>`。</p><h2 id="cdce" class="nl jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">可信站点</h2><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nx"><img src="../Images/3e121f4d2cf6b47d32ba7eb6438b135a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6YbCYaPb7so6iutE"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">受信任的站点Web服务器菜单</figcaption></figure><h2 id="6248" class="nl jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">邪恶网站</h2><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ny"><img src="../Images/2276fd45a02c47d3ff70e94f4a6d36bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*omcGP-PUR8J2tPZz"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">邪恶网站Web服务器菜单</figcaption></figure><h1 id="ce12" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用XHR和获取请求玩CORS规则</h1><h1 id="9ace" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">XHR请求的CORS规则</h1><p id="7efb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir"> XMLHttpRequest标准</strong><a class="ae md" href="https://xhr.spec.whatwg.org/" rel="noopener ugc nofollow" target="_blank">【11】</a>定义了一个API，它提供脚本化的客户端功能，用于在<strong class="kn ir">客户端</strong>和<strong class="kn ir">服务器</strong>之间传输数据。</p><p id="5026" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">关于其安全方面，我们应该注意一些警告事实，如<strong class="kn ir">浏览器安全手册，第2部分</strong><a class="ae md" href="https://code.google.com/archive/p/browsersec/wikis/Part2.wiki" rel="noopener ugc nofollow" target="_blank">【12】</a>所述。</p><blockquote class="mx my mz"><p id="db25" class="kl km lo kn b ko lj kq kr ks lk ku kv na ll ky kz nb lm lc ld nc ln lg lh li ij bi translated"><em class="iq">“XMLHttpRequest提供的、在其他浏览器机制中看不到的一组安全相关特性如下:</em></p></blockquote><ul class=""><li id="7261" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated"><em class="lo">指定任意HTTP请求方法的能力(通过</em><strong class="kn ir"><em class="lo">open()</em></strong><em class="lo">方法)、</em></li><li id="d91a" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated"><em class="lo">在请求上设置自定义HTTP头的能力(通过</em><strong class="kn ir"><em class="lo">setRequestHeader()</em></strong><em class="lo">)，</em></li><li id="7222" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated"><em class="lo">回读完整响应头的能力(通过</em><strong class="kn ir"><em class="lo">getResponseHeader()</em></strong><em class="lo">和</em><strong class="kn ir"><em class="lo">getAllResponseHeaders()</em></strong><em class="lo">)，</em></li></ul><blockquote class="mx my mz"><p id="b729" class="kl km lo kn b ko lj kq kr ks lk ku kv na ll ky kz nb lm lc ld nc ln lg lh li ij bi translated"><em class="iq">能够以JavaScript字符串的形式读回完整的响应正文(通过</em><strong class="kn ir"><em class="iq">responseText</em></strong><em class="iq">属性)。</em></p><p id="0166" class="kl km lo kn b ko lj kq kr ks lk ku kv na ll ky kz nb lm lc ld nc ln lg lh li ij bi translated"><em class="iq">由于通过XMLHttpRequest发送的所有请求都包含一组由浏览器维护的目标站点的cookies，并且该机制提供了比脚本可用的任何其他功能更强大的与服务器端组件交互的能力，</em> <strong class="kn ir"> <em class="iq">建立适当的安全控制极其重要。”</em> </strong></p></blockquote><p id="0caf" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在处理XHR请求时，必须遵守以下防止篡改来源的浏览器保护措施。</p><ul class=""><li id="298b" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated">当试图通过<strong class="kn ir"> setRequestHeader()对`<strong class="kn ir"> origin </strong>`标头进行<strong class="kn ir">更改/毒化</strong>时，原始标头将被保留。</strong></li><li id="c196" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">当试图<strong class="kn ir">改变/毒化</strong>附加头(作为参数传递给<strong class="kn ir"> xhr.send() </strong>)时，<strong class="kn ir">原始头被保留。</strong></li></ul><h1 id="9562" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">提取请求的CORS规则</h1><blockquote class="mx my mz"><p id="1617" class="kl km lo kn b ko lj kq kr ks lk ku kv na ll ky kz nb lm lc ld nc ln lg lh li ij bi translated">"<em class="iq">许多API提供了获取资源的能力，例如</em> <strong class="kn ir"> <em class="iq"> HTML的img </em> </strong> <em class="iq">和</em> <strong class="kn ir"> <em class="iq">脚本</em> </strong> <em class="iq"> </em> <strong class="kn ir"> <em class="iq">元素</em> </strong> <em class="iq">，</em> <strong class="kn ir"> <em class="iq"> CSS的光标</em> </strong> <em class="iq">和</em> <strong class="kn ir"> <em class="iq">列表样式-图像</em> <strong class="kn ir"> <em class="iq">抓取标准</em> </strong> <em class="iq">为这些特性提供了一个统一的架构，因此它们在抓取的各个方面都是一致的，比如重定向和</em><strong class="kn ir"><em class="iq">CORS</em></strong><em class="iq">协议。</em>——<a class="ae md" href="https://fetch.spec.whatwg.org/" rel="noopener ugc nofollow" target="_blank">https://fetch.spec.whatwg.org/</a></strong></p></blockquote><p id="b08c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">尽管<em class="lo">获取标准</em>取代了“origin”元素语义(最初在<strong class="kn ir">Web Origin概念</strong><a class="ae md" href="https://tools.ietf.org/html/rfc6454" rel="noopener ugc nofollow" target="_blank">【13】</a>—<em class="lo">RFC 6454</em>中定义)，XHR篡改保护的相同效果也适用于此。</p><ul class=""><li id="fbf8" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated">当试图通过<strong class="kn ir"> fetch() </strong>参数<strong class="kn ir">改变/毒化</strong>原始<strong class="kn ir">头时，<strong class="kn ir">原始头被保留。</strong></strong></li></ul><h1 id="8be5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">在实践中理解请求周期</h1><p id="561f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">既然你已经知道了<strong class="kn ir"> SOP、CORS、XHR </strong>和<strong class="kn ir"> Fetch </strong>请求的基本原理，我们就可以开始玩提议的场景了。</p><p id="2960" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">可信站点</strong>和<strong class="kn ir">邪恶站点</strong>页面都有类似的菜单。首先，尝试<strong class="kn ir">可信站点</strong>的四个请求选项。</p><p id="785b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">注意，请求的资源，<strong class="kn ir"> <em class="lo"> OWASP bug镜像</em> </strong>或者显示<strong class="kn ir"> <em class="lo">你的所有base都属于我们的脚本；D </em> </strong>”，被页面成功加载和消费。这是属于同一个域的一个页面调用本地资源的典型例子。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/e671bb188ff06fe557c31e88247e6455.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/0*Nx9KI78YER8jrhVc"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><em class="mv">hello _ script . js的内容在一个相同的域页面请求后执行</em></figcaption></figure><p id="87ed" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，让我们将范围更改为<strong class="kn ir">邪恶站点</strong>。</p><ol class=""><li id="6afb" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li oa lv lw lx bi translated">打开`<a class="ae md" href="http://evilsite.com" rel="noopener ugc nofollow" target="_blank">http://evilsite.com</a>网站</li><li id="7918" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li oa lv lw lx bi translated">调出<strong class="kn ir"> Web开发者工具</strong>窗口(在Firefox或Chrome中按<strong class="kn ir"> F12 </strong></li><li id="4949" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li oa lv lw lx bi translated">点击与<strong class="kn ir"> OWASP图像+ JavaScript XHR </strong>相关联的锚链接</li><li id="268a" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li oa lv lw lx bi translated">点击与<strong class="kn ir">警报脚本+ JavaScript提取</strong>关联的锚链接</li></ol><p id="cbee" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">从<strong class="kn ir"> Web Developer Tools </strong>中获得控制台选项卡上的焦点。我们应该看到类似下面的屏幕。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ob"><img src="../Images/fd9189590b25b87ce446d2ca4ee67aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YJNGyvmi1zq2s2pf"/></div></div></figure><p id="cbaf" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">第三和第四步从上面的屏幕生成消息。为了便于阅读，将它们抄录如下。</p><blockquote class="mx my mz"><p id="5212" class="kl km lo kn b ko lj kq kr ks lk ku kv na ll ky kz nb lm lc ld nc ln lg lh li ij bi translated"><strong class="kn ir">跨来源请求受阻</strong>:同一来源策略不允许在<a class="ae md" href="http://trustedsite.com/img/owasp_bug.png." rel="noopener ugc nofollow" target="_blank"><strong class="kn ir">http://trustedsite.com/img/owasp_bug.png</strong>读取远程资源。</a>(原因:CORS表头【访问控制-允许-来源】与<a class="ae md" href="http://trustedsite.com" rel="noopener ugc nofollow" target="_blank">http://trustedsite.com</a>不匹配)。</p><p id="77bc" class="kl km lo kn b ko lj kq kr ks lk ku kv na ll ky kz nb lm lc ld nc ln lg lh li ij bi translated"><strong class="kn ir">跨源请求受阻</strong>:同源策略不允许读取<a class="ae md" href="http://trustedsite.com/static/hello_script.js." rel="noopener ugc nofollow" target="_blank"><strong class="kn ir">http://trustedsite.com/static/hello_script.js</strong>的远程资源。</a>(原因:CORS表头【访问控制-允许-来源】与<a class="ae md" href="http://trustedsite.com" rel="noopener ugc nofollow" target="_blank">http://trustedsite.com</a>’不匹配)。</p></blockquote><p id="341e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">从这里，可以理解为什么浏览器禁止了请求的资源。还记得<strong class="kn ir">阿帕奇服务器吗。htaccess </strong>配置，它将<strong class="kn ir">ACAO(Access-Control-Allow-Origin)</strong>CORS报头添加到特定的HTTP响应(图像文件和<strong class="kn ir">)。js </strong>脚本)。</p><p id="b8fd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，我们将更详细地研究这些请求。从<strong class="kn ir"> Web开发者工具</strong>中点击<strong class="kn ir">网络</strong>标签。然后，选择`<strong class="kn ir"> hello_script.js </strong>`资源的<strong class="kn ir">选项</strong>请求。在屏幕的右侧，您应该会看到下面的HTTP请求和响应。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/53fc79fb7c47b46f688df6fd8723ed96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/0*UAvaat5BKGYeiEdZ"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><em class="mv">选项hello_script.js资源的HTTP请求和响应</em></figcaption></figure><p id="76ca" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">注意上方的`<strong class="kn ir">原点</strong>'标题。上面写着“http://evilsite.com”。但是如果我们深入到邪恶站点的“<strong class="kn ir"> script_fetch.js </strong>”实现中，关于“<strong class="kn ir"> Origin </strong>”头的一些东西就很突出了。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi od"><img src="../Images/f405b1223f434312e045bcd5236c7bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/0*MPPcUg2plhAvpW6Q"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><em class="mv">`</em><strong class="bd jp"><em class="mv">evil _ site _ public _ html/static/script _ fetch . js</em></strong><em class="mv">` content</em></figcaption></figure><p id="f11b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">尽管我们试图将`<strong class="kn ir"> Origin </strong>`头(第7行)与<strong class="kn ir">可信站点</strong>的域`<a class="ae md" href="http://trustedite.com" rel="noopener ugc nofollow" target="_blank">http://trustedite.com</a>的授权地址重叠，但浏览器实现的Fetch API阻止了这一点。</p><p id="06ee" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这就是为什么我们在<strong class="kn ir"> Web Developer Tools的“网络</strong>选项卡— HTTP OPTIONS请求”中将“<a class="ae md" href="http://evilsite.com" rel="noopener ugc nofollow" target="_blank">http://evilsite.com</a>”视为“<strong class="kn ir">来源</strong>”。</p><h1 id="5c8d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">通过代理拦截绕过CORS(手动)</h1><p id="be45" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">迄今为止，这是一条漫长的道路。所以如果你是在这里做的，是时候在汤里放点盐了。</p><p id="e4db" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">CORS<strong class="kn ir"/>(以及<em class="lo">CSP——内容安全政策</em>)背后的主要原则是浏览器和web服务器之间基于信任的关系。web服务器指示web浏览器它可以进一步信任哪些域。实际上，HTTP安全头设置了这个指令。</p><p id="bd39" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，让我们从恶意的角度来思考。为了绕过<strong class="kn ir"> CORS </strong>规则，攻击者必须<strong class="kn ir">拦截<strong class="kn ir">服务器的HTTP响应</strong>，其中包含<strong class="kn ir">CORS ACAO(Access-Control-Allow-Origin</strong>)<strong class="kn ir"/>报头。其次是<strong class="kn ir">，</strong>他/她更改其值以反映攻击者的页面来源或允许任意域(使用字符*)。</strong></p><p id="31fe" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">当它被称为<strong class="kn ir"> <em class="lo">【拦截】</em> </strong>时，它可以是一个自动过滤HTTP请求-响应循环的代理服务器(有关这方面的更多信息，请参见下一节)。或者通过像<strong class="kn ir"> Burp Suite </strong>这样的代理工具进行手动操作，就像我们之后要做的那样。</p><h1 id="67a4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">设置史努比代理工具</h1><p id="dd15" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果您已经熟悉了ZAP、Burp Suite之类的代理工具，请随意进入下一部分。这里我们将使用PortSwagger的<strong class="kn ir"> Burp Suite社区</strong><a class="ae md" href="https://portswigger.net/burp/releases/professional-community-2020-9-2" rel="noopener ugc nofollow" target="_blank">【14】</a>。</p><p id="a235" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">根据您的平台/架构安装并运行Burp套件。</p><p id="44b2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★在<strong class="kn ir">选项</strong>页签，编辑<strong class="kn ir">代理监听器</strong>设置的<strong class="kn ir">界面</strong>栏如下("<strong class="kn ir"> 127.0.0.1:10001 </strong>"):</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oe"><img src="../Images/b9dbf0469445d9c2d6dac1dbefb98c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gMvDXNllGvHTeHYV"/></div></div></figure><p id="2720" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★在同一个选项卡上，设置<strong class="kn ir">拦截客户端请求</strong>设置如下:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi of"><img src="../Images/0fa90b1a685bb59fe36b8e2460e3b6ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f65nMVYn6AKZRCrs"/></div></div></figure><p id="8021" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★仍然在<strong class="kn ir">选项</strong>选项卡，设置<strong class="kn ir">拦截服务器响应</strong>设置如下:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi og"><img src="../Images/36fca96da9e997bf2bb904af481a804c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tOizoXyNERD00u71"/></div></div></figure><p id="25c6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★确保<strong class="kn ir">截取</strong>选项卡中的<strong class="kn ir">截取在</strong>按钮上<strong class="kn ir">激活</strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/bb7d6c35aecbaf9ac7b90ab37eb6d9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/0*9tMMwXZcQiaSzRsc"/></div></figure><p id="e91b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">最后，在您的浏览器上，您将配置它通过我们的代理传递请求。请注意，代理正在监听<strong class="kn ir">端口10001。这里我们有两个配置选项。我通常使用<strong class="kn ir"> FoxyProxy </strong>扩展<a class="ae md" href="https://getfoxyproxy.org/" rel="noopener ugc nofollow" target="_blank">【15】</a>来设置我的代理。但是您可以通过浏览器的网络设置<a class="ae md" href="https://support.mozilla.org/en-US/kb/connection-settings-firefox" rel="noopener ugc nofollow" target="_blank">【16】</a>手动完成。</strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/05fdf8c8a62d27fb6bb2de78c6a1559e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/0*yCgRPt-GUjK2oY7s"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><em class="mv">我的火狐的FoxyProxy打嗝代理设置</em></figcaption></figure><p id="4e18" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">好了，就这些。我们准备好出发了。</p><h1 id="e7c4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">通过篡改HTTP响应绕过CORS</h1><p id="ebd8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">★打开<strong class="kn ir">邪恶网站</strong>(`<a class="ae md" href="http://evilsite.com" rel="noopener ugc nofollow" target="_blank"><strong class="kn ir"/></a>`)</p><p id="5246" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如前所述，<strong class="kn ir">邪恶站点</strong>请求的来自<strong class="kn ir">可信站点</strong>的资源没有被授权给相应的页面使用。这是因为<strong class="kn ir"> CORS ACAO(访问控制允许起源)</strong>报头只允许`<a class="ae md" href="http://trustedsite.com" rel="noopener ugc nofollow" target="_blank">http://trustedsite.com</a>域。</p><p id="8fbd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★ <strong class="kn ir">在浏览器上激活</strong>你的打嗝代理</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/ef5d4717ff11cf422ed8e5b9f1d0efc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/0*HBblbnNI6wUEjhGf"/></div></figure><p id="6017" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★点击/请求<strong class="kn ir"> OWASP镜像</strong>资源<strong class="kn ir">通过XHR请求</strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ok"><img src="../Images/4553cfe7ba8376a8daa135b1c39064dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gd5GoLrrMeywtMx4"/></div></div></figure><ol class=""><li id="13c6" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li oa lv lw lx bi translated">停下来，查看与<strong class="kn ir"> HTTP请求</strong>相对应的<strong class="kn ir">打嗝套件对话框</strong></li></ol><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ol"><img src="../Images/cd8e5a234daa0c83cedc96273cdcf24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NUOGhcOm1C4skenP"/></div></div></figure><p id="9e75" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★点击“<strong class="kn ir">前进</strong>”继续请求，无需进一步编辑</p><p id="452e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★在包含<strong class="kn ir"> CORS报头</strong>的<strong class="kn ir"> HTTP响应</strong>处停止</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi om"><img src="../Images/6ff7ecd3d9c377e557b1dde42415acb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/0*scTInJZfSpPJEVwI"/></div></figure><p id="6381" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★将<strong class="kn ir"> CORS ACAO </strong>表头值编辑为`<strong class="kn ir"> * </strong>'</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi on"><img src="../Images/942e21dd7303f64ec2a4fa6c920af6c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yiNlr2h7rj3t3cvv"/></div></div></figure><p id="5b75" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★ <strong class="kn ir">点击<strong class="kn ir">转发</strong>向浏览器提交</strong>响应</p><p id="bdcc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">★显示受保护的资源(OWASP错误图像)内容(注意没有CORS错误信息):</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oo"><img src="../Images/f6a4fcd0988bee7e74ef1e031bed9906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qRpaKs3zVTyO6riS"/></div></div></figure><h1 id="2acb" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">黑客作业</h1><p id="c89a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在前面的场景中，我们通过Burp代理拦截并篡改了一个JavaScript XHR请求。这种开箱即用方法的一个重要方面是彻底分析HTTP请求-响应周期。哪些标题是必需的，当它们丢失或配置错误时，您在浏览器控制台上得到什么样的错误消息。</p><p id="5e1a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在是时候让你自己运用学到的知识了。下一节还将给出一些关于<strong class="kn ir">警报脚本+ JavaScript FETCH </strong>组合的CORS绕过的提示。</p><p id="a46d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">既然没有限制，你可以尝试绕过<strong class="kn ir">邪恶网站</strong>菜单中的剩余选项。</p><h2 id="2c41" class="nl jo iq bd jp nm nn dn jt no np dp jx kw nq nr kb la ns nt kf le nu nv kj nw bi translated">绕过警报脚本+ JavaScript获取的技巧</h2><p id="cc13" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">除了更改<strong class="kn ir">Access-Control-Allow-Origin</strong>头，您还必须在HTTP OPTIONS请求中添加<strong class="kn ir">Access-Control-Allow-Headers</strong>(使用Burp请求编辑对话框中的add按钮)。</p><p id="48d2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这是必要的，因为客户端(<strong class="kn ir">)。启动XHR请求的js </strong>脚本)默认情况下在后续GET请求中添加头“<strong class="kn ir"> cache-control </strong>和“<strong class="kn ir"> pragma </strong>”。因此，您将希望在<strong class="kn ir"> HTTP OPTIONS响应</strong>中反映这一点。</p><p id="326e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">请记住，这里我们有一个<strong class="kn ir"> HTTP预检</strong>场景(如果有疑问，请查看<em class="lo">预检HTTP请求部分</em>)，其中HTTP选项请求在实际资源检索请求之前。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi op"><img src="../Images/b2bbdfad7bc2c38d1ba982796b11b62f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/0*_gLYQy-CrptUnEux"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><strong class="bd jp"> <em class="mv"> HTTP选项响应</em> </strong> <em class="mv">编辑以反映绕过</em>的CORS报头</figcaption></figure><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/28be8699708cdc9c5200ff2f7d341d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*V-URxmvjcoT-HQBi"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><strong class="bd jp"><em class="mv">HTTP GET response</em></strong><em class="mv">from</em><strong class="bd jp"><em class="mv">` hello _ script . js</em></strong><em class="mv">`资源检索(注意ACAO CORS头文件)</em></figcaption></figure><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi or"><img src="../Images/fc79ae679a35170ddef3af2dd3c067b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VJVL1dpVj1CWKwtC"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><strong class="bd jp"> <em class="mv">成功</em> </strong> <em class="mv"> CORS黑客攻击得到我们上面那个漂亮的对话框</em></figcaption></figure><h1 id="13a1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">自动旁路和其他CORS有趣的项目</h1><p id="24a3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在上一节中，我们看到了如何手动绕过CORS规则保护。然而，从实用的角度来看，这不是很有效。</p><p id="1239" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">自动化绕过过程的一个可行的方法是部署一个代理服务器，如<strong class="kn ir"> CORS任何地方</strong><a class="ae md" href="https://cors-anywhere.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">【17】</a>API。代理服务器将充当中介，过滤请求和响应头，以反映代理配置时指定的允许和拒绝规则。</p><p id="85fb" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">请参考该项目的Github页面<a class="ae md" href="https://github.com/Rob--W/cors-anywhere" rel="noopener ugc nofollow" target="_blank">【18】</a>了解更多细节和设置面向web的代理时的注意事项(朋友，小心开放的代理)。你可以在这里测试一下现场API<a class="ae md" href="https://robwu.nl/cors-anywhere.html" rel="noopener ugc nofollow" target="_blank">【19】</a>。</p><p id="bfcd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">另一个围绕<strong class="kn ir"> CORS </strong>(以及<strong class="kn ir"> <em class="lo"> CSP —内容安全策略</em> </strong>)的奇葩举措，头头的理解是`<strong class="kn ir"> CORS演示</strong>`<a class="ae md" href="https://cors-client.digi.ninja/" rel="noopener ugc nofollow" target="_blank">【20】</a>来自`<strong class="kn ir">digi . ninja</strong>`<a class="ae md" href="https://digi.ninja/blog/cors_demos.php" rel="noopener ugc nofollow" target="_blank">【21】</a>。非常好的概念证明。</p><h1 id="1fc9" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结束语</h1><p id="3e7f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你已经走了这么远，恭喜你。HTTP头本身是一个非常庞大的主题，因为该协议试图发展以接近web应用程序的实际情况。这种现实变得越来越普遍，尤其是随着API通过REST等技术的普及。</p><p id="85c7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">CORS的标题是错综复杂的，充满了细微差别。当实现处理域间通信的解决方案时，要注意可能出现的常见陷阱。来自<strong class="kn ir"> `moesif.com </strong>博客的文章<a class="ae md" href="https://www.moesif.com/blog/technical/cors/Authoritative-Guide-to-CORS-Cross-Origin-Resource-Sharing-for-REST-APIs" rel="noopener ugc nofollow" target="_blank">【22】</a>很好地解释了这一点(以及更多)。</p><p id="47a9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">关于CORS及其弱点的最后一个信息是，浏览器和应用程序之间的信任应该由安全配置明确保证。正确选择部署哪种AJAX方法和CORS头文件将对API的整体安全性产生积极影响。</p><p id="b1f9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">记住我们提出的四种资源消耗场景。它们很简单。事实上，资源共享还有其他选择和组合。但是，也许(我希望我们已经达到了这一步)这里展示的理论和实践可以作为设计更复杂、更安全的默认web应用程序的基础。</p><h1 id="a360" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用的浏览器</h1><ul class=""><li id="7e4f" class="lp lq iq kn b ko kp ks kt kw os la ot le ou li lu lv lw lx bi translated">Mozilla Firefox 68.5.0esr (64位)</li><li id="d128" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">谷歌浏览器版本70.0.3538.77(官方版本)(64位)</li><li id="6a6b" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">谷歌Chrome (2018旧版)70</li></ul><p id="bbce" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><em class="lo">特别感谢审稿人Luiz Rennó和</em><a class="ov ow ep" href="https://medium.com/u/b5ec764976c0?source=post_page-----512cb125c528--------------------------------" rel="noopener" target="_blank"><em class="lo">Vitoria Rio</em></a><em class="lo">。</em></p></div></div>    
</body>
</html>