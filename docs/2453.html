<html>
<head>
<title>Uncovering Vulnerabilities in C Programming: A Guide to Reverse Engineering and Exploiting Function Calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭示C编程中的漏洞:逆向工程和利用函数调用指南</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/reverse-engineering-function-call-in-c-and-exploiting-it-b1b539974018?source=collection_archive---------1-----------------------#2022-10-17">https://infosecwriteups.com/reverse-engineering-function-call-in-c-and-exploiting-it-b1b539974018?source=collection_archive---------1-----------------------#2022-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4293" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在当今的数字时代，公司正在花费越来越多的资金来保护其基础设施免受网络攻击。但事实是，<strong class="jp ir">不是会不会被黑的问题，而是什么时候</strong>。</p><p id="25e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我想让你了解一个看似简单的C函数是如何导致程序执行中断的。我们将研究<strong class="jp ir">如何利用函数</strong>的返回地址以及它对程序行为的潜在影响。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c3cfe1a792d258a919f366fa2ca3bdf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIS2KWpDmG0LOeI1Qe5n2w.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">GDB快照</figcaption></figure><h1 id="c1d5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一点理论</h1><p id="3814" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在副标题中，我提到了二进制利用——这是网络安全中的一个广泛话题，<strong class="jp ir">归结为找到程序中的漏洞，并利用它来获得对外壳的控制或修改程序的功能</strong>。如果这没有吓到你，让我为你重新措辞。如果有人设法利用二进制开发技术来利用您的系统，您就大错特错了。他/她不仅可以访问整个系统，还可以利用它来执行其他恶意任务，如DDoS。</p><p id="96cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了用一个简单的C代码函数调用的例子来演示这一点，我们需要了解一两件关于程序执行和幕后“参与者”的事情。首先是寄存器。</p><h2 id="e976" class="me lc iq bd ld mf mg dn lh mh mi dp ll jy mj mk lp kc ml mm lt kg mn mo lx mp bi translated">登记</h2><p id="6532" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">执行程序(即程序指令)需要各种寄存器。寄存器是一种超快速存储器，它存储几个不同的指针，这些指针在整个存储器中来回指向，以执行程序的指令:</p><ul class=""><li id="1061" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated"><strong class="jp ir">栈指针</strong> (SP) <strong class="jp ir">指向栈顶</strong>(最低数字地址)——栈底在固定地址。堆栈指针(SP)也是实现相关的。它可能指向堆栈上的最后一个地址，或者指向堆栈后的下一个空闲地址。</li><li id="2216" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><strong class="jp ir">帧指针</strong> (FP)也是<strong class="jp ir">局部基址指针</strong> (LB) <strong class="jp ir">指向调用函数</strong>时推入并弹出的逻辑堆栈帧的开始。在英特尔CPU上，帧指针被称为BP (EBP ),我也将在下面的章节中使用它。因为BP是固定的，所以我们可以用它来引用堆栈框架中的变量</li><li id="dc01" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><strong class="jp ir">堆栈帧</strong> (SF) <strong class="jp ir">由函数</strong>(从右到左)<strong class="jp ir">的输入参数、返回地址、前一个BP及其局部变量</strong>组成</li><li id="795e" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><strong class="jp ir">指令指针</strong> (IP) <strong class="jp ir">指向下一条指令的位置</strong>——虽然与“堆栈指针”不完全相关，但为了避免任何混淆，还是提一下它为好</li></ul><p id="52cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图说明了每种方法的用途，这至少对于解释以便进一步理解概念是至关重要的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/dbf708d47a62a8dfeecba2a8e6645463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ue_jbNYiTUlAdvmrfyRpFQ.png"/></div></div></figure><p id="2223" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有许多其他的寄存器，但是提到的这些寄存器足以执行我们正在讨论的利用。上面的图像描绘了堆栈的快照，但仍然有疑问的是这个堆栈是如何增长或收缩的。这就把我们带到了下一节。</p><h2 id="3365" class="me lc iq bd ld mf mg dn lh mh mi dp ll jy mj mk lp kc ml mm lt kg mn mo lx mp bi translated">功能序言</h2><p id="cbf8" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如果我说你的代码最常执行的任务是调用一个函数，我可能没有完全弄错。在每次函数调用之前，都会有一个叫做函数序言的东西出现。在汇编语言编程中，函数序言是在函数开头的几行代码，它为函数中使用的堆栈和寄存器做准备。开场白是这样的:</p><p id="ba38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nf"> 1。)</em> </strong> <strong class="jp ir">通过将旧BP推送到堆栈来保存它</strong> (SP相应地更新)</p><blockquote class="ng nh ni"><p id="6c1b" class="jn jo nf jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated">❓ <strong class="jp ir">你为什么需要拯救老BP？</strong></p><p id="1cd6" class="jn jo nf jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated">💡因为一旦子例程/函数退出，它需要有一个对调用堆栈框架的引用。记住，局部变量可以通过在BP上加上或减去偏移量来引用。</p><p id="1e89" class="jn jo nf jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated">❓:但寄信人地址不就是为了这个吗？</p><p id="0c2d" class="jn jo nf jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated">💡不。返回地址不指向前一个堆栈帧，而是指向调用方法中的下一条指令。</p></blockquote><p id="f86a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nf"> 2。)</em>将SP复制到BP中以创建新的BP </strong> —指向内存中局部变量缓冲区的开始</p><p id="84f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nf"> 3。)</em> </strong> <strong class="jp ir">提前SP为逻辑栈帧</strong> —即函数局部变量预留空间</p><p id="7d3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有许多其他伟大的文章比我更好地说明了这一点，但这是我们需要理解的东西，以便能够理解下一节中的黑客。</p><h1 id="ea0d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">砍</h1><p id="2046" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><em class="nf">现在有趣的部分来了</em>——随着理论的发展，如果我们<strong class="jp ir">修改子例程</strong>中的返回地址值，我们可以影响调用函数中代码执行的位置(在子例程完成之后)。还是不是？让我们试着在代码中看到它。</p><p id="fcac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个概念是这样的:</p><ol class=""><li id="291d" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk nm mw mx my bi translated"><strong class="jp ir">在堆栈上找到返回地址的位置</strong></li><li id="66a5" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk nm mw mx my bi translated"><strong class="jp ir">创建一个指向那个位置的指针</strong></li><li id="a273" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk nm mw mx my bi translated"><strong class="jp ir">修改返回地址的值，即值指针指向</strong></li></ol><p id="d9c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在下面的代码中演示这一点:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="70ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个基本的C代码，我相信你们大多数人都已经理解了。主要思想是<strong class="jp ir">创建一个指针</strong> <em class="nf">(第10行)</em> <strong class="jp ir"> <em class="nf"> </em>指向堆栈上的返回地址内存位置并修改其值</strong>以跳过<em class="nf">第19行</em> <strong class="jp ir">。</strong>返回地址内存位置可以通过偏移<em class="nf"> buffer1 </em>的内存位置来计算——一个<em class="nf"> char </em>类型变量<em class="nf">(第8行)</em>的数组。该偏移量可以计算为从<em class="nf">缓冲器1 </em>到BP的偏移量和BP 大小的<strong class="jp ir">之和。看看上面的图表可以帮助你自己。</strong></p><blockquote class="ng nh ni"><p id="fbdd" class="jn jo nf jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated">💡<strong class="jp ir">64位系统上指针的大小是8字节，32位系统上是4字节。</strong></p></blockquote><p id="8650" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了计算出<em class="nf"> buffer1 </em>和BP之间的偏移量，我们将使用一个<a class="ae np" href="https://de.wikipedia.org/wiki/GNU_Debugger" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> GDB — GNU调试器</strong> </a>。这不是一个关于GDB的教程，所以我将只列出你可以运行的命令来获取两者的内存位置并计算偏移量。</p><pre class="km kn ko kp gt nq nr ns nt aw nu bi"><span id="0f33" class="me lc iq nr b gy nv nw l nx ny"><strong class="nr ir">gcc binexploit1.c -g -o binexploit -fno-stack-protector </strong># compile<br/><strong class="nr ir">gdb binexploit</strong> # open GDB shell<br/>(gdb) <strong class="nr ir">break function</strong> # set a breakpoint<br/>(gdb) <strong class="nr ir">run</strong> # run code to the breakpoint<br/>(gdb) <strong class="nr ir">step</strong> # take the next step<br/>(gdb) <strong class="nr ir">print/x &amp;buffer1</strong> # print memory address of buffer1</span><span id="94c3" class="me lc iq nr b gy nz nw l nx ny">(gdb) <strong class="nr ir">info registers </strong># print register information - in the output look for <strong class="nr ir">rbp</strong> row and the memory address it is pointing to</span></pre><p id="765e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了这两个值，我们可以通过简单的十六进制算法<a class="ae np" href="https://www.calculator.net/hex-calculator.html" rel="noopener ugc nofollow" target="_blank">计算两者之间的偏移量(如果必须的话，使用</a><a class="ae np" href="https://www.calculator.net/hex-calculator.html" rel="noopener ugc nofollow" target="_blank">十六进制计算器</a>)<strong class="jp ir">并加上BP </strong>的大小(在我的例子中<em class="nf">是8字节</em>，因为我是在一台<em class="nf"> 64位</em>机器上运行的)。这是脚本顶部的X值。</p><blockquote class="ng nh ni"><p id="afcf" class="jn jo nf jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated">❓ <strong class="jp ir">为什么我们取</strong> <code class="fe oa ob oc nr b"><strong class="jp ir"><em class="iq">buffer1 + X</em></strong></code> <strong class="jp ir">的和而不减去</strong>？</p><p id="7aae" class="jn jo nf jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated">💡堆栈向下增长—朝着较低的地址。这是它在许多计算机上实现的方式，包括英特尔、摩托罗拉、SPARC和MIPS处理器。</p></blockquote><p id="ebc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要修改返回地址的值来跳过赋值<code class="fe oa ob oc nr b"><strong class="jp ir"><em class="nf">x = 1;</em></strong></code> <em class="nf">(第19行)</em>并在下一行打印出<code class="fe oa ob oc nr b"><strong class="jp ir"><em class="nf">"x: 0”</em></strong></code>。因为我们已经有了指向返回地址内存位置的指针<code class="fe oa ob oc nr b"><strong class="jp ir"><em class="nf">ret</em></strong></code>，我们只需要修改它的值为<em class="nf">第20行</em>而不是<em class="nf">第19行</em>(在代码中)。简单来说，我们可以这样做，首先将<code class="fe oa ob oc nr b"><strong class="jp ir"><em class="nf">Y</em></strong></code>设置为零，并增加它，直到跳过想要的行，或者我们可以使用GDB来拆卸内存——这取决于你。以下是需要在GDB运行的命令:</p><pre class="km kn ko kp gt nq nr ns nt aw nu bi"><span id="2f0e" class="me lc iq nr b gy nv nw l nx ny"><strong class="nr ir">gdb binexploit</strong> # open GDB shell<br/>(gdb) <strong class="nr ir">disassemble main</strong> # disassemble main function memory</span></pre><p id="0a47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出应该如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a3a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到<em class="nf">第10行</em>(赋值操作)和<em class="nf">第11行</em>(打印功能的“准备”)之间的偏移量是<em class="nf"> 7字节</em>，这是我们的<code class="fe oa ob oc nr b"><strong class="jp ir"><em class="nf">Y</em></strong></code>值。</p><blockquote class="ng nh ni"><p id="c9c1" class="jn jo nf jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated">💡<strong class="jp ir">上面的代码片段或者我应该说输出的是</strong> <a class="ae np" href="https://en.wikipedia.org/wiki/Assembly_language" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">汇编代码</strong> </a> <strong class="jp ir">你的特定CPU架构是能够理解和执行的。您可能想更深入地了解一下，以更好地理解我是如何确定printf语句的起始位置的。</strong></p></blockquote><p id="c8ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，现实世界中的这种攻击通常很容易被检测和阻止，但是如果您想了解一两件关于堆栈的事情，我发现这非常有趣。类似地，我们可以使用堆内存来实现同样的事情，但是我会把这个麻烦留给你😉</p><p id="c3fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是这篇文章的全部内容——我正在准备这篇文章的第二部分，我们将研究一种类似的方法，其中我们不仅将执行延迟到程序的后期，而且还执行任意命令，如运行shell或Python脚本。</p><h1 id="94fe" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">而不是结论</h1><p id="1874" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在我结束本教程之前，我想挑战你:</p><blockquote class="ng nh ni"><p id="9ea3" class="jn jo nf jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated"><em class="iq">在</em>第12行<em class="iq">中，尝试将</em> <strong class="jp ir"> buffer1 </strong> <em class="iq">改为</em><strong class="jp ir">buffer 2</strong><em class="iq">——然后相应地更新</em> <code class="fe oa ob oc nr b"><strong class="jp ir"><em class="iq">X</em></strong></code> <em class="iq">和</em> <code class="fe oa ob oc nr b"><strong class="jp ir"><em class="iq">Y</em></strong></code> <em class="iq">，以达到与我们(</em> <code class="fe oa ob oc nr b"><strong class="jp ir"><em class="iq">"x: 0”</em></strong></code> <em class="iq">)相同的结果。</em></p></blockquote><p id="a120" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请在评论中告诉我你的结果。</p><blockquote class="od"><p id="0fbc" class="oe of iq bd og oh oi oj ok ol om kk dk translated">感谢阅读！😎如果你喜欢这篇文章，点击下面的按钮👏</p><p id="0f39" class="oe of iq bd og oh oi oj ok ol om kk dk translated">对我来说意义重大，也有助于其他人了解这个故事。在<a class="ae np" href="https://www.linkedin.com/in/teodor-janez-podobnik/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a> | <a class="ae np" href="https://twitter.com/TeodorJanez" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上打招呼</p><p id="fd50" class="oe of iq bd og oh oi oj ok ol om kk dk translated">要不要开始读Medium上的独家故事？使用此<a class="ae np" href="https://medium.com/@tp4348/membership" rel="noopener">推荐链接</a>🔗</p><p id="8807" class="oe of iq bd og oh oi oj ok ol om kk dk translated">如果你喜欢我的帖子，你可以<a class="ae np" href="https://www.buymeacoffee.com/tp4348" rel="noopener ugc nofollow" target="_blank">给我买一个热狗</a>🌭</p><p id="d389" class="oe of iq bd og oh oi oj ok ol om kk dk translated">你是一个热情的工程师，但缺乏能力来编写引人注目和鼓舞人心的技术内容吗？雇用我做🛠️的升级工作</p><p id="72f7" class="oe of iq bd og oh oi oj ok ol om kk dk translated">在Teodor J. Podobnik，@dorkamotorka 上查看我的其他内容，并关注我的更多内容，干杯！</p></blockquote></div><div class="ab cl op oq hu or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ij ik il im in"><h2 id="427b" class="me lc iq bd ld mf mg dn lh mh mi dp ll jy mj mk lp kc ml mm lt kg mn mo lx mp bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae np" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4个线程、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>