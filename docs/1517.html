<html>
<head>
<title>Abusing NTLM Relay and Pass-The-Hash for Admin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">滥用NTLM中继和为管理员传递散列</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/abusing-ntlm-relay-and-pass-the-hash-for-admin-d24d0f12bea0?source=collection_archive---------0-----------------------#2021-08-12">https://infosecwriteups.com/abusing-ntlm-relay-and-pass-the-hash-for-admin-d24d0f12bea0?source=collection_archive---------0-----------------------#2021-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1b71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着PetitPotam最近的崛起，我受到启发，对整个NTLM接力赛做了更多的研究。所以我花了一些时间阅读不同的技术，并设法将我经常看到的两个想法结合起来，Responder/NTLMRelayx和Pass-The-Hash在我的一些工作中取得了显著的效果。这些技术已经为人所知很多年了，但是仍然在没有实现强大网络安全的环境中使用。</p><p id="c2d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于有经验的pentesters来说，这可能不是什么开创性的或新的东西，但我在其他任何地方都没有见过像这篇文章这样的完整攻击链，所以我想我还是把它写下来吧。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/50cc84643e8b394758a1136b7a70753b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_fB9CnsEhWdLqZ3FQyWTA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">攻击路径示例</figcaption></figure><blockquote class="le lf lg"><p id="180a" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">注意:下面所有的例子都是在一个个人测试域上，所以，是的，这个例子的密码很容易被破解。</p></blockquote><h2 id="70dc" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated">NTLM中继</h2><p id="98a6" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">在深入技术细节之前，让我们回顾一下NTLM中继，概述一下开发的必要条件。Windows新技术局域网管理器(NTLM)是由Microsoft提供的一套安全协议，用于对Windows计算机上的用户进行身份验证和授权。NTLM是一种挑战/响应式协议，其结果是Net-NTLMv1或v2哈希。这种散列相对来说很难破解，但是如果遵循强有力的随机长密码安全策略，它就能很好地保存。然而，Net-NTLM哈希<strong class="js iu">不能</strong>用于传递哈希(PTH)攻击，只有本地NTLM哈希在受害机器本身。</p><p id="456c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，我们在SOCKS服务器中继中捕获Net-NTLM散列，并使用这个认证从机器中提取本地NTLM散列。有了这些散列，我们就可以沿着标准的PTH攻击路径前进了。对于PTH，我将展示使用NTLM散列的3种不同方法，并解释为什么一种可能比另一种更有帮助，这是基于真实世界的约定，包括避免反病毒。</p><p id="39de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要深入了解不同的Windows身份验证协议，我推荐阅读<a class="ae mj" href="https://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4" rel="noopener">https://medium . com/@ Peter gobos/lm-NTLM-net-NTLM v2-oh-my-a9 b 235 c 58 ed 4</a>，这是一篇关于不同部分的精彩文章。</p><h2 id="90a4" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated">先决条件</h2><ol class=""><li id="33f4" class="mk ml it js b jt me jx mf kb mm kf mn kj mo kn mp mq mr ms bi translated">局域网的第2层接入</li><li id="c9ca" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">安装在Linux上的<a class="ae mj" href="https://github.com/SecureAuthCorp/impacket" rel="noopener ugc nofollow" target="_blank"> Impacket </a>(最好是Kali，因为它预装了所有需要的工具)</li><li id="30ad" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">在受害者端点上禁用SMB签名(可以通过crackmapexec轻松检查)。</li></ol><h2 id="6046" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated">使用CrackMapExec识别SMB签名</h2><p id="05e5" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">这种攻击途径的第一步是收集LAN中禁用SMB签名的IP列表。SMB签名是一项防止重放攻击的安全功能。但是，它通常被禁用以支持传统设备或提高网络速度。使用<a class="ae mj" href="https://github.com/byt3bl33d3r/CrackMapExec" rel="noopener ugc nofollow" target="_blank"> CrackMapExec </a>无需签名即可轻松定位计算机:</p><p id="9a57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe my mz na nb b">crackmapexec smb — gen-relay-list smb_targets.txt 192.168.1.0/24</code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/c58e2a2ba1f1a889b386c2c162a36832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDbfecz85M55kPRjBVQ3UQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">针对本地子网的CrackMapExec的输出</figcaption></figure><p id="6d7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此命令显示子网中所有禁用签名的设备，并以方便的列表形式输出IP，供以后使用。对于我们的示例，DC01域控制器显示签名被禁用。</p><h2 id="3ae2" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated">NTLMRelayx</h2><p id="4e79" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">现在我们有了目标列表(smb_targets.txt)，我们可以设置<a class="ae mj" href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/ntlmrelayx.py" rel="noopener ugc nofollow" target="_blank"> NTLMRelayx.py </a>，这是我的中继，因为它与Responder集成在一起。如果您在查找脚本时遇到问题，请确保Impacket安装正确。</p><p id="6026" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe my mz na nb b">ntlmrelayx.py -socks -smb2support -tf smb_targets.txt</code></p><blockquote class="le lf lg"><p id="c8b8" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">注意:对于我的网络，-smb2support标志是不必要的，因为SMBv1是受支持的，但是通常SMBv1是禁用的，所以最好包含该标志。</p></blockquote><p id="f82b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">-tf标志根据文件中的IP列表自动测试任何捕获的凭据，而-socks标志在端口1080上打开一个socks服务器，我们将使用它来中继捕获的凭据。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nd"><img src="../Images/14f5bbc6d99d9c2f87be5d421c1c81bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eibz_t2FrsIOfkPbh0t-fw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Ntlmrelayx.py激活</figcaption></figure><h2 id="09d5" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated">代理链</h2><p id="29bd" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">为了通过创建的SOCKS代理发送请求，我们使用proxychains。用<code class="fe my mz na nb b">sudo nano /etc/proxychains4.conf</code>编辑/etc/proxychains4.conf，并将最后一行改为<code class="fe my mz na nb b">socks4 127.0.0.1 1080</code>，指向新创建的SOCKS服务器。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/2115fe0abd4c4d36dada63c874c71fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*BgpX5NQJTjUwNc5QVvfGdQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">代理链配置</figcaption></figure><h2 id="fd94" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated">回答者</h2><p id="1e84" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">既然先决条件已经完成，让我们开始有趣的部分吧！</p><p id="a7f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mj" href="https://github.com/lgandx/Responder" rel="noopener ugc nofollow" target="_blank"> Responder </a>是众所周知的LLMNR/NBT-NS/mDNS投毒者和NTLMv1/2中继，会自动捕获网络上的任何请求。由于ntlmrelayx.py本身使用SMB/HTTP端口，请确保通过将<code class="fe my mz na nb b">/etc/responder/Responder.conf</code>中的相应行从开编辑为关来禁用响应器端口。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/d9e8ce155568bd545c2c9c538ae83918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aVr4t86h8zqW0QC4DXzrYw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">响应器配置</figcaption></figure><p id="ec9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后在正确的接口上启动Responder，在我的例子中是eth0。</p><p id="a920" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe my mz na nb b">sudo responder -I eth0</code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/de8f0822e4a9d08b821fa6e2218df9b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*x9G3fjeZFzEKkQN6RD8cdA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">响应程序启动</figcaption></figure><p id="d2ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一点上，它只是一个在网络上捕获凭证的等待游戏。如果社交工程在范围内，您可以尝试让用户加载一个名称不正确的网络共享，这通常会触发LLMNR或NBT-NS广播，响应者可能会中毒。</p><h2 id="433e" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated">获取哈希的方法</h2><ol class=""><li id="2c89" class="mk ml it js b jt me jx mf kb mm kf mn kj mo kn mp mq mr ms bi translated">如果您在某个端点上执行某种形式的命令，请让该端点尝试通过CMD或Run连接到一个伪共享。</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/49ccf7bbd109c02d5251d435b9c6d894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*eVO2rVVZneEX4pU4boT0Sw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">通过CMD强制NTLMv2哈希</figcaption></figure><p id="4578" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.或者，如果社交工程在范围之内，你可以给用户发一封电子邮件，链接到这个虚假的网络共享，并尝试让他们点击它来加载。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ni"><img src="../Images/ea24a4fda3b24d625780672fc0ece53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkeQjVuS5CQvJLWnG0HIGg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">响应者捕获发出的请求</figcaption></figure></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="89f6" class="nq lm it bd ln nr ns nt lq nu nv nw lt nx ny nz lw oa ob oc lz od oe of mc og bi translated">袜子连接</h1><p id="1141" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">无论是通过时间还是利用，您应该开始在ntlmrelayx输出中看到正在启动的会话。要查看捕获会话的完整列表，请在ntlmrelayx控制台中键入<code class="fe my mz na nb b">socks</code>，您将看到目标IP、用户，甚至该用户是否是管理员。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/f8d934893ad94b2c735b6cc6f87374d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*xtbHuc3oFC-FZX1gtbi0Wg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Ntlmrelayx socks输出</figcaption></figure><p id="4252" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您捕获的用户对目标具有SMB权限，并且没有防病毒或其他网络块，您可以通过proxychains利用<a class="ae mj" href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbexec.py" rel="noopener ugc nofollow" target="_blank"> smbexec.py </a>来获得对端点的命令执行。需要注意的是psexec.py不起作用，因为它打开了多个连接，而SOCKS服务器不知道如何处理。</p><p id="c491" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe my mz na nb b">proxychains4 -q smbexec.py test/testadmin:test@192.168.1.161</code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/6911258e3a522b4ce027716214a50e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XIGVtN2WxlSnrRnNRMYKGw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">smbexec通过捕获的登录会话</figcaption></figure><p id="aefe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，我发现这种直接的路径并不经常工作，通常是由于反病毒或EDR捕捉smbexec创建的服务。为了解决这个问题，我发现采取提取本地散列并在PTH攻击中使用它们的额外步骤要好得多。</p><h2 id="a256" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated">秘密转储</h2><p id="defb" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">第一步是获取目标的本地NTLM散列。为此，我们使用Impacket的<a class="ae mj" href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/secretsdump.py" rel="noopener ugc nofollow" target="_blank"> secretsdump.py </a>，它使用各种技术来转储本地和域散列。我们必须确保使用proxychains通过我们的SOCKS代理路由请求。</p><p id="ef0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe my mz na nb b">proxychains4 -q secretsdump.py test/Testadmin:test@192.168.1.161</code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/2dc95f728a1c671a952c1f484fc014ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DNzItkDvk7PO57ToeQr_yg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Secretsdump.py来提取本地哈希</figcaption></figure><blockquote class="le lf lg"><p id="c5bf" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">注意:在我的例子中，我必须添加-use-vss标志来提取散列。此外，由于凭证是通过SOCKS服务器传递的，所以您输入的密码并不重要。</p></blockquote><p id="fd97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数情况下，您需要本地SAM散列，但是由于我们的目标是没有本地帐户的域控制器，所以我们希望通过NTDS转储域凭证:“Administrator:500:aad3b 435 b 51404 eeaad3b 435 b 51404 ee:2b 576 acbe 6 BCF da 7294 D6 BD 18041 b8 Fe::::”。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h2 id="e6d1" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated">传递散列值</h2><p id="f2e3" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">既然我们已经将捕获的Net-NTLM登录转换为本地Admin NTLM散列，我们可以尝试传递该散列来获得对机器的内部访问。我使用了三种主要的方法来取得显著的效果:</p><ol class=""><li id="da7e" class="mk ml it js b jt ju jx jy kb ok kf ol kj om kn mp mq mr ms bi translated"><a class="ae mj" href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py" rel="noopener ugc nofollow" target="_blank"> Wmiexec.py </a></li></ol><p id="99bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Wmiexec是另一个Impacket远程命令，它使用WMIC发送命令，可以绕过捕获smbexec的AV。</p><pre class="kp kq kr ks gt on nb oo op aw oq bi"><span id="af91" class="ll lm it nb b gy or os l ot ou">wmiexec.py -hashes ‘00000000000000000000000000000000:2b576acbe6bcfda7294d6bd18041b8fe’ administrator@192.168.1.161</span></pre><blockquote class="le lf lg"><p id="06df" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">N <!-- -->注:你必须用0替换NTLM散列的前部，这样才能工作。</p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ov"><img src="../Images/ebcf6d70cbccf33b6ff57a8309db48e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9FcLoWPOS87ZjRGNGjmkEA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">wmicexec.py绕过AV</figcaption></figure><p id="9681" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.<a class="ae mj" href="https://github.com/Hackplayers/evil-winrm" rel="noopener ugc nofollow" target="_blank">邪恶-WinRm </a></p><p id="69d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在端点上启用了WINRM，那么令人敬畏的工具Evil-WinRm支持使用哈希。这是一种非常隐蔽的攻击，通常不会被任何安全解决方案捕获。</p><pre class="kp kq kr ks gt on nb oo op aw oq bi"><span id="88de" class="ll lm it nb b gy or os l ot ou">evil-winrm -u Administrator -H ‘2b576acbe6bcfda7294d6bd18041b8fe’ -i 192.168.1.161</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ow"><img src="../Images/0b659c085ea2699fc945c1de989a8ed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llyF-cl4h_O5rCSCC-o7GQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Evil-WinRM PTH</figcaption></figure><p id="ae91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.<a class="ae mj" href="https://linux.die.net/man/1/xfreerdp" rel="noopener ugc nofollow" target="_blank"> XfreeRDP </a></p><p id="259d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于更多以GUI为中心的攻击，可以使用Xfreerdp获得对终端的rdp访问权限。</p><pre class="kp kq kr ks gt on nb oo op aw oq bi"><span id="1836" class="ll lm it nb b gy or os l ot ou">xfreerdp /u:Administrator /pth:2b576acbe6bcfda7294d6bd18041b8fe /v:192.168.1.161</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ox"><img src="../Images/d6d3ece259b18fae2201e1cfa5b09c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kc29xuHOSW9-uDltchMU6Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">通过PTH的XfreeRDP访问</figcaption></figure><p id="00df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这些访问级别中的任何一个，攻击者都应该能够升级、关闭防御，或者毫不费力地在环境中移动。虽然这种攻击是针对域控制器的，但是捕获Admin login -&gt; Secretsdump -&gt; PTH的基本过程应该适用于任何端点。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="7b95" class="nq lm it bd ln nr ns nt lq nu nv nw lt nx ny nz lw oa ob oc lz od oe of mc og bi translated">补救</h1><ol class=""><li id="98dc" class="mk ml it js b jt me jx mf kb mm kf mn kj mo kn mp mq mr ms bi translated">启用SMB签名</li><li id="a4bf" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">禁用LLMNR</li><li id="328f" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">禁用NBT-NS</li><li id="532c" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">监视</li></ol><h2 id="d0da" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated">启用SMB签名</h2><p id="f109" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">最简单的解决方案是在网络上启用SMB签名，这将立即防止中继攻击。但是，确认此变更不会影响任何传统设备是很重要的。</p><p id="bfb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu">组策略管理编辑器</strong>窗口的控制台树中，转到计算机配置/策略/Windows设置/安全设置/本地策略/安全选项。<br/> <br/>在细节窗格中，双击<strong class="js iu">微软网络服务器:数字签名通信(总是)</strong>。<br/> <br/>确认<strong class="js iu">定义此策略设置</strong>复选框已选中，点击<strong class="js iu">启用</strong>启用SMB数据包签名，然后点击<strong class="js iu">确定</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/1e0f181a57b0f78f0741d1d82c0bb295.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*G5OPi5DAKBDtOBD147_Qmw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">启用SMB签名</figcaption></figure><blockquote class="le lf lg"><p id="48b8" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">补救步骤摘自<a class="ae mj" href="http://mctexpert.blogspot.com/2011/02/disable-smb-signing.html" rel="noopener ugc nofollow" target="_blank">http://mctexpert . blogspot . com/2011/02/disable-SMB-signing . html</a>。</p></blockquote><h2 id="62d3" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated"><strong class="ak">禁用LLMNR </strong></h2><ol class=""><li id="2c3b" class="mk ml it js b jt me jx mf kb mm kf mn kj mo kn mp mq mr ms bi translated">在您的Windows版本中打开组策略编辑器</li><li id="2fd2" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">导航到本地计算机策略&gt;计算机配置&gt;管理模板&gt;网络&gt; DNS客户端</li><li id="380e" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">在DNS客户端下，确保“关闭多播名称解析”设置为启用</li></ol><h2 id="8b39" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated"><strong class="ak">禁用NBT-NS </strong></h2><ol class=""><li id="fb0e" class="mk ml it js b jt me jx mf kb mm kf mn kj mo kn mp mq mr ms bi translated">打开网络连接并查看网络适配器的属性。</li><li id="9959" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">选择互联网协议版本4 (TCP/IPv4)并单击属性。</li><li id="47d7" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">在常规选项卡上，单击高级并导航到WINS选项卡，然后选择“禁用TCP/IP上的NetBIOS”。</li></ol><p id="b550" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">禁用LLMNR和NTB-NS将防止凭据被Responder之类的工具捕获，从而防止攻击者试图破解这些凭据。确保禁用这两个协议，因为当另一个协议失败/被禁用时，Windows默认使用另一个协议。</p><blockquote class="le lf lg"><p id="f30c" class="jq jr lh js b jt ju jv jw jx jy jz ka li kc kd ke lj kg kh ki lk kk kl km kn im bi translated">补救措施从<a class="ae mj" href="https://cccsecuritycenter.org/remediation/llmnr-nbt-ns" rel="noopener ugc nofollow" target="_blank">https://cccsecuritycenter.org/remediation/llmnr-nbt-ns</a>撤出。</p></blockquote><h2 id="fa18" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated"><strong class="ak">监控</strong></h2><p id="1668" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">应对主机进行监控，以发现(1)LLMNR和NBT-NS端口(UDP 5355和137)上的流量，(2)事件id为4697和7045的事件日志(与中继攻击相关)，以及(3)注册表DWORD <em class="lh"> EnableMulticast </em>在<em class="lh">HKLM \软件\策略\微软\Windows NT\DNSClient </em>下的更改。</p></div></div>    
</body>
</html>