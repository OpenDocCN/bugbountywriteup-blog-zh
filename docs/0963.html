<html>
<head>
<title>Writeup to the Decompetition capture the flag</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">写至分解竞争捕获标志</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/writeup-to-the-decompetition-capture-the-flag-2020-3a3f14887525?source=collection_archive---------1-----------------------#2020-11-17">https://infosecwriteups.com/writeup-to-the-decompetition-capture-the-flag-2020-3a3f14887525?source=collection_archive---------1-----------------------#2020-11-17</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/62cd7d67451a6c97149c1d60208a6b00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0IYYu8DU0wBk1wmQbylktA.png"/></div></div></figure><h1 id="9158" class="kc kd iu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">目录一览</h1><ol class=""><li id="b7c9" class="la lb iu lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍</li><li id="cbcf" class="la lb iu lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">准备</li><li id="a909" class="la lb iu lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">dem挑战</li><li id="cc6a" class="la lb iu lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">结论</li><li id="b68e" class="la lb iu lc b ld ls lf lt lh lu lj lv ll lw ln lo lp lq lr bi translated">大声喊出来</li></ol><h1 id="5434" class="kc kd iu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">介绍</h1><p id="b300" class="pw-post-body-paragraph lx ly iu lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln in bi translated"><a class="ae mm" href="https://decompetition.io/" rel="noopener ugc nofollow" target="_blank">去竞争捕捉旗帜</a> (2020版。)号召全球各地的逆向工程师对用<em class="mn"> C </em>、<em class="mn"> C++ </em>、<em class="mn"> Go </em>、<em class="mn"> Rust </em>和<em class="mn"> Swift </em>编写的原生二进制代码进行逆向工程。参赛者的目标是尽可能将编译后的二进制文件重构为原始源代码，CTF持续了二十四(24)小时。</p><figure class="mp mq mr ms gu jv gi gj paragraph-image"><div class="gi gj mo"><img src="../Images/c2732609459108b52051b6db4376221f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*cD001IC7MdLZM_NgqoBHGg.png"/></div><figcaption class="mt mu gk gi gj mv mw bd b be z dk translated">来源:<a class="ae mm" href="https://archive.is/mCFai" rel="noopener ugc nofollow" target="_blank">https://archive.is/mCFai</a></figcaption></figure><p id="6ac3" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">我注册成为用户EntropyThot，开始了我自己的“团队”,叫做摇摆哲学家——基本上只有我自己😋</p><p id="6f8f" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">我获得了第52名(在277名参赛者中)。假设我的数学是正确的，那我就是第77百分位！</p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="c9ea" class="kc kd iu bd ke kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz bi translated">准备</h1><p id="e170" class="pw-post-body-paragraph lx ly iu lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln in bi translated">我决定在去竞争开始前一周做一点研究和练习，这样我就有希望获得更高的排名。CTF根据提交的三个标准评分:你的代码通过单元测试的程度(20%的分数)，它与他们编译的可执行文件“相似”的程度(60%的分数)，以及你的代码是否与他们编译的可执行文件相同(另外20%的分数)。</p><h2 id="0f7e" class="no kd iu bd ke np nq dn ki nr ns dp km lh nt nu kq lj nv nw ku ll nx ny ky nz bi translated">单元测试</h2><p id="101f" class="pw-post-body-paragraph lx ly iu lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln in bi translated">我并没有为单元测试做太多的准备。我只是想，我应该在CTF期间这样做，主要是因为我将与编译的可执行文件一起工作。我想我应该自动化一个Python脚本来运行并与最初编译的可执行文件交互，并让它生成测试用例。</p><h2 id="af15" class="no kd iu bd ke np nq dn ki nr ns dp km lh nt nu kq lj nv nw ku ll nx ny ky nz bi translated">对编码语言的信心</h2><p id="5eaf" class="pw-post-body-paragraph lx ly iu lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln in bi translated">Decompetition在他们的网站上声明，他们将用五种不同的语言编写他们的二进制文件:<em class="mn"> C </em>、<em class="mn"> C++ </em>、<em class="mn"> Go </em>、<em class="mn"> Rust </em>和<em class="mn"> Swift </em>，并将被编译成一个<em class="mn"> x86_64 </em>可执行文件，由各自的编译器专门设计，在运行<em class="mn"> Ubuntu 20.04 </em>的系统上执行。首先，我将对以下语言的自信程度进行排名，从1到10分不等:</p><figure class="mp mq mr ms gu jv gi gj paragraph-image"><div class="gi gj oa"><img src="../Images/9b0e529f64a6a636595941a90b5a967c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*fiPogk6MNvI5blrJNZMmRQ.png"/></div><figcaption class="mt mu gk gi gj mv mw bd b be z dk translated">我对语言的自信程度(越高=越自信)</figcaption></figure><p id="c02c" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">我过去有过用C和C++编写各种程序的经验，最近我刚刚开始用Go和书<em class="mn"> Black Hat Go (2020) </em>进行编程，尽管我实际上没有使用Rust和Swift的经验。我认为我最好的办法是练习一下C和C++，集中精力学习围棋，用Rust和Swift“即兴发挥”。</p><p id="fdd8" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">为了练习，我使用了一个针对n00bs的免费编码练习网站，名为<a class="ae mm" href="https://edabit.com" rel="noopener ugc nofollow" target="_blank"> Edabit </a> ( <a class="ae mm" href="https://edabit.com/user/PDK3Bb98sENmo5wnT" rel="noopener ugc nofollow" target="_blank">我的简介</a>)。如果你是第一次创业，Edabit是一个很好的资源——不，他们不会付钱给我来推广他们😋</p><h2 id="0e9f" class="no kd iu bd ke np nq dn ki nr ns dp km lh nt nu kq lj nv nw ku ll nx ny ky nz bi translated">代码相似性的量化</h2><p id="0456" class="pw-post-body-paragraph lx ly iu lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln in bi translated">Jaccard指数是一种统计结构，用于计算两个数学集合之间对象的“相似性”和“多样性”。Decompetition使用Jaccard指数来量化两个编译程序的反汇编有多相似。我认为我应该对Jaccard index做一些初步的研究，所以我在维基百科上查找并找到了它的条目(特别是在2020年9月6日最后修订的<a class="ae mm" href="https://en.wikipedia.org/w/index.php?title=Jaccard_index&amp;oldid=977019056" rel="noopener ugc nofollow" target="_blank">)。</a></p><p id="6c93" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">给定两个数学集合<strong class="lc iv"> <em class="mn"> X </em> </strong>和<strong class="lc iv"> <em class="mn"> Y </em> </strong>，Jaccard指数<strong class="lc iv"> <em class="mn"> J(X，Y) </em> </strong>被正式定义为:</p><figure class="mp mq mr ms gu jv gi gj paragraph-image"><div class="gi gj ob"><img src="../Images/b614d20a0714dcbc63137aa35e7faf35.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*ZpomonX_uHhXVGMHNsZlOg.png"/></div></figure><p id="ea2b" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">Jaccard索引的一个相关结构是<em class="mn"> Jaccard距离</em>。给定两个数学集合<strong class="lc iv"> <em class="mn"> X </em> </strong>和<strong class="lc iv"> <em class="mn"> Y </em> </strong>，Jaccard距离<strong class="lc iv"> <em class="mn"> dⱼ(X，Y) </em> </strong>正式定义为:</p><figure class="mp mq mr ms gu jv gi gj paragraph-image"><div class="gi gj oc"><img src="../Images/e2634c28b150c7293db6f3c4440d5721.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*ChBo0ohQHxB677jj-0GwYA.png"/></div></figure><p id="bcce" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">Jaccard指数是“相似性”的度量，而Jaccard距离是“差异性”或“多样性”的度量我从<em class="mn">恶意软件数据科学(2018，ch。5) </em>计算两串操作码的Jaccard索引:</p><figure class="mp mq mr ms gu jv"><div class="bz fq l di"><div class="od oe l"/></div></figure><p id="72ed" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">这个脚本是不完整的，也没有经过适当的测试，所以使用风险自担😖</p></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="cc1d" class="kc kd iu bd ke kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz bi translated">dem挑战</h1><p id="22ca" class="pw-post-body-paragraph lx ly iu lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln in bi translated">我不想讨论我解决的所有挑战，但我想讨论其中一些挑战和我用来解决它们的策略。</p><h2 id="ecc6" class="no kd iu bd ke np nq dn ki nr ns dp km lh nt nu kq lj nv nw ku ll nx ny ky nz bi translated">最好的</h2><p id="eb64" class="pw-post-body-paragraph lx ly iu lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln in bi translated">我想讨论的第一个挑战是<code class="fe of og oh oi b">prime</code>二进制。顾名思义，这个小程序在某个数字<code class="fe of og oh oi b">n</code>下生成素数。计算质数的算法有很多，厄拉多塞筛法是最常见的一种:</p><pre class="mp mq mr ms gu oj oi ok ol aw om bi"><span id="da41" class="no kd iu oi b gz on oo l op oq"># From the Wikipedia entry on the Sieve of Eratosthenes (<a class="ae mm" href="https://en.wikipedia.org/w/index.php?title=Sieve_of_Eratosthenes&amp;oldid=985992301" rel="noopener ugc nofollow" target="_blank">29 Oct., 2020 revision</a>), note that this algorithm might not be exactly how it's implemented in the <em class="mn">prime</em> binary in Decompetition.</span><span id="f0eb" class="no kd iu oi b gz or oo l op oq"><strong class="oi iv">algorithm</strong> Sieve of Eratosthenes <strong class="oi iv">is</strong><br/>    <strong class="oi iv">input</strong>: an integer <em class="mn">n</em> &gt; 1.<br/>    <strong class="oi iv">output</strong>: all prime numbers from 2 through <em class="mn">n</em>.<br/><br/>    <strong class="oi iv">let</strong> <em class="mn">A</em> be an <strong class="oi iv">array of Boolean</strong> values, indexed by <strong class="oi iv">integer</strong>s 2 to <em class="mn">n</em>,<br/>    initially all <strong class="oi iv">set</strong> to <strong class="oi iv">true</strong>.<br/>    <br/>    <strong class="oi iv">for</strong> <em class="mn">i</em> = 2, 3, 4, ..., not exceeding <em class="mn">√n</em> <strong class="oi iv">do</strong><br/>        <strong class="oi iv">if</strong> <em class="mn">A</em>[<em class="mn">i</em>] <strong class="oi iv">is</strong> <strong class="oi iv">true</strong><br/>            <strong class="oi iv">for</strong> <em class="mn">j</em> = <em class="mn">i</em>2, <em class="mn">i</em>2+<em class="mn">i</em>, <em class="mn">i</em>2+2<em class="mn">i</em>, <em class="mn">i</em>2+3<em class="mn">i</em>, ..., not exceeding <em class="mn">n</em> <strong class="oi iv">do</strong><br/>                <em class="mn">A</em>[<em class="mn">j</em>] := <strong class="oi iv">false</strong><br/><br/>    <strong class="oi iv">return</strong> all <em class="mn">i</em> such that <em class="mn">A</em>[<em class="mn">i</em>] <strong class="oi iv">is</strong> <strong class="oi iv">true</strong>.</span></pre><p id="0f55" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">当反转用<em class="mn"> C </em>或<em class="mn"> C++ </em>语言编写的二进制文件时，我简单地使用了<em class="mn"> Ghidra的</em>反编译器。这使得重写原始二进制文件变得容易得多；我所要做的就是调整输出，使它在编译的上下文中有意义:</p><figure class="mp mq mr ms gu jv"><div class="bz fq l di"><div class="od oe l"/></div></figure><h2 id="20dc" class="no kd iu bd ke np nq dn ki nr ns dp km lh nt nu kq lj nv nw ku ll nx ny ky nz bi translated">极好的</h2><p id="3152" class="pw-post-body-paragraph lx ly iu lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln in bi translated"><em class="mn">或者，当数学背景有所帮助时……</em></p><p id="1c78" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">不幸的是，我使用Ghidra的反编译器来计算源代码近似值的技术不适用于Go或其他语言。我想他们的编译器会生成不同的反汇编模式，这让Ghidra的反编译程序感到困惑，所以我必须有点创意。</p><p id="1405" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">我采用了黑盒方法来重写<code class="fe of og oh oi b">fabulous</code>二进制文件。我在没有任何参数的情况下运行它，得到了以下输出:</p><pre class="mp mq mr ms gu oj oi ok ol aw om bi"><span id="9184" class="no kd iu oi b gz on oo l op oq"><strong class="oi iv">$ ./fabulous</strong><br/>panic: runtime error: index out of range [1] with length 1</span><span id="6512" class="no kd iu oi b gz or oo l op oq">goroutine 1 [running]:<br/>main.main()<br/>        /mnt/go/fibl/fibl.go:13 +0x247</span></pre><p id="9445" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">好吧，看起来它需要一个论点。让我们看看当我输入一个<code class="fe of og oh oi b">1</code>时会发生什么:</p><pre class="mp mq mr ms gu oj oi ok ol aw om bi"><span id="2af1" class="no kd iu oi b gz on oo l op oq"><strong class="oi iv">$ ./fabulous 1</strong><br/>1</span></pre><p id="bc66" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">有意思。现在，让我们试一试<code class="fe of og oh oi b">fabulous</code>的数字范围:</p><pre class="mp mq mr ms gu oj oi ok ol aw om bi"><span id="66b0" class="no kd iu oi b gz on oo l op oq"><strong class="oi iv">$ for x in range {1..10}; do ./fabulous $x | tr '\r\n' ' '; done</strong><br/>1 1 2 3 5 8 13 21 34 55 89</span></pre><p id="d300" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">这就是拥有数学背景会有所帮助的地方。我立即注意到这是一个斐波那契数列，并迅速实现了一个Golang:</p><figure class="mp mq mr ms gu jv"><div class="bz fq l di"><div class="od oe l"/></div></figure><h2 id="c37f" class="no kd iu bd ke np nq dn ki nr ns dp km lh nt nu kq lj nv nw ku ll nx ny ky nz bi translated">宝贝去吧</h2><p id="2bc2" class="pw-post-body-paragraph lx ly iu lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln in bi translated"><em class="mn">或者，当编码背景有帮助时……</em></p><p id="6f62" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">和<code class="fe of og oh oi b">fabulous</code>一样，我采用了黑盒方法来逆向工程<code class="fe of og oh oi b">baby-go</code>。我开始运行它时没有任何参数:</p><pre class="mp mq mr ms gu oj oi ok ol aw om bi"><span id="e8bd" class="no kd iu oi b gz on oo l op oq"><strong class="oi iv">$ ./baby-go</strong><br/>panic: runtime error: index out of range [1] with length 1</span><span id="dd5c" class="no kd iu oi b gz or oo l op oq">goroutine 1 [running]:<br/>main.main()<br/>        /mnt/go/fizzbuzz/interview.go:12 +0x275</span></pre><p id="3f12" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">好了，现在让我们引入一个论点:</p><pre class="mp mq mr ms gu oj oi ok ol aw om bi"><span id="5d7f" class="no kd iu oi b gz on oo l op oq"><strong class="oi iv">$ ./baby-go 1</strong><br/>1</span></pre><p id="39b7" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">现在让我们探索一下这个函数，看看我们是否能找出一个模式:</p><pre class="mp mq mr ms gu oj oi ok ol aw om bi"><span id="e82b" class="no kd iu oi b gz on oo l op oq"><strong class="oi iv">$ for x in range {1..50}; do ./baby-go $x | tr '\r\n' ' '; done</strong><br/>Green 1 2 Yellow 4 Blue Yellow 7 8 Yellow Blue 11 Yellow 13 14 Green 16 17 Yellow 19 Blue Yellow 22 23 Yellow Blue 26 Yellow 28 29 Green 31 32 Yellow 34 Blue Yellow 37 38 Yellow Blue 41 Yellow 43 44 Green 46 47 Yellow 49 Blue</span></pre><p id="09b1" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">这也是编码背景派上用场的地方。我注意到这是FizzBuzz challenge的一个实现，它被用作淘汰糟糕的程序员的试金石，我立即想到了一个实现:</p><figure class="mp mq mr ms gu jv"><div class="bz fq l di"><div class="od oe l"/></div></figure></div><div class="ab cl nc nd hy ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="in io ip iq ir"><h1 id="8588" class="kc kd iu bd ke kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz bi translated">结论</h1><figure class="mp mq mr ms gu jv gi gj paragraph-image"><div class="gi gj os"><img src="../Images/256412c66efba654a50157e05be65da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*IgndW3QatCy6YnNcey-DAA.png"/></div><figcaption class="mt mu gk gi gj mv mw bd b be z dk translated">来源:<a class="ae mm" href="https://archive.is/H9T2N" rel="noopener ugc nofollow" target="_blank">https://archive.is/H9T2N</a></figcaption></figure><p id="0fd5" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">现在你可能已经发现了，我在重构二进制文件时并没有真正去读它们的反汇编。那是因为我仍然是一个超级00b，需要很多年的练习才能成为1337。我没能使用我写的Jaccard index Python脚本，但是写它很有趣！</p><p id="c3f1" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">尽管如此，反竞争还是很棒，我迫不及待地想在未来做更多的逆向工程😃</p><p id="479c" class="pw-post-body-paragraph lx ly iu lc b ld mx lz ma lf my mb mc lh mz me mf lj na mh mi ll nb mk ml ln in bi translated">哦，如果你想看GitHub项目捕捉旗帜:</p><div class="ot ou gq gs ov ow"><a href="https://github.com/Alekseyyy/ctfs/tree/main/2020/decompetition" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd iv gz z fq pb fs ft pc fv fx it bi translated">Alekseyyy/ctfs</h2><div class="pd l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="pe l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">github.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ka ow"/></div></div></a></div><h1 id="7144" class="kc kd iu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">大声喊出来</h1><p id="eb53" class="pw-post-body-paragraph lx ly iu lc b ld le lz ma lf lg mb mc lh md me mf lj mg mh mi ll mj mk ml ln in bi translated"><a class="ae mm" href="https://twitter.com/hackerfantastic" rel="noopener ugc nofollow" target="_blank">黑客奇人</a>和<a class="ae mm" href="https://twitter.com/Jennifer_Arcuri" rel="noopener ugc nofollow" target="_blank">詹妮弗·阿库里</a>因被点燃af电脑haxx0r教师，以及推特用户<a class="ae mm" href="https://twitter.com/krichard1212" rel="noopener ugc nofollow" target="_blank"> @krichard1212 </a>和<a class="ae mm" href="https://twitter.com/SYSTEMCAWL" rel="noopener ugc nofollow" target="_blank"> @SYSTEMCAWL </a></p></div></div>    
</body>
</html>