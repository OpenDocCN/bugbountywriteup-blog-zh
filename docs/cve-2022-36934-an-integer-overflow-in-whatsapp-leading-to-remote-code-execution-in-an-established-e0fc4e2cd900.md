# CVE-2022–36934:WhatsApp 中的整数溢出导致在已建立的视频通话中远程执行代码

> 原文：<https://infosecwriteups.com/cve-2022-36934-an-integer-overflow-in-whatsapp-leading-to-remote-code-execution-in-an-established-e0fc4e2cd900?source=collection_archive---------0----------------------->

作者:[安舒尔·维亚斯](https://www.instagram.com/_ansh_vyas/)

![](img/1dd0f988c3528014685fdd80d33f7852.png)

[Eyestetix 工作室](https://unsplash.com/@eyestetix?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

# 概观

已建立的视频呼叫中的位数可能会因整数溢出而增加，从而导致远程代码执行(RCE)。根据位数，它可以高于或低于最小可表示值。攻击者可以通过写入更大的值来覆盖系统内存的其他部分，并滥用此功能来远程执行代码。攻击者可以通过操纵 WhatsApp 组件视频调用处理程序来利用此 RCE 漏洞，从而触发基于堆的缓冲区溢出并接管 WhatsApp Messenger。

# 整数溢出

在大多数编程语言中，通常为整数值分配一定数量的位。例如，使用 32 位整数数据类型，space 可以保存范围从 0 到 4，294，967，295 的无符号整数或范围从 2，147，483，648 到 2，147，483，647 的有符号整数。通常，最高有效位(第一位)表示一个整数在有符号整数中是正数还是负数。如果执行计算 4，294，967，295 + 1，当您尝试存储大于整数类型最大值的值时会发生什么，这完全取决于语言和编译器。

然而，许多语言和编译器根本不会产生任何错误，而是执行模运算、循环和截断，或者以其他未定义的方式运行。上面的例子通常得到 0。有符号整数可能会产生更多意想不到的结果。当有符号整数超过其最大值时，结果通常为负。例如，2，147，483，647 +1 通常是 2，147，483，648。当超过最小值(下溢)时，通常返回负数。例如，2，147，483，648-1 通常为 2，147，483，647。

与加法、减法或乘法等典型运算相反，类型转换过程也可能导致整数溢出。例如，一个整数可能被一个操作视为无符号整数，而被另一个操作视为有符号整数，从而导致对值的错误解释。如果在计算缓冲区长度时出现整数溢出，缓冲区可能会溢出。

# 缓冲区溢出

在软件应用程序中达到其地址边界的结果是，当其内存区域写入相邻的内存区域时，会发生缓冲区溢出。堆栈和堆是软件漏洞代码中溢出的两个常见目标。堆是一个内存区域，程序可以请求内存块以供其使用。

在缓冲区溢出中，信息被放入分配的内存区域。它们是不同类型的溢出。开发人员必须在计算机内存中划出一些空间，然后才能向内存中写入任何内容。在应用程序的执行过程中，他们需要存储大量的变量和信息。

然而，为了检查您将什么放入缓冲区，开发人员需要非常小心。如果您将缓冲区设置为特定的大小，您不希望其他人存储比该缓冲区更大的内容，否则会出现缓冲区溢出。每当以特定的方式使用缓冲区溢出时，缓冲区溢出对于坏人来说是非常强大的。

问题是，找到一种特定的情况，允许您以总是为您提供某种结果并且不会导致计算机崩溃的方式溢出缓冲区，这是极其困难的。相反，向计算机请求特殊权限，如操作系统的 root 访问权限或管理员访问权限。因此，如果您可以用易受溢出影响的应用程序或操作系统重复执行缓冲区溢出，坏人现在就可以访问使用它的所有系统。我们试图通过修补或修改可能易受缓冲区溢出攻击的应用程序来避免这种情况。这显示了缓冲区溢出可能导致的后果的一个简化示例。

但是，它确实说明了您是如何利用缓冲区溢出来操纵信息的。我们在内存中有两个变量 A 和 B。没有为变量 a 分配任何字节。它有一些可用的字节，但是在内存中的特定区域没有增加。然而，变量 B 包含数据。就坏人而言，更改变量 B 将允许他们获得对您计算机的额外访问权限。它十进制有 1979，十六进制是零七 BB。

为了改变这个字节，也就是十六进制的零七，他们打算做点别的。因此，他们会将信息添加到变量 A 中，这些信息会溢出到变量 b 中。我们的计划是将过量的信息添加到变量 A 中。如您所见，这溢出到下一个字节中。它是 e- x- c- e- s- s- i- v- e，通常在末尾是一个字节。现在 65 在 B 前面，十六进制值就变了。使用十进制单位，六五零零等于 25，856，这是一个与原来存在的数字非常不同的数字。我们所做的只是改变了存储在 A 中的内容，我们设法修改了存储在 B 中的内容，这是不应该发生的。此时，您的缓冲区溢出发生了，坏人可能操纵变量为所欲为。

# 结论

旧版本的 OpenSSH 中的一个错误导致了缓冲区溢出，这是整数溢出的结果

```
nresp = packet_get_int(); 
**if** (nresp > 0) 
{  
     response = xmalloc(nresp*sizeof(**char***));  
     **for** (i = 0; i < nresp; i++)   
          response[i] = packet_get_string(NULL); 
}
```

在 nresp 为 1073741824 且 sizeof(char*)为 4(这是典型值)的情况下，表达式 nresp*sizeof(char*)会导致溢出。xmalloc()分配了一个 0 字节的缓冲区。攻击者可能通过利用后续循环执行任意代码，这将导致堆缓冲区溢出。

## 来自 Infosec 的报道:Infosec 每天都有很多内容，很难跟上。[加入我们的每周简讯](https://weekly.infosecwriteups.com/)以 5 篇文章、4 条线索、3 个视频、2 个 GitHub Repos 和工具以及 1 个工作提醒的形式免费获取所有最新的 Infosec 趋势！