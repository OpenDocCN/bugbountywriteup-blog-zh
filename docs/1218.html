<html>
<head>
<title>Exploiting a Windows-Based Buffer Overflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用基于Windows的缓冲区溢出</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/exploiting-a-windows-based-buffer-overflow-e4d1b6f6d5fb?source=collection_archive---------0-----------------------#2021-04-12">https://infosecwriteups.com/exploiting-a-windows-based-buffer-overflow-e4d1b6f6d5fb?source=collection_archive---------0-----------------------#2021-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c9a74da3314fb318dd3db685202f4f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*ek7Od8WlbZYFk_RYI7RE0Q.png"/></div></figure><p id="6537" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本文基于使用Vulnserver在Windows中利用一个简单的缓冲区溢出。如果您对缓冲区溢出没有概念，可以在这里阅读我以前关于利用Linux缓冲区溢出的文章，<a class="ae ks" href="https://ravi5hanka.medium.com/privilege-escalation-in-linux-via-a-local-buffer-overflow-dcee4f9b4a49" rel="noopener">https://ravi 5 hanka . medium . com/privilege-escalation-in-Linux-via-a-local-buffer-overflow-dcee 4 F9 B4 a 49</a></p><h2 id="3025" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">使用的工具和操作系统</h2><ul class=""><li id="8aab" class="lm ln iq jw b jx lo kb lp kf lq kj lr kn ls kr lt lu lv lw bi translated">受害者— Windows 10</li><li id="b89e" class="lm ln iq jw b jx lx kb ly kf lz kj ma kn mb kr lt lu lv lw bi translated">攻击者— Parrot OS</li><li id="2d94" class="lm ln iq jw b jx lx kb ly kf lz kj ma kn mb kr lt lu lv lw bi translated">免疫调试器(【https://www.immunityinc.com/products/debugger/】T2</li><li id="8625" class="lm ln iq jw b jx lx kb ly kf lz kj ma kn mb kr lt lu lv lw bi translated">vulnserver(【https://github.com/stephenbradshaw/vulnserver】T4</li><li id="9579" class="lm ln iq jw b jx lx kb ly kf lz kj ma kn mb kr lt lu lv lw bi translated">你可以从这里得到我用过的脚本和python程序，<a class="ae ks" href="https://github.com/ravi5hanka/Windows-Buffer-Overflow-" rel="noopener ugc nofollow" target="_blank">https://github.com/ravi5hanka/Windows-Buffer-Overflow-</a></li></ul><h2 id="1eb3" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">起步</h2><p id="a753" class="pw-post-body-paragraph ju jv iq jw b jx lo jz ka kb lp kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">在受害者中，安装immunity debugger并提取Vulnserver zip的内容。然后以管理员身份运行Vulnserver.exe<strong class="jw ir">。</strong></p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/531da685a147ad050208a5c3d1b569ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*xl_k5XcUqckKAKDzL6rriw.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">以管理员身份运行vulnserver.exe</figcaption></figure><p id="b309" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后以管理员身份打开免疫调试器<strong class="jw ir">，通过<strong class="jw ir"> <em class="mo">文件→附加→ vulnserver →附加将vulnserver进程附加到免疫调试器。</em>T15】</strong></strong></p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/fd4620d8ae28c00e17b1a110e3861ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*mRsccM7NHPGc5kSKfqFpfg.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">将vulnserver进程附加到调试器</figcaption></figure><p id="1fa7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么调试器将如下所示。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/da284cf37a1ced48516d1c0c65ce2a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y65McUxy33tn-EtNjOnX5Q.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">将vulnserver进程附加到调试器后</figcaption></figure><p id="c2cb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">点击<strong class="jw ir"> F9 </strong>键将其状态从<strong class="jw ir">暂停</strong>变为<strong class="jw ir">运行</strong>。然后你需要受害者的<strong class="jw ir"> IP(在CMD中使用<strong class="jw ir"> ipconfig </strong>命令)。我们知道vulnserver在<strong class="jw ir"> 9999 </strong>打开一个端口(阅读Vulnserver的readme.md文件)。然后移动到您的攻击者机器，通过netcat连接到vulnserver。</strong></p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/c798173ea2982709b19ce61b4d747bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*W_ip8shmYUUJFMc0K4gCfw.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">通过netcat连接到vulnserver</figcaption></figure><p id="aa0a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，HELP command显示了我们可以与vulnserver一起使用的命令。所以，让我们一步一步来。</p><p id="1a08" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意<strong class="jw ir"> : </strong> <strong class="jw ir">在Spiking后的每一步，关闭调试器，以管理员身份再次打开vulnserver和调试器，重新附加进程并运行。</strong></p><h2 id="5712" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">尖峰形成</h2><p id="ddc8" class="pw-post-body-paragraph ju jv iq jw b jx lo jz ka kb lp kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">在这个步骤中，我们<strong class="jw ir">识别易受攻击的参数</strong>。我们可以对上面的每个命令发出一串字符，看看程序是否会崩溃。如果它崩溃了，我们可以确定它是脆弱的。</p><p id="5711" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们接受统计数据命令。首先，按如下方式创建一个峰值脚本。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/b819381a634fb5996b8988901e19e308.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*nF7TqfPMGP46ftIVAptObQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">STATS命令的尖峰脚本</figcaption></figure><p id="28b3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后使用<strong class="jw ir"> generic_send_tcp </strong>发送上述脚本，如下。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/89cd47b174b077b0858c973b59177d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*pP8_BeQNTCShlY9pin7IUw.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">generic_send_tcp with STATS.spk</figcaption></figure><p id="c401" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">执行上面的时候看看免疫调试器。你会发现没有什么奇怪的事情发生。正如我们上面所做的，你可以测试所有的参数。</p><p id="5e7d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们取<strong class="jw ir"> TRUN </strong>参数。您需要如下更改spike脚本。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/f51a3ce56e21dd98d8439a2d4198dc5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*02ytSUDbY-p3Kc71bJgI0w.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">TRUN.spk</figcaption></figure><p id="3a83" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后像我们之前做的那样使用<strong class="jw ir"> generic_send_tcp </strong>，这一次，使用<strong class="jw ir"> TRUN.spk </strong>并观察抗干扰调试器。您将遇到如下崩溃。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mz"><img src="../Images/81e6399ec1b47a2395b35586424eb1d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0JMiFp_PrqPFLLzAiYGzQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">调试器崩溃</figcaption></figure><p id="d247" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们查看寄存器部分，可以看到一些重要的内存位置被一串“A”覆盖，如下所示。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/33ee98ec82c90d6a1667b82e29927837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*nHeit9stgSvdUp6vjCPMnQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">寄存器被“A”覆盖</figcaption></figure><p id="31b2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这意味着这里存在一个漏洞，我们可以进一步利用它。EIP <strong class="jw ir"> 41414141 </strong>的十六进制值代表ascii字符“<strong class="jw ir"> AAAA </strong>”。这意味着EIP的长度为<strong class="jw ir"> 4字节</strong>。</p><h2 id="a44a" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated"><strong class="ak">起毛</strong></h2><p id="e9b2" class="pw-post-body-paragraph ju jv iq jw b jx lo jz ka kb lp kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">我们已经将“TRUN”确定为易受攻击的参数。起毛类似于扣球。然而，我们不是攻击不同的参数，而是专门攻击易受攻击的参数<strong class="jw ir"> TRUN，</strong>，以便了解崩溃发生的位置。</p><p id="55b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用以下python程序执行模糊化。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nb"><img src="../Images/553a5c2359842c17bc62242982187d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0gll2FFCrxUv5p_8R4H07g.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">用于模糊化的Python程序</figcaption></figure><p id="a53d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">给予上述程序执行权限并运行它。运行时，观察vulnserver。一旦<strong class="jw ir">完成</strong>说“<strong class="jw ir">连接关闭</strong>”，如下:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/96a254477acdf1985ce9b5e296cd24d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*LMIasfw1JuoFWA3_tuBAww.png"/></div></figure><p id="dcd2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在您的终端中立即点击<strong class="jw ir"> ctrl+c </strong>，以中断程序的执行，如下所示。(这是需要的，因为程序不会自动停止。)</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/abfcdc745e303648ca256086aa2b3e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*DzrAXBQ-HvS36DNSgTjwgg.png"/></div></figure><p id="3d61" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，崩溃发生在<strong class="jw ir">大约3000字节</strong>处。调试器的寄存器部分如下所示。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/577425220e0703e0b263405ab77c0dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*B5fKD5P1U2B_Lo51iuGxHw.png"/></div></figure><p id="137c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如你所见，它没有覆盖<strong class="jw ir"> EIP </strong>寄存器。所以，我们的目标是找到EIP的确切位置。如果我们可以控制EIP，我们就可以将它指向我们的恶意代码，并获得一个反向外壳。</p><h2 id="90b9" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated"><strong class="ak">寻找偏移量</strong></h2><p id="841e" class="pw-post-body-paragraph ju jv iq jw b jx lo jz ka kb lp kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">我们必须找到EIP的确切字节位置。首先使用Metasploit提供的<strong class="jw ir"> pattern_create.rb </strong>工具创建一个独特的漏洞字符串，如下所示。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nf"><img src="../Images/f3e1ecb76cf938281d480fe36fe96b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hS13INy_xL1aLUZbqyqs-A.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">使用msf工具生成漏洞利用模式</figcaption></figure><p id="e17b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于我们知道字节长度在3000左右，所以要用<strong class="jw ir"> -l </strong>开关给它，如上图。作为结果，您将得到一个冗长的模式。将它复制并粘贴到之前使用的python程序中，做一些如下的小改动。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ng"><img src="../Images/6f03c28045e909d43b6d3d70e91dcb7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnwwqyCt5-aWUJYSA2k8EA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">offset.py</figcaption></figure><p id="36e2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">执行上述程序，并观察抗干扰调试器。你会遇到崩溃。这里我们需要关注的是EIP 的<strong class="jw ir">值，如下所示。需要找到确切的字节位置。</strong></p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/d78874fdf7d2f6ec28f07326a7268e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*68fjGj63CsSCL7eJo-YEmA.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">EIP的十六进制值</figcaption></figure><p id="483f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们需要使用另一个名为<strong class="jw ir"> pattern_offset.rb </strong>的msf工具，以便<strong class="jw ir"> </strong>找到offset(EIP)的确切字节位置，如下所示。记得用<strong class="jw ir"> -q </strong>开关提供上述发现值。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ni"><img src="../Images/cd56eb708ed9af433cbf5bd52f4e5a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OpJdBODsFE9e3ymINBz9Rw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">EIP的精确字节位置</figcaption></figure><p id="6204" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，这意味着我们可以将EIP控制在<strong class="jw ir"> 2003字节。</strong></p><h2 id="8508" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">覆盖EIP</h2><p id="7397" class="pw-post-body-paragraph ju jv iq jw b jx lo jz ka kb lp kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">现在我们知道，在到达EIP之前有2003个字节，而EIP本身有4个字节长。让我们尝试重写这4个特定字节。</p><p id="1227" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">之前使用的python程序可以用于此，只需做如下修改。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nj"><img src="../Images/b447ead62ea79fde8d840b3d4a91ce96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qtB75jxWmyxSRUZS7e4Hdw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">overwriteEIP.py</figcaption></figure><p id="c25f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果一切正常，EIP的值应该是<strong class="jw ir">42424242</strong>(“BBBB”的十六进制值)。因此，运行上面的程序并观察调试器。您将看到以下内容。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/cc13ba194f29ecd4c5237da1a0102cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*tikqP9HRIc4Vb9ZaxPtU8Q.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">EIP值= 42424242</figcaption></figure><p id="8e0e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这意味着，EIP被“BBBB”覆盖，现在我们控制了EIP。</p><h2 id="21e0" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">寻找不良角色</h2><p id="2b34" class="pw-post-body-paragraph ju jv iq jw b jx lo jz ka kb lp kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">现在我们需要确保发送给vulnserver的任何内容都被正确读取。如果有一个字没有读对，我们的开发就会失败。因此，我们可以发送每一个可能的字符，并检查他们发生了什么。为此，我们可以使用<strong class="jw ir"> mona.py </strong>。您可能需要手动将mona python程序添加到immunity调试器中。跟着这个，<a class="ae ks" href="https://github.com/corelan/mona" rel="noopener ugc nofollow" target="_blank">https://github.com/corelan/mona</a>。</p><p id="2b55" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下达命令<strong class="jw ir">！mona bytearray </strong>会给你从<strong class="jw ir"> \x00 </strong>到<strong class="jw ir"> \xff </strong>的所有<strong class="jw ir"> </strong>可能的字符，它保存在immunity debugger安装文件夹内的一个文本文件中。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nl"><img src="../Images/90c103255031cc557a201a3012237bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwcU17njRe8b93qe5oueOg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">“的输出mona bytearray "命令</figcaption></figure><p id="c704" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将这些字符复制并粘贴到前面的python脚本中，如下所示。由于<strong class="jw ir"> \x00 </strong>总是一个不好的字符，我们需要删除它。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nm"><img src="../Images/c21233315a414bbef5f9544461944719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bgMB-JNQl4EM9spUvjAlA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">badchars.py</figcaption></figure><p id="9835" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">运行上面的程序并观察调试器。我们要重点关注的是<strong class="jw ir">六角转储</strong>。因此，右键单击ESP寄存器，然后单击“转储中的跟随”。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/52cd99043451abe7ab69e9dceacbccff.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*U07maCoUmod1xmc4g9tIZQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">十六进制转储</figcaption></figure><p id="9054" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如你所见，没有坏人；数字就在那里。(如果有坏的字符，就会有乱序的数字)。所以，唯一不好的角色是<strong class="jw ir"> \x00。</strong></p><h2 id="4a95" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">寻找合适的模块</h2><p id="faa6" class="pw-post-body-paragraph ju jv iq jw b jx lo jz ka kb lp kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">现在，我们需要在一个程序中找到一个文件(例如:dll ),它没有像ASLR、DEP等内存保护机制。以前使用的mona.py可用于此目的。</p><p id="496d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用命令<strong class="jw ir">！在调试器中打开模块</strong>，你会发现有一个名为<strong class="jw ir">essfunc.dll、</strong>的dll文件，它没有内存保护。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi no"><img src="../Images/655220aaf078b63fc22be215f90de3ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3cPszAwnFc8ERxSAJL7FHQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">命令的输出”！mona模块”</figcaption></figure><p id="0ab7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以发送带有外壳代码的有效载荷，并使用<strong class="jw ir"> JMP ESP </strong>(跳转到ESP寄存器)指令跳转到我们的外壳代码。所以，让我们用<strong class="jw ir">检查一下【essfunc.dll】、</strong>关联的<strong class="jw ir"> JMP ESP </strong>指令是否可用！mona jmp -r esp -m "essfunc.dll" 命令如下。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi np"><img src="../Images/974b1923a0c058b41e5759c50f818652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OXgsZGyAHXBNZ3OAk_iL1Q.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">！mona jmp -r esp -m "essfunc.dll "</figcaption></figure><p id="2166" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">获取第一个返回地址值<strong class="jw ir"> 625011af </strong>，并在python程序中使用它，如下所示。我们将使用上面找到的地址覆盖EIP。记住以相反的顺序使用它，因为x86体系结构是小端的。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nq"><img src="../Images/71006763940f54de958740ed7226c19d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ve2XSI9yJYgd6Uycr6vghg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">jmpESP.py</figcaption></figure><p id="7e3b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在运行上述程序之前，在调试器中的<strong class="jw ir"> 625011af处放置一个断点。</strong>(找到地址后，点击<strong class="jw ir"> F2 </strong>添加断点)。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/826e86ab3124265456fc28420cf80aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*BkNIYgGwZu9Rkm0XQZBThQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">在<strong class="bd kv"> 625011af </strong>上的断点</figcaption></figure><p id="e6fb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后运行上面的python程序。观察调试器，您将看到以下内容。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b91f14acc6408d68514f47eaa1a018d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*qbThByGMUcxbDFFgbjZxaQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">EIP被625011af覆盖</figcaption></figure><p id="a2f6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这意味着我们可以用JMP ESP的返回地址覆盖EIP。所以，现在我们只需要将它指向我们的外壳代码。</p><h2 id="aeb0" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">生成外壳代码</h2><p id="fd5f" class="pw-post-body-paragraph ju jv iq jw b jx lo jz ka kb lp kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">现在我们需要一个外壳代码，以便使用上述python漏洞。您可以使用msfvenom生成外壳代码，如下所示。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nt"><img src="../Images/2d0c8dc2b98d957d3140c3b433eb82a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uEywA4ZhMePS2-RbLygcvQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">生成外壳代码</figcaption></figure><p id="31f5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如上所示，您必须定义有效负载类型以获得反向shell，定义攻击者机器的IP和端口，文件类型为c，体系结构为x86，因为我们只有\x00作为坏字符，所以在这里定义它。您将得到一个冗长的外壳代码作为输出。复制它。</p><h2 id="5428" class="kt ku iq bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">获得反向外壳</h2><p id="51c3" class="pw-post-body-paragraph ju jv iq jw b jx lo jz ka kb lp kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">将上述外壳代码粘贴到python程序中，如下所示。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">revShell.py</figcaption></figure><p id="c790" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面的程序将发送一串“A ”,直到它到达EIP，EIP将被JMP ESP的返回地址覆盖。因此，vulnserver将执行JMP ESP指令，它将指向我们的外壳代码。此外，您需要在JMP ESP的返回地址和外壳代码之间添加一个NOP slide("\x90"*32)，以便安全执行该漏洞利用。</p><p id="a7a8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们不需要调试器了。因此，请关闭它，并以管理员身份重新打开vulnserver。</p><p id="7be2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后使用创建外壳代码时使用的端口创建一个<strong class="jw ir"> netcat监听器</strong>(在我的例子中是5555)。此时，您可能需要关闭windows defender防火墙。</p><p id="2aca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后执行上面创建的python漏洞，并查看一下监听器。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nw"><img src="../Images/f211602f1cbee4f23343d79734f1808c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VT-AGO6nixkUquT7jOBQXg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">反向外壳</figcaption></figure><p id="4615" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">瞧啊。！！我们得到了Windows受害者机器的反向外壳。</p><p id="0beb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">自己试试这个，你一定会喜欢的。在LinkedIn上帮我联系，<a class="ae ks" href="https://www.linkedin.com/in/ravishanka-silva-a632351a0" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/ravishanka-silva-a632351a0</a>/</p><p id="faae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">黑客快乐！！！</p><p id="8d0f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">感谢对OSCP考试的帮助，</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><a href="https://www.buymeacoffee.com/ravi5hanka"><div class="gh gi nx"><img src="../Images/fd1ce4bb5a0a84f5def26393118764be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U5D4zRxkiDfNftPD"/></div></a></figure></div></div>    
</body>
</html>