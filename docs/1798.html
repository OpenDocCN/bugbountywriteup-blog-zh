<html>
<head>
<title>Windows application exploitation series PART 1 — Leaky Handles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Windows应用程序开发系列第1部分—泄漏句柄</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/windows-application-exploitation-series-part-1-leaky-handles-dae031011a4e?source=collection_archive---------3-----------------------#2022-01-11">https://infosecwriteups.com/windows-application-exploitation-series-part-1-leaky-handles-dae031011a4e?source=collection_archive---------3-----------------------#2022-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ef4e525c84ef0c4ea6b34679c140aeae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYhbyvH_wcO9bd1nxbGasQ.jpeg"/></div></div></figure><h1 id="7f3c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">关于windows应用程序开发系列:</strong> <br/>在这个系列中，我们将看看开发Windows应用程序的几种独特方法。</h1><p id="d11a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="ky ir"> <em class="lu">完整故事上:</em></strong><a class="ae lv" href="https://rehacks.live/t/windows-application-exploitation-series-part-1-leaky-handles/14" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="lu">https://rehacks . live/t/windows-应用-开发-系列-部分-1-漏洞-句柄/ </em> </strong> </a></p><h1 id="e5b5" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">第1部分:泄漏手柄</strong></h1><p id="c767" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Github回购链接<br/><a class="ae lv" href="https://github.com/abankalarm/ReHacks/tree/main/Leaky%20Handles" rel="noopener ugc nofollow" target="_blank">https://github . com/abankalarm/re hacks/tree/main/Leaky % 20 handles</a></p><p id="a763" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><strong class="ky ir">什么是手柄？根据MSDN，对象是代表系统资源的数据结构，可以是文件、进程、线程等。<br/>然而，我们不能与它们直接交互，要访问资源或对象我们需要它们的句柄。</strong></p><p id="d257" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">获取句柄很简单，可以通过多种方式完成，使用OpenProcess的一个简单示例是:</p><blockquote class="mb mc md"><p id="c7ae" class="kw kx lu ky b kz lw lb lc ld lx lf lg me ly lj lk mf lz ln lo mg ma lr ls lt ij bi translated">int PID =<insert pid="" here="">；<br/>HANDLE h PROCESS = open PROCESS(PROCESS _ ALL _ ACCESS，true，PID)；</insert></p></blockquote><p id="31e9" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">但是，要获得进程的句柄，您需要有一定的权限。用户进程不能只获得管理员进程的句柄并直接对其进行更改，因为这将允许用户进程以更高的权限向进程中注入代码或控制其行为，这将最终导致诸如远程或本地权限提升、dos等漏洞。</p><h1 id="cf5d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">漏句柄及其继承</strong></h1><p id="99b5" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这可以描述为一个场景，其中资源的句柄泄漏给另一个进程(子进程)，现在它可以与它原来无权访问的资源进行交互。</p><p id="ee38" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">此时，理解句柄可以在父进程和子进程之间继承是很重要的，即使它们在不同的权限下运行。</p><p id="0ab9" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">[MSDN句柄继承](<a class="ae lv" href="https://docs.microsoft.com/en-us/windows/win32/sysinfo/handle-inheritance" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/windows/win32/sysinfo/handle-inheritance</a>)对此进行了解释，并展示了一个相同的场景。</p><p id="d0c6" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">当应用程序打开一个资源的句柄而不关闭它时，它会导致句柄泄漏或内存泄漏，在这种情况下，内存被分配但从未被释放。</p><h1 id="acd1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">漏洞</strong></h1><p id="fbda" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">不关闭句柄或糟糕的编码会导致多种情况:</p><p id="38c4" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">1.句柄没有关闭，但是攻击者不能以误用代码的方式注入代码。在这种情况下，攻击者仍然可以通过产生大量句柄来造成DOS条件，这些句柄将填满内存并最终使应用程序或系统崩溃。这也可以远程完成。<br/>举例。[Telnet DOS](<a class="ae lv" href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2001-0346)**" rel="noopener ugc nofollow" target="_blank">http://cve.mitre.org/cgi-bin/cvename.cgi?name=2001-0346)** </a> <br/>会话终止时，telnet无法正确关闭句柄。这会导致资源耗尽，并导致无法建立新会话的拒绝服务情况。<br/>尽管这是一个古老的例子，但这是相当普遍的。</p><p id="2a58" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">2.当特权句柄泄漏给特权较低的进程时，它允许特权较低的进程提升其特权，从而导致特权提升的标准情况。<br/>举例。【Cygwin local privilege escalation】(<a class="ae lv" href="https://masthoon.github.io/exploit/2019/03/29/cygeop.html)**" rel="noopener ugc nofollow" target="_blank">https://mast hoon . github . io/exploit/2019/03/29/cygeop . html)* *</a><br/>我们将更多地关注这个场景。</p><p id="2fca" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">完整报道:<a class="ae lv" href="https://rehacks.live/t/windows-application-exploitation-series-part-1-leaky-handles/14" rel="noopener ugc nofollow" target="_blank">https://re hacks . live/t/windows-application-exploation-series-part-1-leaky-handles/</a></p></div></div>    
</body>
</html>