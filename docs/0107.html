<html>
<head>
<title>Let’s Figure out how Notepad Supports Unix Line Endings (Part II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们弄清楚记事本是如何支持Unix行尾的(第二部分)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/lets-figure-out-how-notepad-supports-unix-line-endings-part-ii-2755c001611c?source=collection_archive---------1-----------------------#2018-05-13">https://infosecwriteups.com/lets-figure-out-how-notepad-supports-unix-line-endings-part-ii-2755c001611c?source=collection_archive---------1-----------------------#2018-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ccad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文继续讨论记事本如何支持Unix和Macintosh行尾。在<a class="ae kl" href="https://medium.com/bugbountywriteup/lets-figure-out-how-notepad-supports-unix-line-endings-part-i-26d54b29cf93" rel="noopener">第一部分</a>中，我们已经发现应用程序如何通过<code class="fe km kn ko kp b">SendMessage</code>检索和设置行尾类型。第一部分的结尾提到，简单地创建一个编辑公共控件并不能使它支持LF和CR行尾。我们将在本文中讨论如何解决这个问题。</p><p id="95a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回想一下，微软<a class="ae kl" href="https://blogs.msdn.microsoft.com/commandline/2018/05/08/extended-eol-in-notepad/" rel="noopener ugc nofollow" target="_blank">公告</a>提到有两个注册表项允许你配置这个特性:在<code class="fe km kn ko kp b">HKEY_CURRENT_USER\Software\Microsoft\Notepad</code>下，将<code class="fe km kn ko kp b">fWindowsOnlyEOL</code>设置为1会导致记事本忽略Linux/Mac行尾(即与之前相同)，将<code class="fe km kn ko kp b">fPasteOriginalEOL</code>设置为1会使记事本不修改粘贴文本中的EOLs。这是一个暗示，可能在公共控件级别，这个特性在默认情况下是关闭的。也许我们需要向编辑控件发送一些消息来启用它。</p><p id="1676" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">找出这两个注册表设置如何影响编辑控件的一个简单方法是在读取这些注册表项时查看调用堆栈。这可以通过在WinDbg中设置条件断点或使用进程监视器来完成。我发现使用进程监视器更容易，但是两者都是可行的。</p><p id="5a77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在进程监视器中，我们设置过滤器只显示<code class="fe km kn ko kp b">notepad.exe</code>注册表事件。然后在列表中找到<code class="fe km kn ko kp b">fWindowsOnlyEOL</code>和<code class="fe km kn ko kp b">fPasteOriginalEOL</code>。选择事件条目，按Ctrl-P，然后打开堆栈选项卡:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/c1fcb179f52960a590a8c2b54ed5b951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcL8I50Rfp4pqZMuaL64Fg.png"/></div></div></figure><p id="892f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的框架是#7: <code class="fe km kn ko kp b">GetGlobals</code>，因为我们想看看记事本读取这两个键后，是如何使用它们的值的。那么我们来考察一下IDA Pro中的功能<code class="fe km kn ko kp b">notepad!GetGlobals</code>:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lc"><img src="../Images/a14d5ced95a71212e0824f7cafd751ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*waFfy6XtbPBU1UexQFgZlg.jpeg"/></div></div></figure><p id="83da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记事本将注册表值保存到全局变量<code class="fe km kn ko kp b">_fWindowsOnlyEOL</code>和<code class="fe km kn ko kp b">_fPasteOriginalEOL</code>中。然后我们跳到<code class="fe km kn ko kp b">SetEditControl</code>，在该函数中<code class="fe km kn ko kp b">_fWindowsOnlyEOL</code>被读取:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ld"><img src="../Images/a31b9cf6fa543b9afaddbf9a71043efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WPOC_2OZgwu4GD5k7byRQ.jpeg"/></div></div></figure><p id="e8f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码相当于下面的C++代码:</p><pre class="kr ks kt ku gt le kp lf lg aw lh bi"><span id="c7cb" class="li lj iq kp b gy lk ll l lm ln">SendMessage(_hwndEdit, EM_LIMITTEXT, 0, 0);<br/>SendMessage(_hwndEdit, 0x150A, 3, (_fWindowsOnlyEOL ? 0 : 3)); <br/>SendMessage(_hwndEdit, 0x150A, 4, (_fPasteOriginalEOL ? 0 : 4));</span></pre><p id="f40c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着，要实现完整的Unix/Mac EOL处理，我们只需调用:</p><pre class="kr ks kt ku gt le kp lf lg aw lh bi"><span id="0338" class="li lj iq kp b gy lk ll l lm ln">SendMessage(_hwndEdit, 0x150A, 3, 3);<br/>SendMessage(_hwndEdit, 0x150A, 4, 4);</span></pre><p id="c7c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加这两行之后，我的测试程序现在能够处理所有的EOL字符:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lo"><img src="../Images/db7f168fde348ef64a04b1f7adad2aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5x8emaSxs5jgPyPvnlsfNA.jpeg"/></div></div></figure><p id="ed13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一个尚未探索的领域是EOL检测。同样，我们可以从函数名中找到一些提示:有一个函数叫做<code class="fe km kn ko kp b">Comctl32!EditML_EOLDetectChar</code>。该名称表明它负责处理行尾检测。为了找出如何从应用程序中调用它，我们启动记事本并在这个函数上设置一个断点。</p><pre class="kr ks kt ku gt le kp lf lg aw lh bi"><span id="0d66" class="li lj iq kp b gy lk ll l lm ln">0:000&gt; bp COMCTL32!EditML_EOLDetectChar<br/>0:000&gt; g</span></pre><p id="638d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果这个函数在UI出现之前被调用了三次。前两个调用发生在文本文件加载之前，所以我们可以跳过它们。第三次，调用堆栈是:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lp"><img src="../Images/20aa2d2ec53115fad881faad0be03a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQs4FK7fyO3vkLWjQl-k6g.jpeg"/></div></div></figure><p id="a50f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里记事本调用<code class="fe km kn ko kp b">SendMessageW(0x6078C, 0x00BC, 0x06A30004, ...)</code>。<code class="fe km kn ko kp b">0x00BC</code>是<code class="fe km kn ko kp b">EM_SETHANDLE</code>的消息ID。<a class="ae kl" href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb761641.aspx" rel="noopener ugc nofollow" target="_blank">文档</a>说这个消息“设置一个多行编辑控件将使用的内存句柄”，而<code class="fe km kn ko kp b">wParam</code>参数是一个“编辑控件用来存储当前显示文本的内存缓冲区句柄，而不是分配它自己的内存”。由此，我们可以推断出<code class="fe km kn ko kp b">EditML_EOLDetectChar</code>从传递给<code class="fe km kn ko kp b">EM_SETHANDLE</code>的缓冲区中的文本中检测到了EOL字符。因此，我们可以使用以下代码来检测编辑控件中当前文本的EOL类型:</p><pre class="kr ks kt ku gt le kp lf lg aw lh bi"><span id="02ee" class="li lj iq kp b gy lk ll l lm ln">HLOCAL hMem = (HLOCAL)SendMessageW(g_hwndEdit, EM_GETHANDLE, 0, 0);<br/>HLOCAL hNewMem = LocalReAlloc(hMem, BUF_LEN, LMEM_MOVEABLE);<br/>SendMessageW(g_hwndEdit, EM_SETHANDLE, (WPARAM)hNewMem, 0);</span></pre><p id="79ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一系列文章中，我们发现了微软是如何在记事本中实现Linux和Mac行尾的。我为测试编写的程序的源代码可以在:<a class="ae kl" href="https://github.com/xiaoyinl/UnixTextboxDemo" rel="noopener ugc nofollow" target="_blank">https://github.com/xiaoyinl/UnixTextboxDemo</a>获得。</p><p id="8254" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，使用未记录的API并不是一个好主意，就像本文中没有提到的那样，但是研究一下这些内部API是如何工作的并没有什么坏处。此外，由于微软不会混淆Windows二进制文件，并提供公共符号，因此反转它们相对容易。所以如果你是逆向工程新手，我觉得挑选一些有趣的Windows EXE/DLL文件进行逆向是练习你逆向工程技能的好方法。</p></div></div>    
</body>
</html>