<html>
<head>
<title>Using a PIE binary as a Shared Library — HCSC-2020 CTF Writeup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PIE二进制文件作为共享库— HCSC-2020 CTF报道</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/using-a-pie-binary-as-a-shared-library-hcsc-2020-ctf-writeup-390a8a437f31?source=collection_archive---------0-----------------------#2020-10-23">https://infosecwriteups.com/using-a-pie-binary-as-a-shared-library-hcsc-2020-ctf-writeup-390a8a437f31?source=collection_archive---------0-----------------------#2020-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="498e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由匈牙利<a class="ae kl" href="https://nki.gov.hu/" rel="noopener ugc nofollow" target="_blank">国家网络安全中心</a>主办的<a class="ae kl" href="https://nki.gov.hu/rendezvenyek/hcsc/" rel="noopener ugc nofollow" target="_blank">匈牙利网络安全挑战赛</a> 2020 CTF预选赛平台<a class="ae kl" href="https://next.avatao.com" rel="noopener ugc nofollow" target="_blank"> Avatao Next </a>上的<a class="ae kl" href="https://next.avatao.com/events/hcsc-2020-qualifier/challenges/baseline-test/description" rel="noopener ugc nofollow" target="_blank">挑战赛“基线测试”</a>是一场难度<strong class="jp ir">难度</strong>的逆向工程大挑战。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/c316f1c4b63e8ef6e93dc1898f498faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-mqO2us1ZS0p3jl-TbD5pw.png"/></div></div></figure><h1 id="f630" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">挑战</h1><blockquote class="lw lx ly"><p id="432b" class="jn jo lz jp b jq jr js jt ju jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj kk ij bi translated">点数:300 <br/>难度:<strong class="jp ir">难度</strong></p><p id="17c4" class="jn jo lz jp b jq jr js jt ju jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj kk ij bi translated">回答一些简单的问题。</p><p id="91b8" class="jn jo lz jp b jq jr js jt ju jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj kk ij bi translated">说明</p><p id="f38a" class="jn jo lz jp b jq jr js jt ju jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj kk ij bi translated">基线测试是一种旨在测量任何情绪异常的检查。除了最初的测试，这个测试还有第二部分挑战合理性。回答每个问题以获取旗帜。</p></blockquote><p id="7072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">访问挑战是由SSH提供的(cmdline包含在挑战描述中)，在容器中有一个名为“test”的SUID二进制文件，这实际上就是挑战。运行二进制测试开始问问题:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi md"><img src="../Images/92992b706ccf6743cb70381d8f298bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qx0SIoYJ_Q-XKN7bvG3HUw.png"/></div></div></figure><p id="980b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试二进制文件应下载到本地机器进行逆向工程分析(例如使用<a class="ae kl" href="https://linux.die.net/man/1/scp" rel="noopener ugc nofollow" target="_blank"> scp </a>)。</p><p id="7465" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你给出了错误的答案，或者给出了正确的答案，但速度不够快，那就回到起点。只有快速正确的答案才有效。通过所有问题后，SUID二进制文件读取并输出文件/srv/flag.txt，该文件只能由root读取。(解释见下文。)。)</p><h1 id="7276" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第一轮问题</h1><p id="a53b" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">使用<a class="ae kl" href="https://ghidra-sre.org/" rel="noopener ugc nofollow" target="_blank"> Ghidra </a>反编译视图可以很容易地逆转这个工作流程:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mj"><img src="../Images/4c7d0545fad6831973b44dafef27e734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5KPp7EslaRuTCqknCLiaA.png"/></div></div></figure><p id="dd98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在不深入细节的情况下，FUN_001010f0()函数是main()函数，FUN_00101450()管理问题，第一个参数是指向提供问题的函数的指针，第二个参数是以秒为单位的一个答案的超时。</p><p id="417f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题提供程序函数使用以下参数提供问题和答案:</p><ol class=""><li id="3157" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated">问题的编号(0，1，2，…，7)</li><li id="c8d8" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">指向答案字符串的指针</li><li id="adae" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated">答案字符串的长度</li></ol><p id="01c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FUN_001013f0()函数提供第一轮问题，暂停时间很短，为1秒。这些是基本的、平凡的可逆静态问答对:第一个问题的答案是“细胞”另外7个问题的答案是“相通的”。</p><p id="1343" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:如果没有任何静态反转方法，动态分析可能会有所帮助。只需将<a class="ae kl" href="https://linux.die.net/man/1/ltrace" rel="noopener ugc nofollow" target="_blank"> ltrace </a>附加到运行测试流程中:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi my"><img src="../Images/deb6d7d18d1b50eb2f0616fce17ef505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9WXaBWhUCtwYx2IDyyWQQ.png"/></div></div></figure><p id="9e42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，正确的答案可以在输入答案后从strcmp调用中获取，也可以在回答前从snprintf调用中获取。</p><p id="4ac8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，这真的很容易，但有趣(也更难)的部分是下面的一个(静态反转是不可避免的)。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="394e" class="ky kz iq bd la lb ng ld le lf nh lh li lj ni ll lm ln nj lp lq lr nk lt lu lv bi translated">与二进制文件交互</h1><p id="6bea" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">在进入第二部分之前，先简单介绍一下动手解决方案。</p><p id="3837" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我最喜欢的与这种二进制文件交互的方法是使用CTF工具包<a class="ae kl" href="https://github.com/Gallopsled/pwntools" rel="noopener ugc nofollow" target="_blank"> pwntools </a>(当然；) ).</p><p id="8dd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于运行二进制文件(本地)和控制输入/输出，这种方式非常容易和舒适(Python片段回答了第一个问题):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="672e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想通过SSH与远程二进制文件交互，只需将<code class="fe nn no np nq b">c = process("./test")</code>行改为:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1e82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在有了正确的答案，我们可以进入第二部分(并切换到与<code class="fe nn no np nq b">c.interactive()</code>的互动模式):</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nr"><img src="../Images/4f05e9c39e6cf8357157a5e3487cf14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YkwUqkh8HYx-vCoHJbSgg.png"/></div></div></figure></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="0c0a" class="ky kz iq bd la lb ng ld le lf nh lh li lj ni ll lm ln nj lp lq lr nk lt lu lv bi translated">第二部分</h1><p id="6318" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">第二轮问题是动态的(随机？)16字节二进制数据(格式化为32长度的十六进制字符串)。看起来像是某种大麻。</p><p id="d956" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用ltrace进行动态分析:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ns"><img src="../Images/715e8ef8897f3b88c3d4c6095a2c7274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AT7izzQsOIWsDji-XqMjaA.png"/></div></div></figure><p id="db8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着以下问答对(还可以继续):</p><pre class="kn ko kp kq gt nt nq nu nv aw nw bi"><span id="1f1a" class="nx kz iq nq b gy ny nz l oa ob">+=========================================+================+<br/>|         Question (hash)                 | Answer (plain) |<br/>+=========================================+================+<br/>| 2f24579ea2305a2d6d15c666d90e761f        | 411-722-287    |<br/>+-----------------------------------------+----------------+<br/>| 4892eea2909a8faca148ca2fb1312c3e        | 823-168-034    |<br/>+-----------------------------------------+----------------+</span></pre><p id="c29f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回到Ghidra的静态分析。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mj"><img src="../Images/880b8822533e86c6f99db32136ebcc86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lu-rjKI04xRwLaKl3o3myw.png"/></div></div></figure><p id="8c91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答案是随机整数(来自/dev/urandom ),分成三个3位数的块。问题由FUN_00101680()以这些随机答案作为输入进行计算。</p><p id="1d2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FUN_00101680()是做什么的？它非常类似于MD5散列计算，但略有不同(移位量似乎是正确的，正弦常数似乎是正确的，但初始值似乎是不同的，可能还有一些其他差异)。</p><p id="9a64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何回答这些问题？如果我们可以计算一个字符串的哈希值(就像“测试”二进制文件所做的那样)，我们可以通过尝试所有XXX-XXX-XXX模式的变体(其中X是一个任意的数字)来暴力破解目标哈希的明文。这意味着强行1.000.000.000变异。</p><p id="8800" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这并非不可能(在类似MD5的操作中)。在我的英特尔酷睿i5–7300 u CPU上进行MD5计算基准测试(使用<a class="ae kl" href="https://hashcat.net/hashcat/" rel="noopener ugc nofollow" target="_blank"> hashcat </a>):</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oc"><img src="../Images/d26bf449affb86015ca15998b0af13f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6dyVpwHpKIcQGUQhQr9Npw.png"/></div></div></figure><p id="4969" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着1.000.000.000 MD5哈希的时间少于2.24秒(我们在5秒的时间范围内；) ).但是这种方法需要对优化的MD5代码进行一些修改，因为我们的二进制文件中的代码不是标准的MD5。</p><p id="a775" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有另一个选项，它需要一些准备，但不需要严格的反转和实现定制的优化算法。</p><h1 id="c5dd" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用二进制文件本身的函数</h1><p id="0f93" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">如果我们可以在“测试”二进制文件中重用二进制代码(未修改的),计算散列将会非常容易。用某个“XXX-XXX-XXX”参数(作为明文)调用FUN_00101680()函数，得到计算出来的哈希值，那就太棒了。</p><p id="4b32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理论上，这是可能的，因为我们的二进制文件(幸运的是)是一个PIE(位置独立的可执行文件)，它的行为非常类似于共享库。</p><p id="7237" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢<a class="ae kl" href="https://twitter.com/rh0main" rel="noopener ugc nofollow" target="_blank"> Romain Thomas的出色工作，<a class="ae kl" href="https://quarkslab.com/" rel="noopener ugc nofollow" target="_blank"> Quarkslab的</a>安全工程师，</a> <a class="ae kl" href="https://github.com/lief-project/LIEF" rel="noopener ugc nofollow" target="_blank"> LIEF项目</a> ( <strong class="jp ir">库到仪器可执行格式</strong>)在实践中帮助做了以上工作。</p><p id="313c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LIEF项目也有一个详细的<a class="ae kl" href="https://lief.quarkslab.com/doc/latest/tutorials/08_elf_bin2lib.html" rel="noopener ugc nofollow" target="_blank">教程，关于将一个ELF可执行文件转换成一个库</a>。简而言之，我们需要做的只是将所需的函数添加到导出函数的列表中(因为如果二进制文件没有被编译为库，它就是空的)。</p><p id="3380" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来看看实践中怎么做。首先，我们需要LIEF的最新未发布版本，因为我们需要从转换的二进制文件/库中删除DF_1_PIE标志，以便绕过最近的libc (≥2.29)版本中的dlopen()限制，并且DF_1_PIE支持只出现在未发布的master分支中(因此有必要进行一点耗时(在我的普通pc上大约60分钟)的编译；如果不能接受，使用旧的libc并使用简单的<code class="fe nn no np nq b">pip install</code>安装一个发布的二进制版本:</p><pre class="kn ko kp kq gt nt nq nu nv aw nw bi"><span id="26a3" class="nx kz iq nq b gy ny nz l oa ob">git clone <a class="ae kl" href="https://github.com/lief-project/LIEF" rel="noopener ugc nofollow" target="_blank">https://github.com/lief-project/LIEF</a><br/>python3 -m venv venv<br/>. ./venv/bin/activate<br/>pip install .</span></pre><p id="9015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确认二进制文件是PIE可执行文件:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi od"><img src="../Images/51fc0b1a45df87ceb229a91e5e748d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rzStyNs-ZbYwbKQC4ZOWDw.png"/></div></div></figure><p id="f585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们将所需的函数(FUN_00101680)添加到导出列表中。在Python中:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="72e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在libtest.so已经准备好了，可以调用FUN_00101680()(作为md5_custom())。用于调用md5_custom()的PoC代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">自定义_md5.c</figcaption></figure><p id="0a7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，在输出散列之前有一些否定操作数和字节交换，这来自于反转过程，它只是给CTF玩家造成一些麻烦:)。</p><p id="5676" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译为可执行文件:</p><pre class="kn ko kp kq gt nt nq nu nv aw nw bi"><span id="9d16" class="nx kz iq nq b gy ny nz l oa ob">gcc custom_md5.c -o custom_md5 -ldl</span></pre><p id="8f8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在通过上述问答对进行测试(参见<strong class="jp ir">第二部分</strong>部分的开头):</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oi"><img src="../Images/14074dd247af9e46f28649d03fdb13d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gIsth-nMWJqH0lpanVuqGg.png"/></div></div></figure><p id="e985" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好，结果和上面一样。因此，这似乎是可行的。</p><p id="9bdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但不幸的是，这不是一个优化的版本，用这个版本强制1.000.000.000哈希几乎肯定会超过5秒的障碍。</p><p id="f02b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，有一个时间-内存权衡解决方案来克服这个问题:使用预先计算的彩虹表。</p><h1 id="209f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">彩虹桌</h1><p id="8a9d" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">生成所需的rainbow表作为预计算的查找表与上面的md5_custom()调用者PoC代码几乎相同。只需要在1.000.000.000变量上添加一个循环:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">彩虹. c</figcaption></figure><p id="2da6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译是一样的:</p><pre class="kn ko kp kq gt nt nq nu nv aw nw bi"><span id="a6ca" class="nx kz iq nq b gy ny nz l oa ob">gcc rainbow.c -o rainbow -ldl</span></pre><p id="9627" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生成的表的大小非常大(并且没有优化)，大约需要45 GB的空间，所以要保存在磁盘上(保存到一个名为rainbow.txt的文件中，计算和转储用了&lt;20 mins on my pc):</p><pre class="kn ko kp kq gt nt nq nu nv aw nw bi"><span id="a36e" class="nx kz iq nq b gy ny nz l oa ob">./rainbow &gt; rainbow.txt</span></pre><p id="66cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">The resulted rainbow.txt with 1.000.000.000 lines is:</p><pre class="kn ko kp kq gt nt nq nu nv aw nw bi"><span id="ea71" class="nx kz iq nq b gy ny nz l oa ob">34a14e65171d97079f631b9dce0d307e:000-000-000<br/>279872821e4cd80dc5c79e6a247a637f:000-000-001<br/>7797d3ac947f16c7311ca103309b5609:000-000-002<br/>126d68f1dccf202eabf3eb77c4dafb1e:000-000-003<br/>a9194f2b865cb1c155e9b310cf7d651d:000-000-004<br/>...<br/>...<br/>...<br/>feaf5e97a52937e6de30e5a40eee1cad:999-999-996<br/>9ffe1659209465ebd7ed08a8ca773858:999-999-997<br/>061e3c8b0ca20f035291c0a48f2b21f4:999-999-998<br/>f81ccfa495e9856bdf2d74145884d86b:999-999-999</span></pre><p id="89ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Searching a hash in this text file is really slow, so let’s optimize it by some structured indexing. Using the file based <a class="ae kl" href="https://www.sqlite.org/index.html" rel="noopener ugc nofollow" target="_blank"> SQLite </a>数据库对于这个任务来说是一个简单但有效的解决方案。</p><p id="d650" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个数据库和一个表，然后将创建的转储文件作为csv文件导入(大约需要20分钟，大约需要+55 GB的磁盘空间):</p><pre class="kn ko kp kq gt nt nq nu nv aw nw bi"><span id="0f9a" class="nx kz iq nq b gy ny nz l oa ob">sqlite3 rainbow.db<br/>sqlite&gt; CREATE TABLE hashes(hash TEXT, text TEXT);<br/>sqlite&gt; .separator :<br/>sqlite&gt; .import rainbow.txt hashes</span></pre><p id="fc6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，创建一个高效查找散列的索引(再次花费大约20分钟，大约需要+45 GB的磁盘空间；但是，如果磁盘空间不足，现在可以删除rainbow.txt文件):</p><pre class="kn ko kp kq gt nt nq nu nv aw nw bi"><span id="72e6" class="nx kz iq nq b gy ny nz l oa ob">sqlite&gt; CREATE INDEX hash ON hashes(hash);</span></pre><p id="39bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在对散列的查找应该非常快:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oj"><img src="../Images/e69c503f8f693b235aa728809eb8ba16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pyuDm2vW_SFkaKUuTh0WdQ.png"/></div></div></figure><p id="d91c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，不要忘记退出(避免数据库文件写入时的文件同步问题):</p><pre class="kn ko kp kq gt nt nq nu nv aw nw bi"><span id="1a84" class="nx kz iq nq b gy ny nz l oa ob">sqlite&gt; .quit</span></pre><p id="d5ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在一切都准备好了。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="586e" class="ky kz iq bd la lb ng ld le lf nh lh li lj ni ll lm ln nj lp lq lr nk lt lu lv bi translated">把所有的放在一起</h1><p id="2904" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">我们有sqlite db形式的超快速查找表，所以没有什么可以阻止我们用pwntools构建最终的解决方案脚本。</p><p id="6058" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是(也可以在我的ctfs文章github repo，<a class="ae kl" href="https://github.com/tothi/ctfs/blob/master/hcsc-2020/Baseline/solve.py" rel="noopener ugc nofollow" target="_blank"> solve.py </a>)中找到:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="35ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是它的作用:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ok"><img src="../Images/3042b1eb463be85f5beab2871bceff11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_JlMDP3spXa2M8qmRyeeEA.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">应对挑战的完整解决方案</figcaption></figure><p id="2083" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看哈希求解的回答时间，比5秒快了几个数量级:)</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ol"><img src="../Images/f2501c43d55df9240f477c28a1eef83c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t1U-I3xG9vwOwJX9p4kMag.png"/></div></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">哈希查找速度超快</figcaption></figure><p id="9bc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，我喜欢这个挑战，因为PIE二进制到共享库转换的优雅而健壮的方法，以及直接调用散列计算函数(不需要严格地重新实现和/或反转它)，但是也应该有其他解决方案，例如，识别和实现散列函数的优化版本，以及不需要预先计算的表的强力方法(5秒钟就足够了)。</p><p id="f15c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有其他解决方案和/或任何问题，欢迎评论(在这里或在我的<a class="ae kl" href="https://twitter.com/an0n_r0" rel="noopener ugc nofollow" target="_blank">推特</a>)。</p></div></div>    
</body>
</html>