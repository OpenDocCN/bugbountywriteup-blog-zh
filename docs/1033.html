<html>
<head>
<title>Handling Short Expiration Time of Authorization Tokens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理授权令牌的短到期时间</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/handling-short-expiring-time-of-authorization-tokens-4e7552bdaf1a?source=collection_archive---------2-----------------------#2020-12-22">https://infosecwriteups.com/handling-short-expiring-time-of-authorization-tokens-4e7552bdaf1a?source=collection_archive---------2-----------------------#2020-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0640" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在使用Burp套件测试web应用程序或API时不浪费宝贵的时间</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/0abc111f42f99fe61e9a9216ed74fd97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*u3purQ9SIq3LbhPeKrrPmA.png"/></div></figure><h1 id="fc8c" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">介绍</h1><p id="a96c" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在我从事web/API pentesting的几年中，这是我第一次不得不考虑如何在使用Burp的入侵者进行暴力攻击的过程中以及在使用Burp的中继器时自动更新授权令牌，这样我就不必每隔十分钟手动更新一次，而在这种情况下，这是令牌的过期时间。</p><p id="0ade" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">嗯，因为我还没有看到任何关于这个特定场景的博客帖子，所以我决定自己写一篇。也许它能帮助像我最近一样挣扎的人们。</p><p id="4edd" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我实际上在一个API上做了一个pentest，它有两个主要端点:一个用于获取新的授权令牌，另一个用于使用这个令牌请求一些数据。下面您可以看到对这些端点的两个请求:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/088413162e9c31f44ffbbf534756beb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSP8Iy4L62z7wtdHyc2Hfg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">对负责为API生成新访问令牌的端点的请求</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mp"><img src="../Images/7bd6b211e6d24077cb6e78e7b28a7db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dY0lDMo2tHsJzyCNBrnidw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">对使用访问令牌的端点的请求</figcaption></figure><h1 id="e171" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">问题是</h1><p id="2388" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如您在上面的第一幅图中看到的，由于响应体中的属性“expires_in ”,在我们需要另一个令牌之前，我们有一个非常小的窗口用于与API进行交互。事实上，当我试图运行入侵者超过十分钟时，我开始得到状态代码401(未授权)。不幸的是，当我测试API时，我并没有打算就此写一篇博文，所以一旦我发现了这一点，我就简单地再次运行攻击，所有导致401的请求都会重新发出。这里没有指纹，抱歉…</p><h1 id="35c5" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">解决方案的第一部分</h1><p id="4956" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">继续前进，一旦我意识到我必须在请求新令牌之前处理这个短暂的时间框架，我就开始做每一个优秀的渗透测试人员都会做的事情:<a class="ae mq" href="https://miro.medium.com/max/455/1*snTXFElFuQLSFDnvZKJ6IA.png" rel="noopener">跪求google给我带来一个解决方案</a>。玩笑归玩笑，我知道Burp有处理会话的功能，但我以前从未使用过，也不知道这些选项在哪里。即便如此，找到它们并不困难:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mr"><img src="../Images/d2d936643448a594d7571c9905368bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgZX2x1R6qrrcvcLSThKnA.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">“会话处理规则”和“宏”在Burp套件中的位置</figcaption></figure><p id="5297" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">正如我们所看到的，描述是不言自明的:会话处理规则定义了规则。每次发出该规则范围内的请求时，都会应用它们。让我们更详细地介绍一下这个领域:</p><p id="9113" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir">会话处理规则</strong></p><p id="d197" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">此会话允许您创建具有预定义范围的规则，这些规则将在同一范围内的每个请求之前执行。它可以用来检查会话的有效性，向请求添加cookies，执行登录。重要的是要注意，所有规则都是按照它们列出的顺序应用的，考虑到它们的作用域，也就是说，如果一个规则不在某个请求的作用域内，它就不会被应用到那个特定的请求。</p><p id="56b0" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir">宏</strong></p><p id="6c4d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">引用一个非常恰当的描述:</p><blockquote class="ms mt mu"><p id="f510" class="lf lg mv lh b li mb jr lk ll mc ju ln mw md lq lr mx me lu lv my mf ly lz ma ij bi translated">宏是一个或多个(HTTP)请求的序列。您可以在会话处理规则中使用宏来执行诸如登录应用程序、获取反CSRF令牌等任务。</p></blockquote><p id="7b3b" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir">建立会话处理规则</strong></p><p id="fa67" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">知道了这两个资源是如何工作的，我们现在可以开始构建一个会话规则和宏来更新我们的访问令牌。首先让我们添加一个新规则:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mz"><img src="../Images/184418e06499352be5be3436cfcf38f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nfbeI7e5NhXirx-O_R-OGg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">添加新的会话处理规则</figcaption></figure><p id="4bee" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">在上图中，我们可以看到一个区域的简短描述，以及它被调用后将执行的动作。这也是“范围”选项卡，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/03e5c6016a5c9c501b1913d2aef227d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*9DR1bReJMngKWj9K-fiVvg.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">新会话规则的范围定义</figcaption></figure><p id="c166" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">此选项卡允许您选择将在Burp Suite的哪些部分使用此规则，它们可以应用到哪些URL，以及将规则限制为仅包含自定义参数的请求。</p><p id="7dd6" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir">添加规则动作</strong></p><p id="a926" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">定义了规则范围后，让我们添加一个在执行该规则时要执行的操作。我们将该操作命名为“检查会话是否有效”,这是事情开始变得真实的地方:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nb"><img src="../Images/e08c59346a8ebb3cb918a4494720c78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3dM-28ZkaazNHmyaVCQWrw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">会话处理规则的操作编辑器的第一部分</figcaption></figure><p id="be47" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">让我们把动作编辑器分成两部分:</p><p id="80e3" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir">规则动作编辑器:第一部分</strong></p><ol class=""><li id="dd1c" class="nc nd iq lh b li mb ll mc lo ne ls nf lw ng ma nh ni nj nk bi translated">首先，操作需要发出一个HTTP请求，作为验证会话的第一步。在这里，我说我想要发出正在被验证的相同请求，但是如果是这样的话，我也可以运行一个宏(让我们稍后再看宏)来做同样的事情。</li><li id="07b1" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">根据请求，Burp执行会话验证的频率。在图中，我们可以看到每10个请求，这在这个场景中是不必要的，但是让我们保持这种方式。</li><li id="cef2" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">在哪里检查响应以检查会话是否有效。这里我们可以看到“HTTP头”、“响应体”(我们的例子)和“重定向目标的URL”。</li><li id="78a1" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">检查响应时要看什么。在我的例子中，我必须在响应体中查找字符串“401 ”,因为这是我在令牌过期时得到的行为。注意，我们也可以查找<a class="ae mq" href="https://www.pinterest.com/pin/270708627573628298/" rel="noopener ugc nofollow" target="_blank"> regex </a>，并使搜索区分大小写。</li><li id="bb98" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">最后，对于第一部分，我们必须指出匹配意味着会话仍然有效还是无效。在我的例子中，字符串“401”意味着会话无效。</li></ol><p id="0936" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir">规则动作编辑器:第二部分</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nq"><img src="../Images/e40d72d2eabbb83e9e31486ee7d0a7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jtEnn2i-DdKB87ea6Q7xw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">会话处理规则的操作编辑器的第二部分</figcaption></figure><p id="84b6" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">第二部分分为两部分:</p><ol class=""><li id="5f27" class="nc nd iq lh b li mb ll mc lo ne ls nf lw ng ma nh ni nj nk bi translated">如果会话有效/无效会发生什么:如果它是<strong class="lh ir">有效的</strong>，则不会为该请求处理任何其他规则或操作。如果是<strong class="lh ir">无效</strong>，我选择运行宏，我们接下来会看到。</li><li id="1424" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">对于最后一部分，我们可以用最终宏响应中匹配的参数更新请求，和/或用会话处理cookie jar中的cookie更新请求。</li></ol><h1 id="9dbd" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">解决方案的第二部分</h1><p id="f833" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，注意上图中的最后一个复选框。在运行宏之后，我可以调用一个Burp扩展操作处理程序。id所做的是将宏的请求传递给扩展，它将对它们做一些事情。</p><p id="755f" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">现在，你能告诉我，如果我有一个完整的系统来处理会话，为什么我首先需要一个分机？如果仔细观察，没有一个请求实际上有会话，因为它们不使用会话cookies来处理授权。我们所拥有的只是标题<em class="mv"> Authorization: Bearer </em>后面有一个大base64，这是实际的令牌。</p><p id="6625" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">因此，经过这次旅行之后，我们可以看到Burp没有(至少现在还没有)一个内置的处理这类需求的过程:<strong class="lh ir">我需要用宏响应的部分内容替换请求头的内容。</strong>好消息是，Burp拥有整合扩展以填补这些空白的惊人能力。</p><p id="3d4f" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">因此，针对这一特定需求，有一个名为“<a class="ae mq" href="https://github.com/PortSwigger/custom-parameter-handler" rel="noopener ugc nofollow" target="_blank">自定义参数处理程序</a>”或CPH的打嗝扩展。它所做的是“以外科手术般的精度修改HTTP消息，即使是在使用宏的时候”。更确切地说，在我的场景中，它允许<a class="ae mq" href="https://github.com/elespike/burp-cph/wiki/03.-Find-and-replace" rel="noopener ugc nofollow" target="_blank">搜索和替换内部请求和响应</a>。</p><p id="af9b" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">但是在我们深入扩展的配置之前，我们必须看看这个宏到底是做什么的，因为我们很快就会需要这些知识。</p><p id="b14d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir">配置宏</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nr"><img src="../Images/88e1bb819f99a6f4872a8830f62d4d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_13FZBrSxknZZwxc0Z2V0g.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">在Burp套件中录制宏</figcaption></figure><p id="b6e1" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">在上图中，我们可以看到记录和配置宏的主窗口。如前所述，宏是一组按顺序发出的请求。此外，我们可以将一个请求的部分响应传递给下一个请求，直到得到一个最终的HTTP响应。在我的例子中，这里列出的所有请求都将被传递给CPH扩展。</p><p id="d163" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">首先，我们必须记录这个宏，也就是说，从proxy HTTP history选项卡中选择我们希望成为宏的一部分的所有请求。在我的例子中，只有它生成一个新的访问令牌:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ns"><img src="../Images/9d5b23fcf8e84db6fd6b790799169982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGYDVkcExXR-r-xyh6MClg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">在Burp套件中录制宏</figcaption></figure><p id="049d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">如果我们愿意，我们可以配置每个宏请求，从响应中获取所有需要的参数，并将它们传递给下一个请求:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nt"><img src="../Images/26d7860a07058dcfb054e03ab6963b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3affn3KmhOoOixazCg0-zg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">配置宏请求以处理参数和cookies</figcaption></figure><p id="ba86" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">虽然在这一部分我不会讲得太深，但是这个窗口允许您添加和使用来自会话处理cookie jar的每个响应的cookie，以便它们可以在下一个请求中使用。此外，我们可以非常精确地指定参数。Burp将获得这里配置的参数，并将它们传递给宏的下一个请求。</p><p id="db27" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">因此，现在您可以看到，我们没有任何选项来将头值从宏的响应替换到我们的实际请求中。这就是为什么我们需要使用CPH扩展。让我们终于看到了神奇之处:</p><p id="8ebd" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated"><strong class="lh ir">配置CPH扩展</strong></p><p id="21c2" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">让我们把这个解释分成三个部分。这首先将处理CPH选项:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nu"><img src="../Images/97ca86571070a48424f56d8d66c14121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsnZ4l8gVMvjQjE_uUrBqg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">CPH期权</figcaption></figure><ol class=""><li id="40f0" class="nc nd iq lh b li mb ll mc lo ne ls nf lw ng ma nh ni nj nk bi translated">安装扩展后，将出现CPH选项卡。</li><li id="fca9" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">在其中我们可以看到选项选项卡。在这里，我们可以保存/加载或导入/导出配置，还可以设置扩展将使用的Burp工具。</li></ol><p id="a3dc" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">第二部分处理选项卡的创建:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nv"><img src="../Images/0631de0bb273437fccfd1b1ddb489ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-KiMft2ytZNAElS_zP8ZA.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">配置新的CPH选项卡</figcaption></figure><p id="6fcc" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">一旦您在会话处理动作编辑器的最后部分选择了“运行宏后，调用Burp扩展动作处理程序”复选框，就会自动创建一个CPH选项卡来处理宏的请求。选项卡的第一部分让我来命名它，并设置Burp范围内的URL的使用范围。</p><p id="8536" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">第三部分是魔术:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nw"><img src="../Images/a0d79b141d0897d5716db1c7d7618f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKbxwHZgBBHjCeOy9e2e8g.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">从响应中提取一个字符串，并用它替换原始请求的字符串</figcaption></figure><ol class=""><li id="dd95" class="nc nd iq lh b li mb ll mc lo ne ls nf lw ng ma nh ni nj nk bi translated">这里我们设置了一个正则表达式来搜索原始请求中要替换的字符串。请注意，正则表达式以“ey”开头。它将与过期的访问令牌(T2 JWT T3)完全匹配。</li><li id="b599" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">正则表达式在(1)中找到的第一个字符串将被第二个正则表达式的内容替换。在这种情况下，“\g <jwt>指的是一个名为“jwt”的正则表达式组，我们将在(4)中看到。</jwt></li><li id="ff2f" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">如果我选中“我需要的值是动态的”框，选项四将变为可用。我们希望使用它，因为每次我们发出请求时，都会生成一个新的令牌。</li><li id="97c8" class="nc nd iq lh b li nl ll nm lo nn ls no lw np ma nh ni nj nk bi translated">最后，当发出宏请求时，执行这个正则表达式搜索来提取新收到的访问令牌。注意，我用<em class="mv">(？P &lt; jwt &gt;</em></li></ol><p id="dc39" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">因此，通过regex (4)搜索从响应中提取的值用于替换旧的访问令牌(选项2)。这样，我甚至可以用一个无效的JWT向API的主端点发出一个请求，这个请求仍然可以工作，因为这个扩展将在后台发挥它的魔力。</p><h1 id="6599" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">结论</h1><p id="4a0f" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这里的结论是，打嗝套件比你我想象的要强大得多。我甚至没有使用它的全部能量。澄清一下，这篇文章不是由PortSwigger赞助的。我只是在陈述一个事实。他们用这个工具做得非常好。</p></div></div>    
</body>
</html>