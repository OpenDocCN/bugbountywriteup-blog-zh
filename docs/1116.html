<html>
<head>
<title>How to understand and develop a Nmap of your Own — Part 4 — CyberForged</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何理解和开发自己的Nmap第4部分——网络锻造</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/how-to-understand-and-develop-a-nmap-of-your-own-part-4-cyberforged-c0c47d8ca15a?source=collection_archive---------0-----------------------#2021-02-12">https://infosecwriteups.com/how-to-understand-and-develop-a-nmap-of-your-own-part-4-cyberforged-c0c47d8ca15a?source=collection_archive---------0-----------------------#2021-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dee89a7ff281837f24374d3816d04b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dmagI3M_uh68N98DK-yvQ.png"/></div></div></figure><p id="18cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯嗯嗯…完成这个关于Nmap及其发展的系列怎么样？</p><p id="0122" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本系列的上一部分中，我们看到了如何编写自己版本的Nmap来扫描服务器上开放的UDP端口。如果你错过了，你可以在这里看:<a class="ae kw" href="https://cyberforged.com/how-to-understand-and-develop-a-nmap-of-your-own-part-3/" rel="noopener ugc nofollow" target="_blank">https://cyber forged . com/how-to-understand-and-develop-a-nmap-of-your-own-part-3/</a></p><p id="db15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这最后一部分，我们将重现Nmap的最佳特性之一。这个功能是能够运行脚本(或现成的食谱)的侦察对服务器。迷茫？让我解释一下。</p><h1 id="dca0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">NMAP和它的配方引擎</h1><p id="d2dd" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">到目前为止，我们已经看到Nmap是一个静态程序:它要么进行TCP类型的扫描，要么进行UDP类型的扫描。它将总是执行相同的动作和相同的技术来检测相同的东西(开放端口)。但是，如果我们在给定时刻想要检测的只是编号为10–100的TCP端口，而不是我们已经检测的0–1024端口，那该怎么办呢？或者，如果我们想要检测的不是系统上开放的端口，而是我们可以在目标服务器中找到的潜在漏洞，该怎么办？</p><p id="b950" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这正是Nmap最大的潜力所在:我们可以制作食谱，让NMAP运行它们，并在屏幕上向我们展示结果。例如，我们可以在https://svn.nmap.org/nmap/scripts/http-git.nse的<a class="ae kw" href="https://svn.nmap.org/nmap/scripts/http-git.nse" rel="noopener ugc nofollow" target="_blank">看到一个用LUA(一种编程和脚本语言)编写的这类食谱的例子:</a></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="97d8" class="mj ky iq mf b gy mk ml l mm mn">local http = require("http") <br/>local shortport = require("shortport") <br/>local stdnse = require("stdnse") <br/>local string = require("string") <br/>local table = require("table") <br/>description = [[Checks for a Git repository found in a website's document root/.git/) and retrieves as much repo information aspossible, including language/framework, remotes, last commitmessage, and repository description.]]</span></pre><p id="0e0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，NSE脚本(或食谱)的描述可以在https://nmap.org/book/nse-language.html<a class="ae kw" href="https://nmap.org/book/nse-language.html" rel="noopener ugc nofollow" target="_blank">的官方网站</a>上找到:</p><p id="bacc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">“Nmap脚本引擎的核心是一个可嵌入的Lua解释器。Lua是一种为可扩展性而设计的轻量级语言。它为与其他软件(如Nmap)的接口提供了一个强大的、文档完善的API。</em></p><p id="e47f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">Nmap脚本引擎的第二部分是NSE库，它连接Lua和Nmap。这一层处理诸如Lua解释器的初始化、并行脚本执行的调度、脚本检索等问题。它也是NSE网络I/O框架和异常处理机制的核心。它还包括实用程序库，使脚本更加强大和方便。”</em></p><p id="3cae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这些脚本非常简单，因为我们只需告诉Nmap我们希望它运行哪个脚本，以及在什么条件下运行:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/e38315d28d9ae927365cb652f62e5637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GlbUesMxa79twBQp.png"/></div></div></figure><p id="8f8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们将它与没有任何脚本的情况下运行NMAP相比，我们可以看到，当我们运行它时，添加了相当多的信息:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/803795b5d6f311d391bfcc522cb5a130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M5tr6ZPn-oJcyHRx.png"/></div></div></figure><p id="dd65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，有了这些配方或脚本，我们能够做的就是通过编程与Nmap进行交互，并告诉它执行一些预定的操作。有用吧？</p><h1 id="7370" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">太好了，现在怎么办？</h1><p id="a6e8" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在，我们必须在我们自己的Nmap版本中复制这种行为。我们要做的事情并不像Nmap那样复杂，因为我们的只是一个简单的概念证明。</p><p id="86f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要做的是开发我们自己类型的配方或脚本引擎，使用计算社区的另一个标准:JSON。在这种情况下，我们将在一个单独的Java类中定义一些函数，我们将看到如何从JSON文件中读取数据，然后能够根据脚本或配方中的内容执行一些函数或其他函数。</p><p id="f1b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们去吧！</p><h1 id="53ae" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结构</h1><p id="f20f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们必须设计的第一件事是我们的NMAP在执行流程方面的外观:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/5fd7fa6267e4a2d7cd10b4345d7b9f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/0*nKv-ugHAgt6_-Bi1.png"/></div></figure><p id="cb7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果要运行的脚本通过main函数的参数到达我们这里，我们将执行它。如果没有，我们将运行我们在本指南的前两部分已经看到的功能。很简单，不是吗？</p><h1 id="d19f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JSON脚本设计</h1><p id="534e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了运行我们将要开发的食谱，我们首先需要知道的是我们在食谱中需要什么，对吗？这些是我们将要使用的功能:</p><ul class=""><li id="975c" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated"><em class="mo">名称</em>:能够在内部区分每个文件。</li><li id="afe0" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><em class="mo"> IP </em>:我们需要知道我们应该将这个脚本或配方的操作指向哪个目的IP。</li><li id="5de2" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><em class="mo">类型</em>:对于这个概念证明，我们将只处理一种类型的脚本。这将是拒绝服务类型。我们将尝试模拟如何注入足够的数据包，以了解服务可以抵御这种类型的攻击。</li><li id="4e58" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><em class="mo">每个端口的数据包</em>:如果脚本/方法说攻击类型是DOS，我们将能够在知道它是否影响系统之前，指示每个端口打开多少个连接/数据包。</li><li id="35d5" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><em class="mo">端口</em>:我们必须知道我们必须在哪个/哪些端口上发送这些数据包，例如用逗号分隔。</li><li id="2d21" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><em class="mo">协议</em>:我们要“用菜谱分析”的是TCP还是UDP端口。</li></ul><p id="a322" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照这种结构，我们可以讨论如下示例:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6c7d" class="mj ky iq mf b gy mk ml l mm mn">{ <br/>"name": "Script for the POC", <br/>"IP": "192.168.142.128", <br/>"type": "DOS", <br/>"number_packets_per_port": 200, <br/>"ports": "1,10", "protocol": "TCP" <br/>}</span></pre><p id="1e50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这个和适当的类，我们可以告诉我们的NMAP做什么和如何表现。</p><p id="304c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们开始编程好吗？</p><h1 id="3e1c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">编程，编程，整天编程。</h1><p id="18e2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">好了，让我们开始真正的工作:对所有这些进行编程。</p><p id="ab4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一件事是创建能够读取JSON脚本属性的对象。我们可以使用像<a class="ae kw" href="https://json2csharp.com/json-to-pojo" rel="noopener ugc nofollow" target="_blank">https://json2csharp.com/json-to-pojo</a>或<a class="ae kw" href="http://www.jsonschema2pojo.org/" rel="noopener ugc nofollow" target="_blank">http://www.jsonschema2pojo.org/</a>这样的页面将JSON直接转换成Java中相应的类。</p><p id="1c5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在eclipse中创建了一个名为“ScriptProperties”的新类，并复制我们从这些页面中获得的内容:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/42492a5bdb34e6b15a914876686c3c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/0*kQVKyHBAhrThqhEY.png"/></div></figure><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="66cb" class="mj ky iq mf b gy mk ml l mm mn">import com.google.gson.annotations.Expose; <br/>import com.google.gson.annotations.SerializedName; <br/>  <br/>public class ScriptProperties { <br/>  <br/>@SerializedName("name") <br/>@Expose <br/>private String name; <br/>@SerializedName("IP") <br/>@Expose <br/>private String IP; <br/>@SerializedName("type") <br/>@Expose <br/>private String type; <br/>@SerializedName("number_packets_per_port") <br/>@Expose <br/>private Integer numberPacketsPerPort; <br/>@SerializedName("ports") <br/>@Expose <br/>private String ports; <br/>@SerializedName("protocol") <br/>@Expose <br/>private String protocol; <br/> <br/>public ScriptProperties() { <br/>  super(); <br/>} <br/>  <br/>public String getName() { <br/>  return name; <br/>} <br/>  <br/>public void setName(String name) { <br/>  this.name = name; <br/>} <br/> <br/>public String getIP() { <br/>  return IP; <br/>} <br/>  <br/>public void setIP(String iP) { <br/>  IP = iP; <br/>} <br/>  <br/>public String getType() { <br/>  return type; <br/>} <br/>  <br/>public void setType(String type) { <br/>  this.type = type; <br/>} <br/>  <br/>public Integer getNumberPacketsPerPort() { <br/>  return numberPacketsPerPort; <br/>} <br/>  <br/>public void setNumberPacketsPerPort(Integer numberPacketsPerPort) { <br/>  this.numberPacketsPerPort = numberPacketsPerPort; <br/>} <br/>  <br/>public String getPorts() { <br/>  return ports; <br/>} <br/>  <br/>public void setPorts(String ports) { <br/>  this.ports = ports; <br/>} <br/>  <br/>public String getProtocol() { <br/>  return protocol; <br/>} <br/>  <br/>public void setProtocol(String protocol) { <br/>  this.protocol = protocol; <br/>} <br/><br/>}</span></pre><p id="fb4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们决定使用GSON库作为解析目标JSON的引擎。</p><p id="227d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们必须使之成为可能，如果在执行我们的NMAP的main方法时，我们检测到有一个标志指示一个脚本的执行，我们将不得不跳转到执行它，而不做一个完整的TCP/UDP扫描。为此，我们将读取main方法的输入参数并调用一个名为ScriptEngine的外部类，在这里我们将执行需要执行的内容:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c6fe" class="mj ky iq mf b gy mk ml l mm mn">public static void main(String[] args) { <br/>  <br/> // Check if a command line argument exists, if it does it should be the script <br/>  if (args.length &gt; 0) { <br/>  <br/>    Gson gson = new Gson(); <br/>  <br/>    // Then try to read the script, in this case we are going to have it in <br/>    // C:\Users\Public <br/>    ScriptProperties scriptProperties = null; <br/>    try { <br/>     scriptProperties = gson.fromJson(new FileReader("C:\\Users\\Public\\scriptPOC.json"), <br/>ScriptProperties.class); <br/>    } catch (JsonSyntaxException | JsonIOException | FileNotFoundException e) { <br/>      e.printStackTrace(); <br/>    } <br/>      // Then we call the engine for it to execute the Script <br/>      ScriptEngine scriptEngine = new ScriptEngine(); <br/>      scriptEngine.executeScript(scriptProperties); <br/>  <br/>} else { <br/>    // In here it would go the normal TCP and UDP port detection  we saw before this guide <br/>…...</span></pre><p id="c1ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在ScriptEngine类中，我们将只为这个POC编写基础程序。我们要做的是检查所有的值，并在这种情况下执行DOS类型的攻击，发送数据包，告诉我们JSON:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6228" class="mj ky iq mf b gy mk ml l mm mn">import java.io.DataOutputStream; <br/>import java.io.IOException; <br/>import java.net.Socket; <br/>import java.util.ArrayList; <br/>import java.util.Arrays; <br/>import java.util.List; <br/>  <br/>public class ScriptEngine { <br/>  <br/>  public void executeScript(ScriptProperties scriptProperties) { <br/>  <br/>    System.out.println("We are going to execute the script with name: " + scriptProperties.getName()); <br/>  <br/>    // The only type of script we admit as of now <br/>    if (scriptProperties.getType().equals("DOS")) { <br/>  <br/>      // As the ports are separated by commas, we read them into a List. <br/>      List&lt;String&gt; ports = Arrays.asList(scriptProperties.getPorts().split("\\s*,\\s*")); <br/>  <br/>      // And if it is a TCP scan... <br/>      if (scriptProperties.getProtocol().equals("TCP")) { <br/>  <br/>      // We start port by port <br/>      for (String port : ports) { <br/>        System.out.println("Attacking port " + port); <br/>  <br/>        // Opening a connections and sending as much packets as the script tells us in the JSON <br/>        Socket socket = null; <br/>        DataOutputStream dataOutput = null; <br/>  <br/>        try { <br/>          socket = new         Socket(scriptProperties.getIP(), Integer.valueOf(port)); <br/>          dataOutput = new DataOutputStream(socket.getOutputStream()); <br/>          for (int i = 0; i &lt; scriptProperties.getNumberPacketsPerPort(); i++) { <br/>  <br/>          try { <br/>            // Send packages of data <br/>            dataOutput.writeByte(1); <br/>            dataOutput.writeUTF("Test?"); <br/>            dataOutput.flush(); <br/>  <br/>          } catch (Exception ex) { <br/>            System.out.println("It seems the port " + port + " is closed now!"); <br/>            ex.printStackTrace(); <br/>            break; <br/>          } <br/>  <br/>         } <br/>  <br/>        socket.close(); <br/>  <br/>      } catch (NumberFormatException | IOException e) { <br/>        e.printStackTrace(); <br/>      } <br/>  <br/>      // Then we check if the port is still alive! <br/>      try { <br/>        Socket verifySocket = new          Socket(scriptProperties.getIP(), Integer.valueOf(port)); <br/>        System.out.println("It seems the port " + port + " is still alive!"); <br/>  <br/>      } catch (Exception ex) { <br/>        System.out.println("It seems we broke the port " + port); <br/>      } <br/>    } <br/>  <br/>  } else if (scriptProperties.getProtocol().equals("UDP")) { <br/>     // You would do the same as in TCP but with the UDP packets <br/>  } else { <br/>    System.out.println("The only possible values are TCP and UDP"); <br/>  } <br/>  <br/> } else { <br/>  System.out.println("We don't support this type of scan....yet"); <br/>  } <br/>  } <br/>}</span></pre><p id="4ba9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了告诉Eclipse给我们传递一个参数，我们必须转到Run &gt; Run configuration s &gt; Arguments，并在第一个小框中包含任何字符串:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/608d36b2b43c83f35edd8834303daaf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GNeqkz2FdyZz5_ix.png"/></div></div></figure><p id="fcce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，我们就可以运行它，看看一个端口是否真的能够处理200个数据包，就像JSON示例中配置的那样。我们可以使用我们的Kali机器启动一个Python服务器，看看它如何反应(端口1将关闭，端口10将持有web服务器):</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/493985b01b795b66b5b9dda6093b19d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vEc5T87Xq_QI1KZg.png"/></div></div></figure><p id="c59b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们看到对于端口1，连接被拒绝，因为没有服务监听，但是我们看到端口10可以处理200个包，没有任何问题！</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/d7fbd109dee8c21a0030971e3c3e2548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wKV5ZgzvzuPIPa9E.png"/></div></div></figure><p id="f6df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，关于NMAP如何工作以及它的功能如何包含在Java项目中的分析到此为止。当然，在代码质量等方面还有很多工作要做，但是你怎么看，你有什么意见吗？在下面的评论里留下吧！</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="9eae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">原载于2021年2月12日</em><a class="ae kw" href="https://cyberforged.com/how-to-understand-and-develop-a-nmap-of-your-own-part-4/" rel="noopener ugc nofollow" target="_blank"><em class="mo">【https://cyberforged.com】</em></a><em class="mo">。</em></p></div></div>    
</body>
</html>