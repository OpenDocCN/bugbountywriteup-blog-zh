<html>
<head>
<title>Testing for Directory or Path Traversal Vulnerabilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试目录或路径遍历漏洞</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/testing-for-directory-or-path-traversal-vulnerabilities-dfbe49fdfe92?source=collection_archive---------0-----------------------#2020-11-28">https://infosecwriteups.com/testing-for-directory-or-path-traversal-vulnerabilities-dfbe49fdfe92?source=collection_archive---------0-----------------------#2020-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1851" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将讨论如何执行目录遍历或路径遍历攻击，又名<strong class="jp ir">、【点-点-斜线】、</strong>、<strong class="jp ir">、【回溯】。</strong></p><h2 id="48ec" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">什么是路径遍历漏洞？</h2><blockquote class="le lf lg"><p id="282e" class="jn jo lh jp b jq jr js jt ju jv jw jx li jz ka kb lj kd ke kf lk kh ki kj kk ij bi translated">简而言之:<em class="iq">当应用程序</em> <strong class="jp ir"> <em class="iq">使用用户可控制的数据以不安全的方式访问应用服务器或另一个后端文件系统上的文件和目录</em> </strong> <em class="iq">时，就会出现路径遍历漏洞。</em></p></blockquote><p id="8d11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过提交精心编制的输入，攻击者可能能够<strong class="jp ir">在被访问的文件系统的任何位置读取或写入任意内容，从服务器读取敏感信息，或覆盖敏感文件</strong>，最终导致在服务器上执行任意命令。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/6b0dd12831e21af5a3a5603ed7a3ac3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*6fpPQ0zD5swZPDh1"/></div></figure><blockquote class="le lf lg"><p id="e27a" class="jn jo lh jp b jq jr js jt ju jv jw jx li jz ka kb lj kd ke kf lk kh ki kj kk ij bi translated">用技术术语来说:<em class="iq">路径遍历攻击旨在访问存储在webroot文件夹之外的文件和目录。</em> <strong class="jp ir"> <em class="iq">通过操纵引用文件的变量，用“点-点-斜线(../)"序列及其变体，或者通过使用绝对文件路径</em> </strong> <em class="iq">，就有可能访问存储在文件系统上的任意文件和目录，包括应用程序源代码或配置和关键系统文件。</em></p></blockquote><p id="70f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lh">注:</em>对文件的访问受到系统操作访问控制的限制(例如在微软视窗操作系统上锁定或使用文件的情况下)。</p><p id="1347" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们考虑下面的例子</p><p id="5782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，应用程序<strong class="jp ir">使用动态页面将静态图像</strong>返回给客户端。请求图像的名称在查询字符串参数中指定:<br/> <code class="fe lt lu lv lw b">https://testsite/image/8/getfile.ashx?filename=profile1.jpg</code></p><p id="dbe6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当服务器处理这个请求时，它遵循以下步骤:<br/> 1 .从查询字符串中提取filename参数的值。<br/> 2。将该值附加到前缀<code class="fe lt lu lv lw b">C:\filedirectory\</code>上。<br/> 3。以此名称打开文件。<br/> 4。读取文件内容并将其返回给客户端。</p><p id="8db5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">攻击者可以将p个遍历序列(../)放入文件名中，以便从指定的目录&amp;向上回溯，从而从应用程序使用的用户上下文有权访问的服务器上的任何位置访问文件。<code class="fe lt lu lv lw b">https://testsite/image/8/getfile.ashx?filename=..\windows\win.ini</code> <br/>当应用程序将filename参数的值附加到图像目录的名称上时，它获得以下路径:<br/> <code class="fe lt lu lv lw b">C:\filedirectory\..\windows\win.ini</code> <br/>这两个遍历序列实际上是从图像目录返回到<code class="fe lt lu lv lw b">C:</code>驱动器的根目录，因此前面的路径相当于:<br/> <code class="fe lt lu lv lw b">C:\windows\win.ini</code></p><p id="8cea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，<strong class="jp ir">服务器实际上返回了一个默认的Windows配置文件，而不是返回一个镜像文件。</strong></p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/ecc936bb77dd846c345e7fad77b6bec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*8Fs_xwF01eEqzRH2XhIAyg.gif"/></div></figure><h1 id="f313" class="ly km iq bd kn lz ma mb kq mc md me kt mf mg mh kw mi mj mk kz ml mm mn lc mo bi translated">如何测试路径遍历漏洞？</h1><h2 id="6512" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">步骤:</h2><p id="34d6" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">1.请注意<strong class="jp ir">请求参数似乎包含文件或目录的名称</strong>，例如<code class="fe lt lu lv lw b">include=main.inc</code>或<code class="fe lt lu lv lw b">template=/en/sidebar</code>。<br/>其实现可能<strong class="jp ir">涉及从服务器文件系统中检索数据的任何功能</strong>，例如显示办公文档或图像。<br/> 2。寻找错误消息或其他感兴趣的异常事件，或者<strong class="jp ir">用户提供的数据被传递到文件API或作为操作系统命令</strong>的参数的实例。<br/> " <em class="lh">如果您可以本地访问应用程序(白盒测试),请监控应用程序执行的所有文件系统交互。</em><br/>3。修改参数值为<strong class="jp ir">插入任意子目录</strong>和<strong class="jp ir">单遍历序列</strong>。<br/>例如:</p><p id="6205" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果应用程序提交这个参数:<code class="fe lt lu lv lw b">file=foo/file1.txt</code> <br/>尝试提交:<code class="fe lt lu lv lw b">file=foo/bar/../file1.txt</code> <br/>如果应用程序的<strong class="jp ir">行为在两种情况下是相同的</strong>，那么它<strong class="jp ir">可能是易受攻击的</strong>。尝试通过遍历起始目录来访问不同的文件。<br/> 4。如果应用程序的<strong class="jp ir">行为在两种情况下不同于</strong>，那么<strong class="jp ir">可能是阻塞、剥离或清理遍历序列，导致无效的文件路径</strong>。</p><p id="addf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查是否有任何方法可以避开应用程序的验证过滤器。<br/> 5。如果您发现提交遍历序列而不遍历起始目录并不影响应用程序的行为，那么<strong class="jp ir">会尝试遍历起始目录并从服务器文件系统的其他地方访问文件</strong>。<br/> 6。如果您攻击的应用程序函数提供了对文件的<strong class="jp ir">读取权限，那么<br/>会尝试访问操作系统</strong>上的一个已知全球可读文件<br/>问题。提交以下值之一作为您控制的文件名参数<br/>:<br/><code class="fe lt lu lv lw b">../../../../../../../../../../../../etc/passwd<br/>../../../../../../../../../../../../windows/win.ini</code><br/>如果成功，您的浏览器会显示您所请求文件的内容。<br/> 7。如果您攻击的函数提供了对某个文件的<strong class="jp ir">写权限，请尝试写两个文件</strong>，一个应该对任何用户都是可写的<strong class="jp ir">，另一个甚至对root或管理员都是不可写的</strong>。</p><p id="0125" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在<strong class="jp ir"> Windows平台</strong>上试试这个:<br/> <code class="fe lt lu lv lw b">../../../../../../../../../../../../writetest.txt<br/>../../../../../../../../../../../../windows/system32/config/sam</code> <br/>在<strong class="jp ir">基于UNIX的平台</strong>上，root可能不写的文件是版本相关的，但是试图用一个文件覆盖一个目录应该总是失败，所以你可以试试这个:<br/> <code class="fe lt lu lv lw b">../../../../../../../../../../../../tmp/writetest.txt<br/>../../../../../../../../../../../../tmp</code> <br/>如果应用程序的行为在响应第一个和第二个请求时是不同的，那么这个应用程序可能是易受攻击的。</p><p id="c441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">8.或者用<strong class="jp ir">写访问</strong>验证遍历缺陷是<strong class="jp ir">尝试在web服务器的webroot中写一个新文件，然后尝试用浏览器</strong>检索它。但是，如果您知道webroot目录的位置，或者如果发生文件访问的用户上下文没有权限写入该目录，则此方法将有效。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/017e50ff20bb039fca188b03c1658558.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/0*0i33Fbvb_oRiZsT8"/></div></figure><blockquote class="le lf lg"><p id="7ab5" class="jn jo lh jp b jq jr js jt ju jv jw jx li jz ka kb lj kd ke kf lk kh ki kj kk ij bi translated"><strong class="jp ir">温馨提示:</strong></p><p id="e278" class="jn jo lh jp b jq jr js jt ju jv jw jx li jz ka kb lj kd ke kf lk kh ki kj kk ij bi translated">在探测缺陷时提交大量的遍历序列。数据附加到的起始目录可能位于文件系统的深处，因此使用过多的序列有助于避免误判。</p><p id="7de5" class="jn jo lh jp b jq jr js jt ju jv jw jx li jz ka kb lj kd ke kf lk kh ki kj kk ij bi translated">此外，Windows平台允许使用正斜杠和反斜杠作为目录分隔符，而基于UNIX的平台只允许使用正斜杠。</p><p id="1717" class="jn jo lh jp b jq jr js jt ju jv jw jx li jz ka kb lj kd ke kf lk kh ki kj kk ij bi translated">此外，一些web应用程序过滤一个版本，但不过滤另一个版本。即使您确定web服务器运行的是基于UNIX的操作系统，应用程序仍可能调用基于Windows的后端组件。因此，在探测遍历缺陷时，尝试这两个版本总是明智的。</p></blockquote></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="3a4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果您最初执行遍历攻击的尝试不成功，这并不意味着应用程序没有漏洞。</strong></p><p id="b12a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多应用程序开发人员意识到了路径遍历漏洞，并实现了各种类型的输入验证检查，试图阻止它们。然而，这些防御措施通常是有缺陷的，可以被熟练的攻击者绕过。</p><p id="5749" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.通常遇到的第一种类型的输入过滤器包括<strong class="jp ir">检查filename参数是否包含任何路径遍历序列</strong>。如果是，过滤器要么拒绝请求，要么尝试清理输入以删除序列。这种类型的过滤器通常容易受到各种攻击，这些攻击使用替代编码和其他技巧来破坏过滤器。<br/> 1.1。使用下面的编码尝试遍历序列的简单的URL编码表示。<strong class="jp ir">确保对你输入的每一个斜线和点进行编码</strong> : <br/> <code class="fe lt lu lv lw b">Dot — %2e Forward slash — %2f Backslash — %5c</code> <br/> 1.2。尝试使用<strong class="jp ir"> 16位Unicode编码</strong> : <br/> <code class="fe lt lu lv lw b">Dot — %u002e Forward slash — %u2215 Backslash — %u2216</code> <br/> 1.3。试试<strong class="jp ir">双URL编码</strong>:1.4<br/><code class="fe lt lu lv lw b">Dot — %252e Forward slash — %252f Backslash — %255c</code><br/>。试试<strong class="jp ir">超长UTF-8 Unicode编码</strong> : <br/> <code class="fe lt lu lv lw b">Dot — %c0%2e, %e0%40%ae, %c0ae,</code>等等<br/> <code class="fe lt lu lv lw b">Forward slash — %c0%af, %e0%80%af, %c0%2f,</code>等等<br/> <code class="fe lt lu lv lw b">Backslash — %c0%5c, %c0%80%5c,</code>等等。</p><p id="3e21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在Burp Intruder中使用<strong class="jp ir">非法的Unicode有效载荷</strong>类型来<br/>生成任意给定字符的大量替代表示，并将其提交到目标参数中的相关位置。<br/>这些表示严格违反了Unicode表示的规则，但仍然被许多Unicode解码器的实现所接受，尤其是在Windows平台上。<br/> 1.5。如果应用程序试图通过删除遍历序列来净化用户输入，并且没有递归地应用该过滤器，则可以通过将一个序列放在另一个序列中来绕过该过滤器。例如:<br/> <code class="fe lt lu lv lw b">….//<br/>….\/<br/>…./\<br/>….\\</code></p><p id="3a44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.在防御路径遍历攻击中经常遇到的第二种类型的输入过滤器包括<strong class="jp ir">验证用户提供的文件名是否包含应用程序期望的后缀(文件类型)或前缀(起始目录)</strong>。这种类型的防御可以与已经描述的过滤器一起使用。<br/> <br/> 2.1。一些应用程序<strong class="jp ir">检查用户提供的文件名是否以<br/>特定文件类型或一组文件类型</strong>结尾，并拒绝访问<br/>任何其他内容的尝试。有时，这种检查可以通过<strong class="jp ir">将一个URLencoded空字节</strong>放在您请求的文件名的末尾，后面跟着一个应用程序接受的<br/>文件类型来破坏。例如:<br/> <code class="fe lt lu lv lw b">../../../../../boot.ini%00.jpg</code></p><blockquote class="le lf lg"><p id="55a9" class="jn jo lh jp b jq jr js jt ju jv jw jx li jz ka kb lj kd ke kf lk kh ki kj kk ij bi translated">这种攻击有时会成功的原因是，文件类型检查是在允许字符串包含空字符的托管执行环境中使用API实现的(如Java中的String.endswith())。但是，当实际检索文件时，应用程序最终会在非托管环境中使用API，在该环境中，字符串以null结尾。因此，您的文件名实际上被截断为您想要的值。</p></blockquote><p id="735d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.一些应用程序试图通过<strong class="jp ir">在用户</strong>提供的文件名后添加自己的文件类型后缀来控制正在访问的文件类型。<br/>在这种情况下，出于同样的原因，上述任何一种利用都可能有效。<br/> 3。一些应用程序检查用户提供的<strong class="jp ir">文件名是否以起始目录的特定子目录开始，或者甚至以特定的文件名</strong>开始。当然，这种检查很容易被绕过，如下:<br/> <code class="fe lt lu lv lw b">filestore/../../../../../../../etc/passwd</code> <br/> 4 .如果前面针对输入过滤器的攻击都没有成功，那么<strong class="jp ir">应用程序可能正在实现多种类型的过滤器</strong>。因此，您需要同时结合这些攻击(针对遍历序列过滤器和文件类型或目录过滤器)。试着把问题分成不同的阶段。</p><p id="b472" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果对:<code class="fe lt lu lv lw b">diagram1.jpg</code>的请求成功，但对:<br/> <code class="fe lt lu lv lw b">foo/../diagram1.jpg</code>的请求失败，则尝试所有可能的遍历序列旁路，直到第二个请求的变化成功。</p><p id="d33a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这些成功的遍历序列绕过不能使您访问<code class="fe lt lu lv lw b">/etc/passwd</code>，则探查是否实现了任何文件类型过滤，并且可以通过请求绕过:<code class="fe lt lu lv lw b">diagram1.jpg%00.jpg</code> <br/>完全在应用程序定义的开始目录内工作，尝试探查以了解所有正在实现的过滤器，并且查看是否可以使用所描述的技术单独绕过每个过滤器。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/568816c83c5b9e44bfc27da96f8de64f.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/1*gLFqqpMKBwVOpVPfmVVPHA.gif"/></div></figure><p id="daa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.您可以利用读取访问路径遍历缺陷来<strong class="jp ir">从服务器</strong>检索感兴趣的文件，这些文件可能包含直接有用的信息，或者帮助您针对其他漏洞改进攻击。例如:<br/> a)用于操作系统和应用程序的密码文件<br/> b)用于发现其他漏洞或微调不同攻击的服务器和应用程序配置文件<br/> c)包括可能包含数据库凭证的文件<br/> d)应用程序使用的数据源，如MySQL数据库文件或<br/> XML文件<br/> e)服务器可执行页面的源代码，以在<br/>中执行代码审查，搜索错误(例如<code class="fe lt lu lv lw b">GetImage.aspx?file=GetImage.aspx</code> ) <br/> f)可能</p><p id="ceac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您发现一个允许写访问的路径遍历漏洞，利用这个漏洞使<strong class="jp ir">在服务器</strong>上任意执行命令。这里有一些利用这个漏洞的方法。在用户的启动文件夹中创建脚本。<br/> 2。修改<code class="fe lt lu lv lw b">.ftpd</code>中的文件，以便在用户连接时执行任意命令。<br/> 3。使用执行权限将脚本写入web目录，并从浏览器中调用它们<br/>。</p><p id="898c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">针对<strong class="jp ir"> web服务器</strong> <br/> <code class="fe lt lu lv lw b">https://testsite/../../../../../etc/passwd<br/>https://testsite/..%255c..%255c..%255cboot.ini<br/>https://testsite/..%u2216..%u2216someother/file</code>的路径遍历攻击</p><p id="03c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">针对一个<strong class="jp ir"> web应用</strong> <br/>的路径遍历攻击原文:<code class="fe lt lu lv lw b">https://testsite/foo.cgi?home=index.htm</code> <br/>攻击:<code class="fe lt lu lv lw b">https://testsite/foo.cgi?home=foo.cgi</code></p><p id="a4eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，web应用程序揭示了<code class="fe lt lu lv lw b">foo.cgi </code>文件的源代码。</p><p id="7fc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">针对使用特殊字符序列的<strong class="jp ir"> web应用的路径遍历攻击:</strong> <br/>原始:<code class="fe lt lu lv lw b">https://testsite/scripts/foo.cgi?page=menu.txt</code> <br/>攻击:<code class="fe lt lu lv lw b">http://testsite/scripts/foo.cgi?page=../scripts/foo.cgi%00txt</code></p><p id="708c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，web应用程序通过使用特殊字符序列揭示了<code class="fe lt lu lv lw b">foo.cgi</code>文件的源代码。“<code class="fe lt lu lv lw b">../</code>”序列用于遍历当前目录之上的一个目录，并进入<code class="fe lt lu lv lw b">/</code>脚本目录。“<code class="fe lt lu lv lw b">%00</code>”序列用于绕过文件扩展名检查，并在读入文件时剪掉扩展名。</p><h1 id="11fd" class="ly km iq bd kn lz ma mb kq mc md me kt mf mg mh kw mi mj mk kz ml mm mn lc mo bi translated">绝对路径遍历</h1><p id="b7b2" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">以下URL可能容易受到此攻击:</p><pre class="lm ln lo lp gt nc lw nd ne aw nf bi"><span id="33af" class="kl km iq lw b gy ng nh l ni nj">https://testsite/get.php?f=list<br/>https://testsite/get.cgi?f=5<br/>https://testsite/get.asp?f=test</span></pre><p id="e5f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">攻击者可以像这样执行攻击:</p><pre class="lm ln lo lp gt nc lw nd ne aw nf bi"><span id="828f" class="kl km iq lw b gy ng nh l ni nj">https://testsite/get.php?f=/var/www/html/get.php<br/>https://testsite/get.cgi?f=/var/www/html/admin/get.inc<br/>https://testsite/get.asp?f=/etc/passwd</span></pre><p id="bf97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当web服务器返回关于web应用程序中的错误的信息时，攻击者更容易猜出正确的位置(例如，带有源代码的文件的路径，然后可能会显示出来)。</p><h1 id="58be" class="ly km iq bd kn lz ma mb kq mc md me kt mf mg mh kw mi mj mk kz ml mm mn lc mo bi translated">考虑以下字符编码机制:</h1><p id="2513" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated"><strong class="jp ir"> URL编码和双重URL编码</strong></p><pre class="lm ln lo lp gt nc lw nd ne aw nf bi"><span id="e74b" class="kl km iq lw b gy ng nh l ni nj">%2e%2e%2f represents ../<br/>%2e%2e/ represents ../<br/>..%2f represents ../<br/>%2e%2e%5c represents ..\<br/>%2e%2e\ represents ..\<br/>..%5c represents ..\<br/>%252e%252e%255c represents ..\<br/>..%255c represents ..\ and so on.</span></pre><p id="cfaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Unicode/UTF-8编码</strong>(仅适用于能够接受超长UTF-8序列的系统)</p><pre class="lm ln lo lp gt nc lw nd ne aw nf bi"><span id="ed46" class="kl km iq lw b gy ng nh l ni nj">.%c0%af represents ../<br/>..%c1%9c represents ..\</span></pre><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/5ff757cbb0188447543554c58269012a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*P4jOVc4BjA-AaOJB1BYL8Q.png"/></div></figure><p id="9280" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有其他特定于操作系统和应用程序框架的注意事项。例如，Windows在解析文件路径时非常灵活。</p><p id="46fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Windows shell: </strong>在shell命令中使用的路径上添加以下任何一项都不会导致功能上的差异:<br/> 1 .路径<br/> 2末端的尖括号<code class="fe lt lu lv lw b">&lt;</code>和<code class="fe lt lu lv lw b">&gt;</code>。路径<br/> 3末尾的双引号(正确结束)。无关的当前目录标记，如<code class="fe lt lu lv lw b">./</code>或<code class="fe lt lu lv lw b">.\\</code> <br/> 4。带有可能存在也可能不存在的任意项目的无关父目录标记:</p><pre class="lm ln lo lp gt nc lw nd ne aw nf bi"><span id="b390" class="kl km iq lw b gy ng nh l ni nj">file.txt<br/>file.txt…<br/>file.txt&lt;spaces&gt;<br/>file.txt””””<br/>file.txt&lt;&lt;&lt;&gt;&gt;&gt;&lt;<br/>./././file.txt<br/>nonexistant/../file.txt</span></pre><p id="2766" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Windows API </strong>:当在任何shell命令或API调用中使用字符串作为文件名时，<code class="fe lt lu lv lw b">periods or spaces</code>被丢弃。</p><p id="3a6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Windows UNC文件路径</strong>:用于引用SMB共享上的文件。有时，可以让应用程序引用远程UNC文件路径上的文件。如果是这样，Windows SMB服务器可能会将存储的凭据发送给攻击者，攻击者可以捕获并破解这些凭据。它们还可以与自引用IP地址或域名一起使用，以避开过滤器，或者用于访问攻击者无法访问但可以从web服务器访问的SMB共享上的文件。</p><ul class=""><li id="7391" class="nl nm iq jp b jq jr ju jv jy nn kc no kg np kk nq nr ns nt bi translated"><code class="fe lt lu lv lw b">\\server_or_ip\path\to\file.abc</code></li><li id="da11" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated"><code class="fe lt lu lv lw b">\\?\server_or_ip\path\to\file.abc</code></li></ul><p id="accd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Windows NT设备命名空间:</strong>用于指Windows设备命名空间。某些引用将允许使用不同的路径访问文件系统。</p><ul class=""><li id="3834" class="nl nm iq jp b jq jr ju jv jy nn kc no kg np kk nq nr ns nt bi translated">可能相当于一个驱动器号，如<code class="fe lt lu lv lw b">c:\</code>，甚至是一个没有分配驱动器号的驱动器卷:<code class="fe lt lu lv lw b">\\.\GLOBALROOT\Device\HarddiskVolume1\</code></li><li id="a8e5" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated">指机器上的第一个光盘驱动器:<code class="fe lt lu lv lw b">\\.\CdRom0\</code></li></ul><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/df75a8fe278c43009126f311f633969e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*qwHs6Fztvf8kfrIgCHNYvA.jpeg"/></div></figure><p id="699a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">推荐人:</strong></p><p id="ded4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae oa" href="https://www.amazon.in/Web-Application-Hackers-Handbook-Exploiting-ebook/dp/B005LVQA9S/ref=asc_df_B005LVQA9S/?tag=googleshopdes-21&amp;linkCode=df0&amp;hvadid=399149299095&amp;hvpos=&amp;hvnetw=g&amp;hvrand=1877591999365636626&amp;hvpone=&amp;hvptwo=&amp;hvqmt=&amp;hvdev=c&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=1007818&amp;hvtargid=pla-405660971168&amp;psc=1&amp;ext_vrnc=hi" rel="noopener ugc nofollow" target="_blank">网络应用:黑客手册- 2 </a></p><div class="ob oc gp gr od oe"><a href="https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/05-Authorization_Testing/01-Testing_Directory_Traversal_File_Include.md" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">OWASP/wstg</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">许多web应用程序在日常操作中使用和管理文件。使用具有以下特点的输入验证方法…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os lr oe"/></div></div></a></div></div></div>    
</body>
</html>