<html>
<head>
<title>CSRF leads to account takeover in Yahoo!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSRF导致雅虎账户被接管！</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/csrf-leads-to-account-takeover-in-yahoo-aa96c678d2aa?source=collection_archive---------0-----------------------#2022-06-16">https://infosecwriteups.com/csrf-leads-to-account-takeover-in-yahoo-aa96c678d2aa?source=collection_archive---------0-----------------------#2022-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f3c501e384b2cb5feb137ffc09731bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5N92bGree-OLbj3a66kPg.jpeg"/></div></div></figure></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="f190" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">大家好！</p><p id="b518" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在我的bug bounty之旅中，我曾经阅读了大量的著作来学习狩猎时不同的技巧和观点。我读过的大部分文章都是来自成功入侵雅虎的研究人员。。正因为如此，我开始着手黑掉<strong class="kh ir">雅虎！直到我成功了才罢休。幸运的是，我只用了30分钟就成功破解了它们。话不多说，这就是这个不可思议的故事。</strong></p><p id="595e" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在列出所有我能找到的域名并检查了哪些运行网络服务器后，我把注意力集中在了那些不包含<strong class="kh ir"> Yahoo！</strong>。不知何故，我觉得在这些子域中，我有更好的机会找到一个好的安全漏洞。在所有被过滤的域名中，我决定选择一个，我称之为vulnerable.com。</p><h2 id="607d" class="ld le iq bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">关注高严重性漏洞</h2><p id="246d" class="pw-post-body-paragraph kf kg iq kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc ij bi translated">就我个人而言，我不喜欢在低严重性的bug上浪费时间。我喜欢挑战。因此，在分析了这个有问题的应用程序一段时间后，我想到了分析更新用户帐户数据的功能。我想看看能不能找到一个CSRF(尽管当时我对在这么明显的地方找到一个CSRF没有多大信心，更不用说在像雅虎这样的公司了！)。</p><p id="54b2" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">于是我去功能更改用户账号数据，把邮箱从<a class="ae mb" href="mailto:victim@gmail.com" rel="noopener ugc nofollow" target="_blank">victim@gmail.com</a>改成<a class="ae mb" href="mailto:netstat2332@gmail.com" rel="noopener ugc nofollow" target="_blank">netstat2332@gmail.com</a>。</p><h2 id="d123" class="ld le iq bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">原始请求</h2><p id="7460" class="pw-post-body-paragraph kf kg iq kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc ij bi translated">原始电子邮件更改请求如下所示:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mc"><img src="../Images/5cbb5d0f41cbb7a76fa7093fb6da67a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9yHKkvfjGnC9l92s6EkZw.png"/></div></div></figure><h2 id="3bc2" class="ld le iq bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">任意来源的原始请求</h2><p id="51ea" class="pw-post-body-paragraph kf kg iq kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc ij bi translated">因为我们试图实现一个CSRF，所以验证服务器是否接受任意来源的请求是很方便的。一些服务器不允许来自任意来源的请求被启动。但是，服务器很友好，允许任何域向它发送HTTP请求:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/8ffd5358afacc6a502a88552ac392f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j4NSXRVTv694FWPfIyDymw.png"/></div></div></figure><h2 id="1a17" class="ld le iq bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">使用不同HTTP方法的原始请求</h2><p id="875b" class="pw-post-body-paragraph kf kg iq kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc ij bi translated">此时，我正要创建恶意的HTTP表单来利用CSRF。但是，我注意到这些请求是使用HTTP PATCH方法发出的。</p><p id="affb" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这是一个问题，因为HTTP表单只接受有限的一组HTTP方法。所以我第一个想到的就是直接把HTTP方法改成POST。然而，这不起作用:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/b29c5362b5292057d0f81f177f19dc92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76AxkJKvLvwUPdVS29rNEQ.png"/></div></div></figure><h2 id="d7f3" class="ld le iq bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">具有不同内容类型的原始请求</h2><p id="5f99" class="pw-post-body-paragraph kf kg iq kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc ij bi translated">之后，我花了一点时间思考我还可以尝试什么，或者我还可以如何在服务器上引起意外的行为。所以我想到了将Content-type头的值从<strong class="kh ir"> application/json </strong>改为<strong class="kh ir">application/x-www-form-urlencoded</strong>:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/250494bd31ee250bfc665b1221be8ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vHhe05Qq6pTrL5eW87RS3w.png"/></div></div></figure><p id="4686" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">看到这一点，我决定将请求体从JSON转换为urlencoded，看看服务器响应中是否还存在错误。</p><h2 id="eb15" class="ld le iq bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">具有HTTP方法覆盖的原始请求</h2><p id="a489" class="pw-post-body-paragraph kf kg iq kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc ij bi translated">我已经将请求体从JSON重写为urlencoded。但是，我们仍然必须用POST方法发送这个请求。因为HTTP表单，正如我们之前看到的，只使用<strong class="kh ir"> GET/POST </strong>方法。</p><p id="6711" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这里的问题是后端期望这个请求通过<strong class="kh ir">补丁</strong>方法到达。经过一番思考，我想出了一个在HTTP方法到达服务器之前改变它的方法。要做到这一点，有几种技术，每一种都很大程度上依赖于后端使用的编程语言。</p><p id="1f02" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">所以我使用了wappalyzer来查看应用程序使用了什么技术。感谢这一点，我能够意识到应用程序的后端是在<strong class="kh ir"> Ruby On Rails </strong>上编写的。幸运的是，这个框架提供了一种方法来实现我们非常想要的<a class="ae mb" href="https://rubydoc.org/gems/rack-methodoverride-with-params" rel="noopener ugc nofollow" target="_blank"> HTTP方法覆盖</a>。</p><p id="3325" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">最后，有了所有这些因素，我们设法绕过了应用程序中存在的所有限制，从而能够利用CSRF，让我们只需单击一下鼠标就可以窃取任意用户帐户:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/230ef10d0952d6b59a8b6b72b2b9951f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QixS5B5Q5pg1ccGHPbHeWg.png"/></div></div></figure><h2 id="09ab" class="ld le iq bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">利用来改变用户的电子邮件地址</h2><p id="799c" class="pw-post-body-paragraph kf kg iq kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc ij bi translated">用于攻击此漏洞的方法如下:</p><blockquote class="mj mk ml"><p id="c1b5" class="kf kg mm kh b ki kj kk kl km kn ko kp mn kr ks kt mo kv kw kx mp kz la lb lc ij bi translated"> <br/> &lt; html &gt; <br/> &lt;正文&gt; <br/> &lt;表单action = "<a class="ae mb" href="https://vulnerable.com/api/v2/users/update" rel="noopener ugc nofollow" target="_blank"/>" method = " POST "&gt;<br/>&lt;输入type = " hidden " name = " _ method " value = " patch "/&gt;<br/>&lt;输入type = " hidden " name = " user[email]" value = "<a class="ae mb" href="mailto:bello.carlos@something.com" rel="noopener ugc nofollow" target="_blank"/>"/&gt;<br/>&lt;输入类型submit()；<br/>&lt;/脚本&gt;<br/>&lt;/正文&gt; <br/> &lt; /html &gt;</p></blockquote><h2 id="68e6" class="ld le iq bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">利用来更改用户密码</h2><p id="7c3e" class="pw-post-body-paragraph kf kg iq kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc ij bi translated">在报告了这个bug之后，我意识到这个漏洞也可以用来修改用户的密码。这是因为应用程序没有提示输入当前密码:</p><blockquote class="mj mk ml"><p id="92ff" class="kf kg mm kh b ki kj kk kl km kn ko kp mn kr ks kt mo kv kw kx mp kz la lb lc ij bi translated"> <br/> &lt; html &gt; <br/> &lt;正文&gt; <br/> &lt;表单action = "【https://vulnerable.com/api/v2/users/update】method = " POST "&gt;<br/>&lt;input type = " hidden " name = " _ method " value = " patch "/&gt;<br/>&lt;input type = " hidden " name = " password " value = " you+have+hacked+by+retr 02332 "/&gt;<br/>&lt;/form【T43submit()；<br/>&lt;/脚本&gt;<br/>&lt;/正文&gt; <br/> &lt; /html &gt;</p></blockquote><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/76365dae13df2d91b517cb8abfe5566d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8w1-eH931gR3EO2U9I8CA.png"/></div></div></figure><p id="6997" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">由于我们能够改变密码和电子邮件(密码恢复方式)，我们已经设法完全获得帐户的任何用户的应用程序只需一次点击。</p><h2 id="5c33" class="ld le iq bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">为什么像雅虎这样的应用程序？至少有一个反CSRF的令牌？</h2><p id="8c37" class="pw-post-body-paragraph kf kg iq kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc ij bi translated">我想把最好的留到最后，我相信你们很多人都没有意识到这一点(虽然我不知道这种技术今天在Chrome中是否仍然有效)。</p><p id="f50d" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">原来<strong class="kh ir">雅虎！</strong>没有为请求中使用的会话cookie定义特定的SameSite。这在firefox中并不是一个主要的风险，因为它默认使用了<strong class="kh ir"> LAX </strong>。这可以防止在该浏览器中利用此漏洞。显然，<strong class="kh ir">雅虎！开发者认为所有的浏览器都会将这些cookies设置在<strong class="kh ir"> LAX </strong>中，这样就不必使用<strong class="kh ir">反CSRF </strong>令牌(这就是为什么需要有几层安全措施，谨慎胜于自信)。</strong></p><p id="2b33" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">然而，在Chrome中，情况就不同了。出于兼容性的原因，Chrome暂时允许没有显式设置SameSite属性的cookies被视为None，时间限制为两分钟。之后，浏览器会将它们设置为<strong class="kh ir"> LAX </strong>。Chrome将这个功能命名为<strong class="kh ir"> LAX+POST </strong>，你可以在这里找到更多关于它的细节<a class="ae mb" href="https://chromestatus.com/feature/5088147346030592" rel="noopener ugc nofollow" target="_blank">。有几种技术可以让Chrome指定的这两分钟更长。这些技巧可以在</a><a class="ae mb" href="https://medium.com/@renwa/bypass-samesite-cookies-default-to-lax-and-get-csrf-343ba09b9f2b" rel="noopener">这里</a>找到。</p><p id="e447" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我不确定这个技巧目前在Chrome中是否仍然有效。如果它在Chrome的最新版本中对你有效，请在评论框中告诉我；)</p><h2 id="e334" class="ld le iq bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">报告被接受并获得奖励</h2><p id="b047" class="pw-post-body-paragraph kf kg iq kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc ij bi translated">一旦我报告了这个错误，它在几天内被接受，并在3个月后获得奖励:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/ac72ab2690ff43e6f1c2f7fb1e5064a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*4FsSG5tuGG7KlfYoPOYAnA.png"/></div></figure><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/ef184a0217409e154f942820bcfba336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5JBdqpXCo8HiCHSnZxnqA.png"/></div></div></figure><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/5e26780cad37bd17e61f8fdedd061f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQfeaF6ol3iffsUa_1c-uQ.png"/></div></div></figure><h2 id="865d" class="ld le iq bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">再见</h2><p id="fcea" class="pw-post-body-paragraph kf kg iq kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc ij bi translated">这些都是暂时的，我希望你和我一样喜欢和学习。感谢阅读和快乐的黑客！</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/1fba0f34ce43f40b40f332eb3472d05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*ZdTT6F_lPLG3m9TrCKr1qw.gif"/></div></figure></div></div>    
</body>
</html>