<html>
<head>
<title>Browsers — A Localhost Gateway: Client Port Scanning Using WebAssembly And Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浏览器—本地主机网关:使用WebAssembly和Go进行客户端端口扫描</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/identify-website-users-by-client-port-scanning-using-webassembly-and-go-e9798b4aa05c?source=collection_archive---------1-----------------------#2021-07-25">https://infosecwriteups.com/identify-website-users-by-client-port-scanning-using-webassembly-and-go-e9798b4aa05c?source=collection_archive---------1-----------------------#2021-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="2db6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">网站倾向于从浏览器扫描其用户的开放端口，以更好地识别新用户/回头客。<br/>‘localhost’会不会被浏览器滥用？<br/>可以通过WebAssembly实现吗？</p><blockquote class="kt ku kv"><p id="399f" class="ju jv ks jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated">代码可在https://github.com/avilum/portsscan的<a class="ae kz" href="https://github.com/avilum/portsscan" rel="noopener ugc nofollow" target="_blank"/>，<br/>获得，欢迎投稿。</p></blockquote><p id="604e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我将展示浏览器如何被滥用来攻击本地主机服务——渗透组织或从浏览器运行远程代码。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/c532bca31b415553e797a764cc4abb64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ds068HNUqvMskugv"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@macroman?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Immo Wegmann </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e454" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们访问网页时，我们每个人都有一个独一无二的指纹，这不是什么秘密。客户指纹帮助网站跟踪我们在许多其他网站上的活动。 <br/>指纹是许多因素的组合，包括您的设备、浏览器、屏幕大小、IP地址和许多其他变量。当两者结合在一起时，它们使我们很容易被网站识别。</p><h1 id="b62c" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">关于客户端代码的一句话</h1><p id="22fe" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated">易贝等网站无休止地在我们的电脑上运行代码。他们以前只用JavaScript就能做到。<br/>这些年来，前端技术不断发展，比如<br/><strong class="jw ir">Javascript</strong>(ECMAScript)<strong class="jw ir">TypeScript</strong>、<a class="ae kz" href="https://deno.land/manual/getting_started/webassembly" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> Deno </strong> </a>(安全快速的Javascript运行时，用rust编写)</p><p id="8aff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">浏览器的Javascript API一直被恶意软件滥用，因为它是浏览器支持的唯一语言。随着近年来下一代web技术的发展，例如<strong class="jw ir"> WebAssembly </strong>，下一代恶意软件可能会更加复杂。</p><p id="03bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> WebAssembly </strong> (WASM)运行时允许将语言编译成二进制代码，浏览器的WebAssembly运行时可以使用这些代码在访问网页时在您的浏览器中执行低级代码。除了快得多<strong class="jw ir"/>(编译后的代码通常比JS、<strong class="jw ir">快，但不总是</strong>)之外，WASM将编程语言解耦，专注于“做什么”。</p><p id="c63f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">WebAssembly的运行时间令人惊叹——它为浏览器带来了许多新的API和功能，但没有免费的午餐——WASM是安全研究人员和黑客的一个很好的目标。毕竟，尽管它是公开的，但WASM有大量的代码没有经过多少人的审查。</p><p id="8b01" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是为什么许多新语言，如<a class="ae kz" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>、<a class="ae kz" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>和<a class="ae kz" href="https://deno.land/manual/getting_started/webassembly" rel="noopener ugc nofollow" target="_blank"> Deno </a>，为WebAssembly作为目标架构/运行时提供开箱即用的支持。到今天为止，你可以用Go、Rust等等编写代码，而不是使用javascript派生的语言。因此，系统编程语言在开发人员中变得广泛适用，他们希望获得超越我们曾经认为的“跨平台”的能力。<br/> <strong class="jw ir"> Python </strong>现在不那么“跨平台”了吧？(开个玩笑——你可能会觉得https://pyodide.org/en/stable/console.html很有趣)。</p><h1 id="4b20" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">研究WebAssembly运行时(使用Go)</h1><div class="lb lc ld le gt ab cb"><figure class="mt lf mu mv mw mx my paragraph-image"><img src="../Images/b56da4a11523b75481f1bc358b7f3346.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*dXrK6i4SJ3_ROuoeVLrJ0w.png"/></figure><figure class="mt lf mu mv mw mx my paragraph-image"><img src="../Images/59de314bdf361095637b65c940a3b4c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*yL_m-h_Ue8STUS78P7BZNg.jpeg"/></figure></div><p id="bd74" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi mz translated"><span class="l na nb nc bm nd ne nf ng nh di"> H </span>当用户访问我的网站时，从浏览器上下文映射主机上的开放端口(活动的监听服务)有多容易？我能用一种低级语言做到吗？</p><p id="e8ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为一个网站所有者，假设我想识别一个用户是否是开发者。<br/>端口扫描技术每秒都能发现资产和服务器。“开放端口”字面上指的是绑定到<a class="ae kz" href="https://en.wikipedia.org/wiki/Network_interface_controller" rel="noopener ugc nofollow" target="_blank"> NIC </a>设备上特定端口的服务器。有些服务必须手动定义，但许多操作系统在启动时运行服务，公开许多本地主机上可用的应用程序API，如IPC、SMB/Samba、SSH、SMTP、FTP等。</p><p id="cb0c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于这一点，找到易受1day漏洞(公开但未披露)攻击的资产变得非常容易。只是谁先到那里，是否被报告(和修复)的问题。</p><p id="a96f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">自从几年前第一次听说WASM，我就一直相信它。我开始玩它。我选择Go是因为它的easy Net/Socket和HTTP标准库API。顺便说一下，<strong class="jw ir"> Rust </strong>也获得了开箱即用的海量WebAssembly编译支持。</p><h1 id="deb1" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">理解流程</h1><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi ni"><img src="../Images/ab90049053e5447755b694d401163eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mK627c1sA2qbsti8SM3Xqw.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">用户访问网页</figcaption></figure></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="954f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，用户的浏览器将初始化WebAssembly运行时。然后，它将自动运行我的Go端口扫描器，它被编译成一个WebAssembly二进制文件。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nj"><img src="../Images/a618c205ebad34df053244bfeaf43832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eT4Kpx8RzsO7wA314FXFOQ.png"/></div></div></figure><h1 id="0d34" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">让我们开始:编写一个(不那么简单的)端口扫描器</h1><p id="8db9" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated">我使用Go的“syscalls/js”绑定遵循Javascript API。当我使用HTTP Go API时，我发现浏览器很喜欢它，但它不能很好地与(可能没有完全实现的)“net”Go API一起工作。</p><p id="b101" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">浏览器中尚不支持WebAssembly原始TCP会话和UDP。这个社区也在致力于新的<a class="ae kz" href="https://github.com/WebAssembly/WASI" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir"/></a>标准——最终有一天会要求浏览器实现原始的TCP/UDP会话。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="3ca8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在尝试了几种滥用WebAssembly的原始TCP会话来接收原始TCP响应的方法后，我明白了使用本机TCP会话扫描的<strong class="jw ir">编程是行不通的</strong>。出于安全原因(如CORS和不安全端口)，Chrome代理(有时会阻止)WebAssembly请求和响应。</p><h2 id="d716" class="nk lr iq bd ls nl nm dn lw nn no dp ma kf np nq me kj nr ns mi kn nt nu mm nv bi translated">让我们定义端口扫描器:</h2><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="2dc8" class="nk lr iq bd ls nl nm dn lw nn no dp ma kf np nq me kj nr ns mi kn nt nu mm nv bi translated">然后，我们将定义端口扫描功能:</h2><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="4e76" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Go的“http”API有一些很大的好处，比如用于HTTP跟踪的“GotFirstResponseByte”处理程序。我希望它能起作用，但它没有——想象一下这将是多么容易。</p><p id="e05d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用Go著名的“http”包会更好，毕竟——浏览器都是关于应用程序的。使用像HTTP这样的应用程序协议应该更容易。</p><h1 id="1950" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">理解反应。</h1><p id="760a" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated"><strong class="jw ir">您如何使用高级HTTP会话一致地扫描端口？<br/> </strong>得到回应是一回事。理解它们并对它们进行正确的分类是一个挑战，因为我们不能按原样看到响应。端口扫描器通常使用原始数据包和会话对网络进行分类。在WebAssembly运行时内部，这在撰写本文时是不可能的。</p><p id="ff73" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">我们可以积极地对以下响应进行分段:</strong> <br/> -连接被拒绝(端口关闭)<br/> <strong class="jw ir"> - </strong>超时(端口可以是打开的，也可以是关闭的)。<strong class="jw ir"> <br/> </strong> - HTTP响应(打开——并且对方有有效的HTTP服务器！)</p><h2 id="4f47" class="nk lr iq bd ls nl nm dn lw nn no dp ma kf np nq me kj nr ns mi kn nt nu mm nv bi translated">我发现相对较小的超时非常可靠。</h2><p id="a2c3" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated">随着我的进步，我遇到了更多的问题。浏览器拦截了缺少<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>报头的有效HTTP响应，将其描述为一般的“获取错误”，掩盖了错误的真正原因，并将请求标记为“不安全”。浏览器甚至没有将错误内容转发给WASM运行时——它只是失败了，没有进一步的细节。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">迭代常见错误。将它们视为“开放端口”。</figcaption></figure><h2 id="7757" class="nk lr iq bd ls nl nm dn lw nn no dp ma kf np nq me kj nr ns mi kn nt nu mm nv bi translated">CORS怎么样？</h2><p id="eddc" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated">localhost HTTP服务经常错过“跨源-****”头。<br/><strong class="jw ir"/>(不同于<strong class="jw ir"> window.location </strong>的<strong class="jw ir">主机+端口</strong>的组合)保护默认可用，所以没有这些头的HTTP请求会失败。您无法知道请求失败是因为WebAssembly上下文中的CORS。</p><p id="14e8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我不得不设法克服这一点，在经典的JS中，人们会简单地在fetch()请求中添加一个‘no-CORS’模式。在做了一些研究之后，想到了一种覆盖JS的fetch() API调用的方法，我发现了一个非常简单的方法，它非常有效！</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">我从来没有想过在我的请求中添加这样一个HTTP头。使用Go语言修改浏览器行为(syscall)就是这样一种有线方式。</figcaption></figure><p id="7411" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，CORS不再是演示的问题，但这并不意味着它将在明确指定“访问控制允许来源”标题的网站上工作。我们无法处理这种情况。尽管如此，世界上仍有很多网站可以成功运行这一WASM代码。</p><h2 id="64cd" class="nk lr iq bd ls nl nm dn lw nn no dp ma kf np nq me kj nr ns mi kn nt nu mm nv bi translated">支持TLS/SSL服务的端口</h2><p id="d407" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated">如果没有SSL握手，我们会“跳过”浏览器默认激活的许多SSL安全特性。这有助于我找到任何TCP开放端口，而不仅仅是接受SSL传输的服务。</p><p id="9ce3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们必须记住，WebAssembly运行时的TCP栈是由Chrome自己的TCP栈代理的。如果证书不匹配，浏览器会终止我们的SSL请求，而不说明原因——这看起来就像典型的“连接被拒绝”。SSL增加了复杂性和安全性，因此我继续使用纯文本HTTP。</p><h2 id="eb5a" class="nk lr iq bd ls nl nm dn lw nn no dp ma kf np nq me kj nr ns mi kn nt nu mm nv bi translated">定义启动功能:</h2><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">请注意我使用syscalls/js库注入的JS DOM元素，它支持使用Go代码修改DOM。我对它的简单感到惊讶。</figcaption></figure><h2 id="bd17" class="nk lr iq bd ls nl nm dn lw nn no dp ma kf np nq me kj nr ns mi kn nt nu mm nv bi translated">编译代码:</h2><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="c25e" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">定义加载WASM的网页</h1><p id="2186" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated">现在我们来看看客户的电脑。哪些端口当前正在监听(例如“打开”)？</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">注意wasm_exec.js脚本标记，它是WebAssembly Go运行时绑定。</figcaption></figure><p id="abe8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">开始本地演示:</p><pre class="lb lc ld le gt ny nz oa ob aw oc bi"><span id="f6b5" class="nk lr iq nz b gy od oe l of og">&gt;&gt;&gt; python3 -m http.server 5000</span></pre><h1 id="bb2c" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">访问时运行本地端口扫描:</h1><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi oh"><img src="../Images/053fbe86790872621891d79182caf283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BbmAne2qUiefBYtNyPEzCQ.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">访问者在启动时看到的(index.html)——HTML本身作为Go loads被注入！多酷啊。</figcaption></figure><h2 id="468c" class="nk lr iq bd ls nl nm dn lw nn no dp ma kf np nq me kj nr ns mi kn nt nu mm nv bi translated">让我们来看看访问者的网络数据包</h2><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi oi"><img src="../Images/36fc8422b5e0bfd2ffeb3e4375c28ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXXyvY9E2L4SDFjQkQiEqg.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">网络数据包在本地主机(环回)网络接口上被捕获。数据包在左边编号:数据包10–20，是index.html请求和响应，包括脚本。在数据包22之后，浏览器开始端口扫描。它发出(TCP SYN)数据包，并接收(RST，ACK)数据包作为响应，这意味着端口关闭。</figcaption></figure><p id="210b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们来看一个开放端口指示器。<br/>如果套接字接收到HTTP超时，但没有接收到ConnectionRefused错误，则在接受连接的端口(通常被视为“已过滤”)上一定有什么在侦听，并返回Reset / Ack响应。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi oj"><img src="../Images/e5e3c6981235d67d4ade8c2e8dd07a21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CXAb5hR_zowJpbTNDDWJxQ.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">注意有效的HTTP / TCP响应(蓝色/紫色)。有人在外面偷听！</figcaption></figure><h1 id="a3fe" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">综上所述:</h1><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi ok"><img src="../Images/451a41af3c79b4834c0a56fc1901a2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2OdEOeBzjLhgibhFIdpSg.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">通过浏览器的WebAssmebly运行时对访问者运行端口扫描的HTML页面</figcaption></figure><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi ol"><img src="../Images/8073e8d59d4e2a911c820965bc820986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESicrM-9oniIM22Zx_Hssw.png"/></div></div></figure><h1 id="2bcd" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">将结果与实际情况进行比较。</h1><p id="4194" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated">我用<a class="ae kz" href="https://en.wikipedia.org/wiki/Netstat" rel="noopener ugc nofollow" target="_blank"> netstat </a>和<a class="ae kz" href="https://nmap.org/" rel="noopener ugc nofollow" target="_blank"> nmap </a>来验证我所看到的。<br/>我期望我的结果是一样的，事实也的确如此。</p><div class="lb lc ld le gt ab cb"><figure class="mt lf om mv mw mx my paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><img src="../Images/c562b20e94839964e53f93b48c59a54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*6rHN-xS4AG7-9wzyf4xz4g.png"/></div></figure><figure class="mt lf on mv mw mx my paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><img src="../Images/0546d7c2f3d1c7b5c96e9ee06c7517ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*i55TYJScTqN8_RgODQkSYA.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk oo di op oq translated">NetStat输出(打开侦听当前操作系统的端口)与NMap输出(从攻击者的角度看，TCP扫描这些端口)的对比。我在WASM港口扫描仪中找到的每个港口都得到这些结果的支持。</figcaption></figure></div></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="0613" class="lq lr iq bd ls lt or lv lw lx os lz ma mb ot md me mf ou mh mi mj ov ml mm mn bi translated">Localhost不是本地的，毕竟是远程的。</h1><p id="24c6" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated">今天，当在个人计算机上配置或工作时，我们将Localhost视为一个“安全”或“封闭”的环境。曾经，攻击本地主机服务似乎要困难得多。我们安装的持久化应用程序经常在本地主机上分配和监听端口。</p><p id="d636" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">操作系统</strong>倾向于<strong class="jw ir">打开本地主机</strong>网络接口上的端口，<strong class="jw ir">在启动</strong>时开始工作。无论是<strong class="jw ir"> Windows，Mac，Linux</strong>——你的电脑在本地主机上监听某些东西。正如我所展示的——Javascript或WebAssembly应用程序可以轻松地扫描这些本地主机服务。他们也可以虐待他们。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="1003" class="lq lr iq bd ls lt or lv lw lx os lz ma mb ot md me mf ou mh mi mj ov ml mm mn bi translated">场景1:使用单一访问，通过Linux客户端上的RPC漏洞拒绝服务。</h1><p id="473e" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated"><a class="ae kz" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-8779" rel="noopener ugc nofollow" target="_blank">https://cve.mitre.org/cgi-bin/cvename.cgi?name = CVE-2017-8779</a><br/><strong class="jw ir">RPC-BOMB</strong>是一个示例漏洞，攻击者可以通过过时的Linux内置RPC服务(<a class="ae kz" href="https://man7.org/linux/man-pages/man8/rpcbind.8.html#:~:text=The%20rpcbind%20utility%20is%20a,it%20is%20prepared%20to%20serve." rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> rpcbind </strong> </a>)，使用<strong class="jw ir">恶意TCP数据包</strong>，在操作系统上造成拒绝服务攻击。</p><p id="ef5e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">想象一下:你访问一个网站。一秒钟后——你的电脑卡住或重启，破坏了你最近未保存的工作。<strong class="jw ir"> <br/> 1。</strong>查找易受攻击端口是否打开(111) <br/> <strong class="jw ir"> 2。</strong>向本地主机发送巧尽心思构建的TCP数据包:111 <br/> <strong class="jw ir"> 3。您已经成功关闭了访客的电脑。</strong></p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><h1 id="2b59" class="lq lr iq bd ls lt or lv lw lx os lz ma mb ot md me mf ou mh mi mj ov ml mm mn bi translated">场景2: Windows后台打印程序远程代码执行漏洞(<a class="ae kz" href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-34527" rel="noopener ugc nofollow" target="_blank">CVE-2021–34527</a>):</h1><blockquote class="kt ku kv"><p id="cc48" class="ju jv ks jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated">当Windows后台打印程序服务不正确地执行特权文件操作时，存在一个远程代码执行漏洞。成功利用此漏洞的攻击者可以使用系统权限运行任意代码。然后，攻击者可以安装程序；查看、更改或删除数据。或者创建具有完全用户权限的新帐户。</p></blockquote><p id="9797" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于浏览器对localhost、0.0.0.0、192.168.1.1等的访问，该漏洞可用于攻击数百万用户，利用不同的设备。我们很多人都使用windows，这种易受攻击的服务会在启动时启动并运行。绑定在0.0.0.0上，可通过网络访问，黑客可以利用此漏洞渗透组织。</p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="4ee1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">开发人员(比如我自己)经常在localhost上运行本地服务器/容器。<br/>我也经常忘记关闭它们(例如，当使用restart=always运行docker容器时)。除了利用漏洞之外，开发人员还可以被识别(例如通过stack overflow/Linkedin/脸书),以了解我们在开发中使用了哪些技术。</p><p id="4a99" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">依我拙见，浏览器WASM攻击面将随着时间的推移被滥用，因为更多的未来将被实现。<br/>在本文中，我展示了关于浏览器的安全特性，一个web页面如何在用户的本地主机网络上通信和映射服务。它可以在许多编译成web程序集的语言中实现，尽管目前还不可能使用原始的TCP/UDP会话。</p><p id="ef87" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我举了一个例子，Linux主机可以通过从浏览器访问网页来体验DOS以及如何利用微软的新漏洞<a class="ae kz" href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-34527" rel="noopener ugc nofollow" target="_blank">CVE-2021–34527</a>。</p><p id="8380" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae kz" href="https://wasi.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir"> WASI </strong> </a>令人惊叹。<br/><a class="ae kz" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">web assembly</strong></a>很棒。<br/> <a class="ae kz" href="https://community.spiceworks.com/topic/1244428-i-need-a-new-browser-one-that-doesn-t-suck-when-you-use-it" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">浏览器</strong> </a>并没有那么好——它们将永远对我们所有人构成严重的风险&amp;攻击媒介，因为随着时间的推移，它们将变成操作系统，支持越来越多的WASI规范功能。</p><h1 id="ba6e" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">密码</h1><p id="3291" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated">代码可在<a class="ae kz" href="https://github.com/avilum/portsscan" rel="noopener ugc nofollow" target="_blank">https://github.com/avilum/portsscan</a>获得，欢迎投稿。</p></div></div>    
</body>
</html>