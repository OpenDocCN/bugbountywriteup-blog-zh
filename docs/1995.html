<html>
<head>
<title>Server-Side Request Forgery (SSRF) Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器端请求伪造(SSRF)解释</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/server-side-request-forgery-ssrf-explained-7d87b67b0e3b?source=collection_archive---------3-----------------------#2022-04-08">https://infosecwriteups.com/server-side-request-forgery-ssrf-explained-7d87b67b0e3b?source=collection_archive---------3-----------------------#2022-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="aa1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">服务器端请求伪造</strong>(或<strong class="jp ir"> SSRF </strong>)是一种攻击，包括诱导web应用程序向非预期目的地发送后端请求。</p><p id="7b1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在云服务和复杂后端架构日益普及的推动下，这种攻击近年来变得越来越常见。</p><p id="ffb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在OWASP十大Web应用程序安全风险中，SSRF有自己的类别(A10)，这反映了此漏洞的严重程度。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/684a7614c2e35486c433176a3e3e5501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*J-UwIM_jtF1yJG051hf7kg.jpeg"/></div></figure></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="92b0" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是SSRF？</h1><p id="85cf" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">在服务器端请求伪造攻击中，恶意参与者将通过发送包含伪造URL的请求来利用web应用程序。该URL通常指向位于受限后端位置的资源。这将导致web应用程序与这个非预期的目的地进行通信，并将结果发送回用户。</p><p id="6d95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目的地可以在目标web应用服务器所在的后端网络上，也可以在同一台服务器上。另一种类型是目的地位于外部服务器上，通常由攻击者控制。</p><h2 id="c645" class="md lb iq bd lc me mf dn lg mg mh dp lk jy mi mj lo kc mk ml ls kg mm mn lw mo bi translated">瞄准内部基础设施</h2><p id="7791" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">在这种类型的SSRF中，攻击者会试图向无法从Internet访问的后端服务发送请求。</p><p id="364f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，该服务器位于防火墙后面的安全区域，并且可以向web应用程序授予例外，以允许它与服务器通信。</p><p id="36ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">攻击者将利用后端服务在易受攻击的应用程序中建立的信任关系。他们会诱使应用程序向后端系统发送请求，从而允许他们未经授权访问数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/2c138f0fd06b206e64109bd64ecf65d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/0*EjZGGgXOC7-bXQF8.jpg"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">SSRF过程</figcaption></figure><p id="09cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一个攻击者如何利用易受攻击的web应用程序的示例。</p><p id="be73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">不安全应用示例</strong></p><p id="0247" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了演示攻击是如何进行的，我们将考虑一个非常基本的不安全PHP代码的例子。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="d42e" class="md lb iq mu b gy my mz l na nb">&lt;?php <br/>if (isset($_GET['url']))<br/>{<br/>// The url is provided in a GET parameter<br/>$url = $_GET['url'];<br/>// The destination url is accessed and the content is opened<br/>$handle = fopen($url,"rb");<br/>// The content of the file is dumped<br/>fpassthru($handle);<br/>}<br/>?&gt;</span></pre><p id="5f00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，应用程序打开一个名为<code class="fe nc nd ne mu b">url</code>的GET参数中提供的文件。</p><p id="af64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当用户向应用程序发送请求时，它看起来是这样的:</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="2e50" class="md lb iq mu b gy my mz l na nb">GET /?url=http://destination.com/resource<br/>Host: vulnerablesite.com</span></pre><p id="5c07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，用户可以操作这个参数，并将其更改为他们想要的任何其他URL。因为应用程序没有任何保护机制来防止这种情况，所以用户可以提供一个私有IP地址来诱导应用程序检索后端网络上的资源。</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="3651" class="md lb iq mu b gy my mz l na nb">GET /?url=http://192.168.1.45/resource<br/>Host: vulnerablesite.com</span></pre><p id="8a30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述IP地址位于192 . 168 . 0 . 0–192 . 168 . 255 . 255范围内，该范围是为私有IP地址保留的。</p><p id="84a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在到达这行代码:<code class="fe nc nd ne mu b">$handle = fopen($url,"rb");</code>时，web应用程序将向在本地网络上拥有这个IP <code class="fe nc nd ne mu b">192.168.1.45</code>的主机发送一个请求。</p><p id="a9d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，在这种情况下，后端服务拥有这个IP地址的几率非常低。</p><p id="9549" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，攻击者可以构建一个脚本来执行主机发现。该脚本将扫描私有IP的所有可能范围，并检测哪些后端服务做出响应。</p><p id="c54e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">攻击者还可以更进一步，在发现的主机上执行端口扫描。</p><h2 id="5721" class="md lb iq bd lc me mf dn lg mg mh dp lk jy mi mj lo kc mk ml ls kg mm mn lw mo bi translated">以同一台服务器为目标</h2><p id="d8d5" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">另一种类型的SSRF包括以承载web应用程序的相同服务器为目标。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/43185ca7c060aaa359e7bb5fc588ff6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/0*DjbHJjsrMlfl2fCa.jpg"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">SSRF瞄准同一个服务器</figcaption></figure><p id="2912" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">攻击者可以提供环回地址(127.0.0.1或localhost ),后跟要公开的文件的路径。</p><p id="bd44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">他们还可以使用以<code class="fe nc nd ne mu b">file:///</code>开头的URL来使用服务器上文件的绝对路径。</p><p id="1b95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据前面给出的同一个示例，针对同一台服务器的HTTP请求将如下所示:</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="90f7" class="md lb iq mu b gy my mz l na nb">GET /?url=http://127.0.0.1/resource<br/>Host: vulnerablesite.com</span></pre><p id="dbb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者</p><pre class="km kn ko kp gt mt mu mv mw aw mx bi"><span id="c1d6" class="md lb iq mu b gy my mz l na nb">GET /?url=file:///path/to/local/resource<br/>Host: vulnerablesite.com</span></pre><p id="a75d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，攻击者可以利用此漏洞在托管web应用程序的机器上执行端口扫描。这可能会泄露目标计算机上运行的可能服务的信息。</p><h1 id="393e" class="la lb iq bd lc ld nf lf lg lh ng lj lk ll nh ln lo lp ni lr ls lt nj lv lw lx bi translated">防止SSRF袭击</h1><p id="1d70" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">为了保护您的web应用程序免受服务器端请求伪造，有一组好的实践可以遵循。它们应该可以帮助您降低SSRF攻击您的应用程序的风险。</p><p id="7265" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">白名单:</strong>不依赖黑名单网址。恶意用户总能找到绕过这些过滤器的方法，要么使用不同的编码；使用指向同一位置的替代域；或者利用开放重定向漏洞。相反，您可以使用白名单来只允许授权的目的地。</p><p id="4721" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">网络分段:</strong>并非所有后端服务都需要在同一个网络上。您可以尝试通过防火墙将您的网络分成多个部分。如果SSRF袭击发生的话，这应该会降低其影响。</p><p id="8acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">只允许https模式:</strong>通常，应用程序只需要使用https模式进行通信。可以禁用其他模式，如<code class="fe nc nd ne mu b">file:///</code>、<code class="fe nc nd ne mu b">ftp://</code>等可用于利用SSRF漏洞的模式。</p><p id="2918" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">认证:</strong>您的应用程序应该要求认证，即使是同一内部网络上的后端服务之间的通信。</p><p id="aef8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，不用说，您应该始终遵循安全web应用程序的通用良好实践。这些包括用户输入验证、正确的错误处理、安全的API实践、安全的HTTP头等等。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><p id="ce53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nk">原载于2022年4月8日https://patchthenet.com</em><a class="ae nl" href="https://patchthenet.com/articles/web-application-security/server-side-request-forgery-ssrf-explained/" rel="noopener ugc nofollow" target="_blank"><em class="nk"/></a><em class="nk">。</em></p></div></div>    
</body>
</html>