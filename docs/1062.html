<html>
<head>
<title>DBaaSadge — Writeup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DBA asedge—向上写</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/dbaasadge-writeup-61ebcdbe4357?source=collection_archive---------2-----------------------#2021-01-12">https://infosecwriteups.com/dbaasadge-writeup-61ebcdbe4357?source=collection_archive---------2-----------------------#2021-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/b7fb396f7f953a5cfdce84a8689f563d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*k9h6otL8sez-GgVDYkzeng.png"/></div></figure><div class=""/><div class=""><h2 id="1702" class="pw-subtitle-paragraph ju iw ix bd b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dk translated">CTF现实世界2021</h2></div><p id="33b8" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">今年我和索克劳德队在真实世界CTF比赛，我们获得了第二名。我参与了解决DBaaSadge，一个网络挑战，我很高兴把我的文章作为一个很好的知识来源分享给其他人。</p><p id="fb10" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如果您想了解自己的设置，您可以在这里找到所有的挑战文件<a class="ae li" href="https://github.com/chaitin/Real-World-CTF-3rd-Challenge-Attachments/tree/main/DBaaSadge" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="2bd7" class="lj lk ix bd ll lm ln lo lp lq lr ls lt kd lu ke lv kg lw kh lx kj ly kk lz ma bi translated">挑战</h1><p id="18bb" class="pw-post-body-paragraph km kn ix ko b kp mb jy kr ks mc kb ku kv md kx ky kz me lb lc ld mf lf lg lh ij bi translated">在挑战中，我们得到了一个Dockerfile文件，它建立了一个Postgres 10数据库，有两个扩展:<a class="ae li" href="https://www.postgresql.org/docs/10/dblink.html" rel="noopener ugc nofollow" target="_blank"> dblink </a>和<a class="ae li" href="https://github.com/EnterpriseDB/mysql_fdw" rel="noopener ugc nofollow" target="_blank"> mysql_fdw </a>。第一个是Postgres本身的扩展，允许用户链接和连接Postgres数据库。第二个扩展实现了同样的功能，但是使用MySQL数据库。</p><p id="2cbf" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为了与数据库对话，我们可以使用HTTP请求来执行SQL语句并返回输出。在下面的代码中，<em class="mg">index.php</em>，你可以清楚地看到其中的逻辑。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">挑战的index.php</figcaption></figure><p id="9c95" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">查看逻辑，我们可以看到SQL命令被限制在100个字符以内，由Postgres数据库中的用户<em class="mg"> realuser </em>执行。此外，数据库包含超级用户postgres，我们可以在提供的Dockerfile文件中看到。最后，服务器包含一个<em class="mg"> getflag </em>二进制文件，我们需要执行它来接收这个标志。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">该片段显示了Dockerfile文件的一部分</figcaption></figure><p id="10fa" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为了理解解决挑战和最终利用的途径，让我们以相反的顺序开始，考虑如何执行任意代码。</p><h1 id="663f" class="lj lk ix bd ll lm ln lo lp lq lr ls lt kd lu ke lv kg lw kh lx kj ly kk lz ma bi translated">远程代码执行</h1><p id="a8f6" class="pw-post-body-paragraph km kn ix ko b kp mb jy kr ks mc kb ku kv md kx ky kz me lb lc ld mf lf lg lh ij bi translated">从测试任意代码开始，为了更容易使用，我们在本地机器上设置了挑战，并将超级用户密码改为<em class="mg">密码</em>。此外，我们直接在服务器上执行SQL命令，而不是使用HTTP请求来避免100个字符的限制。这使得调试更加容易。</p><p id="a282" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">接下来，我们查看Postgres文档，发现<a class="ae li" href="https://www.postgresql.org/docs/10/sql-copy.html" rel="noopener ugc nofollow" target="_blank"> COPY语句</a>可以通过提供关键字PROGRAM来执行命令。所以，我们来试试吧。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">通过“从程序复制”，用户可以在Postgresql中执行外壳代码</figcaption></figure><p id="9188" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们可以看到，我们首先创建了一个表，在这个表中我们复制了shell命令<em class="mg"> id </em>的输出。之后，我们可以通过从cmd_table中选择数据来查看结果。这很容易，并让我们从数据库内部执行任意代码。</p><p id="3cb6" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">不幸的是，在数据库内部，程序选项只对超级用户可用。因此，下一步是考虑如何成为超级用户。</p><p id="3a40" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">回想一下，我们启用了扩展dblink。使用这个扩展，我们可以通过指定主机、数据库、用户和密码来连接Postgres数据库。</p><pre class="mh mi mj mk gt mr ms mt mu aw mv bi"><span id="6324" class="mw lk ix ms b gy mx my l mz na">SELECT * FROM dblink ('host=127.0.0.1 dbname=postgres user=postgres password=password', 'COPY cmd_table FROM PROGRAM ''/readflag'';') AS a (b text);</span></pre><p id="e888" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在上面的SQL语句中，我们可以看到，如果我们知道超级用户postgres的密码，我们也可以将我们的本地机器和当前数据库postgres连接起来。此外，我们执行readflag二进制文件。</p><p id="08b3" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在执行readflag二进制文件之前，我们有两个限制。第一，我们不知道密码。第二，语句长度超过100个字符。</p><h1 id="9697" class="lj lk ix bd ll lm ln lo lp lq lr ls lt kd lu ke lv kg lw kh lx kj ly kk lz ma bi translated">长度限制旁路</h1><p id="e5f3" class="pw-post-body-paragraph km kn ix ko b kp mb jy kr ks mc kb ku kv md kx ky kz me lb lc ld mf lf lg lh ij bi translated">如果执行复杂的SQL语句，100个字符并不多。因此，我们寻找绕过这一限制的方法。幸运的是，这种绕过是通过所谓的eval方法实现的:我们将长有效载荷存储到数据库中，并使用eval函数执行它。</p><p id="51c7" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">首先，让我们看看我们创建的eval函数。</p><pre class="mh mi mj mk gt mr ms mt mu aw mv bi"><span id="1736" class="mw lk ix ms b gy mx my l mz na">CREATE FUNCTION eval_func (i TEXT, out o TEXT) AS $$ BEGIN execute i INTO o; END $$ LANGUAGE plpgsql</span></pre><p id="3def" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">创建的函数接受输入文本I，执行它，并返回输出o——这正是我们对eval的期望。这个eval现在可以用来执行任意长度的SQL语句，如下例所示。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">使用eval表和函数，我们可以执行任意长度的SQL语句。</figcaption></figure><p id="c0c0" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">如前所述，我们将命令的所有部分插入到eval表中，并使用连接的命令字符串作为输入来调用eval函数。</p><p id="fc0a" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这样，只有超级用户的密码丢失。</p><h1 id="febf" class="lj lk ix bd ll lm ln lo lp lq lr ls lt kd lu ke lv kg lw kh lx kj ly kk lz ma bi translated">密码文件</h1><p id="0a34" class="pw-post-body-paragraph km kn ix ko b kp mb jy kr ks mc kb ku kv md kx ky kz me lb lc ld mf lf lg lh ij bi translated">窃取超级用户密码是挑战的主要部分，是基于MySQL协议中一个非常巧妙的设计缺陷。</p><p id="8a79" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">MySQL包含一个名为<a class="ae li" href="https://dev.mysql.com/doc/refman/8.0/en/load-data.html" rel="noopener ugc nofollow" target="_blank"> LOAD DATA </a>的函数，允许用户将数据从一个文件加载到一个表中。然而，它也允许客户端提供一个本地文件<a class="ae li" href="https://dev.mysql.com/doc/refman/8.0/en/load-data-local-security.html" rel="noopener ugc nofollow" target="_blank">，如果他指定了本地关键字</a>。由于SQL语句解析发生在服务器端，恶意的MySQL服务器可以随时告诉连接的客户端传输任何文件。</p><p id="c45e" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">对于mysql_fdw，Postgres服务器处于作为mysql客户端可能受到该设计缺陷攻击的情况。例如，通过下面的SQL语句，我们可以将Postgres服务器连接到MySQL服务器，无论恶意与否。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">将Postgres服务器连接到MySQL的SQL语句。</figcaption></figure><p id="3f84" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">幸运的是，利用上述缺陷的恶意服务器已经在GitHub 上实现了<a class="ae li" href="https://github.com/jib1337/Rogue-MySQL-Server" rel="noopener ugc nofollow" target="_blank">。服务器从我们指定路径的客户端下载任何文件。记住Postgres密码文件的路径，这可以为我们提供超级用户的密码散列。事实上，要使用恶意服务器获取散列文件，公共可用服务器上的以下行(加上前面提到的SQL语句)就足够了:</a></p><pre class="mh mi mj mk gt mr ms mt mu aw mv bi"><span id="251a" class="mw lk ix ms b gy mx my l mz na">python RogueSQL.py -f "/var/lib/postgresql/10/main/global/1260"</span></pre><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">Postgres的密码文件包含所有密码的哈希。</figcaption></figure><p id="c525" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在，知道了hash <code class="fe nb nc nd ms b">a4824021a91d43cfeede15fdfbf77382f</code>，我们使用hashcat来快速破解它。由于它仅由五个随机字符组成，破解只需几秒钟。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/1c553bef1f58bfc4390a4dc682042b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*ZTyH0jW4S6OzLYDG2cYZmw.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">Hashcat输出密码</figcaption></figure><h1 id="ef19" class="lj lk ix bd ll lm ln lo lp lq lr ls lt kd lu ke lv kg lw kh lx kj ly kk lz ma bi translated">最后的利用</h1><p id="7cef" class="pw-post-body-paragraph km kn ix ko b kp mb jy kr ks mc kb ku kv md kx ky kz me lb lc ld mf lf lg lh ij bi translated">最后，我们把所有的部分组合在一起，得到了这面旗帜。让我总结一下最后的利用:</p><ol class=""><li id="975d" class="nf ng ix ko b kp kq ks kt kv nh kz ni ld nj lh nk nl nm nn bi translated">启动一个公开的恶意MySql服务器，从每个连接的客户端请求密码文件。</li><li id="6c3b" class="nf ng ix ko b kp no ks np kv nq kz nr ld ns lh nk nl nm nn bi translated">向服务器发送SQL，以HTTP请求的形式连接到恶意的MySql服务器。</li><li id="cb19" class="nf ng ix ko b kp no ks np kv nq kz nr ld ns lh nk nl nm nn bi translated">从密码文件中取出散列，用hashcat破解它。</li><li id="eb9e" class="nf ng ix ko b kp no ks np kv nq kz nr ld ns lh nk nl nm nn bi translated">使用密码伪造一个SQL语句，通过dblink以postgres用户的身份执行<em class="mg"> readflag </em>。</li><li id="ace9" class="nf ng ix ko b kp no ks np kv nq kz nr ld ns lh nk nl nm nn bi translated">将语句分成几部分，并使用eval函数绕过100个字符的限制。</li><li id="9ac0" class="nf ng ix ko b kp no ks np kv nq kz nr ld ns lh nk nl nm nn bi translated">获取标志:<strong class="ko iy">rw CTF { pop _ cat _ says _ P1 ea5e _ upd4t 3 _ youR _ libmysql client _ kekW }</strong></li></ol><p id="a9d8" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">很艰难，不是吗？下面你可以看到我最后的python漏洞，它执行除了恶意的MySQL服务器和hashcat之外的所有部分。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="a841" class="lj lk ix bd ll lm ln lo lp lq lr ls lt kd lu ke lv kg lw kh lx kj ly kk lz ma bi translated">摘要</h1><p id="9e9c" class="pw-post-body-paragraph km kn ix ko b kp mb jy kr ks mc kb ku kv md kx ky kz me lb lc ld mf lf lg lh ij bi translated">重新思考挑战显示了挑战的各个阶段，这是我们在CTF期间发现的。我个人学到了很多关于SQL服务器的知识，并喜欢编写最终的漏洞利用。感谢挑战作者这么好的挑战！</p></div></div>    
</body>
</html>