<html>
<head>
<title>Breaking Down: SHA-1 Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解:SHA-1算法</h1>
<blockquote>原文：<a href="https://infosecwriteups.com/breaking-down-sha-1-algorithm-c152ed353de2?source=collection_archive---------0-----------------------#2019-11-06">https://infosecwriteups.com/breaking-down-sha-1-algorithm-c152ed353de2?source=collection_archive---------0-----------------------#2019-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/28bc47d5ae60030f66217981d26698d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*PSMjToG-xUgqVMkPYRY91A.png"/></div></figure><div class=""/><div class=""><h2 id="6718" class="pw-subtitle-paragraph ju iw ix bd b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dk translated">看看引擎盖下面，了解它是如何工作的？</h2></div><p id="23b4" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我已经有一个多月没有写博客了，说实话，原因是我完全没有内容。你可以说我只是没有汽油了，所以我休息了一段时间，日复一日地回到基础学习中。它涉及很多东西，安全编码、云安全、docker和docker安全、哈希和密码学。现在，我已经关注了这些事情，您可以期待关于这些主题的文章。如果有什么事情，特别是你想让我写下来并详细解释给你听的话，你绝对可以找我。</p><p id="1331" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">让我们回到我们在这里的目的，安全哈希算法，又名SHA，是一种哈希技术，它已经被用于各种技术，从校验和，文件集成验证，密码验证等。现有的所有散列技术都具有这两个突出的特征，即这些散列函数的输出将是固定长度的，它可以根据散列函数的不同而不同，但是对于特定的散列函数，散列的长度永远不会改变。哈希函数也是压缩函数，因此其输出通常被称为摘要。</p><p id="c1ce" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我写这篇文章的原因是，尽管大多数安全社区都知道这些算法，并将它们作为它们导入的库的一部分，但他们中的大多数人实际上并不知道hash究竟是如何不可逆的，以及为什么它不能被逆向工程。深入了解哈希技术的工作原理以及为什么一种哈希算法比另一种更好在网络安全领域非常有帮助，并且让您了解应该使用哪些算法，而不仅仅是下载库并在我们的程序中运行它们。</p><h1 id="c8fe" class="li lj ix bd lk ll lm ln lo lp lq lr ls kd lt ke lu kg lv kh lw kj lx kk ly lz bi translated">我们开始吧！</h1><p id="d163" class="pw-post-body-paragraph km kn ix ko b kp ma jy kr ks mb kb ku kv mc kx ky kz md lb lc ld me lf lg lh ij bi translated">在我们深入了解SHA-1及其算法之前。首先，我们需要知道每个哈希算法必须遵循和遵守的规则或属性。有两个这样的规则，第一，原始消息不应该从生成的消息摘要中导出，第二，两个不同的消息不应该具有相同的消息摘要。只要我们理解了这些，我们就能在接下来的步骤中理解为什么在散列算法中使用如此复杂和不可逆的过程。</p><p id="b8ab" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">首先，让我们来鸟瞰一下哈希算法是怎么回事。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mf"><img src="../Images/7795e8cc644aee69a1064abf4ecd586d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3DPD7wSGOcfhJTl6djRhw.png"/></div></div></figure><p id="fa8b" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">图像最左边的部分是我们想要散列的消息，然后我们对我们的消息执行散列函数，以接收散列，在这种特定情况下，它是160位。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mo"><img src="../Images/4cf9124f1372a7deaf765de69ad54c93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F0pxCdC40NvInv3AULmynQ.png"/></div></div></figure><p id="926d" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">让我们更深入地看看左边的图像。首先，我们将我们的消息分成“n”个部分，我们将其描述为X，每个部分的大小为448位，然后我们为每个部分添加64位填充，从而将它们的总长度转换为512位。然后，这512位与压缩输出的160位一起被放入压缩函数中，第一次执行时，我们为160位值提供了一个预定义的值。</p><p id="5a0e" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这个过程一次又一次地持续‘n’次，直到产生消息的最后160位，这就是描述为H(x)的散列</p><h1 id="62d3" class="li lj ix bd lk ll lm ln lo lp lq lr ls kd lt ke lu kg lv kh lw kj lx kk ly lz bi translated">压缩功能</h1><p id="eafa" class="pw-post-body-paragraph km kn ix ko b kp ma jy kr ks mb kb ku kv mc kx ky kz md lb lc ld me lf lg lh ij bi translated">现在让我们更深入地看看上图中的压缩函数。压缩函数本身总共有80个循环，请记住，这80个循环发生在图像的每个部分，当填充时，每个部分总计为512位。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mp"><img src="../Images/aafccbf1d5fbcb186c83b1364e24e789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jTtd6OaB4F2yt3QcQTufqw.png"/></div></div></figure><p id="9c28" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在，下一部分是这512位被进一步分成16个部分，每个部分32位，这些被标记为从M1到M16。</p><p id="ce15" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">因此，目前，我们还有80轮计算要执行，512位消息被分成16部分，每部分32位。</p><p id="d79a" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">问题是，我们只有16个不同的信息部分和80轮计算，因此我们按照它们在M1到M16中的确切顺序一遍又一遍地重复这16个部分五次。</p><p id="f989" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">开始时，我们有160位输入，我们将其分成5部分，命名为A、B、C、D &amp; e。A、B、C、D &amp; E的初始值如下</p><pre class="mg mh mi mj gt mq mr ms mt aw mu bi"><span id="cc7e" class="mv lj ix mr b gy mw mx l my mz">A = 0x67452301<br/>B = 0xEFCDAB89<br/>C = 0x98BADCFE<br/>D = 0x10325476<br/>E = 0xC3D2E1F0</span></pre><p id="e05b" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">一旦我们把它们分解成这5个部分，我们又有了一套复杂的程序，我们在每一轮中都要执行。这是SHA-1算法复杂的基本核心和原因。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e5747e5b6a40d3e08026ffd4ceab3b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*6vi2y0MAoULSMpPY-CBd_g.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">单个回合的深入视图</figcaption></figure><p id="45b2" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">可以看到我已经提到了F(t)，W(t) &amp; K(t)。我们已经知道W(t)，这是32位的集合，是512位消息的一部分，但我们仍然不知道F(t)和K(t)。这些是用于计算散列的唯一的一组函数和值，并且它们每20轮保持不变，即在80轮计算发生时它们改变4次。对于每20轮，F(t)和K(t)是常数，它们具有一组预定义的值和函数描述，这些值和描述在下面描述。</p><pre class="mg mh mi mj gt mq mr ms mt aw mu bi"><span id="8e0d" class="mv lj ix mr b gy mw mx l my mz">Rounds 1-20<br/>f(1) = (B <strong class="mr iy">and</strong> C) <strong class="mr iy">or</strong> ((<strong class="mr iy">not</strong> B) <strong class="mr iy">and</strong> D)<br/>k(1) = 0x5A827999</span><span id="198e" class="mv lj ix mr b gy nf mx l my mz">Rounds 21-40<br/>f(2) = B <strong class="mr iy">xor </strong>C <strong class="mr iy">xor</strong> D<br/>k(2) = 0x6ED9EBA1</span><span id="3ce1" class="mv lj ix mr b gy nf mx l my mz">Rounds 41-60<br/>f(3) = (B <strong class="mr iy">and</strong> C) <strong class="mr iy">or</strong> (B <strong class="mr iy">and</strong> D) <strong class="mr iy">or</strong> (C <strong class="mr iy">and</strong> ) <br/>k(3) = 0x8F1BBCDC</span><span id="4502" class="mv lj ix mr b gy nf mx l my mz">Rounds 61-80<br/>f(4) = B <strong class="mr iy">xor </strong>C <strong class="mr iy">xor</strong> D<br/>k(4) = 0xCA62C1D6</span></pre><h1 id="a320" class="li lj ix bd lk ll lm ln lo lp lq lr ls kd lt ke lu kg lv kh lw kj lx kk ly lz bi translated">结论</h1><p id="08d8" class="pw-post-body-paragraph km kn ix ko b kp ma jy kr ks mb kb ku kv mc kx ky kz md lb lc ld me lf lg lh ij bi translated">毫无疑问，SHA-1算法是复杂的，更大的新闻是，它不再被使用，因为它已经被破解，被认为不再安全。因此，为了对整个事情有一个总体的了解，让我用通俗的语言在一个段落中再解释一遍。</p><blockquote class="ng nh ni"><p id="b823" class="km kn nj ko b kp kq jy kr ks kt kb ku nk kw kx ky nl la lb lc nm le lf lg lh ij bi translated">需要被散列的消息被分解成448比特的片段，并且另外64比特被填充到该片段中，作为继续前进的消息块。然后，该消息块再次被分解成16个部分，每个部分32位，然后被传递给压缩函数。压缩函数包括80轮计算。消息块的这16个部分被馈送到这些轮中，并且在每16轮之后以顺序方式重复。同样进入压缩功能的160比特被分解成5个部分(A、B、C、D &amp; E ),其中再次执行一组指令，其中我们对B、C &amp; D应用F(t ),并且用消息块然后用密钥对K(t)执行模数运算。有4个不同的F(t)和K(t ),它们是为SHA-1算法预定义的，并且在20轮计算中保持不变。在80个这样的循环之后，160比特的输出再次被倒回到压缩函数中，但是这一次是消息的第二个448比特，并且它继续直到原始消息的最后比特被计算，因此我们得到160比特的输出，这是我们传递的原始消息的散列。</p></blockquote><p id="4638" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这就是SHA-1算法全部功能的简短版本。</p><h2 id="a68d" class="mv lj ix bd lk nn no dn lo np nq dp ls kv nr ns lu kz nt nu lw ld nv nw ly nx bi translated">学分:</h2><ol class=""><li id="f4d5" class="ny nz ix ko b kp ma ks mb kv oa kz ob ld oc lh od oe of og bi translated"><a class="ae oh" href="https://www.youtube.com/watch?v=plxMklEvlCU" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=plxMklEvlCU</a>—我参考了这个视频对SHA-1有了基本的了解</li><li id="594b" class="ny nz ix ko b kp oi ks oj kv ok kz ol ld om lh od oe of og bi translated">https://en.wikipedia.org/wiki/SHA-1<a class="ae oh" href="https://en.wikipedia.org/wiki/SHA-1" rel="noopener ugc nofollow" target="_blank">——维基百科关于SHA-1的文章</a></li></ol><p id="d97c" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="ko iy">如果你喜欢，请鼓掌让我们合作吧。获取、设置、破解！</strong></p><p id="8c0a" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="ko iy">网站</strong>:<a class="ae oh" href="https://www.aditya12anand.com/" rel="noopener ugc nofollow" target="_blank">aditya12anand.com</a>|捐赠:<a class="ae oh" href="https://paypal.me/aditya12anand" rel="noopener ugc nofollow" target="_blank">paypal.me/aditya12anand</a><br/><strong class="ko iy">电报</strong>:<a class="ae oh" href="https://t.me/aditya12anand" rel="noopener ugc nofollow" target="_blank">https://t.me/aditya12anand</a><br/><strong class="ko iy">推特</strong>:<a class="ae oh" href="https://twitter.com/aditya12anand?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">twitter.com/aditya12anand</a><br/><strong class="ko iy">LinkedIn</strong>:<a class="ae oh" href="https://www.linkedin.com/in/aditya12anand/?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/aditya12anand/</a><br/><strong class="ko iy">电子邮件</strong>:aditya12anand@protonmail.com</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="d0f8" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><em class="nj">关注</em> <a class="ae oh" href="https://medium.com/bugbountywriteup" rel="noopener"> <em class="nj"> Infosec报道</em> </a> <em class="nj">获取更多此类精彩报道。</em></p><div class="ip iq gp gr ir ou"><a href="https://medium.com/bugbountywriteup" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iy gy z fp oz fr fs pa fu fw iw bi translated">信息安全报道</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">收集了世界上最好的黑客的文章，主题从bug奖金和CTF到vulnhub…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">medium.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi it ou"/></div></div></a></div></div></div>    
</body>
</html>